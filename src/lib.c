
/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

#pragma safety enable





#ifndef __OWNERSHIP_H__
#define __OWNERSHIP_H__

#ifdef __STDC_OWNERSHIP__

typedef typeof(sizeof(0)) size_t; // valid since C23

/*
  ownership is suported
*/
void* _Owner _Opt calloc(int nmemb, size_t size);
void free(void* _Owner _Opt ptr);
void* _Owner _Opt malloc(size_t size);
void* _Owner _Opt realloc(void* _Opt ptr, size_t size);
char* _Owner _Opt strdup(const char* src);

inline char* _Opt strrchr(char* const _String, int const _Ch);

int snprintf(
        _Out char*       const _Buffer,
        size_t      const _BufferCount,
        char const* const _Format,
        ...);

long strtol(
    char const* _String,
    char**     _Opt _EndPtr,
    int         _Radix
    );

int snprintf(_Out char* const _Buffer,
             size_t const _BufferCount,
             char const* const _Format,
             ...);

typedef struct _iobuf FILE;
FILE* _Owner _Opt fopen(char const* _FileName, char const* _Mode);
int fclose(FILE* _Owner _Stream);

size_t fread(
        _Out void*  _Buffer,
        size_t _ElementSize,
        size_t _ElementCount,
        FILE*  _Stream
        );

long long strtoll(
    char const* _String,
    char** _Opt _EndPtr,
    int         _Radix
    );

double strtod(
    char const* _String,
    char**      _Opt _EndPtr
    );

long double strtold(char const* _String,char** _Opt _EndPtr);


unsigned long long strtoull(
    char const* _String,
    char**      _Opt _EndPtr,
    int         _Radix
    );

float strtof(char const* _String, char** _Opt _EndPtr);

//typedef unsigned long long time_t;
//static time_t time(time_t* const _Opt _Time);

#else
/*
  ownership not suported
*/

#define _Out
#define _Opt
#define _Owner
#define _Obj_owner
#define _View
#define static_debug(x)
#define static_set(x, s)
#endif

#endif




#include <assert.h>


#include <stdio.h>


#include <string.h>


#include <stdlib.h>



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

//#pragma once



#include <stdbool.h>

#ifdef _WIN32


#include <conio.h>
#else
//#include <curses.h>
#endif



bool enable_vt_mode(void);

/*
  DISABLE_COLORS is defined to generate a
  version of cake that does not ouput colors
  A runtime flag msvcouput is already used..
  but some utility functions are not using
*/
#ifndef DISABLE_COLORS
#define COLOR_ESC(x) x
#define COLOR_ESC_PRINT(x) x
#define ESC "\x1b"
#define CSI "\x1b["
#else
#define COLOR_ESC(x) ""
#define COLOR_ESC_PRINT(x)
#define ESC ""
#define CSI ""

#endif

/*change foreground color*/


#define BLACK     COLOR_ESC("\x1b[30m")
#define BLUE     COLOR_ESC("\x1b[34m")
#define GREEN     COLOR_ESC("\x1b[32m")
#define CYAN     COLOR_ESC("\x1b[36m")
#define RED COLOR_ESC("\x1b[31;1m")
#define MAGENTA     COLOR_ESC("\x1b[35m")
#define BROWN     COLOR_ESC("\x1b[31m")
#define LIGHTGRAY COLOR_ESC("\x1b[37m")
#define DARKGRAY COLOR_ESC("\x1b[90m")
#define LIGHTBLUE    COLOR_ESC("\x1b[34;1m")
#define  LIGHTGREEN COLOR_ESC("\x1b[92m")
#define LIGHTCYAN COLOR_ESC("\x1b[36;1m")
#define LIGHTRED COLOR_ESC("\x1b[91m")
#define LIGHTMAGENTA COLOR_ESC("\x1b[95m")
#define YELLOW COLOR_ESC("\x1b[93m")
#define WHITE COLOR_ESC("\x1b[97m")

    //https//en.wikipedia.org/wiki/ANSI_escape_code


#define BK_BLACK COLOR_ESC("\x1b[40m")
#define BK_BLUE COLOR_ESC("\x1b[44m")
#define BK_GREEN  COLOR_ESC("\x1b[42m")
#define BK_CYAN COLOR_ESC("\x1b[46m")
#define BK_RED COLOR_ESC("\x1b[41;1m")
#define BK_MAGENTA COLOR_ESC("\x1b[45m")
#define BK_BROWN COLOR_ESC("\x1b[41m")
#define BK_LIGHTGRAY COLOR_ESC("\x1b[40;1m")
#define BK_DARKGRAY COLOR_ESC("\x1b[40m")
#define BK_LIGHTBLUE COLOR_ESC("\x1b[44;1m")
#define BK_LIGHTGREEN COLOR_ESC("\x1b[42,1m")
#define BK_LIGHTCYAN COLOR_ESC("\x1b[46;1m")
#define BK_LIGHTRED COLOR_ESC("\x1b[41;1m")
#define BK_LIGHTMAGENTA COLOR_ESC("\x1b[45;1m")
#define BK_YELLOW             COLOR_ESC("\x1b[43;1m")
#define BK_WHITE             COLOR_ESC("\x1b[47;1m")
#define BK_BLINK COLOR_ESC("\x1b[40m")

#define RESET COLOR_ESC(ESC "[0m")


int c_kbhit(void);
int c_getch(void);

void c_clrscr();



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

//#pragma once



#include <stdarg.h>

struct osstream
{
    char* _Owner _Opt c_str;
    int size;
    int capacity;
};


void ss_close( struct osstream * _Obj_owner stream);

int ss_vafprintf(struct osstream* stream, const char* fmt, va_list args);
int ss_fprintf(struct osstream* stream, const char* fmt, ...);
int ss_putc(char ch, struct osstream* stream);
void ss_clear(struct osstream* stream);
void ss_swap(struct osstream* a, struct osstream* b);



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

//#pragma once


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

//#pragma once
/*
* tag allow more than one type of object be inserted at the same map
*/
enum tag
{
    TAG_TYPE_NONE,
    
    TAG_TYPE_ENUN_SPECIFIER,
    TAG_TYPE_STRUCT_OR_UNION_SPECIFIER,

    TAG_TYPE_ENUMERATOR,
    TAG_TYPE_ONLY_DECLARATOR,
    TAG_TYPE_INIT_DECLARATOR,
};


struct map_entry {
    struct map_entry* _Owner _Opt next;
    unsigned int hash;
    char* _Owner key;
    void* p;
    enum tag type; /*type of the object pointed by p*/
};

struct hash_map {
    struct map_entry *_Owner * _Owner _Opt table;
    int capacity;
    int  size;
};

void hashmap_remove_all(struct hash_map* map);
void hashmap_destroy( struct hash_map* _Obj_owner map);
struct map_entry* _Opt hashmap_find(struct hash_map* map, const char* key);
void* _Opt hashmap_remove(struct hash_map* map, const char* key, enum tag* p_type_opt);
int hashmap_set(struct hash_map* map, const char* key, const void* p, enum tag type);


struct owner_map_entry {
    struct owner_map_entry* _Owner _Opt next;
    unsigned int hash;
    char* _Owner key;
    void* _Owner p;
    enum tag type; /*type of the object pointed by p*/
};

struct owner_hash_map {
    struct owner_map_entry *_Owner _Opt * _Owner _Opt table;
    int capacity;
    int  size;
};

void owner_hashmap_remove_all(struct owner_hash_map* map, void (*pf)(void* _Owner ));
void owner_hashmap_destroy( struct owner_hash_map* _Obj_owner map, void (*pf)(void*));
struct owner_map_entry* _Opt owner_hashmap_find(struct owner_hash_map* map, const char* key);
void*  _Owner _Opt owner_hashmap_remove(struct owner_hash_map* map, const char* key, enum tag* p_type_opt);
void* _Owner _Opt owner_hashmap_set(struct owner_hash_map* map, const char* key, const void* _Owner p, enum tag type);




/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

//#pragma once

enum token_type
{
    /*When changing here we need also change in tokenizer.c::get_token_name*/
    TK_NONE = 0,
    TK_NEWLINE = '\n',
    TK_WHITE_SPACE = ' ',
    TK_EXCLAMATION_MARK = '!',
    TK_QUOTATION_MARK = '"',
    TK_NUMBER_SIGN = '#',
    TK_DOLLAR_SIGN = '$',
    TK_PERCENT_SIGN = '%',
    TK_AMPERSAND = '&',
    TK_APOSTROPHE = '\'',
    TK_LEFT_PARENTHESIS = '(',
    TK_RIGHT_PARENTHESIS = ')',
    TK_ASTERISK = '*',
    TK_PLUS_SIGN = '+',
    TK_COMMA = ',',
    TK_HYPHEN_MINUS = '-',
    TK_FULL_STOP = '.',
    TK_SOLIDUS = '/',
    TK_COLON = ':',
    TK_SEMICOLON = ';',
    TK_LESS_THAN_SIGN = '<',
    TK_EQUALS_SIGN = '=',
    TK_GREATER_THAN_SIGN = '>',
    TK_QUESTION_MARK = '?',
    TK_COMMERCIAL_AT = '@',
    TK_LEFT_SQUARE_BRACKET = '[',
    TK_REVERSE_SOLIDUS = '//',
    TK_RIGHT_SQUARE_BRACKET = ']',
    TK_CIRCUMFLEX_ACCENT = '^',
    TK_FLOW_LINE = '_',
    TK_GRAVE_ACCENT = '`',
    TK_LEFT_CURLY_BRACKET = '{',
    TK_VERTICAL_LINE = '|',
    TK_RIGHT_CURLY_BRACKET = '}',
    TK_TILDE = '~',
    TK_PREPROCESSOR_LINE,
    TK_PRAGMA,
    TK_PRAGMA_END, /*marks the end of pragma internal usage*/
    TK_STRING_LITERAL,
    TK_CHAR_CONSTANT,    
    TK_LINE_COMMENT,
    TK_COMMENT,
    TK_PPNUMBER,

    ANY_OTHER_PP_TOKEN, //@ por ex

    /*PPNUMBER is converted to one of these at parser phase*/
    TK_COMPILER_DECIMAL_CONSTANT,
    TK_COMPILER_OCTAL_CONSTANT,
    TK_COMPILER_HEXADECIMAL_CONSTANT,
    TK_COMPILER_BINARY_CONSTANT,
    TK_COMPILER_DECIMAL_FLOATING_CONSTANT,
    TK_COMPILER_HEXADECIMAL_FLOATING_CONSTANT,


    TK_PLACEMARKER,

    TK_BLANKS,
    TK_PLUSPLUS = '++',
    TK_MINUSMINUS = '--',
    TK_ARROW = '->',
    TK_SHIFTLEFT = '<<',
    TK_SHIFTRIGHT = '>>',
    TK_LOGICAL_OPERATOR_OR = '||',
    TK_LOGICAL_OPERATOR_AND = '&&',

    TK_MACRO_CONCATENATE_OPERATOR = '##',

    TK_IDENTIFIER,
    TK_IDENTIFIER_RECURSIVE_MACRO, /*used to avoid macro recursion*/

    TK_BEGIN_OF_FILE,

    //C23 keywords
    TK_KEYWORD_AUTO,
    TK_KEYWORD_BREAK,
    TK_KEYWORD_CASE,
    TK_KEYWORD_CONSTEXPR,
    TK_KEYWORD_CHAR,
    TK_KEYWORD_CONST,
    TK_KEYWORD_CONTINUE,
    TK_KEYWORD_CATCH, /*extension*/
    TK_KEYWORD_DEFAULT,
    TK_KEYWORD_DO,
    TK_KEYWORD_DEFER, /*extension*/
    TK_KEYWORD_DOUBLE,
    TK_KEYWORD_ELSE,
    TK_KEYWORD_ENUM,
    TK_KEYWORD_EXTERN,
    TK_KEYWORD_FLOAT,
    TK_KEYWORD_FOR,
    TK_KEYWORD_GOTO,
    TK_KEYWORD_IF,
    TK_KEYWORD_INLINE,
    TK_KEYWORD_INT,
    TK_KEYWORD_LONG,
    TK_KEYWORD__INT8,
    TK_KEYWORD__INT16,
    TK_KEYWORD__INT32,
    TK_KEYWORD__INT64,

    TK_KEYWORD_REGISTER,
    TK_KEYWORD_RESTRICT,
    TK_KEYWORD_RETURN,
    TK_KEYWORD_SHORT,
    TK_KEYWORD_SIGNED,
    
    TK_KEYWORD_SIZEOF,
    TK_KEYWORD_NELEMENTSOF, //C2Y

    
    TK_KEYWORD_STATIC,
    TK_KEYWORD_STRUCT,
    TK_KEYWORD_SWITCH,
    TK_KEYWORD_TYPEDEF,
    TK_KEYWORD_TRY, /*extension*/
    TK_KEYWORD_THROW, /*extension*/
    TK_KEYWORD_UNION,
    TK_KEYWORD_UNSIGNED,
    TK_KEYWORD_VOID,
    TK_KEYWORD_VOLATILE,
    TK_KEYWORD_WHILE,
    
    TK_KEYWORD__ALIGNAS,
    TK_KEYWORD__ALIGNOF,
    TK_KEYWORD__ATOMIC,
    //microsoft
    //KEYWORD__FASTCALL,
    //KEYWORD__STDCALL
    // 
    TK_KEYWORD__ASM,
    //end microsoft
    TK_KEYWORD__BOOL,
    TK_KEYWORD__COMPLEX,
    TK_KEYWORD__DECIMAL128,
    TK_KEYWORD__DECIMAL32,
    TK_KEYWORD__DECIMAL64,
    TK_KEYWORD__GENERIC,
    TK_KEYWORD__IMAGINARY,
    TK_KEYWORD__NORETURN,
    TK_KEYWORD__STATIC_ASSERT,    
    TK_KEYWORD_ASSERT, /*extension*/
    TK_KEYWORD__THREAD_LOCAL,

    TK_KEYWORD_TYPEOF, /*C23*/
    
    TK_KEYWORD_TRUE,  /*C23*/
    TK_KEYWORD_FALSE,  /*C23*/
    TK_KEYWORD_NULLPTR,  /*C23*/
    TK_KEYWORD_TYPEOF_UNQUAL, /*C23*/
    TK_KEYWORD__BITINT /*C23*/,

    

    /*cake extension*/
    TK_KEYWORD__OWNER,
    TK_KEYWORD__OUT,
    TK_KEYWORD__OBJ_OWNER, 
    TK_KEYWORD__VIEW,    
    TK_KEYWORD__OPT, 
    

    /*extension compile time functions*/
    TK_KEYWORD_STATIC_DEBUG, /*extension*/
    TK_KEYWORD_STATIC_DEBUG_EX, /*extension*/
    TK_KEYWORD_STATIC_STATE, /*extension*/
    TK_KEYWORD_STATIC_SET, /*extension*/
    
    /*https://en.cppreference.com/w/cpp/header/type_traits*/
    
    TK_KEYWORD_IS_POINTER,
    TK_KEYWORD_IS_LVALUE,
    TK_KEYWORD_IS_CONST,
    TK_KEYWORD_IS_OWNER,
    TK_KEYWORD_IS_ARRAY,
    TK_KEYWORD_IS_FUNCTION,
    TK_KEYWORD_IS_SCALAR,
    TK_KEYWORD_IS_ARITHMETIC,
    TK_KEYWORD_IS_FLOATING_POINT,
    TK_KEYWORD_IS_INTEGRAL,
    

};

enum token_flags
{
    TK_FLAG_NONE = 0,
    TK_FLAG_FINAL = 1 << 0,                    /*compiler will see this token*/
    TK_FLAG_MACRO_EXPANDED = 1 << 1,           /*this token was generated from macro expansion*/
    TK_FLAG_HAS_SPACE_BEFORE = 1 << 2,         /*this token has spaces before*/
    TK_FLAG_HAS_NEWLINE_BEFORE = 1 << 3,       /*this token has newline before*/
    TK_FLAG_IDENTIFIER_IS_TYPEDEF = 1 << 4,    /*saves time on typedef search*/
    TK_FLAG_IDENTIFIER_IS_NOT_TYPEDEF = 1 << 5,

    TK_C_BACKEND_FLAG_HIDE = 1 << 6,                 /*c backend hidden*/
    
    TK_FLAG_IDENTIFIER_IS_ENUMERATOR = 1 << 7,       /*saves time on search*/

    TK_FLAG_IDENTIFIER_IS_NOT_ENUMERATOR = 1 << 8,   /*we know it is not enumerator*/    

    TK_FLAG_SLICED = 1 << 9,                         /*line-slicing in the middle*/

    TK_FLAG_LINE_CONTINUATION = 1 << 10 ,            /*token has one or more line-slicing*/

    TK_C_BACKEND_FLAG_SHOW_AGAIN = 1 << 11,          /*was hidden but maybe reappears*/
};

struct token
{
    enum token_type type;
    char* _Owner lexeme; //TODO make const
    char* original;

    int line;
    int col;

    /*include level - 0 is the current file*/
    int level;

    enum token_flags flags;

    /*points to the token with file name or macro*/
    struct token* token_origin;

    struct token* _Owner _Opt next;
    struct token* _Opt prev;
};

void token_delete( struct token* _Owner _Opt p);

struct token_list
{
    struct token* _Owner _Opt head;
    struct token* _Opt tail;
};
void token_list_set_file(struct token_list* list, struct token* filetoken, int line, int col);
bool token_list_is_empty(struct token_list* p);
void token_list_swap(struct token_list* a, struct token_list* b);

struct token* _Owner _Opt clone_token(struct token* p);
struct token* token_list_add(struct token_list* list, struct token* _Owner pnew);
void token_list_remove(struct token_list* list, struct token* first, struct token* last);
struct token_list token_list_remove_get(struct token_list* list, struct token* first, struct token* last);
void token_list_append_list(struct token_list* dest, struct token_list* source);
void token_list_append_list_at_beginning(struct token_list* dest, struct token_list* source);
struct token* token_list_clone_and_add(struct token_list* list, struct token* pnew);
char* _Owner token_list_join_tokens(struct token_list* list, bool bliteral);
void token_list_clear(struct token_list* list);
bool token_is_blank(const struct token* _Opt p);
bool token_is_identifier_or_keyword(enum token_type t);
void token_range_add_flag(struct token* first, struct token* last, enum token_flags flag);
void token_range_remove_flag(struct token* first, struct token* last, enum token_flags flag);
void token_range_add_show(struct token* first, struct token* last);

void print_tokens_html(struct token* p_token);

struct marker {    
    
    const char* _Opt file;
    int line;
    int start_col;
    int end_col;

    // Line
    //~~~~~~~~^~~~~~~~~
    //begin  caret   end

    const struct token* _Opt p_token_caret;
    const struct token* _Opt p_token_begin;
    const struct token* _Opt p_token_end;
};
void print_line_and_token(struct marker* p_marker, bool visual_studio_ouput_format);

void print_position(const char* path, int line, int col, bool msvc_format);

struct stream
{
    const char* source;
    const char* current;
    int line;
    int col;
    int line_continuation_count;
    const char* path;
};

int is_digit(const struct stream* p);
int is_nondigit(const struct stream* p);
void stream_match(struct stream* stream);


bool style_has_space(const struct token*  token);
bool style_has_one_space(const struct token*  token);

enum token_type parse_number(const char* lexeme, char suffix[4], _Out char erromsg[100]);
const unsigned char* _Opt utf8_decode(const unsigned char* s, _Out unsigned int* c);
const unsigned char* _Opt escape_sequences_decode_opt(const unsigned char* p, unsigned int* out_value);


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

//#pragma once

typedef int errno_t;

#if __STDC_VERSION__  >= 202311L 
#define NODISCARD [[nodiscard]]
#else
#define NODISCARD
#endif


#ifndef __CAKE__

#define try  
#define catch if (0) catch_label:
#define throw do { throw_break_point(); goto catch_label;}while (0)

#endif

const char* get_posix_error_message(int error);
int windows_error_to_posix(int i);

void throw_break_point();


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

//#pragma once

/*
* Compiler options shared with compiler and preprocessor
*/

enum language_version
{
    LANGUAGE_C89 = -1,
    LANGUAGE_C99 = 0, /*default*/
    LANGUAGE_C11 = 1,
    LANGUAGE_C23 = 2, //C23, C2X
    LANGUAGE_C2Y = 3, //C2Y
    LANGUAGE_CAK = 4, //cake extensions
};

enum diagnostic_id {

    W_NONE = 0,  /*not a real warning, used in especial cases*/
    
    
    W_UNUSED_VARIABLE, //-Wunused-variable
    W_DEPRECATED,
    W_ENUN_CONVERSION,//-Wenum-conversion

    W_ADDRESS, //-Waddress (always true)
    W_UNUSED_PARAMETER, //-Wno-unused-parameter
    W_DECLARATOR_HIDE, // gcc no
    W_TYPEOF_ARRAY_PARAMETER,//
    W_ATTRIBUTES, //-Wattributes
    W_UNUSED_VALUE, //-Wunused-value
    W_STYLE, //-Wstyle
    W_COMMENT,
    W_LINE_SLICING,
    W_STRING_SLICED,
    W_DISCARDED_QUALIFIERS,
    W_DECLARATOR_STATE,
    W_UNINITIALZED,
    W_RETURN_LOCAL_ADDR,
    W_MUST_USE_ADDRESSOF,
    W_ARRAY_INDIRECTION,
    /*ownership type system errors*/
    W_OWNERSHIP_MISSING_OWNER_QUALIFIER,
    W_OWNERSHIP_NOT_OWNER,
    W_OWNERSHIP_USING_TEMPORARY_OWNER,
    W_OWNERSHIP_MOVE_ASSIGNMENT_OF_NON_OWNER,
    W_OWNERSHIP_NON_OWNER_TO_OWNER_ASSIGN,
    W_OWNERSHIP_DISCARDING_OWNER,
    W_OWNERSHIP_NON_OWNER_MOVE,    
    //////////////////////////////////////////////
    W_FLOW_NON_NULL, //-Wnonnull
    W_FLOW_MISSING_DTOR,
    W_FLOW_UNINITIALIZED,
    W_FLOW_LIFETIME_ENDED,
    W_FLOW_MOVED,
    W_FLOW_NULL_DEREFERENCE,
    W_FLOW_MAYBE_NULL_TO_NON_OPT_ARG,
    W_FLOW_NULLABLE_TO_NON_NULLABLE,
    W_FLOW_DIVIZION_BY_ZERO,    
    //////////////////////////////////////////////
    W_DIVIZION_BY_ZERO,
    W_CONSTANT_VALUE, /*sample 0 * a */
    W_PASSING_NULL_AS_ARRAY,
    W_INCOMPATIBLE_ENUN_TYPES,
    W_MULTICHAR_ERROR,
    W_OUT_OF_BOUNDS,
    W_ASSIGNMENT_OF_ARRAY_PARAMETER,
    W_CONDITIONAL_IS_CONSTANT,
    W_SWITCH,
    W_UNSUAL_NULL_POINTER_CONSTANT,
    W_SIZEOF_ARRAY_ARGUMENT,
    W_CONST_NOT_INITIALIZED,
    W_NULL_CONVERTION,
    W_IMPLICITLY_UNSIGNED_LITERAL,
    W_INTEGER_OVERFLOW,
    W_ARRAY_SIZE,
    
    
    W_EMPTY_STATEMENT,
    W_NOT_DEFINED53,
    W_NOT_DEFINED54,
    W_NOT_DEFINED55,
    W_NOT_DEFINED56,
    W_NOT_DEFINED57,
    W_NOT_DEFINED58,
    W_NOT_DEFINED59,
    W_NOT_DEFINED60,
    W_NOT_DEFINED61,

    W_LOCATION, /*prints code location*/
    W_NOTE,

    /*
       Warnings have names and errors have numbers. The number of the error is its name.
       The error number cannot change because this breaks unit tests.

       Warnings numbers can change but must respect the size of bit set because
       each warning number is a bit index.
       
       We can have 1..638 warning bits, because the first error starts at 640.
    */
    
    C_ERROR_INVALID_QUALIFIER_FOR_POINTER = 640,
    C_ERROR_UNEXPECTED = 650,
    C_ERROR_TOO_MANY_ARGUMENTS = 660,
    C_ERROR_TOO_FEW_ARGUMENTS = 670,
    C_ERROR_NOT_FOUND = 680,
    C_ERROR_NO_MATCH_FOR_GENERIC = 690,
    C_ERROR_SUBSCRIPTED_VALUE_IS_NEITHER_ARRAY_NOR_POINTER = 700,
    C_ERROR_CALLED_OBJECT_IS_NOT_FUNCTION_OR_FUNCTION_POINTER = 710,
    C_ERROR_STRUCT_MEMBER_NOT_FOUND = 720,
    C_ERROR_STRUCTURE_OR_UNION_REQUIRED = 730,
    C_ERROR_STRUCT_IS_INCOMPLETE = 740,
    C_ERROR_DECLARATOR_NOT_FOUND = 750,
    C_ERROR_EXPECTED_DECLARATOR_NAME = 760,
    C_ERROR_UNKNOWN_ATTRIBUTE_NAME = 770,
    C_ERROR_INDIRECTION_REQUIRES_POINTER_OPERAND = 780,
    C_ERROR_INVALID_TOKEN = 790,
    C_ERROR_EXPECTED_STRUCT_TYPE = 800,
    C_ERROR_EXPECTED_TYPE_NAME = 810,
    C_ERROR_LEFT_IS_NOT_ARITHMETIC = 820,
    C_ERROR_RIGHT_IS_NOT_ARITHMETIC = 830,
    C_ERROR_LEFT_IS_NOT_INTEGER = 840,
    C_ERROR_RIGHT_IS_NOT_INTEGER = 850,
    C_ERROR_INVALID_TYPE = 860,
    C_ERROR_LEFT_IS_NOT_SCALAR = 870,
    C_ERROR_RIGHT_IS_NOT_SCALAR = 880,
    C_ERROR_INCOMPATIBLE_POINTER_TYPES = 890, //warning?
    C_ERROR_ASSIGNMENT_OF_FUNCTION = 900,
    C_ERROR_ASSIGNMENT_TO_EXPRESSION_WITH_ARRAY_TYPE = 910,
    C_ERROR_ASSIGNMENT_OF_READ_ONLY_OBJECT = 920,
    C_ERROR_LVALUE_ASSIGNMENT = 930,
    C_ERROR_CONDITION_MUST_HAVE_SCALAR_TYPE = 940,
    C_ERROR_INCOMPATIBLE_TYPES = 950,
    C_ERROR_EXPECTED_CONSTANT_EXPRESSION = 960,
    C_ERROR_UNEXPECTED_TOKEN = 970,
    C_ERROR_CANNOT_COMBINE_WITH_PREVIOUS_LONG_LONG = 980,
    C_ERROR_EXPECTED_DECLARATION = 990,
    C_ERROR_STATIC_OR_TYPE_QUALIFIERS_NOT_ALLOWED_IN_NON_PARAMETER = 1000,
    C_ERROR_OBJ_OWNER_CAN_BE_USED_ONLY_IN_POINTER = 1010,
    C_ERROR_REDECLARATION = 1020,
    C_ERROR_TAG_TYPE_DOES_NOT_MATCH_PREVIOUS_DECLARATION = 1030,
    C_ERROR_MISSING_ENUM_TAG_NAME = 1040,
    C_ERROR_MULTIPLE_DEFINITION_ENUM = 1050,
    C_ERROR_STATIC_ASSERT_FAILED = 1060,
    C_ERROR_STATIC_SET = 1070,
    C_ANALIZER_ERROR_STATIC_STATE_FAILED = 1080,
    C_ERROR_ATTR_UNBALANCED = 1090,
    C_ERROR_UNEXPECTED_END_OF_FILE = 1100,
    C_ERROR_THROW_STATEMENT_NOT_WITHIN_TRY_BLOCK = 1110,
    C_ERROR_VOID_FUNCTION_SHOULD_NOT_RETURN_VALUE = 1120,
    C_ERROR_ARGUMENT_SIZE_SMALLER_THAN_PARAMETER_SIZE = 1130,
    C_ERROR_TOKEN_NOT_VALID_IN_PREPROCESSOR_EXPRESSIONS = 1140,
    C_ERROR_FILE_NOT_FOUND = 1150,
    C_ERROR_MISSING_CLOSE_PARENTHESIS = 1160,
    C_ERROR_EXPRESSION_ERROR = 1170,
    C_ERROR_PREPROCESSOR_C_ERROR_DIRECTIVE = 1180,
    C_ERROR_TOO_FEW_ARGUMENTS_TO_FUNCTION_LIKE_MACRO = 1190,
    C_ERROR_PREPROCESSOR_MACRO_INVALID_ARG = 1200,
    C_ERROR_PREPROCESSOR_MISSING_MACRO_ARGUMENT = 1210,
    C_ERROR_ADDRESS_OF_REGISTER = 1220,
    C_ERROR_OPERATOR_NEEDS_LVALUE = 1230, //C2105
    C_ERROR_CHARACTER_TOO_LARGE = 1240,
    C_ERROR_PRAGMA_ERROR = 1250,
    C_ERROR_OUT_OF_MEM = 1260,
    C_ERROR_STORAGE_SIZE = 1270,
    C_ERROR_RETURN_LOCAL_OWNER_TO_NON_OWNER = 1280,
    C_ERROR_AUTO_NEEDS_SINGLE_DECLARATOR = 1290,
    C_ERROR_TWO_OR_MORE_SPECIFIERS = 1300,
    C_ERROR_OPERATOR_INCREMENT_CANNOT_BE_USED_IN_OWNER = 1310,
    C_ERROR_OPERATOR_DECREMENT_CANNOT_BE_USED_IN_OWNER = 1320,
    C_PRE_DIVISION_BY_ZERO = 1330,
    C_ERROR_INT_TO_POINTER = 1340,
    C_ERROR_LITERAL_OVERFLOW = 1350,
    C_CHARACTER_NOT_ENCODABLE_IN_A_SINGLE_CODE_UNIT = 1360,
    C_MULTICHAR_ERROR = 1370,
    C_INVALID_TOKEN = 1380,
    C_INVALID_ARGUMENT_NELEMENTSOF = 1390,
};

_Static_assert(W_NOTE == 63, "must be 63, marks the last index for warning");

/*
* These warnings are removed when "nullable=disable"
*/
#define WFLAG(W) (1ULL << W)
#define NULLABLE_DISABLE_REMOVED_WARNINGS  (WFLAG(W_FLOW_NULL_DEREFERENCE) | WFLAG(W_FLOW_NULLABLE_TO_NON_NULLABLE))

#define OWNERSHIP_DISABLE_REMOVED_WARNINGS  (WFLAG(W_FLOW_UNINITIALIZED))


int get_diagnostic_phase(enum diagnostic_id w);

enum style
{
    STYLE_CAKE,

    // https://llvm.org/docs/CodingStandards.html
    STYLE_LLVM,// A style complying with the LLVM coding standards

    //https://google.github.io/styleguide/cppguide.html
    STYLE_GOOGLE,// A style complying with Google’s C++ style guide

    //https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md
    //https://www.kernel.org/doc/html/latest/process/coding-style.html
    STYLE_CHROMIUM,// A style complying with Chromium’s style guide

    //https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html
    STYLE_MOZILLA,// A style complying with Mozilla’s style guide

    //https://www.webkit.org/code-style-guidelines/
    STYLE_WEBKIT,// A style complying with WebKit’s style guide

    STYLE_MICROSOFT,// A style complying with Microsoft’s style guide

    STYLE_GNU,// A style complying with the GNU coding standards

};
int get_warning_name(enum diagnostic_id w, int n, char buffer[/*n*/]);
unsigned long long  get_warning_bit_mask(const char* wname);

enum diagnostic_id  get_warning(const char* wname);

struct diagnostic
{
    /*
      each message has number (0-63) that corresponds to the bit index
      Messages bigger than W_NOTE are errors or bigger than 63
    */

    /*set of warnings reported as errors*/
    unsigned long long errors;
    /*set of warnings reported as warnings*/
    unsigned long long warnings;
    /*set of warnings reported as notes*/
    unsigned long long notes;
};

int get_diagnostic_type(struct diagnostic* d, enum diagnostic_id w);
extern struct diagnostic default_diagnostic;

void diagnostic_remove(struct diagnostic *d, enum diagnostic_id w);

struct diagnostic_stack
{
    int top_index;
    struct diagnostic stack[10];
};

int diagnostic_stack_push_empty(struct diagnostic_stack* diagnostic_stack);
void diagnostic_stack_pop(struct diagnostic_stack* diagnostic_stack);


struct options
{
    /*
       -std=c99
    */
    enum language_version input;

    /*
       -target=c99
    */
    enum language_version target;

    /*
      #pragma CAKE diagnostic push
      #pragma CAKE diagnostic pop
    */
    struct diagnostic_stack diagnostic_stack;

    enum style style;

    /*
       Causes the compiler to output a list of the include files.
       The option also displays nested include files, that is,
       the files included by the files that you include.
    */
    bool show_includes;

    /*
       -disable-assert
    */
    bool disable_assert;


    /*
       -remove-comments
    */
    bool remove_comments;

    /*
       -flow-analysis
    */
    bool flow_analysis;

    /*
    * -testmode
    */
    bool test_mode;

    /*
    * -nullchecks
    */
    bool null_checks_enabled;

    bool ownership_enabled;

    /*
      -E
    */
    bool preprocess_only;

    bool clear_error_at_end; //used by tests
    /*
      -rm
      -direct-compilation
    */
    bool direct_compilation;

    /*
      -sarif
    */
    bool sarif_output;

    bool format_input;
    bool format_ouput;


    /*
      -no-output
      if true cake does not generate ouput
    */
    bool no_output;


    /*
      -fdiagnostics-format=msvc
      -msvc-output
    */
    bool visual_studio_ouput_format;

    /*
      -dump-tokens
      print tokens before preprocessor
    */
    bool dump_tokens;

    /*
      -dump-pp-tokens
      (print tokens after preprocessor)
    */
    bool dump_pptokens;

    /*
      -autoconfig
    */
    bool auto_config;

    /*
      -o filename
      defines the ouputfile when 1 file is used
    */
    char output[200];
    char sarifpath[200];
};

int fill_options(struct options* options,
                 int argc,
                 const char** argv);

void print_help();



#define CAKE_CFG_FNAME "/cakeconfig.h"

struct include_dir
{
    const char* _Owner path;
    struct include_dir* _Owner _Opt next;
};

struct include_dir_list
{
    struct include_dir* _Owner _Opt head;
    struct include_dir* _Opt tail;
};


enum preprocessor_ctx_flags
{
    PREPROCESSOR_CTX_FLAGS_NONE = 0,
    PREPROCESSOR_CTX_FLAGS_ONLY_FINAL = 1 << 0
};

struct preprocessor_ctx
{
    struct options options;
    enum preprocessor_ctx_flags flags;
    struct owner_hash_map macros;
    struct include_dir_list include_dir;

    /*map of pragma once already included files*/
    struct hash_map pragma_once_map;
    
    struct token* _Opt current;
    struct token_list input_list;
    unsigned int count_macro_value;
    bool conditional_inclusion;
    int n_warnings;
    int n_errors;    
};
void preprocessor_ctx_destroy( struct preprocessor_ctx* _Obj_owner p);

bool preprocessor_diagnostic_message(enum diagnostic_id w, struct preprocessor_ctx* ctx, const struct token* _Opt p_token, const char* fmt, ...);


struct tokenizer_ctx
{
    struct options options;
    int n_warnings;
    int n_errors;    
};

struct token_list tokenizer(struct tokenizer_ctx* ctx, const char* text, const char* _Opt filename_opt, int level, enum token_flags addflags);
void add_standard_macros(struct preprocessor_ctx* ctx);
struct include_dir* _Opt include_dir_add(struct include_dir_list* list, const char* path);

struct token_list preprocessor(struct preprocessor_ctx* ctx, struct token_list* input_list, int level);
struct token_list  copy_replacement_list(const struct token_list* list);

void token_list_append_list(struct token_list* dest, struct token_list* _Obj_owner source);
void print_list(struct token_list* list);
void token_list_destroy( struct token_list* _Obj_owner list);
bool token_is_blank(const struct token* p);
void token_list_pop_back(struct token_list* list);
void token_list_pop_front(struct token_list* list);
struct token* _Owner _Opt token_list_pop_front_get(struct token_list* list);
void remove_line_continuation(char* s);
struct token* token_list_clone_and_add(struct token_list* list, struct token* pnew);

void token_list_insert_after(struct token_list* list, struct token* _Opt after, struct token_list* append);
void token_list_insert_before(struct token_list* token_list, struct token* after, struct token_list* append_list);
void token_list_paste_string_after(struct token_list* list,
    struct token* after,
    const char* s);
void token_list_paste_string_before(struct token_list* list,
    struct token* before,
    const char* s);
struct token_list tokenizer(struct tokenizer_ctx* p, const char* text, const char* _Opt filename_opt, int level, enum token_flags addflags);

void print_code_as_we_see(const struct token_list* list, bool remove_comments);
const char* _Owner _Opt get_code_as_compiler_see(const struct token_list* list);
const char* _Owner _Opt get_code_as_we_see_plus_macros(const struct token_list* list);
const char* _Owner _Opt get_code_as_we_see(const struct token_list* list, bool remove_comments);

void print_tokens(const struct token* _Opt p_token);
void print_preprocessed(const struct token* p_token);
const char* _Owner _Opt print_preprocessed_to_string(const struct token* p_token);
const char* _Owner _Opt print_preprocessed_to_string2(const struct token* _Opt p_token);
void check_unused_macros(const struct owner_hash_map* map);

char* _Owner _Opt read_file(const char* path);
const char* get_token_name(enum token_type tk);
void print_all_macros(const struct preprocessor_ctx* prectx);

int string_literal_char_byte_size(const char* s);
int string_literal_byte_size_not_zero_included(const char* s);

int get_char_type(const char* s);
int include_config_header(struct preprocessor_ctx* ctx, const char* file_name);
int stringify(const char* input, int n, char output[]);


#ifdef _WIN32


#include <Windows.h>
#endif

#if defined _MSC_VER && !defined __POCC__


#include <crtdbg.h>
#endif

#if defined _MSC_VER && !defined __POCC__


#include <debugapi.h>
#endif

/*
  PROVISORY - unchecked was removed, now we control flow ownership error with pragma
  TODO review alternatives from Domingo's branch.
*/
#ifdef __CAKE__
#pragma cake diagnostic push
#pragma cake diagnostic ignored "-Wdiscard-owner"
#pragma cake diagnostic ignored "-Wmissing-destructor"
#pragma cake diagnostic ignored "-Wnon-owner-move"
#pragma cake diagnostic ignored "-Wnon-owner-to-_Owner-move"
#endif

//#pragma cake diagnostic pop

bool style_has_space(const struct token* token)
{
    return token_is_blank(token->prev);
}

bool style_has_one_space(const struct token* token)
{
    return token->prev &&
        token->prev->type == TK_BLANKS;
}

void print_literal2(const char* s);

void token_list_clear(struct token_list* list)
{
    struct token* _Owner _Opt p = list->head;
    while (p)
    {
        struct token* _Owner _Opt next = p->next;
        p->next = NULL;
        token_delete(p);
        p = next;
    }

    list->head = NULL;
    list->tail = NULL;
}


void token_range_add_show(struct token* first, struct token* last)
{
    for (struct token* current = first;
         current != last->next;
         current = current->next)
    {
        current->flags = current->flags & ~TK_C_BACKEND_FLAG_HIDE;
        if (current->next == NULL)
            break;
    }
}

void token_range_remove_flag(struct token* first, struct token* last, enum token_flags flag)
{
    for (struct token* _Opt current = first;
        current && current != last->next;
        current = current->next)
    {
        current->flags = current->flags & ~flag;
    }
}

void token_range_add_flag(struct token* first, struct token* last, enum token_flags flag)
{
    for (struct token* _Opt current = first;
        current && current != last->next;
        current = current->next)
    {
        current->flags |= flag;
    }
}

void token_list_pop_back(struct token_list* list)
{
    if (list->head == NULL)
        return;

    if (list->head == list->tail)
    {
        token_delete(list->head);
        list->head = NULL;
        list->tail = NULL;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->prev != NULL);
        list->tail = list->tail->prev;
        token_delete(list->tail->next);
        list->tail->next = NULL;
        if (list->tail == list->head)
        {
            list->tail->prev = NULL;
        }
    }

}

void token_list_pop_front(struct token_list* list) /*unchecked*/
{
    if (list->head == NULL)
        return;

    struct token* _Owner _Opt p = list->head;
    //assert(p->prev == NULL);
    if (list->head == list->tail)
    {
        list->head = NULL;
        list->tail = NULL;
    }
    else
    {
        list->head = p->next;
    }
    p->next = NULL;
    p->prev = NULL;
    token_delete(p);
}

struct token* _Owner _Opt token_list_pop_front_get(struct token_list* list)
{
    if (list->head == NULL)
        return NULL;

    struct token* _Owner _Opt head = list->head;

    if (list->head == list->tail)
    {
        list->head = NULL;
        list->tail = NULL;

        head->next = NULL;
        head->prev = NULL;

        return head;
    }

    list->head = head->next;
    head->next = NULL;
    head->prev = NULL;

    return head;
}

void token_list_swap(struct token_list* a, struct token_list* b)
{
    struct token_list temp = *a;
    *a = *b;
    *b = temp;
}

void token_delete(struct token* _Owner _Opt p)
{
    if (p)
    {
        /*
         * ownership warning here is about the p->next
         * we need a way to remove only this specific warning
        */
        assert(p->next == NULL);
        free(p->lexeme);
        free(p);
    }
}

void token_list_set_file(struct token_list* list, struct token* filetoken, int line, int col)
{
    struct token* _Opt p = list->head;
    while (p)
    {
        p->token_origin = filetoken;
        p->line = line;
        p->col = col;
        p = p->next;
    }
}

void token_list_destroy(struct token_list* _Obj_owner list)
{
    struct token* _Owner _Opt p = list->head;
    while (p)
    {
        struct token* _Owner _Opt next = p->next;
        p->next = NULL;
        token_delete(p);
        p = next;
    }
}

char* _Owner _Opt token_list_join_tokens(struct token_list* list, bool bliteral)
{
    struct osstream ss = { 0 };
    if (bliteral)
        ss_fprintf(&ss, "\"");
    bool has_space = false;
    struct token* _Opt current = list->head;

    while (current)
    {
        if (token_is_blank(current))
        {
            has_space = true;
            current = current->next;
            continue;
        }

        if (has_space)
            ss_fprintf(&ss, " ");

        const char* p = current->lexeme;
        while (*p)
        {
            if (*p == '"')
                ss_fprintf(&ss, "\\\"");
            else
                ss_fprintf(&ss, "%c", *p);
            p++;
        }


        current = current->next;
        if (current)
            has_space = current->flags & TK_FLAG_HAS_SPACE_BEFORE;
    }

    if (bliteral)
        ss_fprintf(&ss, "\"");

    char* _Owner _Opt cstr = ss.c_str;
    ss.c_str = NULL; /*MOVED*/

    ss_close(&ss);

    return cstr;
}


void token_list_paste_string_after(struct token_list* list,
    struct token* after,
    const char* s)
{
    struct tokenizer_ctx tctx = { 0 };
    struct token_list l = tokenizer(&tctx, s, NULL, 0, TK_FLAG_FINAL);
    token_list_insert_after(list, after, &l);
    token_list_destroy(&l);
}

void token_list_paste_string_before(struct token_list* list,
    struct token* before,
    const char* s)
{
    struct tokenizer_ctx tctx = { 0 };
    struct token_list l = tokenizer(&tctx, s, NULL, 0, TK_FLAG_FINAL);
    token_list_insert_before(list, before, &l);
    token_list_destroy(&l);
}


void token_list_insert_after(struct token_list* token_list, struct token* _Opt after, struct token_list* append_list)
{
    if (append_list->head == NULL)
        return;

    if (after == NULL)
    {
        assert(append_list->tail != NULL);
        assert(append_list->tail->next == NULL);
        append_list->tail->next = token_list->head;
        token_list->head->prev = append_list->tail;

        token_list->head = append_list->head;
        append_list->head->prev = NULL;
    }
    else
    {
        struct token* _Owner _Opt follow = after->next;
        if (token_list->tail == after)
        {
            token_list->tail = append_list->tail;
        }
        else if (token_list->head == after)
        {
        }
        assert(append_list->tail != NULL);
        assert(append_list->tail->next == NULL);
        append_list->tail->next = follow;
        follow->prev = append_list->tail;
        after->next = append_list->head;
        append_list->head->prev = after;

    }

    append_list->head = NULL;
    append_list->tail = NULL;

}

void token_list_insert_before(struct token_list* token_list, struct token* after, struct token_list* append_list)
{
    token_list_insert_after(token_list, after->prev, append_list);
}

struct token* token_list_add(struct token_list* list, struct token* _Owner pnew) /*unchecked*/
{
    /*avoid accidentally being in 2 different lists*/
    assert(pnew->next == NULL);
    assert(pnew->prev == NULL);

    if (list->head == NULL)
    {
        pnew->prev = NULL;
        pnew->next = NULL;
        list->head = pnew;
        list->tail = pnew;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);

        pnew->prev = list->tail;
        list->tail->next = pnew;
        list->tail = pnew;
    }
    assert(list->tail != NULL);
    assert(list->tail->next == NULL);
    return list->tail;

}

int is_digit(const struct stream* p)
{
    /*
     digit : one of
     0 1 2 3 4 5 6 7 8 9
    */
    return (p->current[0] >= '0' && p->current[0] <= '9');
}

bool token_is_identifier_or_keyword(enum token_type t)
{
    switch (t)
    {
    case TK_IDENTIFIER: return true;

    case TK_KEYWORD_AUTO:
    case TK_KEYWORD_BREAK:
    case TK_KEYWORD_CASE:
    case TK_KEYWORD_CONSTEXPR:
    case TK_KEYWORD_CHAR:
    case TK_KEYWORD_CONST:
    case TK_KEYWORD_CONTINUE:
    case TK_KEYWORD_CATCH: /*extension*/
    case TK_KEYWORD_DEFAULT:
    case TK_KEYWORD_DO:
    case TK_KEYWORD_DEFER: /*extension*/
    case TK_KEYWORD_DOUBLE:
    case TK_KEYWORD_ELSE:
    case TK_KEYWORD_ENUM:
    case TK_KEYWORD_EXTERN:
    case TK_KEYWORD_FLOAT:
    case TK_KEYWORD_FOR:
    case TK_KEYWORD_GOTO:
    case TK_KEYWORD_IF:
    case TK_KEYWORD_INLINE:
    case TK_KEYWORD_INT:
    case TK_KEYWORD_LONG:
    case TK_KEYWORD__INT8:
    case TK_KEYWORD__INT16:
    case TK_KEYWORD__INT32:
    case TK_KEYWORD__INT64:

    case TK_KEYWORD_REGISTER:
    case TK_KEYWORD_RESTRICT:
    case TK_KEYWORD_RETURN:
    case TK_KEYWORD_SHORT:
    case TK_KEYWORD_SIGNED:
    case TK_KEYWORD_SIZEOF:

    case TK_KEYWORD_STATIC:
    case TK_KEYWORD_STRUCT:
    case TK_KEYWORD_SWITCH:
    case TK_KEYWORD_TYPEDEF:
    case TK_KEYWORD_TRY: /*extension*/
    case TK_KEYWORD_THROW: /*extension*/
    case TK_KEYWORD_UNION:
    case TK_KEYWORD_UNSIGNED:
    case TK_KEYWORD_VOID:
    case TK_KEYWORD_VOLATILE:
    case TK_KEYWORD_WHILE:

    case TK_KEYWORD__ALIGNAS:
    case TK_KEYWORD__ALIGNOF:
    case TK_KEYWORD__ATOMIC:
        //microsoft
        //KEYWORD__FASTCALL:
        //KEYWORD__STDCALL
        // 
    case TK_KEYWORD__ASM:
        //end microsoft
    case TK_KEYWORD__BOOL:
    case TK_KEYWORD__COMPLEX:
    case TK_KEYWORD__DECIMAL128:
    case TK_KEYWORD__DECIMAL32:
    case TK_KEYWORD__DECIMAL64:
    case TK_KEYWORD__GENERIC:
    case TK_KEYWORD__IMAGINARY:
    case TK_KEYWORD__NORETURN:
    case TK_KEYWORD__STATIC_ASSERT:
    case TK_KEYWORD_ASSERT: /*extension*/
    case TK_KEYWORD__THREAD_LOCAL:

    case TK_KEYWORD_TYPEOF: /*C23*/

    case TK_KEYWORD_TRUE:  /*C23*/
    case TK_KEYWORD_FALSE:  /*C23*/
    case TK_KEYWORD_NULLPTR:  /*C23*/
    case TK_KEYWORD_TYPEOF_UNQUAL: /*C23*/
    case TK_KEYWORD__BITINT /*C23*/:



        /*cake extension*/
    case TK_KEYWORD__OWNER:
    case TK_KEYWORD__OUT:
    case TK_KEYWORD__OBJ_OWNER:
    case TK_KEYWORD__VIEW:
    case TK_KEYWORD__OPT:


        /*extension compile time functions*/
    case TK_KEYWORD_STATIC_DEBUG: /*extension*/
    case TK_KEYWORD_STATIC_DEBUG_EX: /*extension*/
    case TK_KEYWORD_STATIC_STATE: /*extension*/
    case TK_KEYWORD_STATIC_SET: /*extension*/

        /*https://en.cppreference.com/w/cpp/header/type_traits*/

    case TK_KEYWORD_IS_POINTER:
    case TK_KEYWORD_IS_LVALUE:
    case TK_KEYWORD_IS_CONST:
    case TK_KEYWORD_IS_OWNER:
    case TK_KEYWORD_IS_ARRAY:
    case TK_KEYWORD_IS_FUNCTION:
    case TK_KEYWORD_IS_SCALAR:
    case TK_KEYWORD_IS_ARITHMETIC:
    case TK_KEYWORD_IS_FLOATING_POINT:
    case TK_KEYWORD_IS_INTEGRAL:
        return true;
    default:
        break;
    }

    return false;
}


bool token_is_blank(const struct token* p)
{
    return p->type == TK_BEGIN_OF_FILE ||
        p->type == TK_BLANKS ||
        p->type == TK_LINE_COMMENT ||
        p->type == TK_COMMENT;
}

struct token* _Opt token_list_clone_and_add(struct token_list* list, struct token* pnew)
{
    struct token* _Owner _Opt clone = clone_token(pnew);

    if (clone == NULL)
        return NULL;

    return token_list_add(list, clone);
}

void token_list_append_list_at_beginning(struct token_list* dest, struct token_list* source)
{
    if (source->head == NULL)
    {
        return;
    }

    if (dest->head == NULL)
    {
        dest->head = source->head;
        dest->tail = source->tail;
    }
    else
    {
        assert(source->tail != NULL);
        assert(source->tail->next == NULL);
        source->tail->next = dest->head;
        dest->head = source->head;
    }

    source->head = NULL;
    source->tail = NULL;
}

void token_list_append_list(struct token_list* dest, struct token_list* source)
{
    if (source->head == NULL)
    {
        return;
    }
    if (dest->head == NULL)
    {
        dest->head = source->head;
        dest->tail = source->tail;
    }
    else
    {
        assert(dest->tail != NULL);
        assert(dest->tail->next == NULL);
        dest->tail->next = source->head;
        source->head->prev = dest->tail;
        dest->tail = source->tail;
    }
    source->head = NULL;
    source->tail = NULL;
}


struct token* _Owner _Opt clone_token(struct token* p)
{
    struct token* _Owner _Opt token = calloc(1, sizeof * token);
    if (token)
    {
        char* _Owner _Opt lexeme = strdup(p->lexeme);
        if (lexeme == NULL)
        {
            free(token);
            return NULL;
        }
        *token = *p;
        token->lexeme = lexeme;
        token->next = NULL;
        token->prev = NULL;
    }
    return token;
}


struct token_list token_list_remove_get(struct token_list* list, struct token* first, struct token* last) /*unchecked*/
{

    struct token_list r = { 0 };

    struct token* _Opt before_first = first->prev;
    struct token* _Owner _Opt after_last = last->next; /*MOVED*/
    last->next = NULL; /*MOVED*/

    before_first->next = after_last;
    after_last->prev = before_first;

    r.head = (struct token* _Owner)first;
    first->prev = NULL;
    r.tail = last;


    return r;
}

void token_list_remove(struct token_list* list, struct token* first, struct token* last)
{
    struct token_list r = token_list_remove_get(list, first, last);
    token_list_destroy(&r);
}


bool token_list_is_empty(struct token_list* p)
{
    assert((p->head == NULL && p->tail == NULL) ||
        (p->head != NULL && p->tail != NULL));

    return p->head == NULL;
}

void print_list(struct token_list* list)
{
    struct token* _Opt current = list->head;
    while (current)
    {
        if (current != list->head)
        {
            printf(u8"˰");
            //printf("`");
        }
        print_literal2(current->lexeme);
        COLOR_ESC_PRINT(printf(RESET));
        if (current == list->tail)
        {
            //printf("`");
        }
        current = current->next;
    }
    printf(u8"\n");
}

void print_literal2(const char* s)
{
    while (*s)
    {
        switch (*s)
        {
        case '\n':
            printf("\\n");
            break;
        default:
            printf("%c", *s);
        }
        s++;
    }
    //printf("`");
}


void print_token(const struct token* p_token)
{
    for (int i = 0; i < p_token->level; i++)
    {
        printf("  ");
    }
    if (p_token->flags & TK_FLAG_FINAL)
        COLOR_ESC_PRINT(printf(LIGHTGREEN));
    else
        COLOR_ESC_PRINT(printf(LIGHTGRAY));
    char buffer0[50] = { 0 };
    snprintf(buffer0, sizeof buffer0, "%d:%d", p_token->line, p_token->col);
    printf("%-6s ", buffer0);
    printf("%-20s ", get_token_name(p_token->type));
    if (p_token->flags & TK_FLAG_MACRO_EXPANDED)
    {
        COLOR_ESC_PRINT(printf(LIGHTCYAN));
    }
    char buffer[50] = { 0 };
    strcat(buffer, "[");
    if (p_token->flags & TK_FLAG_FINAL)
    {
        strcat(buffer, "final ");
    }
    if (p_token->flags & TK_C_BACKEND_FLAG_HIDE)
    {
        strcat(buffer, "hide ");
    }
    if (p_token->flags & TK_FLAG_MACRO_EXPANDED)
    {
        strcat(buffer, "expanded ");
    }
    if (p_token->flags & TK_FLAG_HAS_SPACE_BEFORE)
    {
        strcat(buffer, "space ");
    }
    if (p_token->flags & TK_FLAG_HAS_NEWLINE_BEFORE)
    {
        strcat(buffer, "newline ");
    }
    strcat(buffer, "]");
    printf("%-20s ", buffer);
    print_literal2(p_token->lexeme);
    printf("\n");
    COLOR_ESC_PRINT(printf(RESET));
}

void print_tokens(const struct token* _Opt p_token)
{
    printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n" RESET);
    const struct token* _Opt current = p_token;
    while (current)
    {
        print_token(current);
        current = current->next;
    }
    printf("\n");
    printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n" RESET);
    COLOR_ESC_PRINT(printf(RESET));
}


void print_token_html(struct token* p_token)
{
    printf("<span class=\"");


    if (!(p_token->flags & TK_FLAG_FINAL))
    {
        printf("notfinal ");
    }

    if (p_token->flags & TK_FLAG_FINAL)
    {
        printf("final ");
    }
    if (p_token->flags & TK_C_BACKEND_FLAG_HIDE)
    {
        printf("hide ");
    }
    if (p_token->flags & TK_FLAG_MACRO_EXPANDED)
    {
        printf("expanded ");
    }
    if (p_token->flags & TK_FLAG_HAS_SPACE_BEFORE)
    {
        printf("space ");
    }
    if (p_token->flags & TK_FLAG_HAS_NEWLINE_BEFORE)
    {
        printf("newline ");
    }

    printf("\">");

    print_literal2(p_token->lexeme);

    printf("</span>");

    if (p_token->type == TK_NEWLINE || p_token->type == TK_BEGIN_OF_FILE)
    {
        printf("<br>\n");
    }
}

/*
 CSS for html ouput

 <style>
        .final {
          color:blue;
        }

        .notfinal {
          color:gray;
        }

        .hide {
          text-decoration: line-through;
          color:red;
        }

        .expanded {
           background-color:yellow;
        }

        span {
            border-style: solid;
            border-color: gray;
            border-width: 1px 1px;
            padding:1px;
            margin:2px;
        }

</style>

*/
void print_tokens_html(struct token* p_token)
{
    printf("<pre>\n");
    struct token* _Opt current = p_token;
    while (current)
    {
        print_token_html(current);
        current = current->next;
    }
    printf("\n</pre>");
}

void print_position(const char* path, int line, int col, bool visual_studio_ouput_format)
{

    if (visual_studio_ouput_format)
    {
        //MSVC format
        printf("%s(%d,%d): ", path ? path : "<>", line, col);
    }
    else
    {
        //GCC format
        printf(WHITE "%s:%d:%d: ", path ? path : "<>", line, col);
    }
}

void print_line_and_token(struct marker* p_marker, bool visual_studio_ouput_format)
{

    const struct token* p_token = p_marker->p_token_caret ? p_marker->p_token_caret : p_marker->p_token_begin;

    if (p_token == NULL)
        return;

    const int line = p_marker->line;

    if (!visual_studio_ouput_format)
        COLOR_ESC_PRINT(printf(RESET));

    char nbuffer[20] = { 0 };
    int n = snprintf(nbuffer, sizeof nbuffer, "%d", line);
    printf(" %s |", nbuffer);


    //lets find the begin of line
    const struct token* p_line_begin = p_token;
    while (p_line_begin->prev && (p_line_begin->prev->type != TK_NEWLINE && p_line_begin->prev->type != TK_BEGIN_OF_FILE))
    {
        p_line_begin = p_line_begin->prev;
    }


    const struct token* p_token_begin = p_marker->p_token_begin ? p_marker->p_token_begin : p_marker->p_token_caret;
    const struct token* p_token_end = p_marker->p_token_end ? p_marker->p_token_end : p_marker->p_token_caret;

    //only expand macros if the error is inside
    const bool expand_macro = p_token_begin->flags & TK_FLAG_MACRO_EXPANDED;

    if (!visual_studio_ouput_format)
      COLOR_ESC_PRINT(printf(LIGHTBLUE));

    const struct token* _Opt p_item = p_line_begin;
    while (p_item)
    {
        if (!visual_studio_ouput_format)
        {
            if (p_item->flags & TK_FLAG_MACRO_EXPANDED)
            {
                COLOR_ESC_PRINT(printf(DARKGRAY));
            }
            else if (p_item->type >= TK_KEYWORD_AUTO && 
                     p_item->type <= TK_KEYWORD_IS_INTEGRAL)
            {
                COLOR_ESC_PRINT(printf(BLUE));
            }
            else if (p_item->type == TK_COMMENT || 
                     p_item->type == TK_LINE_COMMENT)
            {
                COLOR_ESC_PRINT(printf(YELLOW));
            }
        }

        if (!(p_item->flags & TK_FLAG_MACRO_EXPANDED) || expand_macro)
        {
            const char* p = p_item->lexeme;
            while (*p)
            {
                putc(*p, stdout);
                p++;
            }
        }

        if (!visual_studio_ouput_format)
        {            
            COLOR_ESC_PRINT(printf(RESET));
        }

        if (p_item->type == TK_NEWLINE)
            break;
        p_item = p_item->next;
    }

    if (!visual_studio_ouput_format)
        COLOR_ESC_PRINT(printf(RESET));

    if (p_item == NULL) printf("\n");

    printf(" %*s |", n, " ");
    bool complete = false;
    int start_col = 1;
    int end_col = 1;
    bool onoff = false;
    p_item = p_line_begin;
    while (p_item)
    {
        if (p_item == p_token_begin)
        {
            if (!visual_studio_ouput_format)
                COLOR_ESC_PRINT(printf(LIGHTGREEN));
            onoff = true;
            end_col = start_col;
        }

        if (!(p_item->flags & TK_FLAG_MACRO_EXPANDED) || expand_macro)
        {
            const char* p = p_item->lexeme;
            while (*p)
            {

                if (onoff)
                {
                    putc('~', stdout);
                    end_col++;
                }
                else
                {
                    putc(' ', stdout);
                    if (!complete) start_col++;
                }
                p++;
            }
        }

        if (p_item->type == TK_NEWLINE)
            break;

        if (p_item == p_token_end)
        {
            complete = true;
            onoff = false;
            if (!visual_studio_ouput_format)
                COLOR_ESC_PRINT(printf(RESET));
        }

        p_item = p_item->next;
    }

    if (!visual_studio_ouput_format)
        COLOR_ESC_PRINT(printf(RESET));

    printf("\n");
    p_marker->start_col = start_col;
    p_marker->end_col = end_col;
}

static void digit_sequence(struct stream* stream)
{
    while (is_digit(stream))
    {
        stream_match(stream);
    }
}

static void binary_exponent_part(struct stream* stream)
{
    // p signopt digit - sequence
    // P   signopt digit - sequence

    stream_match(stream); // p or P
    if (stream->current[0] == '+' || stream->current[0] == '-')
    {
        stream_match(stream); // p or P
    }
    digit_sequence(stream);
}

static bool is_hexadecimal_digit(struct stream* stream)
{
    return (stream->current[0] >= '0' && stream->current[0] <= '9') ||
        (stream->current[0] >= 'a' && stream->current[0] <= 'f') ||
        (stream->current[0] >= 'A' && stream->current[0] <= 'F');
}

static bool is_octal_digit(struct stream* stream)
{
    return stream->current[0] >= '0' && stream->current[0] <= '7';
}

static void hexadecimal_digit_sequence(struct stream* stream)
{
    /*
     hexadecimal-digit-sequence:
     hexadecimal-digit
     hexadecimal-digit ’_Opt hexadecimal-digit
    */

    stream_match(stream);
    while (stream->current[0] == '\'' ||
        is_hexadecimal_digit(stream))
    {
        if (stream->current[0] == '\'')
        {
            stream_match(stream);
            if (!is_hexadecimal_digit(stream))
            {
                // erro
            }
            stream_match(stream);
        }
        else
            stream_match(stream);
    }
}

static void integer_suffix_opt(struct stream* stream, char suffix[4])
{
    /*
        (6.4.4.2) integer-suffix:
          unsigned-suffix long-suffixopt
          unsigned-suffix long-long-suffix
          unsigned-suffix bit-precise-int-suffix
          long-suffix unsigned-suffixopt
          long-long-suffix unsigned-suffixopt
          bit-precise-int-suffix unsigned-suffixop
    */

    //test 3100
    if (/*unsigned-suffix*/
        stream->current[0] == 'U' || stream->current[0] == 'u')
    {
        suffix[0] = 'U';
        stream_match(stream);


        /*long-suffixopt*/
        if (stream->current[0] == 'l' || stream->current[0] == 'L')
        {
            suffix[1] = 'L';
            stream_match(stream);
        }

        /*long-long-suffix*/
        if (stream->current[0] == 'l' || stream->current[0] == 'L')
        {
            suffix[2] = 'L';
            stream_match(stream);
        }
    }
    else if ((stream->current[0] == 'l' || stream->current[0] == 'L'))
    {
        suffix[0] = 'L';

        /*long-suffix*/
        stream_match(stream);

        /*long-long-suffix*/
        if ((stream->current[0] == 'l' || stream->current[0] == 'L'))
        {
            suffix[1] = 'L';
            stream_match(stream);
        }

        if (/*unsigned-suffix*/
            stream->current[0] == 'U' || stream->current[0] == 'u')
        {

            //normalize the output from LLU to ul 
            suffix[3] = suffix[2];
            suffix[2] = suffix[1];
            suffix[1] = suffix[0];
            suffix[0] = 'U';
            stream_match(stream);
        }
    }
    ///////////////MICROSOFT ////////////////////////
        //TODO unit test
    else if (stream->current[0] == 'i' &&
             stream->current[1] == '8')
    {
        stream_match(stream);
        stream_match(stream);
        stream_match(stream);
        suffix[0] = 'i';
        suffix[1] = '8';
    }
    else if (stream->current[0] == 'i' &&
             stream->current[1] == '3' &&
             stream->current[2] == '2')
    {
        stream_match(stream);
        stream_match(stream);
        stream_match(stream);
        suffix[0] = 'i';
        suffix[1] = '3';
        suffix[2] = '2';
    }
    else if (stream->current[0] == 'i' &&
             stream->current[1] == '6' &&
             stream->current[2] == '4')
    {
        stream_match(stream);
        stream_match(stream);
        stream_match(stream);
        suffix[0] = 'i';
        suffix[1] = '6';
        suffix[2] = '4';
    }
    ///////////////MICROSOFT ////////////////////////
}

static void exponent_part_opt(struct stream* stream)
{
    /*
    exponent-part:
    e signopt digit-sequence
    E signopt digit-sequence
    */
    if (stream->current[0] == 'e' || stream->current[0] == 'E')
    {
        stream_match(stream);

        if (stream->current[0] == '-' || stream->current[0] == '+')
        {
            stream_match(stream);
        }
        digit_sequence(stream);
    }
}

static void floating_suffix_opt(struct stream* stream, char suffix[4])
{

    if (stream->current[0] == 'l' || stream->current[0] == 'L')
    {
        suffix[0] = 'L';
        stream_match(stream);
    }
    else if (stream->current[0] == 'f' || stream->current[0] == 'F')
    {
        suffix[0] = 'F';
        stream_match(stream);
    }
}

static bool is_binary_digit(struct stream* stream)
{
    return stream->current[0] >= '0' && stream->current[0] <= '1';
}

static bool is_nonzero_digit(struct stream* stream)
{
    return stream->current[0] >= '1' && stream->current[0] <= '9';
}

enum token_type parse_number_core(struct stream* stream, char suffix[4], _Out char errmsg[100])
{
    errmsg[0] = '\0';

    enum token_type type = TK_NONE;
    if (stream->current[0] == '.')
    {
        type = TK_COMPILER_DECIMAL_FLOATING_CONSTANT;
        stream_match(stream);
        digit_sequence(stream);
        exponent_part_opt(stream);
        floating_suffix_opt(stream, suffix);
    }
    else if (stream->current[0] == '0' && (stream->current[1] == 'x' || stream->current[1] == 'X'))
    {
        type = TK_COMPILER_HEXADECIMAL_CONSTANT;

        stream_match(stream);
        stream_match(stream);

        if (is_hexadecimal_digit(stream))
        {
            while (is_hexadecimal_digit(stream))
            {
                stream_match(stream);
            }
        }
        else
        {
            snprintf(errmsg, 100, "expected hexadecimal digit");
            return TK_NONE;
        }

        integer_suffix_opt(stream, suffix);

        if (stream->current[0] == '.')
        {
            type = TK_COMPILER_HEXADECIMAL_FLOATING_CONSTANT;
            hexadecimal_digit_sequence(stream);
        }

        if (stream->current[0] == 'p' ||
            stream->current[0] == 'P')
        {
            type = TK_COMPILER_HEXADECIMAL_FLOATING_CONSTANT;
            binary_exponent_part(stream);
        }

        if (type == TK_COMPILER_HEXADECIMAL_FLOATING_CONSTANT)
        {
            floating_suffix_opt(stream, suffix);
        }
    }
    else if (stream->current[0] == '0' && (stream->current[1] == 'b' || stream->current[1] == 'B'))
    {
        type = TK_COMPILER_BINARY_CONSTANT;
        stream_match(stream);
        stream_match(stream);
        if (is_binary_digit(stream))
        {
            while (is_binary_digit(stream))
            {
                stream_match(stream);
            }
        }
        else
        {
            snprintf(errmsg, 100, "expected binary digit");
            return TK_NONE;
        }
        integer_suffix_opt(stream, suffix);
    }
    else if (stream->current[0] == '0') // octal
    {
        type = TK_COMPILER_OCTAL_CONSTANT;

        stream_match(stream);

        if (stream->current[0] == 'O' || stream->current[0] == 'o')
        {
            //C2Y
            //https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3319.htm
            stream_match(stream);
        }

        while (is_octal_digit(stream))
        {
            stream_match(stream);
        }
        integer_suffix_opt(stream, suffix);

        if (stream->current[0] == '.')
        {
            hexadecimal_digit_sequence(stream);
            floating_suffix_opt(stream, suffix);
        }
    }
    else if (is_nonzero_digit(stream)) // decimal
    {
        type = TK_COMPILER_DECIMAL_CONSTANT;

        stream_match(stream);
        while (is_digit(stream))
        {
            stream_match(stream);
        }
        integer_suffix_opt(stream, suffix);

        if (stream->current[0] == 'e' || stream->current[0] == 'E')
        {
            exponent_part_opt(stream);
            floating_suffix_opt(stream, suffix);

        }
        else if (stream->current[0] == '.')
        {
            stream_match(stream);
            type = TK_COMPILER_DECIMAL_FLOATING_CONSTANT;
            digit_sequence(stream);
            exponent_part_opt(stream);
            floating_suffix_opt(stream, suffix);
        }
    }

    return type;
}

enum token_type parse_number(const char* lexeme, char suffix[4], _Out char errmsg[100])
{
    struct stream stream = { .source = lexeme, .current = lexeme, .line = 1, .col = 1 };
    return parse_number_core(&stream, suffix, errmsg);
}


/*
    https://en.wikipedia.org/wiki/UTF-8
    Since the restriction of the Unicode code-space to 21-bit values in 2003,
    UTF-8 is defined to encode code points in one to four bytes, depending on the number
    of significant bits in the numerical value of the code point. The following table shows
    the structure of the encoding. The x characters are replaced by the bits of the code point.

    Code point <->UTF - 8 conversion
    First         | Last           | Byte 1   | Byte 2   | Byte 3   | Byte 4
    --------------| -------------- |----------|----------|----------| ----------
    U+0000      0 | U+007F     127 | 0xxxxxxx |          |          |
    U+0080    128 | U+07FF    2047 | 110xxxxx | 10xxxxxx |          |
    U+0800   2048 | U+FFFF   65535 | 1110xxxx | 10xxxxxx | 10xxxxxx |
    U+10000 65536 | U+10FFFF 69631 | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx
*/

const unsigned char* _Opt utf8_decode(const unsigned char* s, _Out unsigned int* c)
{
    *c = 0; //out

    if (s[0] == '\0')
    {
        *c = 0;
        return NULL; /*end*/
    }

    const unsigned char* _Opt next = NULL;
    if (s[0] < 0x80)
    {
        *c = s[0];
        assert(*c >= 0x0000 && *c <= 0x007F);
        next = s + 1;
    }
    else if ((s[0] & 0xe0) == 0xc0)
    {
        *c = ((int)(s[0] & 0x1f) << 6) |
            ((int)(s[1] & 0x3f) << 0);
        assert(*c >= 0x0080 && *c <= 0x07FF);
        next = s + 2;
    }
    else if ((s[0] & 0xf0) == 0xe0)
    {
        *c = ((int)(s[0] & 0x0f) << 12) |
            ((int)(s[1] & 0x3f) << 6) |
            ((int)(s[2] & 0x3f) << 0);
        assert(*c >= 0x0800 && *c <= 0xFFFF);
        next = s + 3;
    }
    else if ((s[0] & 0xf8) == 0xf0 && (s[0] <= 0xf4))
    {
        *c = ((int)(s[0] & 0x07) << 18) |
            ((int)(s[1] & 0x3f) << 12) |
            ((int)(s[2] & 0x3f) << 6) |
            ((int)(s[3] & 0x3f) << 0);
        assert(*c >= 0x10000 && *c <= 0x10FFFF);
        next = s + 4;
    }
    else
    {
        *c = 0;      // invalid
        next = s + 1; // skip this byte
    }

    if (*c >= 0xd800 && *c <= 0xdfff)
    {
        *c = 0; // surrogate half
    }

    return next;
}

static bool is_hex_digit(unsigned char c)
{
    if (c >= '0' && c <= '9')
        return true;
    else if (c >= 'a' && c <= 'f')
        return true;
    else if (c >= 'A' && c <= 'F')
        return true;
    return false;
}

const unsigned char* _Opt escape_sequences_decode_opt(const unsigned char* p, unsigned int* out_value)
{
    // TODO OVERFLOW CHECK
    if (*p == 'x')
    {
        p++;
        int result = 0;
        while (is_hex_digit(*p))
        {
            int byte = 0;
            if (*p >= '0' && *p <= '9')
                byte = (*p - '0');
            else if (*p >= 'a' && *p <= 'f')
                byte = (*p - 'a') + 10;
            else if (*p >= 'A' && *p <= 'F')
                byte = (*p - 'A') + 10;

            result = (result << 4) | (byte & 0xF);
            p++;
        }

        *out_value = result;
    }
    else if (*p == 'u' || *p == 'U')
    {
        // TODO  assuming input is checked
        // missing tests
        const int num_of_hex_digits = *p == 'U' ? 8 : 4;

        p++;
        unsigned long long result = 0;
        for (int i = 0; i < num_of_hex_digits; i++)
        {
            int byte = 0;
            if (*p >= '0' && *p <= '9')
                byte = (*p - '0');
            else if (*p >= 'a' && *p <= 'f')
                byte = (*p - 'a') + 10;
            else if (*p >= 'A' && *p <= 'F')
                byte = (*p - 'A') + 10;

            result = (result << 4) | (byte & 0xF);
            p++;
        }

        *out_value = (int)result;
    }
    else if (*p == '0')
    {
        // octal digit
        p++;

        int result = 0;
        while ((*p >= '0' && *p <= '7'))
        {
            int byte;
            byte = (*p - '0');
            result = (result << 4) | (byte & 0xF);
            p++;
        }
        *out_value = result;
    }
    else
    {
        switch (*p)
        {
        case 'a':
            *out_value = '\a';
            break;
        case 'b':
            *out_value = '\b';
            break;
        case 'f':
            *out_value = '\f';
            break;
        case 'n':
            *out_value = '\n';
            break;
        case 'r':
            *out_value = '\r';
            break;
            ;
        case 't':
            *out_value = '\t';
            break;
        case '\'':
            *out_value = '\'';
            break;
        case '\\':
            *out_value = '\\';
            break;
        case '"':
            *out_value = '"';
            break;
        default:
            // this is handled at tokenizer
            assert(false);
            return NULL;
        }
        p++;
    }

    return p;
}



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/


#pragma safety enable




/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/


//#pragma once

unsigned int string_hash(const char* key);


unsigned int string_hash(const char* key)
{
    // hash key to unsigned int value by pseudorandomizing transform
    // (algorithm copied from STL char hash in xfunctional)
    unsigned int hash_val = 2166136261U;
    unsigned int first = 0;
    unsigned int last = (unsigned int)strlen(key);
    unsigned int stride = 1 + last / 10;

    for (; first < last; first += stride)
    {
        hash_val = 16777619U * hash_val ^ (unsigned int)key[first];
    }

    return (hash_val);
}


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

#pragma safety enable

#ifdef _WIN32
#endif

#if defined _MSC_VER
#endif


void hashmap_remove_all(struct hash_map* map)
{

    if (map->table != NULL)
    {
        for (int i = 0; i < map->capacity; i++)
        {
            struct map_entry* _Owner _Opt pentry = map->table[i];

            while (pentry != NULL)
            {
                struct map_entry* _Owner _Opt next = pentry->next;
                free(pentry->key);
                free(pentry);
                pentry = next;
            }
        }

        free(map->table);
        map->table = NULL;
        map->size = 0;
    }
}

void hashmap_destroy(struct hash_map* _Obj_owner map)
{
    hashmap_remove_all(map);
    assert(map->table == NULL);
}

struct map_entry* _Opt hashmap_find(struct hash_map* map, const char* key)
{
    if (map->table == NULL)
        return NULL;

    const unsigned int hash = string_hash(key);
    const int index = hash % map->capacity;

    struct map_entry* _Opt pentry = map->table[index];

    for (; pentry != NULL; pentry = pentry->next)
    {
        if (pentry->hash == hash && strcmp(pentry->key, key) == 0)
        {
            return pentry;
        }
    }

    return NULL;
}


void* _Opt hashmap_remove(struct hash_map* map, const char* key, enum tag* p_type_opt)
{
    if (map->table != NULL)
    {
        const unsigned int hash = string_hash(key);
        struct map_entry** pp_entry = &map->table[hash % map->capacity];
        struct map_entry* p_entry = *pp_entry;

        for (; p_entry != NULL; p_entry = p_entry->next)
        {
            if ((p_entry->hash == hash) && (strcmp(p_entry->key, key) == 0))
            {
                *pp_entry = p_entry->next;

                if (p_type_opt)
                    *p_type_opt = p_entry->type;

                void* p = p_entry->p;
                free((void* _Owner)p_entry->key);
                free((void* _Owner)p_entry);

                return p;
            }
            pp_entry = &p_entry->next;
        }
    }

    return NULL;
}


int hashmap_set(struct hash_map* map, const char* key, const void* p, enum tag type)
{
    int result = 0;

    try
    {
        if (map->table == NULL)
        {
            if (map->capacity < 1)
            {
                map->capacity = 1000;
            }

            map->table = calloc(map->capacity, sizeof(map->table[0]));
            if (map->table == NULL) throw;
        }

        if (map->table != NULL)
        {
            unsigned int hash = string_hash(key);
            int index = hash % map->capacity;

            struct map_entry* pentry = map->table[index];

            for (; pentry != NULL; pentry = pentry->next)
            {
                if (pentry->hash == hash && strcmp(pentry->key, key) == 0)
                {
                    break;
                }
            }

            if (pentry == NULL)
            {
                struct map_entry* _Owner _Opt p_new_entry = calloc(1, sizeof(*pentry));
                if (p_new_entry == NULL) throw;

                p_new_entry->hash = hash;
                p_new_entry->p = (void*)p;
                p_new_entry->type = type;
                p_new_entry->key = strdup(key);
                p_new_entry->next = map->table[index];
                map->table[index] = p_new_entry;
                map->size++;
                result = 0;
            }
            else
            {
                result = 1;
                pentry->p = (void*)p;
                pentry->type = type;
            }
        }
    }
    catch
    {
    }
    return result;
}


/////////////



void owner_hashmap_remove_all(struct owner_hash_map* map, void (*pf)(void* _Owner))
{
    if (map->table != NULL)
    {
        for (int i = 0; i < map->capacity; i++)
        {
            struct owner_map_entry* _Owner _Opt pentry = map->table[i];

            while (pentry != NULL)
            {
                struct owner_map_entry* _Owner _Opt next = pentry->next;

                pf(pentry->p); //TODO

                free(pentry->key);
                free(pentry);

                pentry = next;
            }
        }

        free(map->table);
        map->table = NULL;
        map->size = 0;
    }
}

void owner_hashmap_destroy(struct owner_hash_map* _Obj_owner map, void (*pf)(void* _Owner))
{
    owner_hashmap_remove_all(map, pf);
    assert(map->table == NULL);
}

struct owner_map_entry* _Opt owner_hashmap_find(struct owner_hash_map* map, const char* key)
{
    if (map->table == NULL)
        return NULL;

    const unsigned int hash = string_hash(key);
    const int index = hash % map->capacity;

    struct owner_map_entry* _Opt pentry = map->table[index];

    for (; pentry != NULL; pentry = pentry->next)
    {
        if (pentry->hash == hash && strcmp(pentry->key, key) == 0)
        {
            return pentry;
        }
    }

    return NULL;
}


void* _Owner _Opt owner_hashmap_remove(struct owner_hash_map* map, const char* key, enum tag* p_type_opt)
{
    if (map->table != NULL)
    {
        const unsigned int hash = string_hash(key);
        struct owner_map_entry* _Opt* pp_entry = &map->table[hash % map->capacity];
        struct owner_map_entry* _Opt p_entry = *pp_entry;

        for (; p_entry != NULL; p_entry = p_entry->next)
        {
            if ((p_entry->hash == hash) && (strcmp(p_entry->key, key) == 0))
            {
                *pp_entry = p_entry->next;

                if (p_type_opt)
                    *p_type_opt = p_entry->type;

                void* _Owner _Opt p = p_entry->p;
                free(p_entry->key);
                free((void* _Owner)p_entry);

                return p;
            }
            pp_entry = &p_entry->next;
        }
    }

    return NULL;
}


void* _Owner _Opt owner_hashmap_set(struct owner_hash_map* map, const char* key, const void* _Owner p, enum tag type)
{
    void* _Owner _Opt previous = NULL;

    try
    {
        if (map->table == NULL)
        {
            if (map->capacity < 1)
            {
                map->capacity = 1000;
            }

            map->table = calloc(map->capacity, sizeof(map->table[0]));
            if (map->table == NULL) throw;
        }

        const unsigned int hash = string_hash(key);
        const int index = hash % map->capacity;

        /* searching existing entry */
        struct owner_map_entry* _Opt pentry = map->table[index];

        for (; pentry != NULL; pentry = pentry->next)
        {
            if (pentry->hash == hash && strcmp(pentry->key, key) == 0)
            {
                break;
            }
        }

        if (pentry == NULL)
        {
            char* _Owner _Opt const key_temp = strdup(key);
            if (key_temp == NULL) throw;

            struct owner_map_entry* _Owner _Opt p_new_entry = calloc(1, sizeof(*pentry));
            if (p_new_entry == NULL)
            {
                free(key_temp);
                throw;
            }

            p_new_entry->hash = hash;
            p_new_entry->p = (void* _Owner)p;
            p_new_entry->type = type;
            p_new_entry->key = key_temp;

            p_new_entry->next = map->table[index];
            map->table[index] = p_new_entry;
            map->size++;
        }
        else
        {
            previous = pentry->p;
            pentry->p = (void* _Owner) p;
            pentry->type = type;
        }
    }
    catch
    {
        //if caller receives the same pointer p then it is an error
        return (void* _Owner _Opt) p;
    }
    return previous;
}



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

#pragma safety enable


#ifdef _WIN32
#else


#include <termios.h>


#include <unistd.h>


#include <fcntl.h>


#include <sys/ioctl.h>
#endif

#ifndef WIN32

bool enable_vt_mode(void)
{
    return true;
}

int c_kbhit(void)
{
    struct termios oldt = {0};
    struct termios newt = {0};
    int ch;
    int oldf;

    tcgetattr(STDIN_FILENO, &oldt);
    newt = oldt;
    newt.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &newt);
    oldf = fcntl(STDIN_FILENO, F_GETFL, 0);
    fcntl(STDIN_FILENO, F_SETFL, oldf | O_NONBLOCK);

    ch = getchar();

    tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
    fcntl(STDIN_FILENO, F_SETFL, oldf);

    if (ch != EOF)
    {
        ungetc(ch, stdin);
        return 1;
    }

    return 0;
}

/* Read 1 character without echo */
int c_getch(void)
{
    struct termios old = {0};
    struct termios new = {0};
    int ch;

    tcgetattr(0, &old);

    new = old;
    new.c_lflag &= ~ICANON;
    new.c_lflag &= ~ECHO;
    tcsetattr(0, TCSANOW, &new);

    ch = getchar();

    tcsetattr(0, TCSANOW, &old);

    return ch;
}

#else

bool enable_vt_mode(void)
{
//missing in mingw (installed with codeblocs)
#ifndef ENABLE_VIRTUAL_TERMINAL_PROCESSING  
#define ENABLE_VIRTUAL_TERMINAL_PROCESSING  0x0004
#endif

    DWORD mode = 0;
    HANDLE h_out = GetStdHandle(STD_OUTPUT_HANDLE);
    if (h_out != INVALID_HANDLE_VALUE &&
            GetConsoleMode(h_out, &mode) != 0 &&
            SetConsoleMode(h_out, mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING) != 0 &&
            SetConsoleOutputCP(CP_UTF8) != 0)
    {
        return true;//ok
    }
    return false;//error
}

int c_kbhit(void)
{
    return _kbhit();
}
int c_getch(void)
{
    return _getch();
}

#endif

void c_clrscr()
{
    puts("\x1b[2J\x1b[1;1H");
    fflush(stdout);
}


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

#pragma safety enable

/*

   1 - The initial input is a string.
   2 - This string is transformed into a linked list of tokens

   ┌───┐   ┌───┐   ┌───┐   ┌───┐
   │   ├──►│   ├──►│   ├──►│   │──► NULL
   └───┘   └───┘   └───┘   └───┘

   The list is then expanded using includes and macros through a preprocessor.


   ┌───┐                  ┌───┐   ┌───┐   ┌───┐
   │   ├──────┐           │   ├──►│x  ├──►│x  │ ──► NULL   Level 0
   └───┘      │           └───┘   └───┘   └───┘
            ┌─▼─┐   ┌───┐   ▲
            │   ├───┤   ├───┘  (includes)                  Level 1
            └───┘   └───┘


    Each item in the list has additional properties:

    level         :  An integer indicating the level of inclusion.

    bmacroexpanded: A boolean indicating whether the token was generated
                    from macro expansion.

    bfinal        : A boolean indicating whether the token is the
                    final, the one seen by the parser.

*/



#include <ctype.h>


#include <sys/stat.h>


#include <errno.h>


#include <stddef.h>


#include <time.h>


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

//#pragma once


#ifdef _WIN32 


#include <direct.h>


#include <sys/types.h>

#ifdef __CAKE__
#pragma cake diagnostic push
#pragma cake diagnostic ignored "-Wstyle"
#endif


//https://docs.microsoft.com/pt-br/cpp/c-runtime-library/reference/mkdir-wmkdir?_View=msvc-160
#define mkdir(a, b) _mkdir(a)
#define rmdir _rmdir
#define chdir _chdir

#ifdef __CAKE__
#pragma cake diagnostic pop
#endif

/*
 opendir,  readdir closedir for windows.
 include dirent.h on linux
*/



enum
{
    DT_UNKNOWN = 0,
    DT_FIFO = 1,
    DT_CHR = 2,
    DT_DIR = 4,
    DT_BLK = 6,
    DT_REG = 8,
    DT_LNK = 10,
    DT_SOCK = 12,
    DT_WHT = 14
};

struct dirent
{
    ino_t d_ino;             /* Inode number */
    off_t d_off;             /* Not an offset; see below */
    unsigned short d_reclen; /* Length of this record */
    unsigned char d_type;    /* Type of file; not supported
                                     by all filesystem types*/
    char d_name[256];        /* Null-terminated filename */
};

#ifdef __CAKE__
#pragma CAKE diagnostic push
#pragma CAKE diagnostic ignored "-Wstyle"
#endif
struct TAGDIR;
typedef struct TAGDIR DIR;

#ifdef __CAKE__
#pragma CAKE diagnostic pop
#endif

DIR* _Owner _Opt opendir(const char* name);
int closedir(DIR* _Owner dirp);
struct dirent* _Opt readdir(DIR* dirp);


#else

//TODO fails on macos because it has a diferent declaration
//typedef struct __dirstream DIR;
//DIR * _Owner _Opt opendir (const char *__name);
//int closedir(DIR* _Owner dirp);


#define MAX_PATH 500

//https://man7.org/linux/man-pages/man2/mkdir.2.html


#include <dirent.h>
#endif



char* _Opt realpath(const char* restrict path, char* restrict resolved_path);

int get_self_path(char* buffer, int maxsize);

char* _Owner _Opt read_file(const char* path);
char* dirname(char* path);
char* basename(const char* filename);

const char* get_posix_error_message(int error);


bool path_is_relative(const char* path);
bool path_is_absolute(const char* path);



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

//#pragma once

struct preprocessor_ctx;

int pre_constant_expression(struct preprocessor_ctx* ctx, long long* pvalue);



#ifdef _WIN32
#endif

#if defined _MSC_VER && !defined __POCC__
#endif

#define STRINGIFY(x) #x
#define TOSTRING(x) STRINGIFY(x)


// Includes tokens that are not necessary for compilation at second level of includes
enum { INCLUDE_ALL = 1 };

///////////////////////////////////////////////////////////////////////////////
void naming_convention_macro(struct preprocessor_ctx* ctx, struct token* token);
///////////////////////////////////////////////////////////////////////////////



struct macro_parameter
{
    const char* _Owner name;
    struct macro_parameter* _Owner _Opt next;
};



struct macro
{
    const char* _Owner name;
    struct token_list replacement_list; /*copy*/
    struct macro_parameter* _Owner _Opt parameters;
    bool is_function;
    int usage;

    bool expand;
};


void delete_macro(struct macro* _Owner _Opt macro);

static void delete_macro_void(void* _Owner _Opt p)
{
    struct macro* _Owner _Opt p_macro = p;
    delete_macro(p_macro);
}

void include_dir_list_destroy(struct include_dir_list* _Obj_owner list)
{
    struct include_dir* _Owner _Opt p = list->head;
    while (p)
    {
        struct include_dir* _Owner _Opt next = p->next;
        free((void* _Owner)p->path);
        free(p);
        p = next;
    }
}

void preprocessor_ctx_destroy(struct preprocessor_ctx* _Obj_owner p)
{
    owner_hashmap_destroy(&p->macros, delete_macro_void);
    include_dir_list_destroy(&p->include_dir);
    hashmap_destroy(&p->pragma_once_map);
    token_list_destroy(&p->input_list);
}

struct token_list preprocessor(struct preprocessor_ctx* ctx, struct token_list* input_list, int level);

static void tokenizer_set_error(struct tokenizer_ctx* ctx, struct stream* stream, const char* fmt, ...)
{
    ctx->n_errors++;

    char buffer[200] = { 0 };

#pragma CAKE diagnostic push
#pragma CAKE diagnostic ignored "-Wnullable-to-non-nullable"
#pragma CAKE diagnostic ignored "-Wanalyzer-null-dereference"



    va_list args = { 0 };
    va_start(args, fmt);
    /*int n =*/ vsnprintf(buffer, sizeof(buffer), fmt, args);
    va_end(args);

#pragma CAKE diagnostic pop

    print_position(stream->path, stream->line, stream->col, ctx->options.visual_studio_ouput_format);
    if (ctx->options.visual_studio_ouput_format)
    {
        printf("error: "  "%s\n", buffer);
    }
    else
    {
        printf(LIGHTRED "error: " WHITE "%s\n", buffer);
    }
}


static void tokenizer_set_warning(struct tokenizer_ctx* ctx, struct stream* stream, const char* fmt, ...)
{
    ctx->n_warnings++;


    char buffer[200] = { 0 };

#pragma CAKE diagnostic push
#pragma CAKE diagnostic ignored "-Wnullable-to-non-nullable"
#pragma CAKE diagnostic ignored "-Wanalyzer-null-dereference"


    va_list args = { 0 };
    va_start(args, fmt);
    /*int n =*/ vsnprintf(buffer, sizeof(buffer), fmt, args);
    va_end(args);

#pragma CAKE diagnostic pop

    print_position(stream->path, stream->line, stream->col, ctx->options.visual_studio_ouput_format);
    if (ctx->options.visual_studio_ouput_format)
    {
        printf("warning: " "%s\n", buffer);
    }
    else
    {
        printf(LIGHTMAGENTA "warning: " WHITE "%s\n", buffer);
    }

}


bool preprocessor_diagnostic_message(enum diagnostic_id w, struct preprocessor_ctx* ctx, const struct token* _Opt p_token_opt, const char* fmt, ...)
{
    struct marker marker = { 0 };

    if (p_token_opt == NULL) return false;

    marker.file = p_token_opt->token_origin->lexeme;
    marker.line = p_token_opt->line;
    marker.start_col = p_token_opt->col;
    marker.end_col = p_token_opt->col;
    marker.p_token_caret = p_token_opt;

    /*warnings inside headers are ignored*/
    const bool included_file_location = p_token_opt->level > 0;

    bool is_error = false;
    bool is_warning = false;
    bool is_note = false;

    if (included_file_location)
    {
        //no message for include dir
        return false;
    }

    if (w > W_NOTE)
    {
        is_error = true;
    }
    else
    {
        is_error =
            (ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors & (1ULL << w)) != 0;

        is_warning =
            (ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings & (1ULL << w)) != 0;

        is_note =
            ((ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes & (1ULL << w)) != 0);
    }





    if (is_error)
    {
        ctx->n_errors++;
    }
    else if (is_warning)
    {
        ctx->n_warnings++;
    }
    else if (is_note)
    {

    }
    else
    {
        return false;
    }








    print_position(marker.file, marker.line, marker.start_col, ctx->options.visual_studio_ouput_format);

    char buffer[200] = { 0 };

#pragma CAKE diagnostic push
#pragma CAKE diagnostic ignored "-Wnullable-to-non-nullable"
#pragma CAKE diagnostic ignored "-Wanalyzer-null-dereference"

    va_list args = { 0 };

    va_start(args, fmt);
    /*int n =*/ vsnprintf(buffer, sizeof(buffer), fmt, args);
    va_end(args);
#pragma CAKE diagnostic pop

    if (ctx->options.visual_studio_ouput_format)
    {
        if (is_warning)
            printf("warning: " "%s\n", buffer);
        else if (is_error)
            printf("warning: " "%s\n", buffer);
        else if (is_note)
            printf("note: " "%s\n", buffer);

        print_line_and_token(&marker, ctx->options.visual_studio_ouput_format);
    }
    else
    {
        if (is_error)
            printf(LIGHTRED "error: " WHITE "%s\n", buffer);
        else if (is_warning)
            printf(LIGHTMAGENTA "warning: " WHITE "%s\n", buffer);
        else if (is_note)
            printf(LIGHTCYAN "note: " WHITE "%s\n", buffer);

        print_line_and_token(&marker, ctx->options.visual_studio_ouput_format);

    }

    return true;
}

struct include_dir* _Opt include_dir_add(struct include_dir_list* list, const char* path)
{
    try
    {
        struct include_dir* _Owner _Opt p_new_include_dir = calloc(1, sizeof * p_new_include_dir);
        if (p_new_include_dir == NULL)
            throw;

        int len = strlen(path);
        if (path[len - 1] == '\\')
        {
            //windows path format ending with \ .
            const char* _Owner _Opt temp = strdup(path);
            if (temp == NULL)
            {
                free(p_new_include_dir);
                throw;
            }
            p_new_include_dir->path = temp;
        }
        else if (path[len - 1] != '/')
        {
            /*
              not ending with \, we add it
            */
            const char* _Owner _Opt temp = calloc(len + 2, sizeof(char));
            if (temp == NULL)
            {
                free(p_new_include_dir);
                throw;
            }

            p_new_include_dir->path = temp;
            snprintf((char*)p_new_include_dir->path, len + 2, "%s/", path);
        }
        else
        {
            const char* _Owner _Opt temp = strdup(path);
            if (temp == NULL)
            {
                free(p_new_include_dir);
                throw;
            }
            p_new_include_dir->path = temp;
        }

        if (list->head == NULL)
        {
            list->head = p_new_include_dir;
            list->tail = p_new_include_dir;
        }
        else
        {
            assert(list->tail != NULL);
            assert(list->tail->next == NULL);
            list->tail->next = p_new_include_dir;
            list->tail = p_new_include_dir;
        }
        return list->tail;
    }
    catch
    {

    }
    return NULL;
}


const char* _Owner _Opt  find_and_read_include_file(struct preprocessor_ctx* ctx,
    const char* path, /*as in include*/
    const char* current_file_dir, /*this is the dir of the file that includes*/
    bool* p_already_included, /*_Out file alread included pragma once*/
    char full_path_out[], /*this is the final full path of the file*/
    int full_path_out_size)
{

    full_path_out[0] = '\0';

    if (path_is_absolute(path))
    {
        //todo realpath
        if (hashmap_find(&ctx->pragma_once_map, path) != NULL)
        {
            *p_already_included = true;
            return NULL;
        }

        char* _Owner _Opt content = read_file(path);
        if (content != NULL)
        {
            snprintf(full_path_out, full_path_out_size, "%s", path);
            return content;
        }
        return NULL;
    }



    char newpath[200] = { 0 };
    snprintf(newpath, sizeof newpath, "%s/%s", current_file_dir, path);

#ifdef __EMSCRIPTEN__
    /*realpath returns empty on emscriptem*/
    snprintf(full_path_out, full_path_out_size, "%s", newpath);
#else
    if (!realpath(newpath, full_path_out))
        full_path_out[0] = '\0';
#endif


    if (hashmap_find(&ctx->pragma_once_map, full_path_out) != NULL)
    {
        *p_already_included = true;
        return NULL;
    }

    char* _Owner _Opt content = read_file(full_path_out);
    if (content != NULL)
        return content;


    struct include_dir* _Opt current = ctx->include_dir.head;
    while (current)
    {
        int len = strlen(current->path);
        if (current->path[len - 1] == '/')
        {
            snprintf(full_path_out, full_path_out_size, "%s%s", current->path, path);
        }
        else
        {
            snprintf(full_path_out, full_path_out_size, "%s/%s", current->path, path);
        }

        if (hashmap_find(&ctx->pragma_once_map, full_path_out) != NULL)
        {
            *p_already_included = true;
            return NULL;
        }

        content = read_file(full_path_out);
        if (content != NULL)
        {
            return content;
        }
        current = current->next;
    }
    full_path_out[0] = '\0';
    return NULL;
}





/*used to check recursion*/
struct macro_expanded
{
    const char* name;
    struct macro_expanded* _Opt p_previous;
};


void add_macro(struct preprocessor_ctx* ctx, const char* name)
{
    try
    {
        char* _Owner _Opt name_local = strdup(name);
        if (name_local == NULL)
        {
            throw;
        }

        struct macro* _Owner _Opt macro = calloc(1, sizeof * macro);
        if (macro == NULL)
        {
            free(name_local);
            throw;
        }

        macro->name = name_local;
        struct macro* _Owner _Opt previous = (struct macro* _Owner)owner_hashmap_set(&ctx->macros, name, (void* _Owner) macro, 0);
        if (previous)
        {
            delete_macro(previous);
            previous = NULL;
        }
    }
    catch
    {
    }
}

struct macro_argument
{
    const char* _Owner name;
    struct token_list tokens;
    struct macro_argument* _Owner _Opt next; /*linked list*/
};
void macro_argument_delete(struct macro_argument* _Owner _Opt p);


struct token_list copy_replacement_list(const struct token_list* list);

struct token_list copy_argument_list_tokens(struct token_list* list)
{
    // Makes a copy of the tokens, trimming the beginning and end
    // Any space, comments, etc., will become a single space
    struct token_list r = { 0 };
    struct token* _Opt current = list->head; /*null is fine*/

    // skip all leading white spaces
    while (current &&
        (token_is_blank(current) ||
            current->type == TK_NEWLINE))
    {
        current = current->next;
    }

    // Removes leading space flag if present
    bool is_first = true;

    for (; current;)
    {
        if (current && (token_is_blank(current) ||
            current->type == TK_NEWLINE))
        {
            if (current == list->tail)
                break;

            current = current->next;
            continue;
        }
        struct token* token = token_list_clone_and_add(&r, current);
        if (token->flags & TK_FLAG_HAS_NEWLINE_BEFORE)
        {
            token->flags = token->flags & ~TK_FLAG_HAS_NEWLINE_BEFORE;
            token->flags |= TK_FLAG_HAS_SPACE_BEFORE;
        }
        if (is_first)
        {
            token->flags = token->flags & ~TK_FLAG_HAS_SPACE_BEFORE;
            token->flags = token->flags & ~TK_FLAG_HAS_NEWLINE_BEFORE;
            is_first = false;
        }
        remove_line_continuation(token->lexeme);

        if (current == list->tail)
            break;

        current = current->next;
    }

    return r;
}

void macro_argument_delete(struct macro_argument* _Owner _Opt p)
{
    if (p)
    {
        assert(p->next == NULL);
        token_list_destroy(&p->tokens);
        free((void* _Owner) p->name);
        free(p);
    }
}

struct token_list copy_argument_list(struct macro_argument* p_macro_argument)
{
    try
    {
        struct token_list list = copy_argument_list_tokens(&p_macro_argument->tokens);
        if (list.head == NULL)
        {
            /*it's never empty...if puts a TK PLACEMARKER*/
            struct token* _Owner _Opt p_new_token = calloc(1, sizeof * p_new_token);
            if (p_new_token == NULL) throw;

            p_new_token->lexeme = strdup("");
            p_new_token->type = TK_PLACEMARKER;
            token_list_add(&list, p_new_token);
        }
        return list;
    }
    catch
    {
    }

    struct token_list empty = { 0 };
    return empty;
}


struct macro_argument_list
{
    struct token_list tokens;
    struct macro_argument* _Owner _Opt head;
    struct macro_argument* _Opt tail;
};

void macro_argument_list_destroy(struct macro_argument_list* _Obj_owner list)
{
    token_list_destroy(&list->tokens);
    struct macro_argument* _Owner _Opt p = list->head;
    while (p)
    {
        struct macro_argument* _Owner _Opt next = p->next;
        p->next = NULL;
        macro_argument_delete(p);
        p = next;
    }
}

void print_macro_arguments(struct macro_argument_list* arguments)
{
    struct macro_argument* _Opt p_argument = arguments->head;
    while (p_argument)
    {
        printf("%s:", p_argument->name);
        print_list(&p_argument->tokens);
        p_argument = p_argument->next;
    }
}

struct macro_argument* _Opt find_macro_argument_by_name(struct macro_argument_list* parameters, const char* name)
{
    /*
     * The arguments are collected in the macro expansion and each one (except ...)
     * is associated with one of the macro parameters.
     */
    struct macro_argument* _Opt p = parameters->head;
    while (p)
    {
        if (strcmp(p->name, name) == 0)
        {
            return p;
        }
        p = p->next;
    }
    return NULL;
}


void argument_list_add(struct macro_argument_list* list, struct macro_argument* _Owner pnew)
{
    assert(pnew->next == NULL);
    if (list->head == NULL)
    {
        list->head = pnew;
        assert(list->tail == NULL);
        list->tail = pnew;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = pnew;
        list->tail = pnew;
    }
}


void print_macro(struct macro* macro)
{
    printf("%s", macro->name);
    if (macro->is_function)
        printf("(");
    struct macro_parameter* _Opt parameter = macro->parameters;
    while (parameter)
    {
        if (macro->parameters != parameter)
            printf(",");
        printf("%s", parameter->name);
        parameter = parameter->next;
    }
    if (macro->is_function)
        printf(") ");
    print_list(&macro->replacement_list);
}

void macro_parameters_delete(struct macro_parameter* _Owner _Opt parameters)
{
    struct macro_parameter* _Owner _Opt p = parameters;
    while (p)
    {
        struct macro_parameter* _Owner p_next = p->next;
        free((void* _Owner)p->name);
        free(p);
        p = p_next;
    }
}

void delete_macro(struct macro* _Owner _Opt macro)
{
    if (macro)
    {
        token_list_destroy(&macro->replacement_list);

        struct macro_parameter* _Owner _Opt p_macro_parameter = macro->parameters;
        while (p_macro_parameter)
        {
            struct macro_parameter* _Owner _Opt p_next = p_macro_parameter->next;
            free((void* _Owner)p_macro_parameter->name);
            free(p_macro_parameter);
            p_macro_parameter = p_next;
        }

        free((void* _Owner) macro->name);
        free(macro);
    }
}

struct macro* _Opt find_macro(struct preprocessor_ctx* ctx, const char* name)
{
    struct owner_map_entry* _Opt p_entry = owner_hashmap_find(&ctx->macros, name);
    if (p_entry == NULL)
        return NULL;

    return p_entry->p;
}

void stream_print_line(struct stream* stream)
{
    const char* p = stream->current;
    while ((p - 1) >= stream->source &&
        *(p - 1) != '\n')
    {
        p--;
    }
    while (*p && *(p + 1) != '\n')
    {
        printf("%c", *p);
        p++;
    }
    printf("\n");
    for (int i = 0; i < stream->col - 1; i++)
        printf(" ");
    printf("^\n");
}

void stream_match(struct stream* stream)
{
    if (stream->current[0] == '\n')
    {
        stream->line++;
        stream->col = 1;
    }
    else
    {
        stream->col++;
    }

    if (stream->current[0] == '\0')
        return;
    stream->current++;

    while (stream->current[0] == '\\' && stream->current[1] == '\n')
    {
        /*
            2. Each instance of a backslash character (\) immediately followed by a new-line character is
            deleted, splicing physical source lines to form logical source lines. Only the last backslash on
            any physical source line shall be eligible for being part of such a splice. A source file that is
            not empty shall end in a new-line character, which shall not be immediately preceded by a
            backslash character before any such splicing takes place.
        */
        stream->current++;
        stream->current++;
        stream->line++;
        stream->col = 1;

        stream->line_continuation_count++;
    }

}

void print_line(struct token* p)
{
    printf("%s\n", p->token_origin->lexeme);
    struct token* prev = p;
    while (prev->prev && prev->prev->type != TK_NEWLINE)
    {
        prev = prev->prev;
    }
    struct token* next = prev;
    while (next && next->type != TK_NEWLINE)
    {
        printf("%s", next->lexeme);
        next = next->next;
    }
    printf("\n");
}

int is_nondigit(const struct stream* p)
{
    /*
    nondigit: one of
     _ a b c d e f g h i j k l m
     n o p q r s t u v w x y z
     A B C D E F G H I J K L M
     N O P Q R S T U V W X Y Z
    */
    return (p->current[0] >= 'a' && p->current[0] <= 'z') ||
        (p->current[0] >= 'A' && p->current[0] <= 'Z') ||
        (p->current[0] == '_');
}


enum token_type is_punctuator(struct stream* stream)
{
    enum token_type type = TK_NONE;
    /*
     punctuator: one of
      [ ] ( ) { } . ->
      ++ -- & * + - ~ !
      / % << >> < > <= >= == != ^ | && ||
      ? : :: ; ...
      = *= /= %= += -= <<= >>= &= ^= |=
      , # ##
      <: :> <% %> %: %:%:
    */
    switch (stream->current[0])
    {
    case '[':
        type = '[';
        stream_match(stream);
        break;
    case ']':
        type = ']';
        stream_match(stream);
        break;
    case '(':
        type = '(';
        stream_match(stream);
        break;
    case ')':
        type = ')';
        stream_match(stream);
        break;
    case '{':
        type = '{';
        stream_match(stream);
        break;
    case '}':
        type = '}';
        stream_match(stream);
        break;
    case ';':
        type = ';';
        stream_match(stream);
        break;
    case ',':
        type = ',';
        stream_match(stream);
        break;
    case '!':
        type = '!';
        stream_match(stream);
        if (stream->current[0] == '=')
        {
            type = '!=';
            stream_match(stream);
        }
        break;
    case ':':
        type = ':';
        stream_match(stream);
        if (stream->current[0] == ':')
        {
            type = '::';
            stream_match(stream);
        }
        break;
    case '~':
        type = '~';
        stream_match(stream);
        break;
    case '?':
        type = '?';
        stream_match(stream);
        break;
    case '/':
        type = '/';
        stream_match(stream);
        if (stream->current[0] == '=')
        {
            type = '/=';
            stream_match(stream);
        }
        break;
    case '*':
        type = '*';
        stream_match(stream);
        if (stream->current[0] == '=')
        {
            type = '*=';
            stream_match(stream);
        }
        break;
    case '%':
        type = '%';
        stream_match(stream);
        if (stream->current[0] == '=')
        {
            type = '%=';
            stream_match(stream);
        }
        break;
    case '-':
        type = '-';
        stream_match(stream);
        if (stream->current[0] == '>')
        {
            type = '->';
            stream_match(stream);
        }
        else if (stream->current[0] == '-')
        {
            type = '--';
            stream_match(stream);
        }
        else if (stream->current[0] == '=')
        {
            type = '-=';
            stream_match(stream);
        }
        break;
    case '|':
        type = '|';
        stream_match(stream);
        if (stream->current[0] == '|')
        {
            type = '||';
            stream_match(stream);
        }
        else if (stream->current[0] == '=')
        {
            type = '|=';
            stream_match(stream);
        }
        break;
    case '+':
        type = '+';
        stream_match(stream);
        if (stream->current[0] == '+')
        {
            type = '++';
            stream_match(stream);
        }
        else if (stream->current[0] == '=')
        {
            type = '+=';
            stream_match(stream);
        }
        break;
    case '=':
        type = '=';
        stream_match(stream);
        if (stream->current[0] == '=')
        {
            type = '==';
            stream_match(stream);
        }
        break;
    case '^':
        type = '^';
        stream_match(stream);
        if (stream->current[0] == '=')
        {
            type = '^=';
            stream_match(stream);
        }
        break;
    case '&':
        type = '&';
        stream_match(stream);
        if (stream->current[0] == '&')
        {
            type = '&&';
            stream_match(stream);
        }
        else if (stream->current[0] == '=')
        {
            type = '&=';
            stream_match(stream);
        }
        break;
    case '>':
        type = '>';
        stream_match(stream);
        if (stream->current[0] == '>')
        {
            type = '>>';
            stream_match(stream);
            if (stream->current[0] == '=')
            {
                type = '>>=';
                stream_match(stream);
            }
        }
        else if (stream->current[0] == '=')
        {
            type = '>=';
            stream_match(stream);
        }

        break;
    case '<':
        type = '<';
        stream_match(stream);
        if (stream->current[0] == '<')
        {
            type = '<<';
            stream_match(stream);
            if (stream->current[0] == '=')
            {
                type = '<<=';
                stream_match(stream);
            }
        }
        else if (stream->current[0] == '=')
        {
            type = '<=';
            stream_match(stream);
        }
        break;
    case '#':
        type = '#';
        stream_match(stream);
        if (stream->current[0] == '#')
        {
            type = '##';
            stream_match(stream);
        }
        break;
    case '.':
        type = '.';
        stream_match(stream);
        if (stream->current[0] == '.' && stream->current[1] == '.')
        {
            type = '...';
            stream_match(stream);
            stream_match(stream);
        }
        break;
    }
    return type;
}


struct token* _Owner _Opt new_token(const char* lexeme_head, const char* lexeme_tail, enum token_type type)
{
    struct token* _Owner _Opt p_new_token = calloc(1, sizeof * p_new_token);
    size_t sz = lexeme_tail - lexeme_head;
    p_new_token->lexeme = calloc(sz + 1, sizeof(char));
    p_new_token->type = type;
    strncpy(p_new_token->lexeme, lexeme_head, sz);
    return p_new_token;
}

struct token* _Owner _Opt identifier(struct stream* stream)
{
    const char* start = stream->current;
    stream_match(stream);
    /*
    identifier:
      identifier-nondigit
      identifier identifier-nondigit
      identifier digit

    identifier-nondigit:
      nondigit
      universal-character-name
      other implementation-defined characters
    */
    while (is_nondigit(stream) || is_digit(stream))
    {
        stream_match(stream);
    }

    struct token* _Owner _Opt p_new_token = new_token(start, stream->current, TK_IDENTIFIER);


    return p_new_token;
}




bool first_of_character_constant(struct stream* stream)
{
    return stream->current[0] == '\'' ||
        (stream->current[0] == 'u' && stream->current[1] == '8' && stream->current[2] == '\'') ||
        (stream->current[0] == 'u' && stream->current[1] == '\'') ||
        (stream->current[0] == 'U' && stream->current[1] == '\'') ||
        (stream->current[0] == 'L' && stream->current[1] == '\'');
}

struct token* _Owner _Opt character_constant(struct tokenizer_ctx* ctx, struct stream* stream)
{
    const char* start = stream->current;

    /*
      encoding-prefix: one of
       u8 u U L
    */
    if (stream->current[0] == 'u')
    {
        stream_match(stream);
        if (stream->current[0] == '8')
            stream_match(stream);
    }
    else if (stream->current[0] == 'U' ||
        stream->current[0] == 'L')
    {
        stream_match(stream);
    }


    stream_match(stream); //"


    while (stream->current[0] != '\'')
    {
        if (stream->current[0] == '\\')
        {
            stream_match(stream);
            stream_match(stream);
        }
        else
            stream_match(stream);

        if (stream->current[0] == '\0' ||
            stream->current[0] == '\n')
        {
            tokenizer_set_warning(ctx, stream, "missing terminating ' character");
            break;
        }
    }
    stream_match(stream);
    struct token* _Owner _Opt p_new_token = new_token(start, stream->current, TK_CHAR_CONSTANT);
    return p_new_token;
}

bool first_of_string_literal(struct stream* stream)
{
    /*
    string-literal:
    encoding_prefix_opt " s-char-sequenceopt "

    encoding_prefix:
    u8
    u
    U
    L
    */

    return stream->current[0] == '"' ||
        (stream->current[0] == 'u' && stream->current[1] == '8' && stream->current[2] == '"') ||
        (stream->current[0] == 'u' && stream->current[1] == '"') ||
        (stream->current[0] == 'U' && stream->current[1] == '"') ||
        (stream->current[0] == 'L' && stream->current[1] == '"');
}

struct token* _Owner _Opt string_literal(struct tokenizer_ctx* ctx, struct stream* stream)
{
    struct token* _Owner _Opt p_new_token = NULL;
    const char* start = stream->current;

    try
    {
        /*encoding_prefix_opt*/
        if (stream->current[0] == 'u')
        {
            stream_match(stream);
            if (stream->current[0] == '8')
                stream_match(stream);
        }
        else if (stream->current[0] == 'U' ||
            stream->current[0] == 'L')
        {
            stream_match(stream);
        }


        stream_match(stream); //"


        while (stream->current[0] != '"')
        {
            if (stream->current[0] == '\0' ||
                stream->current[0] == '\n')
            {
                tokenizer_set_error(ctx, stream, "missing terminating \" character");
                throw;
            }

            if (stream->current[0] == '\\')
            {
                stream_match(stream);
                stream_match(stream);
            }
            else
                stream_match(stream);
        }
        stream_match(stream);
        p_new_token = new_token(start, stream->current, TK_STRING_LITERAL);
    }
    catch
    {
    }

    return p_new_token;
}

int get_char_type(const char* s)
{
    if (s[0] == 'L')
        return 2; /*wchar*/

    return 1;
}
/*
  Returns the char byte size according with the literal suffix
*/
int string_literal_char_byte_size(const char* s)
{
    if (s[0] == 'u')
    {
        //must be followed by u8 but not checked here
    }
    else if (s[0] == 'U' || s[0] == 'L')
    {
        return (int)sizeof(wchar_t);
    }

    return 1;
}

int string_literal_byte_size_not_zero_included(const char* s)
{

    struct stream stream = { .source = s,
        .current = s,
        .line = 1,
        .col = 1 };

    int size = 0;
    const int charsize = string_literal_char_byte_size(s);

    try
    {
        /*encoding_prefix_opt*/
        if (stream.current[0] == 'u')
        {
            stream_match(&stream);
            if (stream.current[0] == '8')
                stream_match(&stream);
        }
        else if (stream.current[0] == 'U' ||
            stream.current[0] == 'L')
        {
            stream_match(&stream);
        }


        stream_match(&stream); //"


        while (stream.current[0] != '"')
        {
            if (stream.current[0] == '\0' ||
                stream.current[0] == '\n')
            {
                throw;
            }

            if (stream.current[0] == '\\')
            {
                stream_match(&stream);
                stream_match(&stream);
                size++;
            }
            else
            {
                stream_match(&stream);
                size++;
            }
        }
        stream_match(&stream);
    }
    catch
    {
    }

    /*
       Last \0 is not included
    */

    return size * charsize;
}

struct token* _Owner ppnumber(struct stream* stream)
{
    /*
     pp-number:
      digit
      . digit
      pp-number identifier-continue
      pp-number ’ digit
      pp-number ’ nondigit
      pp-number e sign
      pp-number E sign
      pp-number p sign
      pp-number P sign
      pp-number .
    */

    /*
     identifier-continue:
       digit
       nondigit
       XID_Continue character
       universal-character-name of class XID_Continue
    */

    const char* start = stream->current;
    if (is_digit(stream))
    {
        stream_match(stream);//digit
    }
    else if (stream->current[0] == '.')
    {
        stream_match(stream); //.
        stream_match(stream); //digit
    }
    else
    {
        assert(false);
    }

    for (;;)
    {
        if (stream->current[0] == '\'')
        {
            //digit separators c23
            stream_match(stream);
            if (is_digit(stream))
            {
                stream_match(stream);
            }
            else if (is_nondigit(stream))
            {
                stream_match(stream);
            }
            else
            {
                assert(false);
                break;
            }
        }
        else if ((stream->current[0] == 'e' ||
            stream->current[0] == 'E' ||
            stream->current[0] == 'p' ||
            stream->current[0] == 'P') &&
            (stream->current[1] == '+' || stream->current[1] == '-'))
        {
            stream_match(stream);//e E  p P
            stream_match(stream);//sign
        }
        else if (stream->current[0] == '.')
        {
            stream_match(stream);//.
        }
        else if (is_digit(stream) || is_nondigit(stream))
        {
            ////identifier-continue
            /*
            * OBS test for is_nondigit must be AFTER
            * test for e E p P
            */
            stream_match(stream);//nondigit
        }
        else
        {
            break;
        }
    }
    struct token* _Owner p_new_token = new_token(start, stream->current, TK_PPNUMBER);
    return p_new_token;
}

struct token_list embed_tokenizer(struct preprocessor_ctx* ctx,
    const struct token* position,
    const char* filename_opt,
    int level, enum token_flags addflags)
{
    struct token_list list = { 0 };

    FILE* _Owner _Opt file = NULL;

    bool b_first = true;
    int line = 1;
    int col = 1;
    int count = 0;
    try
    {
#ifndef MOCKFILES
        file = (FILE * _Owner _Opt)fopen(filename_opt, "rb");
        if (file == NULL)
        {
            preprocessor_diagnostic_message(C_ERROR_FILE_NOT_FOUND, ctx, position, "file '%s' not found", filename_opt);
            throw;
        }
#else
        /*web versions only text files that are included*/
        char* textfile = read_file(filename_opt);
        if (textfile == NULL)
        {
            preprocessor_diagnostic_message(C_ERROR_FILE_NOT_FOUND, ctx, ctx->current, "file '%s' not found", filename_opt);
            throw;
        }

        const char* pch = textfile;
#endif

        unsigned char ch = 0;
#ifndef MOCKFILES
        while (fread(&ch, 1, 1, file))
        {
#else
        while (*pch)
        {
            ch = *pch;
            pch++;
#endif
            if (b_first)
            {
                b_first = false;
            }
            else
            {
                char b[] = ",";
                struct token* _Owner _Opt p_new_token = new_token(b, &b[1], TK_COMMA);
                p_new_token->flags |= addflags;
                p_new_token->level = level;
                p_new_token->token_origin = NULL;
                p_new_token->line = line;
                p_new_token->col = col;
                token_list_add(&list, p_new_token);

                if (count > 0 && count % 25 == 0)
                {
                    /*new line*/
                    char newline[] = "\n";
                    struct token* _Owner _Opt p_new3 = new_token(newline, &newline[1], TK_NEWLINE);
                    p_new3->level = level;
                    p_new3->token_origin = NULL;
                    p_new3->line = line;
                    p_new3->col = col;
                    token_list_add(&list, p_new3);
                }
            }

            char buffer[30] = { 0 };
            int c = snprintf(buffer, sizeof buffer, "%d", (int)ch);

            struct token* _Owner _Opt p_new_token = new_token(buffer, &buffer[c], TK_PPNUMBER);
            p_new_token->flags |= addflags;
            p_new_token->level = level;
            p_new_token->token_origin = NULL;
            p_new_token->line = line;
            p_new_token->col = col;
            token_list_add(&list, p_new_token);


            count++;
        }
#ifdef MOCKFILES
        free(textfile);
#endif

        /*new line*/
        char newline[] = "\n";
        struct token* _Owner _Opt p_new_token = new_token(newline, &newline[1], TK_NEWLINE);
        p_new_token->level = level;
        p_new_token->token_origin = NULL;
        p_new_token->line = line;
        p_new_token->col = col;
        token_list_add(&list, p_new_token);

        assert(list.head != NULL);
    }
    catch
    {
    }

    if (file)
        fclose(file);

    return list;
}

static bool set_sliced_flag(struct stream* stream, struct token* p_new_token)
{
    if (stream->line_continuation_count > 0)
    {
        p_new_token->flags |= TK_FLAG_LINE_CONTINUATION;
        if (stream->line_continuation_count == 1)
        {
            int l = strlen(p_new_token->lexeme);
            if (p_new_token->lexeme[l - 1] == '\n')
            {
                /*not sliced, line continuation is at end of token*/
            }
            else
            {
                p_new_token->flags |= TK_FLAG_SLICED;
            }
        }
        else
        {
            p_new_token->flags |= TK_FLAG_SLICED;
        }
    }

    return p_new_token->flags & TK_FLAG_SLICED;
}

struct token_list tokenizer(struct tokenizer_ctx* ctx, const char* text, const char* _Opt filename_opt, int level, enum token_flags addflags)
{
    struct token_list list = { 0 };
    if (text == NULL)
    {
        return list;
    }

    struct stream stream =
    {
        .col = 1,
        .line = 1,
        .source = text,
        .current = text,
        .path = filename_opt ? filename_opt : ""
    };

    try
    {
        struct token* _Opt p_first = NULL;
        if (filename_opt != NULL)
        {
            const char* begin = filename_opt;
            const char* end = filename_opt + strlen(filename_opt);
            struct token* _Owner p_new = new_token(begin, end, TK_BEGIN_OF_FILE);
            if (p_new == NULL)
                throw;

#ifdef _WINDOWS_
            //windows have case insensive paths
            for (char* p = p_new->lexeme; *p; p++)
            {
                *p = (char)tolower(*p);
            }
#endif
            p_new->level = level;
            p_first = token_list_add(&list, p_new);
        }


        //struct token* current = pFirst;
        bool new_line = true;
        bool has_space = false;
        while (1)
        {
            const int line = stream.line;
            const int col = stream.col;
            stream.line_continuation_count = 0;

            if (stream.current[0] == '\0')
            {
                stream_match(&stream);
                break;
            }
            if (is_digit(&stream) ||
                (stream.current[0] == '.' && isdigit(stream.current[0])))
            {
                struct token* _Owner _Opt p_new_token = ppnumber(&stream);
                if (p_new_token == NULL) throw;

                p_new_token->flags |= has_space ? TK_FLAG_HAS_SPACE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= new_line ? TK_FLAG_HAS_NEWLINE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= addflags;

                p_new_token->flags |= addflags;

                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                new_line = false;
                has_space = false;
                continue;
            }

            /*
             Tem que vir antes identifier
            */
            if (first_of_string_literal(&stream))
            {
                struct token* _Owner _Opt p_new_token = string_literal(ctx, &stream);
                if (p_new_token == NULL) throw;

                p_new_token->flags |= has_space ? TK_FLAG_HAS_SPACE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= new_line ? TK_FLAG_HAS_NEWLINE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= addflags;

                p_new_token->flags |= addflags;

                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                new_line = false;
                has_space = false;

                continue;
            }

            if (first_of_character_constant(&stream))
            {
                //TODO if we have ' in the middle then it is not character constant
                struct token* _Owner _Opt p_new_token = character_constant(ctx, &stream);
                if (p_new_token == NULL) throw;

                p_new_token->flags |= has_space ? TK_FLAG_HAS_SPACE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= new_line ? TK_FLAG_HAS_NEWLINE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= addflags;

                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                new_line = false;
                has_space = false;

                continue;
            }

            if (is_nondigit(&stream))
            {
                struct token* _Owner _Opt p_new_token = identifier(&stream);
                if (p_new_token == NULL) throw;

                p_new_token->flags |= has_space ? TK_FLAG_HAS_SPACE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= new_line ? TK_FLAG_HAS_NEWLINE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= addflags;

                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;

                new_line = false;
                has_space = false;
                if (set_sliced_flag(&stream, p_new_token))
                {
                    tokenizer_set_warning(ctx, &stream, "token sliced");
                }
                token_list_add(&list, p_new_token);
                continue;
            }

            if (stream.current[0] == ' ' ||
                stream.current[0] == '\t' ||
                stream.current[0] == '\f')
            {
                const char* start = stream.current;
                while (stream.current[0] == ' ' ||
                    stream.current[0] == '\t' ||
                    stream.current[0] == '\f'
                    )
                {
                    stream_match(&stream);
                }
                struct token* _Owner _Opt p_new_token = new_token(start, stream.current, TK_BLANKS);
                if (p_new_token == NULL) throw;

                p_new_token->flags |= has_space ? TK_FLAG_HAS_SPACE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= new_line ? TK_FLAG_HAS_NEWLINE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= addflags;

                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                /*bNewLine = false;*/ //deixa assim
                has_space = true;

                continue;
            }
            if (stream.current[0] == '/' &&
                stream.current[1] == '/')
            {
                const char* start = stream.current;
                stream_match(&stream);
                stream_match(&stream);
                //line comment
                while (stream.current[0] != '\n')
                {
                    stream_match(&stream);

                    if (stream.current[0] == '\0')
                        break;
                }
                struct token* _Owner _Opt p_new_token = new_token(start, stream.current, TK_LINE_COMMENT);
                if (p_new_token == NULL) throw;

                p_new_token->flags |= has_space ? TK_FLAG_HAS_SPACE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= new_line ? TK_FLAG_HAS_NEWLINE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= addflags;

                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                new_line = true;
                has_space = false;


                if (stream.current[0] == '\0')
                    break;

                continue;
            }
            if (stream.current[0] == '/' &&
                stream.current[1] == '*')
            {
                const char* start = stream.current;
                stream_match(&stream);
                stream_match(&stream);
                //line comment
                for (;;)
                {
                    if (stream.current[0] == '*' && stream.current[1] == '/')
                    {
                        stream_match(&stream);
                        stream_match(&stream);
                        break;
                    }
                    else if (stream.current[0] == '\0')
                    {
                        tokenizer_set_error(ctx, &stream, "missing end of comment");
                        break;
                    }
                    else
                    {
                        stream_match(&stream);
                    }
                }
                struct token* _Owner _Opt p_new_token = new_token(start, stream.current, TK_COMMENT);
                if (p_new_token == NULL) throw;

                p_new_token->flags |= has_space ? TK_FLAG_HAS_SPACE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= new_line ? TK_FLAG_HAS_NEWLINE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= addflags;

                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                token_list_add(&list, p_new_token);
                new_line = false;
                has_space = false;

                /*
                * Ignore line splicing inside comments.
                * if you are curious to see when it happens just add
                * set_sliced_flag
                */

                continue;
            }
            if (new_line && stream.current[0] == '#')
            {
                const char* start = stream.current;
                stream_match(&stream);
                struct token* _Owner _Opt p_new_token = new_token(start, stream.current, '#');
                if (p_new_token == NULL) throw;

                p_new_token->flags |= has_space ? TK_FLAG_HAS_SPACE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= new_line ? TK_FLAG_HAS_NEWLINE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= addflags;

                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                p_new_token->type = TK_PREPROCESSOR_LINE;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                new_line = false;
                has_space = false;

                continue;
            }


            if (stream.current[0] == '\n' || stream.current[0] == '\r')
            {
                if (stream.current[0] == '\r' && stream.current[1] == '\n')
                {
                    stream_match(&stream);
                    stream_match(&stream);
                }
                else
                {
                    stream_match(&stream);
                }
                char  newline[] = "\n";
                struct token* _Owner _Opt p_new_token = new_token(newline, newline + 1, TK_NEWLINE);
                if (p_new_token == NULL) throw;

                p_new_token->flags |= has_space ? TK_FLAG_HAS_SPACE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= new_line ? TK_FLAG_HAS_NEWLINE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= addflags;

                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                new_line = true;
                has_space = false;

                continue;
            }
            const char* start = stream.current;
            enum token_type t = is_punctuator(&stream);
            if (t != TK_NONE)
            {

                struct token* _Owner _Opt p_new_token = new_token(start, stream.current, t);
                if (p_new_token == NULL) throw;

                p_new_token->flags |= has_space ? TK_FLAG_HAS_SPACE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= new_line ? TK_FLAG_HAS_NEWLINE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= addflags;

                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                new_line = false;
                has_space = false;

                continue;
            }
            else
            {
                stream_match(&stream);
                struct token* _Owner _Opt p_new_token = new_token(start, stream.current, ANY_OTHER_PP_TOKEN);
                if (p_new_token == NULL) throw;

                p_new_token->flags |= has_space ? TK_FLAG_HAS_SPACE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= new_line ? TK_FLAG_HAS_NEWLINE_BEFORE : TK_FLAG_NONE;
                p_new_token->flags |= addflags;

                p_new_token->level = level;
                p_new_token->token_origin = p_first;
                p_new_token->line = line;
                p_new_token->col = col;
                set_sliced_flag(&stream, p_new_token);
                token_list_add(&list, p_new_token);
                new_line = false;
                has_space = false;



                continue;
            }


            break;
        }
    }
    catch
    {
    }

    assert(list.head != NULL);
    return list;
}


bool fread2(void* buffer, size_t size, size_t count, FILE * stream, size_t * sz)
{
    *sz = 0;//_Out
    bool result = false;
    size_t n = fread(buffer, size, count, stream);
    if (n == count)
    {
        *sz = n;
        result = true;
    }
    else if (n < count)
    {
        if (feof(stream))
        {
            *sz = n;
            result = true;
        }
    }
    return result;
}


bool preprocessor_token_ahead_is_identifier(struct token* p, const char* lexeme);
struct token_list group_part(struct preprocessor_ctx* ctx, struct token_list* input_list, bool is_active, int level);
struct token_list group_opt(struct preprocessor_ctx* ctx, struct token_list* input_list, bool is_active, int level)
{
    /*
      group:
       group-part
       group group-part
    */
    struct token_list r = { 0 };
    try
    {

        if (token_list_is_empty(input_list))
        {
            return r;
        }
        while (!token_list_is_empty(input_list))
        {

            if (input_list->head->type == TK_PREPROCESSOR_LINE &&
                (preprocessor_token_ahead_is_identifier(input_list->head, "endif") ||
                    preprocessor_token_ahead_is_identifier(input_list->head, "else") ||
                    preprocessor_token_ahead_is_identifier(input_list->head, "elif") ||
                    preprocessor_token_ahead_is_identifier(input_list->head, "elifdef") ||
                    preprocessor_token_ahead_is_identifier(input_list->head, "elifndef")))
            {
                /*follow of group-part*/
                break;
            }
            else
            {
                struct token_list r2 = group_part(ctx, input_list, is_active, level);
                token_list_append_list(&r, &r2);
                token_list_destroy(&r2);
                if (ctx->n_errors > 0) throw;
            }
        }
    }
    catch
    {
    }

    return r;
}

bool is_parser_token(struct token* p)
{
    return p->type != TK_COMMENT &&
        p->type != TK_BLANKS &&
        p->type != TK_LINE_COMMENT &&
        p->type != TK_NEWLINE;
}

bool is_never_final(enum token_type type)
{
    return type == TK_BEGIN_OF_FILE ||
        type == TK_BLANKS ||
        type == TK_LINE_COMMENT ||
        type == TK_COMMENT ||
        type == TK_PLACEMARKER ||
        type == TK_NEWLINE;
}



enum token_type is_keyword(const char* text);






struct token* _Opt preprocessor_look_ahead_core(struct token* p)
{
    struct token* _Opt current = p->next;

    while (current &&
        (current->type == TK_BLANKS ||
            current->type == TK_PLACEMARKER ||
            current->type == TK_LINE_COMMENT ||
            current->type == TK_COMMENT))
    {
        current = current->next;
    }
    return current;
}

bool preprocessor_token_ahead_is(struct token* p, enum token_type t)
{
    struct token* _Opt p_token = preprocessor_look_ahead_core(p);
    if (p_token != NULL && p_token->type == t)
        return true;
    return false;
}

bool preprocessor_token_previous_is(struct token* p, enum token_type t)
{
    if (p == NULL)
    {
        return false;
    }
    struct token* _Opt current = p->prev;
    if (current == NULL)
        return false;

    while (current &&
        (current->type == TK_BLANKS ||
            current->type == TK_LINE_COMMENT ||
            current->type == TK_PLACEMARKER ||
            current->type == TK_COMMENT))
    {
        current = current->prev;
    }
    return (current && current->type == t);
}

bool preprocessor_token_ahead_is_identifier(struct token* p, const char* lexeme)
{
    assert(p != NULL);
    struct token* _Opt p_token = preprocessor_look_ahead_core(p);
    if (p_token != NULL && p_token->type == TK_IDENTIFIER)
    {
        return strcmp(p_token->lexeme, lexeme) == 0;
    }
    return false;
}


static void skip_blanks_level(struct preprocessor_ctx* ctx, struct token_list* dest, struct token_list* input_list, int level)
{
    while (input_list->head)
    {
        if (!token_is_blank(input_list->head))
            break;

        if (INCLUDE_ALL || level == 0)
            token_list_add(dest, token_list_pop_front_get(input_list));
        else
            token_list_pop_front(input_list); //deletar
    }
}

static void skip_blanks(struct preprocessor_ctx* ctx, struct token_list* dest, struct token_list* input_list)
{
    while (input_list->head)
    {
        if (!token_is_blank(input_list->head))
            break;
        token_list_add(dest, token_list_pop_front_get(input_list));
    }
}

void prematch_level(struct token_list* dest, struct token_list* input_list, int level)
{
    if (INCLUDE_ALL || level == 0)
        token_list_add(dest, token_list_pop_front_get(input_list));
    else
        token_list_pop_front(input_list);
}

void prematch(struct token_list* dest, struct token_list* input_list)
{
    token_list_add(dest, token_list_pop_front_get(input_list));
}

struct token_list pp_tokens_opt(struct preprocessor_ctx* ctx, struct token_list* input_list, int level);

struct token_list process_defined(struct preprocessor_ctx* ctx, struct token_list* input_list)
{
    struct token_list r = { 0 };

    try
    {
        while (input_list->head != NULL)
        {
            if (input_list->head->type == TK_IDENTIFIER &&
                strcmp(input_list->head->lexeme, "defined") == 0)
            {
                token_list_pop_front(input_list);
                skip_blanks(ctx, &r, input_list);

                bool has_parentesis = false;
                if (input_list->head->type == '(')
                {
                    token_list_pop_front(input_list);
                    has_parentesis = true;
                }

                skip_blanks(ctx, &r, input_list);


                struct macro* _Opt macro = find_macro(ctx, input_list->head->lexeme);
                struct token* _Owner _Opt p_new_token = token_list_pop_front_get(input_list);
                p_new_token->type = TK_PPNUMBER;
                free(p_new_token->lexeme);
                if (macro)
                {
                    p_new_token->lexeme = strdup("1");
                }
                else
                {
                    p_new_token->lexeme = strdup("0");
                }

                token_list_add(&r, p_new_token);

                if (has_parentesis)
                {
                    if (input_list->head->type != ')')
                    {
                        preprocessor_diagnostic_message(C_ERROR_MISSING_CLOSE_PARENTHESIS, ctx, input_list->head, "missing )");
                        throw;
                    }
                    token_list_pop_front(input_list);
                }


            }
            else if (input_list->head->type == TK_IDENTIFIER &&
                (strcmp(input_list->head->lexeme, "__has_include") == 0 ||
                    strcmp(input_list->head->lexeme, "__has_embed") == 0)
                )
            {
                token_list_pop_front(input_list); //pop __has_include
                skip_blanks(ctx, &r, input_list);
                token_list_pop_front(input_list); //pop (
                skip_blanks(ctx, &r, input_list);


                char path[100] = { 0 };

                if (input_list->head->type == TK_STRING_LITERAL)
                {
                    strcat(path, input_list->head->lexeme);
                    token_list_pop_front(input_list); //pop "file"
                }
                else
                {
                    token_list_pop_front(input_list); //pop <

                    while (input_list->head->type != '>')
                    {
                        strcat(path, input_list->head->lexeme);
                        token_list_pop_front(input_list); //pop (
                    }
                    token_list_pop_front(input_list); //pop >
                }

                char fullpath[300] = { 0 };



                char full_path_result[200] = { 0 };
                bool already_included = false;
                const char* _Owner _Opt s = find_and_read_include_file(ctx,
                    path,
                    fullpath,
                    &already_included,
                    full_path_result,
                    sizeof full_path_result);

                bool has_include = s != NULL;
                free((void* _Owner)s);

                struct token* _Owner _Opt p_new_token = calloc(1, sizeof * p_new_token);
                p_new_token->type = TK_PPNUMBER;
                p_new_token->lexeme = strdup(has_include ? "1" : "0");
                p_new_token->flags |= TK_FLAG_FINAL;

                token_list_add(&r, p_new_token);
                token_list_pop_front(input_list); //pop )
            }
            else if (input_list->head->type == TK_IDENTIFIER &&
                strcmp(input_list->head->lexeme, "__has_c_attribute") == 0)
            {
                token_list_pop_front(input_list); //pop __has_include
                skip_blanks(ctx, &r, input_list);
                token_list_pop_front(input_list); //pop (
                skip_blanks(ctx, &r, input_list);


                char path[100] = { 0 };
                while (input_list->head->type != ')')
                {
                    strcat(path, input_list->head->lexeme);
                    token_list_pop_front(input_list); //pop (
                }
                token_list_pop_front(input_list); //pop >

                /*nodiscard
                * The __has_c_attribute conditional inclusion expression (6.10.1) shall
                * return the value 202003L
                * when given nodiscard as the pp-tokens operand.
                */

                /*maybe_unused
                * The __has_c_attribute conditional inclusion expression (6.10.1) shall return
                * the value 202106L when given maybe_unused as the pp-tokens operand.
                */

                /*deprecated
                * The __has_c_attribute conditional inclusion expression (6.10.1) shall return the value 201904L
                * when given deprecated as the pp-tokens operand
                */

                /*noreturn
                * The __has_c_attribute conditional inclusion expression (6.10.1) shall return the value 202202L
                * when given noreturn as the pp-tokens operand.
                */

                /*reproducible
                 * The __has_c_attribute conditional inclusion expression (6.10.1) shall return the value 202207L
                 * when given reproducible as the pp-tokens operand.
                */

                /*
                * The __has_c_attribute conditional inclusion expression (6.10.1) shall return the value 202207L
                * when given unsequenced as the pp-tokens operand.
                */
                bool has_c_attribute = false;

                struct token* _Owner _Opt p_new_token = calloc(1, sizeof * p_new_token);
                p_new_token->type = TK_PPNUMBER;
                p_new_token->lexeme = strdup(has_c_attribute ? "1" : "0");
                p_new_token->flags |= TK_FLAG_FINAL;

                token_list_add(&r, p_new_token);
                token_list_pop_front(input_list); //pop )
            }
            else
            {
                token_list_add(&r, token_list_pop_front_get(input_list));
            }
        }
    }
    catch
    {
    }

    return r;
}

struct token_list process_identifiers(struct preprocessor_ctx* ctx, struct token_list* _Obj_owner list)
{
    assert(!token_list_is_empty(list));

    struct token_list list2 = { 0 };


    while (list->head != NULL)
    {
        if (list->head->type == TK_IDENTIFIER)
        {

            struct macro* _Opt macro = find_macro(ctx, list->head->lexeme);
            struct token* _Owner p_new_token = token_list_pop_front_get(list);
            p_new_token->type = TK_PPNUMBER;

            if (macro)
            {
                free(p_new_token->lexeme);
                p_new_token->lexeme = strdup("1");
            }
            else
            {
                /*
                * after all replacements due to macro expansion and
                  evaluations of defined macro expressions, has_include expressions, and has_c_attribute expressions
                  have been performed, all remaining identifiers other than true (including those lexically identical
                  to keywords such as false) are replaced with the pp-number 0, true is replaced with pp-number
                  1, and then each preprocessing token is converted into a token.
                */
                if (strcmp(p_new_token->lexeme, "true") == 0)
                {
                    p_new_token->lexeme[0] = '1';
                    p_new_token->lexeme[1] = '\0';
                }
                else if (strcmp(p_new_token->lexeme, "false") == 0)
                {
                    p_new_token->lexeme[0] = '0';
                    p_new_token->lexeme[1] = '\0';
                }
                else
                {
                    free(p_new_token->lexeme);
                    p_new_token->lexeme = strdup("0");
                }
            }
            token_list_add(&list2, p_new_token);
        }
        else
        {
            token_list_add(&list2, token_list_pop_front_get(list));
        }
    }
    assert(!token_list_is_empty(&list2));
    return list2;
}

struct token_list ignore_preprocessor_line(struct token_list* input_list)
{
    struct token_list r = { 0 };
    while (input_list->head->type != TK_NEWLINE)
    {
        token_list_add(&r, token_list_pop_front_get(input_list));
    }
    return r;
}

//todo passar lista para reotnro
long long preprocessor_constant_expression(struct preprocessor_ctx* ctx,
    struct token_list* output_list,
    struct token_list* input_list,
    int level
)
{
    struct token* first = input_list->head;

    ctx->conditional_inclusion = true;

    struct token_list r = { 0 };
    while (input_list->head && input_list->head->type != TK_NEWLINE)
    {
        token_list_add(&r, token_list_pop_front_get(input_list));

        /*
          We call preprocessor that emmit warnings if line continuation
          is used outside macro directives.
          Let's remove TK_FLAG_LINE_CONTINUATION from the original token
          to avoid warning inside constant expressions
        */
        r.tail->flags &= ~TK_FLAG_LINE_CONTINUATION;
    }

    struct token_list list1 = copy_replacement_list(&r);
    token_list_swap(output_list, &r);


    int flags = ctx->flags;
    ctx->flags |= PREPROCESSOR_CTX_FLAGS_ONLY_FINAL;

    /*defined X  por exemplo é mantido sem ser expandido*/

    struct token_list list2 = preprocessor(ctx, &list1, 1);
    ctx->flags = flags;

    long long value = 0;

    if (list2.head == NULL)
    {
        preprocessor_diagnostic_message(C_ERROR_EXPRESSION_ERROR, ctx, first, "empty expression");
    }
    else
    {

        /*aonde defined has_c_aatribute sao transformados em constantes*/
        struct token_list list3 = process_defined(ctx, &list2);


        struct token_list list4 = process_identifiers(ctx, &list3);


        assert(list4.head != NULL);

        struct preprocessor_ctx pre_ctx = { 0 };


        pre_ctx.input_list = list4;
        pre_ctx.current = pre_ctx.input_list.head;

        if (pre_constant_expression(&pre_ctx, &value) != 0)
        {
            preprocessor_diagnostic_message(C_ERROR_EXPRESSION_ERROR, ctx, first, "expression error");
        }

        ctx->conditional_inclusion = false;

        preprocessor_ctx_destroy(&pre_ctx);


    }

    token_list_destroy(&list1);
    token_list_destroy(&r);
    token_list_destroy(&list2);

    return value;
}

void match_level(struct token_list* dest, struct token_list* input_list, int level)
{
    if (INCLUDE_ALL || level == 0)
        token_list_add(dest, token_list_pop_front_get(input_list));
    else
        token_list_pop_front(input_list); //deletar
}


int match_token_level(struct token_list* dest, struct token_list* input_list, enum token_type type, int level,
    struct preprocessor_ctx* ctx)
{
    try
    {
        if (input_list->head == NULL ||
            input_list->head->type != type)
        {
            if (type == TK_NEWLINE && input_list->head == NULL)
            {
                //vou aceitar final de arquivo como substituro do endline
                //exemplo #endif sem quebra de linha
            }
            else
            {
                if (input_list->head)
                    preprocessor_diagnostic_message(C_ERROR_UNEXPECTED_TOKEN, ctx, input_list->head, "expected token %s got %s\n", get_token_name(type), get_token_name(input_list->head->type));
                else
                    preprocessor_diagnostic_message(C_ERROR_UNEXPECTED_TOKEN, ctx, dest->tail, "expected EOF \n");

                throw;
            }
        }
        if (input_list->head != NULL)
        {
            if (INCLUDE_ALL || level == 0)
                token_list_add(dest, token_list_pop_front_get(input_list));
            else
                token_list_pop_front(input_list); //deletar
        }
    }
    catch
    {
    }
    return ctx->n_errors > 0;
}


struct token_list if_group(struct preprocessor_ctx* ctx, struct token_list* input_list, bool is_active, int level, bool* p_result)
{
    *p_result = 0; //_Out

    struct token_list r = { 0 };
    try
    {
        /*
         if-group:
           # if constant-expression new-line group_opt
           # ifdef identifier new-line group_opt
           # ifndef identifier new-line group_opt
        */
        match_token_level(&r, input_list, TK_PREPROCESSOR_LINE, level, ctx);
        skip_blanks_level(ctx, &r, input_list, level);
        assert(input_list->head->type == TK_IDENTIFIER);
        if (strcmp(input_list->head->lexeme, "ifdef") == 0)
        {
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx); //ifdef
            skip_blanks_level(ctx, &r, input_list, level);
            if (is_active)
            {
                struct macro* _Opt macro = find_macro(ctx, input_list->head->lexeme);
                *p_result = (macro != NULL) ? 1 : 0;
                //printf("#ifdef %s (%s)\n", input_list->head->lexeme, *p_result ? "true" : "false");
            }
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);
            skip_blanks_level(ctx, &r, input_list, level);
            match_token_level(&r, input_list, TK_NEWLINE, level, ctx);
        }
        else if (strcmp(input_list->head->lexeme, "ifndef") == 0)
        {
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx); //ifndef
            skip_blanks_level(ctx, &r, input_list, level);
            if (is_active)
            {
                struct macro* _Opt macro = find_macro(ctx, input_list->head->lexeme);
                *p_result = (macro == NULL) ? 1 : 0;
            }
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);
            skip_blanks_level(ctx, &r, input_list, level);
            match_token_level(&r, input_list, TK_NEWLINE, level, ctx);
        }
        else if (strcmp(input_list->head->lexeme, "if") == 0)
        {
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx); //if
            skip_blanks_level(ctx, &r, input_list, level);
            if (is_active)
            {
                struct token_list r0 = { 0 };
                *p_result = preprocessor_constant_expression(ctx, &r0, input_list, level);
                token_list_append_list(&r, &r0);
                token_list_destroy(&r0);
            }
            else
            {
                struct token_list r0 = ignore_preprocessor_line(input_list);
                token_list_append_list(&r, &r0);
                token_list_destroy(&r0);
            }
            match_token_level(&r, input_list, TK_NEWLINE, level, ctx);
        }
        else
        {

            preprocessor_diagnostic_message(C_ERROR_UNEXPECTED, ctx, input_list->head, "unexpected");
            throw;
        }
        struct token_list r2 = group_opt(ctx, input_list, is_active && *p_result, level);
        token_list_append_list(&r, &r2);
        assert(r2.head == NULL);
        assert(r2.tail == NULL);
    }
    catch
    {
    }

    return r;
}

struct token_list elif_group(struct preprocessor_ctx* ctx, struct token_list* input_list, bool is_active, int level, bool* p_elif_result)
{
    *p_elif_result = 0; //_Out

    struct token_list r = { 0 };
    /*
     elif-group:
      # elif constant-expression new-line group_opt

      C23
      # elifdef identifier new-line group_opt
      # elifndef identifier new-line group_opt
    */
    match_token_level(&r, input_list, TK_PREPROCESSOR_LINE, level, ctx);
    skip_blanks(ctx, &r, input_list);
    unsigned long long result = 0;
    if (strcmp(input_list->head->lexeme, "elif") == 0)
    {
        match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);
        skip_blanks(ctx, &r, input_list);

        if (is_active)
        {
            struct token_list r0 = { 0 };
            result = preprocessor_constant_expression(ctx, &r0, input_list, level);
            token_list_append_list(&r, &r0);
            token_list_destroy(&r0);
        }
        else
        {
            struct token_list r0 = ignore_preprocessor_line(input_list);
            token_list_append_list(&r, &r0);
            token_list_destroy(&r0);
        }
    }
    else if (strcmp(input_list->head->lexeme, "elifdef") == 0)
    {
        match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);
        skip_blanks(ctx, &r, input_list);

        if (is_active)
        {
            result = (owner_hashmap_find(&ctx->macros, input_list->head->lexeme) != NULL) ? 1 : 0;
        }
        match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);
    }
    else if (strcmp(input_list->head->lexeme, "elifndef") == 0)
    {
        match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);
        skip_blanks(ctx, &r, input_list);

        if (is_active)
        {
            result = (owner_hashmap_find(&ctx->macros, input_list->head->lexeme) == NULL) ? 1 : 0;
        }
        match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);
    }
    *p_elif_result = (result != 0);
    skip_blanks(ctx, &r, input_list);
    match_token_level(&r, input_list, TK_NEWLINE, level, ctx);
    struct token_list r2 = group_opt(ctx, input_list, is_active && *p_elif_result, level);
    token_list_append_list(&r, &r2);
    token_list_destroy(&r2);
    return r;
}

struct token_list elif_groups(struct preprocessor_ctx* ctx, struct token_list* input_list, bool is_active, int level, bool* pelif_result)
{
    struct token_list r = { 0 };
    /*
    elif-groups:
      elif-group
      elif-groups elif-group
    */
    bool already_found_elif_true = false;
    bool elif_result = false;
    struct token_list r2 = elif_group(ctx, input_list, is_active, level, &elif_result);
    token_list_append_list(&r, &r2);
    if (elif_result)
        already_found_elif_true = true;
    if (input_list->head->type == TK_PREPROCESSOR_LINE &&
        (
            preprocessor_token_ahead_is_identifier(input_list->head, "elif") ||
            preprocessor_token_ahead_is_identifier(input_list->head, "elifdef") ||
            preprocessor_token_ahead_is_identifier(input_list->head, "elifndef")
            )
        )
    {
        /*
          Depois que acha 1 true already_found_elif_true os outros sao false.
        */
        struct token_list r3 = elif_groups(ctx, input_list, is_active && !already_found_elif_true, level, &elif_result);
        token_list_append_list(&r, &r3);
        if (elif_result)
            already_found_elif_true = true;
        token_list_destroy(&r3);
    }
    /*
       Se algum dos elifs foi true retorna true
    */
    *pelif_result = already_found_elif_true;
    token_list_destroy(&r2);
    return r;
}

struct token_list else_group(struct preprocessor_ctx* ctx, struct token_list* input_list, bool is_active, int level)
{
    /*
      else-group:
       # else new-line group_opt
    */

    struct token_list r = { 0 };
    match_token_level(&r, input_list, TK_PREPROCESSOR_LINE, level, ctx);
    skip_blanks_level(ctx, &r, input_list, level);

    match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx); //else
    skip_blanks_level(ctx, &r, input_list, level);
    match_token_level(&r, input_list, TK_NEWLINE, level, ctx);

    struct token_list r2 = group_opt(ctx, input_list, is_active, level);
    token_list_append_list(&r, &r2);

    token_list_destroy(&r2);

    return r;
}

struct token_list endif_line(struct preprocessor_ctx* ctx, struct token_list* input_list, int level)
{
    /*
     endif-line:
       # endif new-line
    */

    struct token_list r = { 0 };

    match_token_level(&r, input_list, TK_PREPROCESSOR_LINE, level, ctx); //#
    skip_blanks_level(ctx, &r, input_list, level);
    match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx); //endif
    skip_blanks_level(ctx, &r, input_list, level);
    match_token_level(&r, input_list, TK_NEWLINE, level, ctx);

    return r;
}

struct token_list if_section(struct preprocessor_ctx* ctx, struct token_list* input_list, bool is_active, int level)
{
    /*
     if-section:
       if-group elif-groups_opt else-group_opt endif-line
    */

    struct token_list r = { 0 };

    try
    {
        bool if_result = false;
        struct token_list r2 = if_group(ctx, input_list, is_active, level, &if_result);
        if (ctx->n_errors > 0)
        {
            token_list_destroy(&r2);
            throw;
        }

        token_list_append_list(&r, &r2);
        bool elif_result = false;
        if (input_list->head->type == TK_PREPROCESSOR_LINE && (
            preprocessor_token_ahead_is_identifier(input_list->head, "elif") ||
            preprocessor_token_ahead_is_identifier(input_list->head, "elifdef") ||
            preprocessor_token_ahead_is_identifier(input_list->head, "elifndef")))
        {
            struct token_list r3 = elif_groups(ctx, input_list, is_active && !if_result, level, &elif_result);
            token_list_append_list(&r, &r3);
            token_list_destroy(&r3);
        }
        if (input_list->head->type == TK_PREPROCESSOR_LINE &&
            preprocessor_token_ahead_is_identifier(input_list->head, "else"))
        {
            struct token_list r4 = else_group(ctx, input_list, is_active && !if_result && !elif_result, level);
            token_list_append_list(&r, &r4);
            token_list_destroy(&r4);
        }

        if (ctx->n_errors > 0)
        {
            token_list_destroy(&r2);
            throw;
        }

        struct token_list r5 = endif_line(ctx, input_list, level);
        token_list_append_list(&r, &r5);
        token_list_destroy(&r5);
        token_list_destroy(&r2);
    }
    catch
    {
    }

    return r;
}

struct token_list identifier_list(struct preprocessor_ctx* ctx, struct macro* macro, struct token_list* input_list, int level)
{
    struct token_list r = { 0 };
    /*
      identifier-list:
      identifier
      identifier-list , identifier
    */
    skip_blanks(ctx, &r, input_list);

    struct macro_parameter* _Owner _Opt p_macro_parameter = calloc(1, sizeof * p_macro_parameter);
    p_macro_parameter->name = strdup(input_list->head->lexeme);

    assert(macro->parameters == NULL);
    macro->parameters = p_macro_parameter;

    struct macro_parameter* p_last_parameter = macro->parameters;

    match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);
    skip_blanks(ctx, &r, input_list);

    while (input_list->head->type == ',')
    {
        match_token_level(&r, input_list, ',', level, ctx);
        skip_blanks(ctx, &r, input_list);
        if (input_list->head->type == '...')
        {
            break;
        }

        struct macro_parameter* _Owner _Opt p_new_macro_parameter = calloc(1, sizeof * p_new_macro_parameter);
        p_new_macro_parameter->name = strdup(input_list->head->lexeme);

        assert(p_last_parameter->next == NULL);
        p_last_parameter->next = p_new_macro_parameter;
        p_last_parameter = p_last_parameter->next;

        match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);
        skip_blanks(ctx, &r, input_list);
    }
    return r;
}


struct token_list replacement_list(struct preprocessor_ctx* ctx, struct macro* macro, struct token_list* input_list, int level)
{
    struct token_list r = { 0 };

    while (input_list->head->type != TK_NEWLINE)
    {
        match_level(&r, input_list, level);
        if (input_list->head == NULL)
        {
            //terminou define sem quebra de linha
        }
    }

    assert(macro->replacement_list.head == NULL);
    struct token_list copy = copy_replacement_list(&r);
    token_list_append_list(&macro->replacement_list, &copy);
    token_list_destroy(&copy);
    return r;
}

struct token_list pp_tokens_opt(struct preprocessor_ctx* ctx, struct token_list* input_list, int level)
{
    struct token_list r = { 0 };
    while (input_list->head && input_list->head->type != TK_NEWLINE)
    {
        prematch_level(&r, input_list, level);
    }
    return r;
}

static bool is_empty_assert(struct token_list* replacement_list)
{
    struct token* token = replacement_list->head;

    if (token == NULL) return false;
    if (strcmp(token->lexeme, "(")) return false;
    token = token->next;

    if (token == NULL) return false;
    if (strcmp(token->lexeme, "(")) return false;
    token = token->next;

    if (token == NULL) return false;
    if (strcmp(token->lexeme, "void")) return false;
    token = token->next;

    if (token == NULL) return false;
    if (strcmp(token->lexeme, ")")) return false;
    token = token->next;

    if (token == NULL) return false;
    if (strcmp(token->lexeme, "0")) return false;
    token = token->next;

    if (token == NULL) return false;
    if (strcmp(token->lexeme, ")")) return false;
    token = token->next;

    if (token != NULL) return false;

    return true;
}

struct token_list control_line(struct preprocessor_ctx* ctx, struct token_list* input_list, bool is_active, int level)
{
    /*
        control-line:
            # "include" pp-tokens new-line
            # "embed" pp-tokens new-line
            # "define" identifier replacement-list new-line
            # "define" identifier ( identifier-list _Opt ) replacement-list new-line
            # "define" identifier ( ... ) replacement-list new-line
            # "define" identifier ( identifier-list , ... ) replacement-list new-line
            # "undef" identifier new-line
            # "line" pp-tokens new-line
            # "error" pp-tokens _Opt new-line
            # "warning" pp-tokens _Opt new-line
            # "pragma" pp-tokens _Opt new-line
            # new-line
    */

    struct token_list r = { 0 };

    try
    {
        if (!is_active)
        {
            //se nao esta ativo eh ignorado
            struct token_list r7 = pp_tokens_opt(ctx, input_list, level);
            token_list_append_list(&r, &r7);
            match_token_level(&r, input_list, TK_NEWLINE, level, ctx);
            token_list_destroy(&r7);
            return r;
        }

#ifdef _WIN32
        //char line[1000] = { 0 };
        //snprintf(line, sizeof line, "%s(%d,%d):\n", input_list->head->token_origin->lexeme, input_list->head->line, input_list->head->col);
        //OutputDebugStringA(line);
#endif
        struct token* const ptoken = input_list->head;
        match_token_level(&r, input_list, TK_PREPROCESSOR_LINE, level, ctx);
        skip_blanks_level(ctx, &r, input_list, level);
        if (strcmp(input_list->head->lexeme, "include") == 0)
        {
            /*
              # include pp-tokens new-line
            */
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx); //include
            skip_blanks_level(ctx, &r, input_list, level);
            char path[100] = { 0 };

            if (input_list->head->type == TK_STRING_LITERAL)
            {
                strcat(path, input_list->head->lexeme);
                prematch_level(&r, input_list, level);
            }
            else
            {
                while (input_list->head->type != '>')
                {
                    strcat(path, input_list->head->lexeme);
                    prematch_level(&r, input_list, level);
                }
                strcat(path, input_list->head->lexeme);
                prematch_level(&r, input_list, level);
            }

            if (input_list->head)
            {
                while (input_list->head->type != TK_NEWLINE)
                {
                    prematch_level(&r, input_list, level);
                }
            }
            match_token_level(&r, input_list, TK_NEWLINE, level, ctx);

            path[strlen(path) - 1] = '\0';

            /*this is the dir of the current file*/
            char current_file_dir[300] = { 0 };
            snprintf(current_file_dir, sizeof current_file_dir, "%s", r.tail->token_origin->lexeme);
            dirname(current_file_dir);


            char full_path_result[200] = { 0 };
            bool already_included = false;
            const char* _Owner _Opt content = find_and_read_include_file(ctx,
                path + 1,
                current_file_dir,
                &already_included,
                full_path_result,
                sizeof full_path_result);

            if (content != NULL)
            {
                if (ctx->options.show_includes)
                {
                    printf("Note: including file:");
                    printf("%*c", level + 1, ' ');
                    printf("%s\n", full_path_result);
                }

                struct tokenizer_ctx tctx = { 0 };
                struct token_list list = tokenizer(&tctx, content, full_path_result, level + 1, TK_FLAG_NONE);
                free((void* _Owner)content);

                struct token_list list2 = preprocessor(ctx, &list, level + 1);
                token_list_append_list(&r, &list2);

                token_list_destroy(&list2);
                token_list_destroy(&list);
            }
            else
            {
                if (!already_included)
                {
                    preprocessor_diagnostic_message(C_ERROR_FILE_NOT_FOUND, ctx, r.tail, "file %s not found", path + 1);

                    for (struct include_dir* p = ctx->include_dir.head; p; p = p->next)
                    {
                        /*let's print the include path*/
                        preprocessor_diagnostic_message(W_NOTE, ctx, r.tail, "dir = '%s'", p->path);
                    }
                }
                else
                {
                    //pragma once..
                }
            }

        }
        else if (strcmp(input_list->head->lexeme, "embed") == 0)
        {
            struct token_list discard0 = { 0 };
            struct token_list* p_list = &r;
            if (ctx->options.target < LANGUAGE_C23)
            {
                p_list = &discard0;

                free(ptoken->lexeme);
                ptoken->lexeme = strdup(" ");

            }

            /*
              C23
              # embed pp-tokens new-line
            */

            const struct token* const p_embed_token = input_list->head;

            match_token_level(p_list, input_list, TK_IDENTIFIER, level, ctx); //embed

            skip_blanks_level(ctx, p_list, input_list, level);
            char path[100] = { 0 };

            if (input_list->head->type == TK_STRING_LITERAL)
            {
                strcat(path, input_list->head->lexeme);
                prematch_level(p_list, input_list, level);
            }
            else
            {
                while (input_list->head->type != '>')
                {
                    strcat(path, input_list->head->lexeme);
                    prematch_level(p_list, input_list, level);
                }
                strcat(path, input_list->head->lexeme);
                prematch_level(p_list, input_list, level);
            }

            if (input_list->head)
            {
                while (input_list->head->type != TK_NEWLINE)
                {
                    prematch_level(p_list, input_list, level);
                }
            }
            match_token_level(p_list, input_list, TK_NEWLINE, level, ctx);



            char fullpath[300] = { 0 };
            path[strlen(path) - 1] = '\0';

            snprintf(fullpath, sizeof(fullpath), "%s", path + 1);


            int nlevel = level;

            enum token_flags f = 0;
            if (ctx->options.target < LANGUAGE_C23)
            {
                //we can see it
                f = TK_FLAG_FINAL;
            }
            else
            {
                f = TK_FLAG_FINAL;
                //we cannot see it just like include
                nlevel = nlevel + 1;
            }


            struct token_list list = embed_tokenizer(ctx, p_embed_token, fullpath, nlevel, f);

            if (ctx->n_errors > 0)
            {
                token_list_destroy(&list);
                throw;
            }

            token_list_append_list(&r, &list);
            token_list_destroy(&list);
            token_list_destroy(&discard0);
        }
        else if (strcmp(input_list->head->lexeme, "define") == 0)
        {
            //TODO strcmp nao pode ser usado temos que criar uma funcao especial

            /*
             #de\
             fine A 1

            A
            */

            struct macro* _Owner _Opt macro = calloc(1, sizeof * macro);
            if (macro == NULL)
            {
                preprocessor_diagnostic_message(C_ERROR_UNEXPECTED, ctx, ctx->current, "_Out of mem");
                throw;
            }

            /*
                # define identifier                           replacement-list new-line
                # define identifier ( identifier-list_opt )    replacement-list new-line
                # define identifier ( ... )                   replacement-list new-line
                # define identifier ( identifier-list , ... ) replacement-list new-line
            */
            //p = preprocessor_match_identifier(p, is_active, level, false, "define");

            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx); //define
            skip_blanks_level(ctx, &r, input_list, level);

            // printf("define %s\n%s : %d\n", input_list->head->lexeme, input_list->head->token_origin->lexeme, input_list->head->line);

            struct token* macro_name_token = input_list->head;


            if (owner_hashmap_find(&ctx->macros, input_list->head->lexeme) != NULL)
            {
                //printf("warning: '%s' macro redefined at %s %d\n",
                  //     input_list->head->lexeme,
                    ///   input_list->head->token_origin->lexeme,
                      // input_list->head->line);
            }

            assert(macro->name == NULL);
            macro->name = strdup(input_list->head->lexeme);


            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx); //nome da macro


            /*sem skip*/
            //p = preprocessor_match_token(p, is_active, level, false, IDENTIFIER); /*name*/
            if (input_list->head->type == '(')
            {

                macro->is_function = true;


                match_token_level(&r, input_list, '(', level, ctx);
                skip_blanks_level(ctx, &r, input_list, level);
                if (input_list->head->type == '...')
                {
                    struct macro_parameter* _Owner _Opt p_macro_parameter = calloc(1, sizeof * p_macro_parameter);
                    p_macro_parameter->name = strdup("__VA_ARGS__");
                    macro->parameters = p_macro_parameter;

                    // assert(false);
                    match_token_level(&r, input_list, '...', level, ctx); //nome da macro
                    skip_blanks_level(ctx, &r, input_list, level);
                    match_token_level(&r, input_list, ')', level, ctx); //nome da macro
                }
                else if (input_list->head->type == ')')
                {
                    match_token_level(&r, input_list, ')', level, ctx);
                    skip_blanks_level(ctx, &r, input_list, level);
                }
                else
                {

                    struct token_list r3 = identifier_list(ctx, macro, input_list, level);
                    token_list_append_list(&r, &r3);
                    token_list_destroy(&r3);

                    skip_blanks_level(ctx, &r, input_list, level);
                    if (input_list->head->type == '...')
                    {
                        struct macro_parameter* _Owner _Opt p_macro_parameter = calloc(1, sizeof * p_macro_parameter);
                        p_macro_parameter->name = strdup("__VA_ARGS__");
                        struct macro_parameter* p_last = macro->parameters;
                        assert(p_last != NULL);
                        while (p_last->next)
                        {
                            p_last = p_last->next;
                        }
                        p_last->next = p_macro_parameter;

                        match_token_level(&r, input_list, '...', level, ctx);
                    }
                    skip_blanks_level(ctx, &r, input_list, level);
                    match_token_level(&r, input_list, ')', level, ctx);
                }
            }
            else
            {
                macro->is_function = false;
            }
            skip_blanks_level(ctx, &r, input_list, level);
            struct token_list r4 = replacement_list(ctx, macro, input_list, level);
            token_list_append_list(&r, &r4);
            token_list_destroy(&r4);

            match_token_level(&r, input_list, TK_NEWLINE, level, ctx);
            if (!ctx->options.disable_assert && strcmp(macro->name, "assert") == 0)
            {
                //cake overrides macro assert in debug and release to be defined as 
                //assert(__VA_ARGS__)
                if (!is_empty_assert(&macro->replacement_list))
                {
                    macro_parameters_delete(macro->parameters);

                    struct macro_parameter* _Owner _Opt p_macro_parameter = calloc(1, sizeof * p_macro_parameter);
                    p_macro_parameter->name = strdup("__VA_ARGS__");
                    macro->parameters = p_macro_parameter;

                    token_list_destroy(&macro->replacement_list);
                    struct tokenizer_ctx tctx = { 0 };
                    macro->replacement_list = tokenizer(&tctx, "assert(__VA_ARGS__)", NULL, level, TK_FLAG_NONE);
                }
            }

            if (macro_name_token)
                naming_convention_macro(ctx, macro_name_token);

            struct macro* _Owner _Opt previous =
                owner_hashmap_set(&ctx->macros, macro->name, (void* _Owner)macro, 0);

            if (previous)
            {
                delete_macro(previous);
                previous = NULL;
            }

        }
        else if (strcmp(input_list->head->lexeme, "undef") == 0)
        {
            /*
             # undef identifier new-line
            */
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//undef
            skip_blanks_level(ctx, &r, input_list, level);

            struct macro* _Owner _Opt macro = (struct macro* _Owner _Opt) owner_hashmap_remove(&ctx->macros, input_list->head->lexeme, NULL);
            assert(find_macro(ctx, input_list->head->lexeme) == NULL);
            if (macro)
            {
                delete_macro(macro);
                match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//undef
            }
            else
            {
                match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//undef
                /*no warnings*/
            }
            skip_blanks_level(ctx, &r, input_list, level);
            match_token_level(&r, input_list, TK_NEWLINE, level, ctx);
        }
        else if (strcmp(input_list->head->lexeme, "line") == 0)
        {
            /*
               # line pp-tokens new-line
            */
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//line
            struct token_list r5 = pp_tokens_opt(ctx, input_list, level);
            token_list_append_list(&r, &r5);
            token_list_destroy(&r5);
            match_token_level(&r, input_list, TK_NEWLINE, level, ctx);
        }
        else if (strcmp(input_list->head->lexeme, "error") == 0)
        {
            /*
              # error pp-tokensopt new-line
            */
            ctx->n_warnings++;
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//error
            struct token_list r6 = pp_tokens_opt(ctx, input_list, level);
            preprocessor_diagnostic_message(C_ERROR_PREPROCESSOR_C_ERROR_DIRECTIVE, ctx, input_list->head, "#error");
            token_list_append_list(&r, &r6);
            token_list_destroy(&r6);
            match_token_level(&r, input_list, TK_NEWLINE, level, ctx);


        }
        else if (strcmp(input_list->head->lexeme, "warning") == 0)
        {
            /*
              # warning pp-tokensopt new-line
            */
            ctx->n_warnings++;

            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//warning

            struct token_list r6 = pp_tokens_opt(ctx, input_list, level);
            preprocessor_diagnostic_message(W_NONE, ctx, input_list->head, "#warning");
            token_list_append_list(&r, &r6);
            match_token_level(&r, input_list, TK_NEWLINE, level, ctx);
            token_list_destroy(&r6);
        }
        else if (strcmp(input_list->head->lexeme, "pragma") == 0)
        {
            /*
              # pragma pp-tokensopt new-line
            */
            /*
               #pragma will survive and compiler will handle as
               pragma declaration
            */
            match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//pragma
            r.tail->type = TK_PRAGMA;
            r.tail->flags |= TK_FLAG_FINAL;
            skip_blanks_level(ctx, &r, input_list, level);

            if (input_list->head->type == TK_IDENTIFIER)
            {
                if (strcmp(input_list->head->lexeme, "CAKE") == 0)
                {
                    match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);
                    r.tail->flags |= TK_FLAG_FINAL;
                    skip_blanks_level(ctx, &r, input_list, level);
                }

                if (input_list->head && strcmp(input_list->head->lexeme, "once") == 0)
                {
                    hashmap_set(&ctx->pragma_once_map, input_list->head->token_origin->lexeme, (void*)1, 0);
                    match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//pragma
                    r.tail->flags |= TK_FLAG_FINAL;
                }
                else if (input_list->head && strcmp(input_list->head->lexeme, "dir") == 0)
                {
                    match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//pragma
                    skip_blanks_level(ctx, &r, input_list, level);
                    if (input_list->head->type != TK_STRING_LITERAL)
                    {
                        preprocessor_diagnostic_message(C_ERROR_UNEXPECTED, ctx, input_list->head, "expected string");
                        throw;
                    }

                    char path[200] = { 0 };
                    strncpy(path, input_list->head->lexeme + 1, strlen(input_list->head->lexeme) - 2);
                    include_dir_add(&ctx->include_dir, path);
                    match_token_level(&r, input_list, TK_STRING_LITERAL, level, ctx);//pragma
                    r.tail->flags |= TK_FLAG_FINAL;
                }
                else if (input_list->head && strcmp(input_list->head->lexeme, "expand") == 0)
                {
                    match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//pragma
                    r.tail->flags |= TK_FLAG_FINAL;
                    skip_blanks_level(ctx, &r, input_list, level);

                    struct macro* _Opt macro = find_macro(ctx, input_list->head->lexeme);
                    if (macro)
                    {
                        macro->expand = true;
                    }

                    match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//pragma
                }
                else if (input_list->head && strcmp(input_list->head->lexeme, "nullchecks") == 0)
                {
                    assert(false);
                    match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//nullchecks
                    r.tail->flags |= TK_FLAG_FINAL;
                    skip_blanks_level(ctx, &r, input_list, level);
                    ctx->options.null_checks_enabled = true;
                }

                if (input_list->head && strcmp(input_list->head->lexeme, "diagnostic") == 0)
                {
                    match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//diagnostic
                    r.tail->flags |= TK_FLAG_FINAL;
                    skip_blanks_level(ctx, &r, input_list, level);

                    if (input_list->head && strcmp(input_list->head->lexeme, "push") == 0)
                    {
                        match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//diagnostic
                        r.tail->flags |= TK_FLAG_FINAL;
                        //#pragma GCC diagnostic push
                        if (ctx->options.diagnostic_stack.top_index <
                            sizeof(ctx->options.diagnostic_stack) / sizeof(ctx->options.diagnostic_stack.stack[0]))
                        {
                            ctx->options.diagnostic_stack.top_index++;

                            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index] =
                                ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index - 1];
                        }
                    }
                    else if (input_list->head && strcmp(input_list->head->lexeme, "pop") == 0)
                    {
                        //#pragma GCC diagnostic pop
                        match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//pop
                        r.tail->flags |= TK_FLAG_FINAL;
                        if (ctx->options.diagnostic_stack.top_index > 0)
                        {
                            ctx->options.diagnostic_stack.top_index--;
                        }
                    }
                    else if (input_list->head && strcmp(input_list->head->lexeme, "warning") == 0)
                    {
                        //#pragma CAKE diagnostic warning "-Wenum-compare"

                        match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//warning
                        r.tail->flags |= TK_FLAG_FINAL;
                        skip_blanks_level(ctx, &r, input_list, level);

                        if (input_list->head && input_list->head->type == TK_STRING_LITERAL)
                        {
                            match_token_level(&r, input_list, TK_STRING_LITERAL, level, ctx);//""
                            r.tail->flags |= TK_FLAG_FINAL;

                            unsigned long long  w = get_warning_bit_mask(input_list->head->lexeme + 1 + 2);
                            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings |= w;
                        }
                    }
                    else if (input_list->head && strcmp(input_list->head->lexeme, "ignore") == 0)
                    {
                        //#pragma CAKE diagnostic ignore "-Wenum-compare"

                        match_token_level(&r, input_list, TK_IDENTIFIER, level, ctx);//ignore
                        r.tail->flags |= TK_FLAG_FINAL;
                        skip_blanks_level(ctx, &r, input_list, level);

                        if (input_list->head && input_list->head->type == TK_STRING_LITERAL)
                        {
                            unsigned long long w = get_warning_bit_mask(input_list->head->lexeme + 1 + 2);
                            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings &= ~w;
                        }
                    }
                }
            }

            struct token_list r7 = pp_tokens_opt(ctx, input_list, level);
            token_list_append_list(&r, &r7);
            match_token_level(&r, input_list, TK_NEWLINE, level, ctx);
            r.tail->type = TK_PRAGMA_END;
            r.tail->flags |= TK_FLAG_FINAL;
            token_list_destroy(&r7);
        }
    }
    catch
    {
    }

    return r;
}


static struct token_list non_directive(struct preprocessor_ctx* ctx, struct token_list* input_list, int level)
{
    /*
      non-directive:
      pp-tokens new-line
     */
    struct token_list r = pp_tokens_opt(ctx, input_list, level);
    skip_blanks_level(ctx, &r, input_list, level);
    match_token_level(&r, input_list, TK_NEWLINE, level, ctx);
    return r;
}

static struct macro_argument_list collect_macro_arguments(struct preprocessor_ctx* ctx,
    struct macro* macro,
    struct token_list* input_list, int level)
{
    struct macro_argument_list macro_argument_list = { 0 };
    try
    {
        assert(input_list->head->type == TK_IDENTIFIER); //nome da macro
        const struct token* const macro_name_token = input_list->head;

        match_token_level(&macro_argument_list.tokens, input_list, TK_IDENTIFIER, level, ctx); //NOME DA MACRO
        if (!macro->is_function)
        {
            //se nao eh funcao so faz isso e retorna o nome da macro
            return macro_argument_list;
        }

        struct macro_parameter* _Opt p_current_parameter = macro->parameters;
        int count = 1;
        skip_blanks(ctx, &macro_argument_list.tokens, input_list);
        match_token_level(&macro_argument_list.tokens, input_list, '(', level, ctx);
        skip_blanks(ctx, &macro_argument_list.tokens, input_list);
        if (input_list->head->type == ')')
        {
            if (macro->parameters != NULL)
            {
                struct macro_argument* _Owner _Opt  p_argument = calloc(1, sizeof(struct macro_argument));
                p_argument->name = strdup(p_current_parameter->name);
                argument_list_add(&macro_argument_list, p_argument);
            }
            match_token_level(&macro_argument_list.tokens, input_list, ')', level, ctx);
            return macro_argument_list;
        }
        struct macro_argument* _Owner _Opt p_argument = calloc(1, sizeof(struct macro_argument));
        p_argument->name = strdup(p_current_parameter->name);
        while (input_list->head != NULL)
        {
            if (input_list->head->type == '(')
            {
                count++;
                token_list_clone_and_add(&p_argument->tokens, input_list->head);
                match_token_level(&macro_argument_list.tokens, input_list, '(', level, ctx);
            }
            else if (input_list->head->type == ')')
            {
                count--;
                if (count == 0)
                {
                    match_token_level(&macro_argument_list.tokens, input_list, ')', level, ctx);
                    argument_list_add(&macro_argument_list, p_argument);
                    p_argument = NULL; //MOVED

                    p_current_parameter = p_current_parameter->next;

                    if (p_current_parameter != NULL)
                    {
                        if (strcmp(p_current_parameter->name, "__VA_ARGS__") == 0)
                        {
                            //adicionamos este argumento como sendo vazio
                            p_argument = calloc(1, sizeof(struct macro_argument));
                            p_argument->name = strdup(p_current_parameter->name);
                            argument_list_add(&macro_argument_list, p_argument);
                            p_argument = NULL; //MOVED
                        }
                        else
                        {
                            preprocessor_diagnostic_message(C_ERROR_TOO_FEW_ARGUMENTS_TO_FUNCTION_LIKE_MACRO, ctx, macro_name_token, "too few arguments provided to function-like macro invocation\n");
                            throw;
                        }
                    }


                    break;
                }
                else
                {
                    token_list_clone_and_add(&p_argument->tokens, input_list->head);
                    match_token_level(&macro_argument_list.tokens, input_list, ')', level, ctx);
                }
            }
            else if (count == 1 && input_list->head->type == ',')
            {
                if (strcmp(p_current_parameter->name, "__VA_ARGS__") == 0)
                {
                    token_list_clone_and_add(&p_argument->tokens, input_list->head);
                    match_token_level(&macro_argument_list.tokens, input_list, ',', level, ctx);
                }
                else //if (count == 1)
                {
                    match_token_level(&macro_argument_list.tokens, input_list, ',', level, ctx);
                    argument_list_add(&macro_argument_list, p_argument);
                    p_argument = NULL; /*MOVED*/

                    p_argument = calloc(1, sizeof(struct macro_argument));
                    p_current_parameter = p_current_parameter->next;
                    if (p_current_parameter == NULL)
                    {
                        preprocessor_diagnostic_message(C_ERROR_PREPROCESSOR_MACRO_INVALID_ARG, ctx, macro_name_token, "invalid args");
                        macro_argument_delete(p_argument);
                        p_argument = NULL; //DELETED
                        throw;
                    }
                    p_argument->name = strdup(p_current_parameter->name);
                }
            }
            else
            {
                token_list_clone_and_add(&p_argument->tokens, input_list->head);
                prematch_level(&macro_argument_list.tokens, input_list, level);
                //token_list_add(&list, token_list_pop_front(input_list));
            }
        }

        assert(p_argument == NULL);
    }
    catch
    {
    }

    return macro_argument_list;
}

struct token_list expand_macro(struct preprocessor_ctx* ctx, struct macro_expanded* _Opt p_list, struct macro* macro, struct macro_argument_list* arguments, int level, const struct token* origin);
struct token_list replacement_list_reexamination(struct preprocessor_ctx* ctx, struct macro_expanded* p_list, struct token_list* oldlist, int level, const struct token* origin);


struct token_list macro_copy_replacement_list(struct preprocessor_ctx* ctx, struct macro* macro, const struct token* origin);

/*#define hash_hash # ## #
#define mkstr(a) # a
#define in_between(a) mkstr(a)
#define join(c, d) in_between(c hash_hash d)

hash_hash

join(x, y)
*/
static struct token_list concatenate(struct preprocessor_ctx* ctx, struct token_list* input_list)
{
    //printf("input="); print_list(input_list);

    struct token_list  r = { 0 };
    //todo juntar tokens mesmo objet macro
    //struct token* p_previousNonBlank = 0;
    while (input_list->head)
    {
        //printf("r="); print_list(&r);
        //printf("input="); print_list(input_list);

        assert(!(input_list->head->flags & TK_FLAG_HAS_NEWLINE_BEFORE));
        if (input_list->head->type == '##')
        {
            if (r.tail == NULL)
            {
                preprocessor_diagnostic_message(C_ERROR_PREPROCESSOR_MISSING_MACRO_ARGUMENT, ctx, input_list->head, "missing macro argument (should be checked before)");
                break;
            }
            /*
            * arranca ## do input (sem adicionar)
            */
            token_list_pop_front(input_list);

            struct osstream ss = { 0 };

            /*
            *  Faz uma string com o fim r + começo do input (## ja foi removido)
            */
            if (r.tail->lexeme[0] != '\0')
                ss_fprintf(&ss, "%s", r.tail->lexeme);

            if (input_list->head && input_list->head->lexeme[0] != '\0')
                ss_fprintf(&ss, "%s", input_list->head->lexeme);

            //copiar o level para gerar um novo igual
            int level = input_list->head ? input_list->head->level : 0;

            /*
            * Já paga do input o token usado na concatenacao
            */
            token_list_pop_front(input_list);

            /*
            * Faz um novo token com a string montada
            */
            struct tokenizer_ctx tctx = { 0 };
            struct token_list newlist = tokenizer(&tctx, ss.c_str, NULL, level, TK_FLAG_NONE);

            if (newlist.head)
            {
                newlist.head->flags = r.tail->flags;
            }
            else
            {
                struct token* _Owner _Opt p_new_token = calloc(1, sizeof * p_new_token);
                p_new_token->lexeme = strdup("");
                p_new_token->type = TK_PLACEMARKER;
                token_list_add(&newlist, p_new_token);
                newlist.head->flags = r.tail->flags;
            }
            /*
            * Arranca o anterior do r que foi usado para formar string
            */
            token_list_pop_back(&r);

            /*adiciona novo token no fim do r*/
            token_list_append_list(&r, &newlist);

            ss_close(&ss);

            token_list_destroy(&newlist);

            if (input_list->head == NULL)
                break;
        }
        else
        {
            prematch(&r, input_list);
        }
    }
    return r;
}

/*
  check if the argument list that corresponds to a trailing ...
  of the parameter list is present and has a non-empty substitution.
*/
static bool has_argument_list_empty_substitution(struct preprocessor_ctx* ctx,
    struct macro_expanded* p_list,
    struct macro_argument_list* p_macro_argument_list,
    const struct token* origin)
{
    if (p_macro_argument_list->head == NULL)
        return true;

    struct macro_argument* _Opt p_va_args_argument =
        find_macro_argument_by_name(p_macro_argument_list, "__VA_ARGS__");

    if (p_va_args_argument)
    {
        if (p_va_args_argument->tokens.head == NULL)
            return true;

        struct token_list argumentlist = copy_argument_list(p_va_args_argument);

        struct token_list r4 = replacement_list_reexamination(ctx, p_list, &argumentlist, 0, origin);
        const bool results_in_empty_substituition = (r4.head == NULL || r4.head->type == TK_PLACEMARKER);
        token_list_destroy(&r4);

        token_list_destroy(&argumentlist);

        return results_in_empty_substituition;
    }

    return false;
}

static struct token_list replace_macro_arguments(struct preprocessor_ctx* ctx, struct macro_expanded* p_list, struct token_list* input_list, struct macro_argument_list* arguments, const struct token* origin)
{
    struct token_list r = { 0 };

    try
    {
        while (input_list->head)
        {
            assert(!(input_list->head->flags & TK_FLAG_HAS_NEWLINE_BEFORE));
            assert(!token_is_blank(input_list->head));
            assert(r.tail == NULL || !token_is_blank(r.tail));
            struct macro_argument* _Opt p_argument = NULL;
            if (input_list->head->type == TK_IDENTIFIER)
            {
                if (strcmp(input_list->head->lexeme, "__VA_OPT__") == 0)
                {
                    token_list_pop_front(input_list); //pop __VA_OPT__
                    token_list_pop_front(input_list); //pop (
                    int parenteses_count = 1;         //we already have one

                    const bool discard_va_opt =
                        has_argument_list_empty_substitution(ctx, p_list, arguments, origin);

                    if (discard_va_opt)
                    {
                        //discard all tokens __VA_OPT__(...)
                        while (input_list->head)
                        {
                            if (input_list->head->type == '(') parenteses_count++;
                            else if (input_list->head->type == ')') parenteses_count--;
                            token_list_pop_front(input_list);
                            if (parenteses_count == 0)
                                break;
                        }
                    }
                    else
                    {
                        // Search and remove the last balanced ')'
                        struct token* _Opt p_token = input_list->head;
                        for (; p_token; p_token = p_token->next)
                        {
                            if (p_token->type == '(') parenteses_count++;
                            else if (p_token->type == ')') parenteses_count--;

                            if (parenteses_count == 0)
                                break;
                        }
                        token_list_remove(input_list, p_token, p_token);
                    }
                    continue;
                }

                p_argument = find_macro_argument_by_name(arguments, input_list->head->lexeme);
            }

            if (p_argument)
            {
                if (r.tail != NULL && r.tail->type == '#')
                {

                    /*
                      deleta nome parametro da lista
                      antes copia flags dele
                    */

                    const enum token_flags flags = input_list->head->flags;
                    token_list_pop_front(input_list);

                    //deleta tambem # do fim
                    while (token_is_blank(r.tail))
                    {
                        token_list_pop_back(&r);
                    }
                    token_list_pop_back(&r);

                    ///----------------------------
                    //transforma tudo em string e coloca no resultado
                    struct token_list argumentlist = copy_argument_list(p_argument);
                    char* _Owner _Opt s = token_list_join_tokens(&argumentlist, true);
                    if (s == NULL)
                    {
                        token_list_destroy(&argumentlist);
                        preprocessor_diagnostic_message(C_ERROR_UNEXPECTED, ctx, input_list->head, "unexpected");
                        throw;
                    }
                    struct token* _Owner _Opt p_new_token = calloc(1, sizeof * p_new_token);
                    
                    if (p_new_token == NULL) 
                    {
                        free(s);
                        token_list_destroy(&argumentlist);
                        throw;
                    }

                    p_new_token->lexeme = s;
                    p_new_token->type = TK_STRING_LITERAL;
                    p_new_token->flags = flags;
                    token_list_add(&r, p_new_token);
                    token_list_destroy(&argumentlist);
                    continue;
                }
                else if (r.tail != NULL && r.tail->type == '##')
                {
                    //estou parametro e anterior era ##
                    token_list_pop_front(input_list);
                    struct token_list argumentlist = copy_argument_list(p_argument);
                    token_list_append_list(&r, &argumentlist);
                    token_list_destroy(&argumentlist);
                }
                else if (input_list->head->next && input_list->head->next->type == '##')
                {
                    //estou no parametro e o da frente eh ##
                    int flags = input_list->head->flags;
                    //tira nome parametro a lista
                    token_list_pop_front(input_list);
                    //passa tudo p resultado
                    struct token_list argumentlist = copy_argument_list(p_argument);
                    if (argumentlist.head != NULL)
                    {
                        argumentlist.head->flags = flags;
                    }
                    token_list_append_list(&r, &argumentlist);
                    // ja passa o ## tambem
                    prematch(&r, input_list);
                    token_list_destroy(&argumentlist);
                }
                else
                {
                    int flags = input_list->head->flags;
                    //remove nome parametro do input
                    token_list_pop_front(input_list);
                    //coloca a expansao no resultado
                    struct token_list argumentlist = copy_argument_list(p_argument);
                    if (argumentlist.head)
                    {
                        //copia os flags do identificador
                        argumentlist.head->flags = flags;
                    }
                    /*depois reescan vai corrigir level*/
                    struct token_list r4 = replacement_list_reexamination(ctx, p_list, &argumentlist, 0, origin);
                    token_list_append_list(&r, &r4);
                    token_list_destroy(&r4);
                    if (ctx->n_errors > 0)
                    {
                        token_list_destroy(&argumentlist);
                        throw;
                    }
                    token_list_destroy(&argumentlist);
                }
            }
            else
            {
                prematch(&r, input_list);
            }
        }
    }
    catch
    {
    }


    return r;
}

struct token_list concatenate(struct preprocessor_ctx* ctx, struct token_list* input_list);

static bool macro_already_expanded(struct macro_expanded* _Opt p_list, const char* name)
{
    struct macro_expanded* _Opt p_item = p_list;
    while (p_item)
    {
        if (strcmp(name, p_item->name) == 0)
        {
            return true;
        }
        p_item = p_item->p_previous;
    }
    return false;
}

struct token_list replacement_list_reexamination(struct preprocessor_ctx* ctx,
    struct macro_expanded* p_list,
    struct token_list* oldlist,
    int level,
    const struct token* origin)
{
    struct token_list r = { 0 };
    try
    {
        //replacement_list_reexamination
        /*
        For both object-like and function-like macro invocations, before the replacement list is reexamined
        for more macro names to replace, each instance of a ## preprocessing token in the replacement list
        (not from an argument) is deleted and the preceding preprocessing token is concatenated with the
        following preprocessing token.
        */
        struct token_list new_list = concatenate(ctx, oldlist);
        while (new_list.head != NULL)
        {
            assert(!(new_list.head->flags & TK_FLAG_HAS_NEWLINE_BEFORE));
            assert(!token_is_blank(new_list.head));
            struct macro* _Opt macro = NULL;
            if (new_list.head->type == TK_IDENTIFIER)
            {
                macro = find_macro(ctx, new_list.head->lexeme);
                if (macro &&
                    macro->is_function &&
                    !preprocessor_token_ahead_is(new_list.head, '('))
                {
                    macro = NULL;
                }

                if (macro && macro_already_expanded(p_list, new_list.head->lexeme))
                {
                    new_list.head->type = TK_IDENTIFIER_RECURSIVE_MACRO;
                    macro = NULL;
                }


                if (ctx->conditional_inclusion)
                {
                    /*
                     Quando estamos expandindo em condinonal inclusion o defined macro ou defined (macro)
                     não é expandido e é considerado depois
                    */
                    if (r.tail &&
                        r.tail->type == TK_IDENTIFIER &&
                        strcmp(r.tail->lexeme, "defined") == 0)
                    {
                        macro = NULL;
                    }
                    else if (r.tail &&
                        r.tail->type == '(')
                    {
                        struct token* previous = r.tail->prev;
                        if (previous != NULL &&
                            previous->type == TK_IDENTIFIER &&
                            strcmp(previous->lexeme, "defined") == 0)
                        {
                            macro = NULL;
                        }
                    }
                }

            }
            if (macro)
            {
                int flags = new_list.head->flags;
                struct macro_argument_list arguments = collect_macro_arguments(ctx, macro, &new_list, level);
                if (ctx->n_errors > 0)
                {
                    macro_argument_list_destroy(&arguments);
                    token_list_destroy(&new_list);
                    throw;
                }


                struct token_list r3 = expand_macro(ctx, p_list, macro, &arguments, level, origin);
                if (ctx->n_errors > 0)
                {
                    token_list_destroy(&new_list);
                    token_list_destroy(&r3);
                    macro_argument_list_destroy(&arguments);
                    throw;
                }

                if (r3.head)
                {
                    r3.head->flags = flags;
                }
                token_list_append_list_at_beginning(&new_list, &r3);
                macro_argument_list_destroy(&arguments);
                token_list_destroy(&r3);
            }
            else
            {
                /*
                 This is a good place to set the level and macro flags
                 because there is always a macro rescan at the end
                */
                new_list.head->level = level;
                new_list.head->flags |= TK_FLAG_MACRO_EXPANDED;
                assert(!(new_list.head->flags & TK_FLAG_HAS_NEWLINE_BEFORE));
                prematch(&r, &new_list); //it wasn't macro
            }
        }
    }
    catch
    {
    }

    return r;
}

/*
  Faz a comparação ignorando a continuacao da linha
  TODO fazer uma revisão geral aonde se usa strcmp em lexeme
  e trocar por esta.
*/
int lexeme_cmp(const char* s1, const char* s2)
{
    while (*s1 && *s2)
    {

        while ((s1[0] == '\\' && s1[1] == '\n'))
        {
            s1++;
            s1++;
        }


        while (s2[0] == '\\' && s2[1] == '\n')
        {
            s2++;
            s2++;
        }

        if (*s1 != *s2)
            break;

        s1++;
        s2++;
    }

    while ((s1[0] == '\\' && s1[1] == '\n'))
    {
        s1++;
        s1++;
    }


    while (s2[0] == '\\' && s2[1] == '\n')
    {
        s2++;
        s2++;
    }

    return *(const unsigned char*)s1 - *(const unsigned char*)s2;
}

void remove_line_continuation(char* s)
{
    char* pread = s;
    char* pwrite = s;
    while (*pread)
    {
        if (pread[0] == '\\' && pread[1] == '\n')
        {
            pread++;
            pread++;
        }
        else
        {
            *pwrite = *pread;
            pread++;
            pwrite++;
        }
    }
    *pwrite = *pread;
}

struct token_list  copy_replacement_list(const struct token_list* list)
{
    //Faz uma copia dos tokens fazendo um trim no iniico e fim
    //qualquer espaco coments etcc vira um unico  espaco
    struct token_list r = { 0 };
    struct token* _Opt current = list->head;
    //sai de cima de todos brancos iniciais
    while (current && token_is_blank(current))
    {
        current = current->next;
    }
    //remover flag de espaco antes se tiver
    bool is_first = true;

    for (; current;)
    {
        if (current && token_is_blank(current))
        {
            if (current == list->tail)
                break;

            current = current->next;
            continue;
        }
        struct token* token_added = token_list_clone_and_add(&r, current);
        if (token_added->flags & TK_FLAG_HAS_NEWLINE_BEFORE)
        {
            token_added->flags = token_added->flags & ~TK_FLAG_HAS_NEWLINE_BEFORE;
            token_added->flags |= TK_FLAG_HAS_SPACE_BEFORE;
        }
        if (is_first)
        {
            token_added->flags = token_added->flags & ~TK_FLAG_HAS_SPACE_BEFORE;
            token_added->flags = token_added->flags & ~TK_FLAG_HAS_NEWLINE_BEFORE;
            is_first = false;
        }
        remove_line_continuation(token_added->lexeme);

        if (current == list->tail)
            break;
        current = current->next;

    }
    return r;
}



struct token_list macro_copy_replacement_list(struct preprocessor_ctx* ctx, struct macro* macro, const struct token* origin)
{
    /*macros de conteudo dinamico*/
    if (strcmp(macro->name, "__LINE__") == 0)
    {
        struct tokenizer_ctx tctx = { 0 };
        char line[50] = { 0 };

        assert(origin != NULL);
        snprintf(line, sizeof line, "%d", origin->line);

        struct token_list r = tokenizer(&tctx, line, "", 0, TK_FLAG_NONE);
        token_list_pop_front(&r);
        r.head->flags = 0;
        return r;
    }
    else if (strcmp(macro->name, "__FILE__") == 0)
    {
        char buffer[300] = { 0 };
        if (stringify(origin->token_origin->lexeme, sizeof buffer, buffer) < 0)
        {
            //ops TODO
        }

        struct tokenizer_ctx tctx = { 0 };
        struct token_list r = tokenizer(&tctx, buffer, "", 0, TK_FLAG_NONE);
        token_list_pop_front(&r);
        r.head->flags = 0;
        return r;
    }
    else if (strcmp(macro->name, "__COUNTER__") == 0)
    {
        //TODO unit test
        char line[50] = { 0 };
        ctx->count_macro_value++;
        snprintf(line, sizeof line, "%d", ctx->count_macro_value);
        struct tokenizer_ctx tctx = { 0 };
        struct token_list r = tokenizer(&tctx, line, "", 0, TK_FLAG_NONE);
        token_list_pop_front(&r);
        r.head->flags = 0;
        return r;
    }

    return copy_replacement_list(&macro->replacement_list);
}

void print_literal2(const char* s);


struct token_list expand_macro(struct preprocessor_ctx* ctx,
    struct macro_expanded* _Opt p_list_of_macro_expanded_opt,
    struct macro* macro,
    struct macro_argument_list* arguments,
    int level,
    const struct token* origin)
{
    macro->usage++;

    struct token_list r = { 0 };
    try
    {
        assert(!macro_already_expanded(p_list_of_macro_expanded_opt, macro->name));
        struct macro_expanded macro_expanded = { 0 };
        macro_expanded.name = macro->name;
        macro_expanded.p_previous = p_list_of_macro_expanded_opt;
        if (macro->is_function)
        {
            struct token_list copy = macro_copy_replacement_list(ctx, macro, origin);
            struct token_list copy2 = replace_macro_arguments(ctx, &macro_expanded, &copy, arguments, origin);
            struct token_list r2 = replacement_list_reexamination(ctx, &macro_expanded, &copy2, level, origin);

            token_list_append_list(&r, &r2);

            token_list_destroy(&copy);
            token_list_destroy(&copy2);
            token_list_destroy(&r2);

            if (ctx->n_errors > 0) throw;
        }
        else
        {
            struct token_list copy = macro_copy_replacement_list(ctx, macro, origin);
            struct token_list r3 = replacement_list_reexamination(ctx, &macro_expanded, &copy, level, origin);
            if (ctx->n_errors > 0)
            {
                token_list_destroy(&copy);
                token_list_destroy(&r3);
                throw;
            }

            token_list_append_list(&r, &r3);
            token_list_destroy(&copy);
            token_list_destroy(&r3);
        }
    }
    catch
    {
    }

    //printf("result=");
    //print_list(&r);
    return r;
}
void print_token(const struct token* p_token);

static struct token_list text_line(struct preprocessor_ctx* ctx, struct token_list* input_list, bool is_active, int level)
{
    /*
          text-line:
          pp-tokens_opt new-line
    */
    struct token_list r = { 0 };

    try
    {
        while (input_list->head &&
            input_list->head->type != TK_PREPROCESSOR_LINE)
        {
            struct macro* _Opt macro = NULL;
            struct token* _Opt start_token = input_list->head;
            const struct token* _Opt origin = NULL;

            if (is_active && input_list->head->type == TK_IDENTIFIER)
            {
                origin = input_list->head;
                macro = find_macro(ctx, input_list->head->lexeme);
                if (macro &&
                    macro->is_function &&
                    !preprocessor_token_ahead_is(input_list->head, '('))
                {
                    macro = NULL;
                }

                if (ctx->conditional_inclusion)
                {
                    /*
                     Quando estamos expandindo em condinonal inclusion o defined macro ou defined (macro)
                     não é expandido e é considerado depois
                    */

                    if (r.tail &&
                        r.tail->type == TK_IDENTIFIER &&
                        strcmp(r.tail->lexeme, "defined") == 0)
                    {
                        macro = NULL;
                    }
                    else if (r.tail &&
                        r.tail->type == '(')
                    {
                        struct token* previous = r.tail->prev;
                        if (previous != NULL &&
                            previous->type == TK_IDENTIFIER &&
                            strcmp(previous->lexeme, "defined") == 0)
                        {
                            macro = NULL;
                        }
                    }
                }
            }
            if (macro)
            {
#ifdef _WIN32
                if (input_list->head->token_origin)
                {
                    //char line[1000] = { 0 };
                    //snprintf(line, sizeof line, "%s(%d,%d):\n", input_list->head->token_origin->lexeme, input_list->head->line, input_list->head->col);
                    //OutputDebugStringA(line);
                }
#endif

                //efeito tetris
                //#define f(a) a
                //#define F g
                //F(1)
                //quero deixar F(g) na saida.
                //e toda parte de dentro escondida no caso  1
                //F(1)`a` acho que vou imprimir desta forma ou so fundo diferente
                //
                enum token_flags flags = input_list->head->flags;
                struct macro_argument_list arguments = collect_macro_arguments(ctx, macro, input_list, level);
                if (ctx->n_errors > 0)
                {
                    macro_argument_list_destroy(&arguments);
                    throw;
                }


                struct token_list start_macro = expand_macro(ctx, NULL, macro, &arguments, level, origin);
                if (start_macro.head)
                {
                    start_macro.head->flags |= flags;
                }

                if (macro->expand)
                {
                    //Esconde a macro e os argumentos
                    for (struct token* _Opt current = arguments.tokens.head;
                        current != arguments.tokens.tail->next;
                        current = current->next)
                    {
                        current->flags |= TK_C_BACKEND_FLAG_HIDE;
                    }

                    //mostra a expansao da macro
                    /*teste de expandir so algumas macros*/
                    for (struct token* _Opt current = start_macro.head;
                        current != start_macro.tail->next;
                        current = current->next)
                    {
                        current->flags &= ~(TK_FLAG_MACRO_EXPANDED | TK_FLAG_SLICED | TK_FLAG_LINE_CONTINUATION);
                    }
                }

                //seta nos tokens expandidos da onde eles vieram
                token_list_set_file(&start_macro, start_token->token_origin, start_token->line, start_token->col);

                token_list_append_list_at_beginning(input_list, &start_macro);

                if (ctx->flags & PREPROCESSOR_CTX_FLAGS_ONLY_FINAL)
                {
                }
                else
                {
                    if (level == 0 || INCLUDE_ALL)
                        token_list_append_list(&r, &arguments.tokens);
                }

                //print_tokens(r.head);
                while (macro)
                {
                    macro = NULL;
                    if (input_list->head && input_list->head->type == TK_IDENTIFIER)
                    {
                        macro = find_macro(ctx, input_list->head->lexeme);
                        if (macro && macro->is_function &&
                            !preprocessor_token_ahead_is(input_list->head, '('))
                        {
                            macro = NULL;
                        }
                        if (macro)
                        {
                            // printf("tetris\n");
                            int flags2 = input_list->head->flags;
                            struct macro_argument_list arguments2 = collect_macro_arguments(ctx, macro, input_list, level);
                            if (ctx->n_errors > 0)
                            {
                                macro_argument_list_destroy(&arguments2);
                                macro_argument_list_destroy(&arguments);
                                token_list_destroy(&start_macro);
                                throw;
                            }

                            if (ctx->flags & PREPROCESSOR_CTX_FLAGS_ONLY_FINAL)
                            {
                            }
                            else
                            {
                                if (level == 0 || INCLUDE_ALL)
                                {
                                    token_list_append_list(&r, &arguments2.tokens);
                                }
                            }


                            struct token_list r3 = expand_macro(ctx, NULL, macro, &arguments2, level, origin);
                            if (ctx->n_errors > 0)
                            {
                                macro_argument_list_destroy(&arguments2);
                                token_list_destroy(&r3);
                                macro_argument_list_destroy(&arguments);
                                token_list_destroy(&start_macro);
                                throw;
                            }

                            //seta nos tokens expandidos da onde eles vieram
                            token_list_set_file(&r3, start_token->token_origin, start_token->line, start_token->col);

                            if (r3.head)
                            {
                                r3.head->flags = flags2;
                            }
                            token_list_append_list_at_beginning(input_list, &r3);
                            macro_argument_list_destroy(&arguments2);
                            token_list_destroy(&r3);
                        }
                    }
                }

                macro_argument_list_destroy(&arguments);
                token_list_destroy(&start_macro);

                continue;
                //exit tetris...
                //entao tudo foi expandido desde a primeiroa
            }
            else
            {
                if (input_list->head->flags & TK_FLAG_LINE_CONTINUATION &&
                    !(input_list->head->flags & TK_FLAG_MACRO_EXPANDED)
                    )
                {
                    /*
                       The only place were line-continuation are really necessary is
                       inside preprocessor directives.
                       Here we are inside text-line so we can send a info that
                       here is optional.
                    */
                    if (input_list->head->type == TK_STRING_LITERAL)
                    {
                        preprocessor_diagnostic_message(W_NOTE, ctx, input_list->head, "you can use \"adjacent\" \"strings\"");
                    }
                    else if (input_list->head->type == TK_LINE_COMMENT)
                        preprocessor_diagnostic_message(W_COMMENT, ctx, input_list->head, "multi-line //comment");
                    else
                        preprocessor_diagnostic_message(W_LINE_SLICING, ctx, input_list->head, "unnecessary line-slicing");
                }

                bool blanks = token_is_blank(input_list->head) || input_list->head->type == TK_NEWLINE;
                bool is_final = is_active && !is_never_final(input_list->head->type);

                if (ctx->flags & PREPROCESSOR_CTX_FLAGS_ONLY_FINAL)
                {
                    if (is_final)
                    {
                        prematch(&r, input_list);
                        r.tail->flags |= TK_FLAG_FINAL;
                    }
                    else
                    {
                        token_list_pop_front(input_list);//todo deletar
                    }
                }
                else
                {
                    if (blanks)
                    {
                        if (level == 0 || INCLUDE_ALL)
                        {
                            prematch(&r, input_list);
                        }
                        else
                            token_list_pop_front(input_list);//todo deletar
                    }
                    else
                    {
                        if (level == 0 || INCLUDE_ALL)
                        {
                            prematch(&r, input_list);
                            if (is_final)
                            {
                                r.tail->flags |= TK_FLAG_FINAL;
                            }
                        }
                        else
                        {
                            if (is_final)
                            {
                                prematch(&r, input_list);
                                r.tail->flags |= TK_FLAG_FINAL;
                            }
                            else
                            {
                                token_list_pop_front(input_list);//todo deletar
                            }
                        }
                    }
                }


            }
        }
    }
    catch
    {
    }

    return r;
}

struct token_list group_part(struct preprocessor_ctx* ctx, struct token_list* input_list, bool is_active, int level)
{
    /*
    group-part:
     if-section
     control-line
     text-line
     # non-directive
    */

    assert(input_list->head != NULL);

    if (input_list->head->type == TK_PREPROCESSOR_LINE)
    {
        if (preprocessor_token_ahead_is_identifier(input_list->head, "if") ||
            preprocessor_token_ahead_is_identifier(input_list->head, "ifdef") ||
            preprocessor_token_ahead_is_identifier(input_list->head, "ifndef"))
        {
            return if_section(ctx, input_list, is_active, level);
        }
        else if (preprocessor_token_ahead_is_identifier(input_list->head, "include") ||
            preprocessor_token_ahead_is_identifier(input_list->head, "embed") ||
            preprocessor_token_ahead_is_identifier(input_list->head, "define") ||
            preprocessor_token_ahead_is_identifier(input_list->head, "undef") ||
            preprocessor_token_ahead_is_identifier(input_list->head, "warning") ||
            preprocessor_token_ahead_is_identifier(input_list->head, "line") ||
            preprocessor_token_ahead_is_identifier(input_list->head, "error") ||
            preprocessor_token_ahead_is_identifier(input_list->head, "pragma"))
        {
            return control_line(ctx, input_list, is_active, level);
        }
        else
        {
            //here I will consume the # inside to make it symmetrical
            return non_directive(ctx, input_list, level);
        }
    }
    return text_line(ctx, input_list, is_active, level);
}


struct token_list preprocessor(struct preprocessor_ctx* ctx, struct token_list* input_list, int level)
{
    struct token_list r = { 0 };
    if (input_list->head == NULL)
    {
        return r;
    }

    if (input_list->head->type == TK_BEGIN_OF_FILE)
    {
        prematch_level(&r, input_list, 1); //sempre coloca
    }

    struct token_list g = group_opt(ctx, input_list, true /*active*/, level);
    token_list_append_list(&r, &g);
    token_list_destroy(&g);
    return r;
}


static void mark_macros_as_used(struct owner_hash_map* map)
{
    /*
     *  Objetivo era alertar macros nao usadas...
     */

    if (map->table != NULL)
    {
        for (int i = 0; i < map->capacity; i++)
        {
            struct owner_map_entry* _Opt pentry = map->table[i];

            while (pentry != NULL)
            {
                struct macro* macro = pentry->p;
                macro->usage = 1;
                pentry = pentry->next;
            }
        }
    }
}

void check_unused_macros(const struct owner_hash_map* map)
{
    /*
     *  Objetivo era alertar macros nao usadas...
     */

    if (map->table != NULL)
    {
        for (int i = 0; i < map->capacity; i++)
        {
            struct owner_map_entry* _Opt pentry = map->table[i];

            while (pentry != NULL)
            {
                struct macro* macro = pentry->p;
                if (macro->usage == 0)
                {
                    //TODO adicionar conceito meu codigo , codigo de outros nao vou colocar erro
                    printf("%s not used\n", macro->name);
                }
                pentry = pentry->next;
            }
        }
    }
}

int include_config_header(struct preprocessor_ctx* ctx, const char* file_name)
{
    char local_cakeconfig_path[MAX_PATH] = { 0 };
    snprintf(local_cakeconfig_path, sizeof local_cakeconfig_path, "%s", file_name);
    dirname(local_cakeconfig_path);

    snprintf(local_cakeconfig_path, sizeof local_cakeconfig_path, "%s" CAKE_CFG_FNAME, local_cakeconfig_path);

    char* _Owner _Opt str = read_file(local_cakeconfig_path);
    while (str == NULL)
    {
        dirname(local_cakeconfig_path);
        dirname(local_cakeconfig_path);
        if (local_cakeconfig_path[0] == '\0')
            break;
        str = read_file(local_cakeconfig_path);
    }


    if (str == NULL)
    {
        //Search cakeconfig at cake executable dir

        char executable_path[MAX_PATH - sizeof(CAKE_CFG_FNAME)] = { 0 };
        get_self_path(executable_path, sizeof(executable_path));
        dirname(executable_path);
        char root_cakeconfig_path[MAX_PATH] = { 0 };
        snprintf(root_cakeconfig_path, sizeof root_cakeconfig_path, "%s" CAKE_CFG_FNAME, executable_path);
        str = read_file(root_cakeconfig_path);
    }

    if (str == NULL)
    {
        //"No such file or directory";
        return  ENOENT;
    }
    const enum diagnostic_id w =
        ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings;

    struct tokenizer_ctx tctx = { 0 };
    struct token_list l = tokenizer(&tctx, str, "standard macros inclusion", 0, TK_FLAG_NONE);
    struct token_list l10 = preprocessor(ctx, &l, 0);
    mark_macros_as_used(&ctx->macros);
    token_list_destroy(&l);
    free(str);
    token_list_destroy(&l10);

    /*restore*/
    ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings = w;

    return  0;
}

void add_standard_macros(struct preprocessor_ctx* ctx)
{
    /*
      This command prints all macros used by gcc
      echo | gcc -dM -E -
    */
    const struct diagnostic w =
        ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index];

    /*we dont want warnings here*/
    ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index] =
        (struct diagnostic){ 0 };

    static char mon[][4] = {
        "Jan", "Feb", "Mar", "Apr", "May", "Jun",
        "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
    };

    time_t now = time(NULL);
    struct tm* tm = localtime(&now);

    struct tokenizer_ctx tctx = { 0 };


    char datastr[100] = { 0 };
    snprintf(datastr, sizeof datastr, "#define __DATE__ \"%s %2d %d\"\n", mon[tm->tm_mon], tm->tm_mday, tm->tm_year + 1900);
    struct token_list l1 = tokenizer(&tctx, datastr, "__DATE__ macro inclusion", 0, TK_FLAG_NONE);
    struct token_list tl1 = preprocessor(ctx, &l1, 0);

    token_list_destroy(&tl1);
    token_list_destroy(&l1);

    char timestr[100] = { 0 };
    snprintf(timestr, sizeof timestr, "#define __TIME__ \"%02d:%02d:%02d\"\n", tm->tm_hour, tm->tm_min, tm->tm_sec);
    struct token_list l2 = tokenizer(&tctx, timestr, "__TIME__ macro inclusion", 0, TK_FLAG_NONE);
    struct token_list tl2 = preprocessor(ctx, &l2, 0);

    token_list_destroy(&tl2);
    token_list_destroy(&l2);


    /*
      Some macros are dynamic like __LINE__ they are replaced  at
      macro_copy_replacement_list but they need to be registered here.
    */

    const char* pre_defined_macros_text =
        "#define __CAKE__ 202311L\n"
        "#define __STDC_VERSION__ 202311L\n"
        "#define __FILE__ \"__FILE__\"\n"
        "#define __LINE__ 0\n"
        "#define __COUNTER__ 0\n"
        "#define _CONSOLE\n"
        "#define __STDC_OWNERSHIP__ 1\n"
        "#define _W_DIVIZION_BY_ZERO_ 29\n"



#ifdef _WIN32

        //see
        //https://learn.microsoft.com/en-us/cpp/preprocessor/predefined-macros?_View=msvc-170
        "#define _WIN32 " TOSTRING(_WIN32) "\n"


#ifdef _WIN64
        "#define _WIN64 " TOSTRING(_WIN64) "\n"
#endif

        "#define _INTEGRAL_MAX_BITS " TOSTRING(_INTEGRAL_MAX_BITS) "\n" /*Use of __int64 should be conditional on the predefined macro _INTEGRAL_MAX_BITS*/

        "#define _MSC_VER " TOSTRING(_MSC_VER) "\n"
        "#define _M_IX86 "  TOSTRING(_M_IX86) "\n"
        "#define __fastcall\n"
        "#define __stdcall\n"
        "#define __cdecl\n"
        "#define __pragma(a)\n"
        "#define __declspec(a)\n"
        "#define __builtin_offsetof(type, member) 0\n"
        "#define __ptr64\n"
        "#define __ptr32\n";

#endif

#ifdef __linux__

    //https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html
        /*some gcc stuff need to parse linux headers*/
    "#define __linux__\n"
        "#define __builtin_va_list\n"
        "#define __builtin_va_start(a, b)\n"
        "#define __builtin_va_end(a)\n"
        "#define __builtin_va_arg(a, b) ((b)a)\n"
        "#define __builtin_va_copy(a, b)\n"
        "#define __builtin_offsetof(type, member) 0\n"
        //see
        //https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html
        //We parse and ignore GCC __attribute__
        "#define __attribute__(x)\n"

        "#define __CHAR_BIT__ " TOSTRING(__CHAR_BIT__) "\n"
        "#define __SIZE_TYPE__ " TOSTRING(__SIZE_TYPE__) "\n"
        "#define __PTRDIFF_TYPE__ " TOSTRING(__PTRDIFF_TYPE__) "\n"
        "#define __WCHAR_TYPE__ " TOSTRING(__WCHAR_TYPE__) "\n"
        "#define __WINT_TYPE__ " TOSTRING(__WINT_TYPE__) "\n"
        "#define __INTMAX_TYPE__ " TOSTRING(__INTMAX_TYPE__) "\n"
        "#define __UINTMAX_TYPE__ " TOSTRING(__UINTMAX_TYPE__) "\n"
        "#define __SIG_ATOMIC_TYPE__ " TOSTRING(__SIG_ATOMIC_TYPE__) "\n"
        "#define __INT8_TYPE__ " TOSTRING(__INT8_TYPE__) "\n"
        "#define __INT16_TYPE__ " TOSTRING(__INT16_TYPE__) "\n"
        "#define __INT32_TYPE__ " TOSTRING(__INT32_TYPE__) "\n"
        "#define __INT64_TYPE__ " TOSTRING(__INT64_TYPE__) "\n"
        "#define __UINT8_TYPE__ " TOSTRING(__UINT8_TYPE__) "\n"
        "#define __UINT16_TYPE__ " TOSTRING(__UINT16_TYPE__) "\n"
        "#define __UINT32_TYPE__ " TOSTRING(__UINT32_TYPE__) "\n"
        "#define __UINT64_TYPE__ " TOSTRING(__UINT64_TYPE__) "\n"
        "#define __INT_LEAST8_TYPE__ " TOSTRING(__INT_LEAST8_TYPE__) "\n"
        "#define __INT_LEAST16_TYPE__ " TOSTRING(__INT_LEAST16_TYPE__) "\n"
        "#define __INT_LEAST32_TYPE__ " TOSTRING(__INT_LEAST32_TYPE__) "\n"
        "#define __INT_LEAST64_TYPE__ " TOSTRING(__INT_LEAST64_TYPE__) "\n"
        "#define __UINT_LEAST8_TYPE__ " TOSTRING(__UINT_LEAST8_TYPE__) "\n"
        "#define __UINT_LEAST16_TYPE__ " TOSTRING(__UINT_LEAST16_TYPE__) "\n"
        "#define __UINT_LEAST32_TYPE__ " TOSTRING(__UINT_LEAST32_TYPE__) "\n"
        "#define __UINT_LEAST64_TYPE__ " TOSTRING(__UINT_LEAST64_TYPE__) "\n"
        "#define __INT_FAST8_TYPE__ " TOSTRING(__INT_FAST8_TYPE__) "\n"
        "#define __INT_FAST16_TYPE__ " TOSTRING(__INT_FAST16_TYPE__) "\n"
        "#define __INT_FAST32_TYPE__ " TOSTRING(__INT_FAST32_TYPE__) "\n"
        "#define __INT_FAST64_TYPE__ " TOSTRING(__INT_FAST64_TYPE__) "\n"
        "#define __UINT_FAST8_TYPE__ " TOSTRING(__UINT_FAST8_TYPE__) "\n"
        "#define __UINT_FAST16_TYPE__ " TOSTRING(__UINT_FAST16_TYPE__) "\n"
        "#define __UINT_FAST32_TYPE__ " TOSTRING(__UINT_FAST32_TYPE__) "\n"
        "#define __UINT_FAST64_TYPE__ " TOSTRING(__UINT_FAST64_TYPE__) "\n"
        "#define __INTPTR_TYPE__ " TOSTRING(__INTPTR_TYPE__) "\n"
        "#define __UINTPTR_TYPE__ " TOSTRING(__UINTPTR_TYPE__) "\n"

        "#define __DBL_MAX__ " TOSTRING(__DBL_MAX__) "\n"
        "#define __DBL_MIN__ " TOSTRING(__DBL_MIN__) "\n"
        "#define __FLT_RADIX__ " TOSTRING(__FLT_RADIX__) "\n"
        "#define __FLT_EPSILON__ " TOSTRING(__FLT_EPSILON__) "\n"
        "#define __DBL_EPSILON__ " TOSTRING(__DBL_EPSILON__) "\n"
        "#define __LDBL_EPSILON__ " TOSTRING(__LDBL_EPSILON__) "\n"
        "#define __DBL_DECIMAL_DIG__ " TOSTRING(__DBL_DECIMAL_DIG__) "\n"
        "#define __FLT_EVAL_METHOD__ " TOSTRING(__FLT_EVAL_METHOD__) "\n"
        "#define __FLT_RADIX__ " TOSTRING(__FLT_RADIX__) "\n"

        // gcc -dM -E

        "#define __DBL_MAX_EXP__ " TOSTRING(__DBL_MAX_EXP__) "\n"
        "#define __DECIMAL_DIG__ " TOSTRING(__DECIMAL_DIG__) "\n"
        "#define __FLT_DECIMAL_DIG__ " TOSTRING(__FLT_DECIMAL_DIG__) "\n"


        "#define __FLT_MIN_10_EXP__ " TOSTRING(__FLT_MIN_10_EXP__) "\n"
        "#define __FLT_MIN__ " TOSTRING(__FLT_MIN__) "\n"
        "#define __FLT_MAX__ " TOSTRING(__FLT_MAX__) "\n"
        "#define __FLT_EPSILON__ " TOSTRING(__FLT_EPSILON__) "\n"
        "#define __FLT_DIG__ " TOSTRING(__FLT_DIG__) "\n"
        "#define __FLT_MANT_DIG__ " TOSTRING(__FLT_MANT_DIG__) "\n"
        "#define __FLT_MIN_EXP__ " TOSTRING(__FLT_MIN_EXP__) "\n"
        "#define __FLT_MAX_10_EXP__ " TOSTRING(__FLT_MAX_10_EXP__) "\n"
        "#define __FLT_ROUNDS__ " TOSTRING(__FLT_ROUNDS__) "\n"
        "#define __FLT_EVAL_METHOD__ " TOSTRING(__FLT_EVAL_METHOD__) "\n"
        "#define __FLT_HAS_SUBNORM__ " TOSTRING(__FLT_HAS_SUBNORM__) "\n"

        "#define __FLT_MAX_EXP__ " TOSTRING(__FLT_MAX_EXP__) "\n"
        "#define __FLT_HAS_DENORM__ " TOSTRING(__FLT_HAS_DENORM__) "\n"


        "#define __SCHAR_MAX__ " TOSTRING(__SCHAR_MAX__) "\n"
        "#define __WCHAR_MAX__ " TOSTRING(__WCHAR_MAX__) "\n"
        "#define __SHRT_MAX__ " TOSTRING(__SHRT_MAX__) "\n"
        "#define __INT_MAX__ " TOSTRING(__INT_MAX__) "\n"
        "#define __LONG_MAX__ " TOSTRING(__LONG_MAX__) "\n"
        "#define __LONG_LONG_MAX__ " TOSTRING(__LONG_LONG_MAX__) "\n"
        "#define __WINT_MAX__ " TOSTRING(__WINT_MAX__) "\n"
        "#define __SIZE_MAX__ " TOSTRING(__SIZE_MAX__) "\n"
        "#define __PTRDIFF_MAX__ " TOSTRING(__PTRDIFF_MAX__) "\n"
        "#define __INTMAX_MAX__ " TOSTRING(__INTMAX_MAX__) "\n"
        "#define __UINTMAX_MAX__ " TOSTRING(__UINTMAX_MAX__) "\n"
        "#define __SIG_ATOMIC_MAX__ " TOSTRING(__SIG_ATOMIC_MAX__) "\n"
        "#define __INT8_MAX__ " TOSTRING(__INT8_MAX__) "\n"
        "#define __INT16_MAX__ " TOSTRING(__INT16_MAX__) "\n"
        "#define __INT32_MAX__ " TOSTRING(__INT32_MAX__) "\n"
        "#define __INT64_MAX__ " TOSTRING(__INT64_MAX__) "\n"
        "#define __UINT8_MAX__ " TOSTRING(__UINT8_MAX__) "\n"
        "#define __UINT16_MAX__ " TOSTRING(__UINT16_MAX__) "\n"
        "#define __UINT32_MAX__ " TOSTRING(__UINT32_MAX__) "\n"
        "#define __UINT64_MAX__ " TOSTRING(__UINT64_MAX__) "\n"
        "#define __INT_LEAST8_MAX__ " TOSTRING(__INT_LEAST8_MAX__) "\n"
        "#define __INT_LEAST16_MAX__ " TOSTRING(__INT_LEAST16_MAX__) "\n"
        "#define __INT_LEAST32_MAX__ " TOSTRING(__INT_LEAST32_MAX__) "\n"
        "#define __INT_LEAST64_MAX__ " TOSTRING(__INT_LEAST64_MAX__) "\n"
        "#define __UINT_LEAST8_MAX__ " TOSTRING(__UINT_LEAST8_MAX__) "\n"
        "#define __UINT_LEAST16_MAX__ " TOSTRING(__UINT_LEAST16_MAX__) "\n"
        "#define __UINT_LEAST32_MAX__ " TOSTRING(__UINT_LEAST32_MAX__) "\n"
        "#define __UINT_LEAST64_MAX__ " TOSTRING(__UINT_LEAST64_MAX__) "\n"
        "#define __INT_FAST8_MAX__ " TOSTRING(__INT_FAST8_MAX__) "\n"
        "#define __INT_FAST16_MAX__ " TOSTRING(__INT_FAST16_MAX__) "\n"
        "#define __INT_FAST32_MAX__ " TOSTRING(__INT_FAST32_MAX__) "\n"
        "#define __INT_FAST64_MAX__ " TOSTRING(__INT_FAST64_MAX__) "\n"
        "#define __UINT_FAST8_MAX__ " TOSTRING(__UINT_FAST8_MAX__) "\n"
        "#define __UINT_FAST16_MAX__ " TOSTRING(__UINT_FAST16_MAX__) "\n"
        "#define __UINT_FAST32_MAX__ " TOSTRING(__UINT_FAST32_MAX__) "\n"
        "#define __UINT_FAST64_MAX__ " TOSTRING(__UINT_FAST64_MAX__) "\n"
        "#define __INTPTR_MAX__ " TOSTRING(__INTPTR_MAX__) "\n"
        "#define __UINTPTR_MAX__ " TOSTRING(__UINTPTR_MAX__) "\n"
        "#define __WCHAR_MIN__ " TOSTRING(__WCHAR_MIN__) "\n"
        "#define __WINT_MIN__ " TOSTRING(__WINT_MIN__) "\n"
        "#define __SIG_ATOMIC_MIN__ " TOSTRING(__SIG_ATOMIC_MIN__) "\n"

        "#define __INT8_C " TOSTRING(__SIG_ATOMIC_MIN__) "\n"
        "#define __INT16_C " TOSTRING(__INT16_C) "\n"
        "#define __INT32_C " TOSTRING(__INT32_C) "\n"
        "#define __INT64_C " TOSTRING(__INT64_C) "\n"
        "#define __UINT8_C " TOSTRING(__UINT8_C) "\n"
        "#define __UINT16_C " TOSTRING(__UINT16_C) "\n"
        "#define __UINT32_C " TOSTRING(__UINT32_C) "\n"
        "#define __UINT64_C " TOSTRING(__UINT64_C) "\n"
        "#define __INTMAX_C " TOSTRING(__INTMAX_C) "\n"
        "#define __UINTMAX_C " TOSTRING(__UINTMAX_C) "\n"

        "#define __SCHAR_WIDTH__ " TOSTRING(__SCHAR_WIDTH__) "\n"
        "#define __SHRT_WIDTH__ " TOSTRING(__SHRT_WIDTH__) "\n"
        "#define __INT_WIDTH__ " TOSTRING(__INT_WIDTH__) "\n"
        "#define __LONG_WIDTH__ " TOSTRING(__LONG_WIDTH__) "\n"
        "#define __LONG_LONG_WIDTH__ " TOSTRING(__LONG_LONG_WIDTH__) "\n"
        "#define __PTRDIFF_WIDTH__ " TOSTRING(__PTRDIFF_WIDTH__) "\n"
        "#define __SIG_ATOMIC_WIDTH__ " TOSTRING(__SIG_ATOMIC_WIDTH__) "\n"
        "#define __SIZE_WIDTH__ " TOSTRING(__SIZE_WIDTH__) "\n"
        "#define __WCHAR_WIDTH__ " TOSTRING(__WCHAR_WIDTH__) "\n"
        "#define __WINT_WIDTH__ " TOSTRING(__WINT_WIDTH__) "\n"
        "#define __INT_LEAST8_WIDTH__ " TOSTRING(__INT_LEAST8_WIDTH__) "\n"
        "#define __INT_LEAST16_WIDTH__ " TOSTRING(__INT_LEAST16_WIDTH__) "\n"
        "#define __INT_LEAST32_WIDTH__ " TOSTRING(__INT_LEAST32_WIDTH__) "\n"
        "#define __INT_LEAST64_WIDTH__ " TOSTRING(__INT_LEAST64_WIDTH__) "\n"
        "#define __INT_FAST8_WIDTH__ " TOSTRING(__INT_FAST8_WIDTH__) "\n"
        "#define __INT_FAST16_WIDTH__ " TOSTRING(__INT_FAST16_WIDTH__) "\n"
        "#define __INT_FAST32_WIDTH__ " TOSTRING(__INT_FAST32_WIDTH__) "\n"
        "#define __INT_FAST64_WIDTH__ " TOSTRING(__INT_FAST64_WIDTH__) "\n"
        "#define __INTPTR_WIDTH__ " TOSTRING(__INTPTR_WIDTH__) "\n"
        "#define __INTMAX_WIDTH__ " TOSTRING(__INTMAX_WIDTH__) "\n"


        "#define __SIZEOF_INT__ " TOSTRING(__SIZEOF_INT__) "\n"
        "#define __SIZEOF_LONG__ " TOSTRING(__SIZEOF_LONG__) "\n"
        "#define __SIZEOF_LONG_LONG__ " TOSTRING(__SIZEOF_LONG_LONG__) "\n"
        "#define __SIZEOF_SHORT__ " TOSTRING(__SIZEOF_SHORT__) "\n"
        "#define __SIZEOF_POINTER__ " TOSTRING(__SIZEOF_POINTER__) "\n"
        "#define __SIZEOF_FLOAT__ " TOSTRING(__SIZEOF_FLOAT__) "\n"
        "#define __SIZEOF_DOUBLE__ " TOSTRING(__SIZEOF_DOUBLE__) "\n"
        "#define __SIZEOF_LONG_DOUBLE__ " TOSTRING(__SIZEOF_LONG_DOUBLE__) "\n"
        "#define __SIZEOF_SIZE_T__ " TOSTRING(__SIZEOF_SIZE_T__) "\n"
        "#define __SIZEOF_WCHAR_T__ " TOSTRING(__SIZEOF_WCHAR_T__) "\n"
        "#define __SIZEOF_WINT_T__ " TOSTRING(__SIZEOF_WINT_T__) "\n"
        "#define __SIZEOF_PTRDIFF_T__ " TOSTRING(__SIZEOF_PTRDIFF_T__) "\n"
#endif
        "\n";

    struct token_list l = tokenizer(&tctx, pre_defined_macros_text, "standard macros inclusion", 0, TK_FLAG_NONE);
    struct token_list l10 = preprocessor(ctx, &l, 0);

    //nao quer ver warning de nao usado nestas macros padrao
    mark_macros_as_used(&ctx->macros);
    token_list_destroy(&l);
    token_list_destroy(&l10);

    /*restore*/
    ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index] = w;
}




const char* get_token_name(enum token_type tk)
{
    switch (tk)
    {
    case TK_NONE: return "TK_NONE";
    case TK_NEWLINE: return "TK_NEWLINE";
    case TK_WHITE_SPACE: return "TK_WHITE_SPACE";
    case TK_EXCLAMATION_MARK: return "TK_EXCLAMATION_MARK";
    case TK_QUOTATION_MARK: return "TK_QUOTATION_MARK";
    case TK_NUMBER_SIGN: return "TK_NUMBER_SIGN";
    case TK_DOLLAR_SIGN: return "TK_DOLLAR_SIGN";
    case TK_PERCENT_SIGN: return "TK_PERCENT_SIGN";
    case TK_AMPERSAND: return "TK_AMPERSAND";
    case TK_APOSTROPHE: return "TK_APOSTROPHE";
    case TK_LEFT_PARENTHESIS: return "TK_LEFT_PARENTHESIS";
    case TK_RIGHT_PARENTHESIS: return "TK_RIGHT_PARENTHESIS";
    case TK_ASTERISK: return "TK_ASTERISK";
    case TK_PLUS_SIGN: return "TK_PLUS_SIGN";
    case TK_COMMA: return "TK_COMMA";
    case TK_HYPHEN_MINUS: return "TK_HYPHEN_MINUS";
    case TK_FULL_STOP: return "TK_FULL_STOP";
    case TK_SOLIDUS: return "TK_SOLIDUS";
    case TK_COLON: return "TK_COLON";
    case TK_SEMICOLON: return "TK_SEMICOLON";
    case TK_LESS_THAN_SIGN: return "TK_LESS_THAN_SIGN";
    case TK_EQUALS_SIGN: return "TK_EQUALS_SIGN";
    case TK_GREATER_THAN_SIGN: return "TK_GREATER_THAN_SIGN";
    case TK_QUESTION_MARK: return "TK_QUESTION_MARK";
    case TK_COMMERCIAL_AT: return "TK_COMMERCIAL_AT";
    case TK_LEFT_SQUARE_BRACKET: return "TK_LEFT_SQUARE_BRACKET";
    case TK_REVERSE_SOLIDUS: return "TK_REVERSE_SOLIDUS";
    case TK_RIGHT_SQUARE_BRACKET: return "TK_RIGHT_SQUARE_BRACKET";
    case TK_CIRCUMFLEX_ACCENT: return "TK_CIRCUMFLEX_ACCENT";
    case TK_FLOW_LINE: return "TK_FLOW_LINE";
    case TK_GRAVE_ACCENT: return "TK_GRAVE_ACCENT";
    case TK_LEFT_CURLY_BRACKET: return "TK_LEFT_CURLY_BRACKET";
    case TK_VERTICAL_LINE: return "TK_VERTICAL_LINE";
    case TK_RIGHT_CURLY_BRACKET: return "TK_RIGHT_CURLY_BRACKET";
    case TK_TILDE: return "TK_TILDE";
    case TK_PREPROCESSOR_LINE: return "TK_PREPROCESSOR_LINE";
    case TK_PRAGMA: return "TK_PRAGMA";
    case TK_STRING_LITERAL: return "TK_STRING_LITERAL";
    case TK_CHAR_CONSTANT: return "TK_CHAR_CONSTANT";
    case TK_LINE_COMMENT: return "TK_LINE_COMMENT";
    case TK_COMMENT: return "TK_COMMENT";
    case TK_PPNUMBER: return "TK_PPNUMBER";

    case ANY_OTHER_PP_TOKEN: return "ANY_OTHER_PP_TOKEN"; //@ por ex

        /*PPNUMBER sao convertidos para constantes antes do parse*/
    case TK_COMPILER_DECIMAL_CONSTANT: return "TK_COMPILER_DECIMAL_CONSTANT";
    case TK_COMPILER_OCTAL_CONSTANT: return "TK_COMPILER_OCTAL_CONSTANT";
    case TK_COMPILER_HEXADECIMAL_CONSTANT: return "TK_COMPILER_HEXADECIMAL_CONSTANT";
    case TK_COMPILER_BINARY_CONSTANT: return "TK_COMPILER_BINARY_CONSTANT";
    case TK_COMPILER_DECIMAL_FLOATING_CONSTANT: return "TK_COMPILER_DECIMAL_FLOATING_CONSTANT";
    case TK_COMPILER_HEXADECIMAL_FLOATING_CONSTANT: return "TK_COMPILER_HEXADECIMAL_FLOATING_CONSTANT";


    case TK_PLACEMARKER: return "TK_PLACEMARKER";

    case TK_BLANKS: return "TK_BLANKS";
    case TK_PLUSPLUS: return "TK_PLUSPLUS";
    case TK_MINUSMINUS: return "TK_MINUSMINUS";
    case TK_ARROW: return "TK_ARROW";
    case TK_SHIFTLEFT: return "TK_SHIFTLEFT";
    case TK_SHIFTRIGHT: return "TK_SHIFTRIGHT";
    case TK_LOGICAL_OPERATOR_OR: return "TK_LOGICAL_OPERATOR_OR";
    case TK_LOGICAL_OPERATOR_AND: return "TK_LOGICAL_OPERATOR_AND";

    case TK_MACRO_CONCATENATE_OPERATOR: return "TK_MACRO_CONCATENATE_OPERATOR";

    case TK_IDENTIFIER: return "TK_IDENTIFIER";
    case TK_IDENTIFIER_RECURSIVE_MACRO: return "TK_IDENTIFIER_RECURSIVE_MACRO"; /*usado para evitar recursao expansao macro*/

    case TK_BEGIN_OF_FILE: return "TK_BEGIN_OF_FILE";

        //C23 keywords
    case TK_KEYWORD_AUTO: return "TK_KEYWORD_AUTO";
    case TK_KEYWORD_BREAK: return "TK_KEYWORD_BREAK";
    case TK_KEYWORD_CASE: return "TK_KEYWORD_CASE";
    case TK_KEYWORD_CONSTEXPR: return "TK_KEYWORD_CONSTEXPR";
    case TK_KEYWORD_CHAR: return "TK_KEYWORD_CHAR";
    case TK_KEYWORD_CONST: return "TK_KEYWORD_CONST";
    case TK_KEYWORD_CONTINUE: return "TK_KEYWORD_CONTINUE";
    case TK_KEYWORD_CATCH: return "TK_KEYWORD_CATCH"; /*extension*/
    case TK_KEYWORD_DEFAULT: return "TK_KEYWORD_DEFAULT";
    case TK_KEYWORD_DO: return "TK_KEYWORD_DO";
    case TK_KEYWORD_DEFER: return "TK_KEYWORD_DEFER"; /*extension*/
    case TK_KEYWORD_DOUBLE: return "TK_KEYWORD_DOUBLE";
    case TK_KEYWORD_ELSE: return "TK_KEYWORD_ELSE";
    case TK_KEYWORD_ENUM: return "TK_KEYWORD_ENUM";
    case TK_KEYWORD_EXTERN: return "TK_KEYWORD_EXTERN";
    case TK_KEYWORD_FLOAT: return "TK_KEYWORD_FLOAT";
    case TK_KEYWORD_FOR: return "TK_KEYWORD_FOR";
    case TK_KEYWORD_GOTO: return "TK_KEYWORD_GOTO";
    case TK_KEYWORD_IF: return "TK_KEYWORD_IF";
    case TK_KEYWORD_INLINE: return "TK_KEYWORD_INLINE";
    case TK_KEYWORD_INT: return "TK_KEYWORD_INT";
    case TK_KEYWORD_LONG: return "TK_KEYWORD_LONG";
    case TK_KEYWORD__INT8: return "TK_KEYWORD__INT8";
    case TK_KEYWORD__INT16: return "TK_KEYWORD__INT16";
    case TK_KEYWORD__INT32: return "TK_KEYWORD__INT32";
    case TK_KEYWORD__INT64: return "TK_KEYWORD__INT64";


    case TK_KEYWORD_REGISTER: return "TK_KEYWORD_REGISTER";
    case TK_KEYWORD_RESTRICT: return "TK_KEYWORD_RESTRICT";
    case TK_KEYWORD_RETURN: return "TK_KEYWORD_RETURN";
    case TK_KEYWORD_SHORT: return "TK_KEYWORD_SHORT";
    case TK_KEYWORD_SIGNED: return "TK_KEYWORD_SIGNED";
    case TK_KEYWORD_SIZEOF: return "TK_KEYWORD_SIZEOF";

    case TK_KEYWORD_STATIC: return "TK_KEYWORD_STATIC";
    case TK_KEYWORD_STRUCT: return "TK_KEYWORD_STRUCT";
    case TK_KEYWORD_SWITCH: return "TK_KEYWORD_SWITCH";
    case TK_KEYWORD_TYPEDEF: return "TK_KEYWORD_TYPEDEF";
    case TK_KEYWORD_TRY: return "TK_KEYWORD_TRY"; /*extension*/
    case TK_KEYWORD_THROW: return "TK_KEYWORD_THROW"; /*extension*/
    case TK_KEYWORD_UNION: return "TK_KEYWORD_UNION";
    case TK_KEYWORD_UNSIGNED: return "TK_KEYWORD_UNSIGNED";
    case TK_KEYWORD_VOID: return "TK_KEYWORD_VOID";
    case TK_KEYWORD_VOLATILE: return "TK_KEYWORD_VOLATILE";
    case TK_KEYWORD_WHILE: return "TK_KEYWORD_WHILE";

    case TK_KEYWORD__ALIGNAS: return "TK_KEYWORD__ALIGNAS";
    case TK_KEYWORD__ALIGNOF: return "TK_KEYWORD__ALIGNOF";
    case TK_KEYWORD__ATOMIC: return "TK_KEYWORD__ATOMIC";
        //microsoft
        //KEYWORD__FASTCALL,
        //KEYWORD__STDCALL
        //
    case TK_KEYWORD__ASM: return "TK_KEYWORD__ASM";
        //end microsoft
    case TK_KEYWORD__BOOL: return "TK_KEYWORD__BOOL";
    case TK_KEYWORD__COMPLEX: return "TK_KEYWORD__COMPLEX";
    case TK_KEYWORD__DECIMAL128: return "TK_KEYWORD__DECIMAL128";
    case TK_KEYWORD__DECIMAL32: return "TK_KEYWORD__DECIMAL32";
    case TK_KEYWORD__DECIMAL64: return "TK_KEYWORD__DECIMAL64";
    case TK_KEYWORD__GENERIC: return "TK_KEYWORD__GENERIC";
    case TK_KEYWORD__IMAGINARY: return "TK_KEYWORD__IMAGINARY";
    case TK_KEYWORD__NORETURN: return "TK_KEYWORD__NORETURN";
    case TK_KEYWORD__STATIC_ASSERT: return "TK_KEYWORD__STATIC_ASSERT";
    case TK_KEYWORD_ASSERT: return "TK_KEYWORD_ASSERT"; /*extension*/
    case TK_KEYWORD__THREAD_LOCAL: return "TK_KEYWORD__THREAD_LOCAL";

    case TK_KEYWORD_TYPEOF: return "TK_KEYWORD_TYPEOF"; /*C23*/

    case TK_KEYWORD_TRUE: return "TK_KEYWORD_TRUE";  /*C23*/
    case TK_KEYWORD_FALSE: return "TK_KEYWORD_FALSE";  /*C23*/
    case TK_KEYWORD_NULLPTR: return "TK_KEYWORD_NULLPTR";  /*C23*/
    case TK_KEYWORD_TYPEOF_UNQUAL: return "TK_KEYWORD_TYPEOF_UNQUAL"; /*C23*/
    case TK_KEYWORD__BITINT: return "TK_KEYWORD__BITINT";  /*C23*/



        /*cake extension*/
    case TK_KEYWORD__OWNER: return "TK_KEYWORD__OWNER";
    case TK_KEYWORD__OUT: return "TK_KEYWORD__OUT";
    case TK_KEYWORD__OBJ_OWNER: return "TK_KEYWORD__OBJ_OWNER";
    case TK_KEYWORD__VIEW: return "TK_KEYWORD__VIEW";
    case TK_KEYWORD__OPT: return "TK_KEYWORD__OPT";


        /*extension compile time functions*/
    case TK_KEYWORD_STATIC_DEBUG: return "TK_KEYWORD_STATIC_DEBUG"; /*extension*/
    case TK_KEYWORD_STATIC_DEBUG_EX: return "TK_KEYWORD_STATIC_DEBUG_EX"; /*extension*/
    case TK_KEYWORD_STATIC_STATE: return "TK_KEYWORD_STATIC_STATE"; /*extension*/
    case TK_KEYWORD_STATIC_SET: return "TK_KEYWORD_STATIC_SET"; /*extension*/

        /*https://en.cppreference.com/w/cpp/header/type_traits*/

    case TK_KEYWORD_IS_POINTER: return "TK_KEYWORD_IS_POINTER";
    case TK_KEYWORD_IS_LVALUE: return "TK_KEYWORD_IS_LVALUE";
    case TK_KEYWORD_IS_CONST: return "TK_KEYWORD_IS_CONST";
    case TK_KEYWORD_IS_OWNER: return "TK_KEYWORD_IS_OWNER";
    case TK_KEYWORD_IS_ARRAY: return "TK_KEYWORD_IS_ARRAY";
    case TK_KEYWORD_IS_FUNCTION: return "TK_KEYWORD_IS_FUNCTION";
    case TK_KEYWORD_IS_SCALAR: return "TK_KEYWORD_IS_SCALAR";
    case TK_KEYWORD_IS_ARITHMETIC: return "TK_KEYWORD_IS_ARITHMETIC";
    case TK_KEYWORD_IS_FLOATING_POINT: return "TK_KEYWORD_IS_FLOATING_POINT";
    case TK_KEYWORD_IS_INTEGRAL: return "TK_KEYWORD_IS_INTEGRAL";
    case TK_PRAGMA_END: return "TK_PRAGMA_END";
    case TK_KEYWORD_NELEMENTSOF: return "TK_KEYWORD_NELEMENTSOF";

    }
    return "TK_X_MISSING_NAME";
};


int stringify(const char* input, int n, char output[])
{
    int count = 0;
    if (count < n)
        output[count++] = '"';

    const char* p = input;
    while (*p)
    {
        if (*p == '\"' ||
            *p == '\\')
        {
            if (count < n)
                output[count++] = '\\';

            if (count < n)
                output[count++] = *p;
            p++;
        }
        else
        {
            if (count < n)
                output[count++] = *p;
            p++;
        }
    }

    if (count < n)
        output[count++] = '"';
    if (count < n)
        output[count++] = 0;

    if (count >= n)
        return -count;

    return count;
}


void print_literal(const char* _Opt s)
{
    if (s == NULL)
    {
        printf("\"");
        printf("\"");
        return;
    }
    printf("\"");
    while (*s)
    {
        switch (*s)
        {
        case '\n':
            printf("\\n");
            break;
        default:
            printf("%c", *s);
        }
        s++;
    }
    printf("\"");
}





const char* _Owner _Opt get_code_as_we_see_plus_macros(const struct token_list* list)
{
    struct osstream ss = { 0 };
    struct token* _Opt current = list->head;
    while (current)
    {
        if (current->level == 0 &&
            current->type != TK_BEGIN_OF_FILE)
        {
            if (current->flags & TK_FLAG_MACRO_EXPANDED)
                ss_fprintf(&ss, LIGHTCYAN);
            else
                ss_fprintf(&ss, WHITE);
            ss_fprintf(&ss, "%s", current->lexeme);
            ss_fprintf(&ss, RESET);
        }
        current = current->next;
    }

    const char* _Owner _Opt cstr = ss.c_str;
    ss.c_str = NULL; /*MOVED*/

    ss_close(&ss);

    return cstr;
}

/*useful to debug visit.c*/
void print_code_as_we_see(const struct token_list* list, bool remove_comments)
{
    if (list->head == NULL || list->tail == NULL)
    {
        return;
    }

    struct token* _Opt current = list->head;
    while (current && current != list->tail->next)
    {
        if (current->level == 0 &&
            !(current->flags & TK_FLAG_MACRO_EXPANDED) &&
            !(current->flags & TK_C_BACKEND_FLAG_HIDE) &&
            current->type != TK_BEGIN_OF_FILE)
        {
            if ((current->flags & TK_FLAG_HAS_SPACE_BEFORE) &&
                (current->prev != NULL && current->prev->type != TK_BLANKS))
            {
                //if an expanded macro is shown it does not have spaces so we insert
                printf(" ");
            }

            if (remove_comments)
            {
                if (current->type == TK_LINE_COMMENT)
                    printf("\n");
                else if (current->type == TK_COMMENT)
                    printf(" ");
                else
                    printf("%s", current->lexeme);
            }
            else
            {
                printf("%s", current->lexeme);
            }
        }
        current = current->next;
    }
}
const char* _Owner _Opt get_code_as_we_see(const struct token_list* list, bool remove_comments)
{
    if (list->head == NULL || list->tail == NULL)
        return NULL;

    struct osstream ss = { 0 };
    struct token* _Opt current = list->head;
    while (current && current != list->tail->next)
    {
        if (current->level == 0 &&
            !(current->flags & TK_FLAG_MACRO_EXPANDED) &&
            !(current->flags & TK_C_BACKEND_FLAG_HIDE) &&
            current->type != TK_BEGIN_OF_FILE)
        {
            if ((current->flags & TK_FLAG_HAS_SPACE_BEFORE) &&
                (current->prev != NULL && current->prev->type != TK_BLANKS))
            {
                //if an expanded macro is shown it has no spaces so we insert
                ss_fprintf(&ss, " ");
            }

            if (remove_comments)
            {
                if (current->type == TK_LINE_COMMENT)
                    ss_fprintf(&ss, "\n");
                else if (current->type == TK_COMMENT)
                    ss_fprintf(&ss, " ");
                else
                    ss_fprintf(&ss, "%s", current->lexeme);
            }
            else
            {
                ss_fprintf(&ss, "%s", current->lexeme);
            }
        }
        current = current->next;
    }

    const char* _Owner _Opt cstr = ss.c_str;
    ss.c_str = NULL; /*MOVED*/

    ss_close(&ss);

    return cstr;
}


const char* _Owner _Opt get_code_as_compiler_see(const struct token_list* list)
{
    if (list->head == NULL || list->tail == NULL)
    {
        return NULL;
    }

    struct osstream ss = { 0 };


    struct token* _Opt current = list->head;
    while (current && current != list->tail->next)
    {
        if (!(current->flags & TK_C_BACKEND_FLAG_HIDE) &&
            current->type != TK_BEGIN_OF_FILE &&
            (current->flags & TK_FLAG_FINAL))
        {
            if (current->flags & TK_FLAG_HAS_SPACE_BEFORE)
                ss_fprintf(&ss, " ");

            if (current->flags & TK_FLAG_HAS_NEWLINE_BEFORE)
                ss_fprintf(&ss, "\n");

            if (current->type == TK_LINE_COMMENT)
                ss_fprintf(&ss, "\n");
            else if (current->type == TK_COMMENT)
                ss_fprintf(&ss, " ");
            else
                ss_fprintf(&ss, "%s", current->lexeme);
        }
        current = current->next;
    }

    return ss.c_str;
}

const char* _Owner _Opt print_preprocessed_to_string2(const struct token* _Opt p_token)
{
    /*
      * At level > 0 (i.e. inside the includes)
      * This function prints the tokens as the compiler sees them
      * and inserts a space or line break to represent
      * the separation between tokens.

      * At level 0 (main file) it prints spaces, comments
      * etc. and inserts spaces in the macro expansion.
  */

    if (p_token == NULL)
        return strdup("(null)");

    struct osstream ss = { 0 };
    const struct token* _Opt current = p_token;
    while (current)
    {

        //We ignored the line continuation and it can appear anywhere in the lexemes. 
        //instead of removing it, you could just skip it when printing
        remove_line_continuation(current->lexeme);

        if (current->flags & TK_FLAG_FINAL)
        {
            if (current->level > 0)
            {
                //at the include levels we may be ignoring all
                //the spaces. in this case it is necessary to include them so as not to add the tokens
                if ((current->flags & TK_FLAG_HAS_NEWLINE_BEFORE))
                    ss_fprintf(&ss, "\n");
                else if ((current->flags & TK_FLAG_HAS_SPACE_BEFORE))
                    ss_fprintf(&ss, " ");
            }
            else
            {
                /*
                 at level 0 we print the spaces.. however in the case of macros
                 it is necessary to put a space because it does not exist.
                */
                if (current->flags & TK_FLAG_MACRO_EXPANDED)
                {
                    if ((current->flags & TK_FLAG_HAS_SPACE_BEFORE))
                        ss_fprintf(&ss, " ");
                }
            }

            if (current->lexeme[0] != '\0')
            {
                ss_fprintf(&ss, "%s", current->lexeme);
            }

            current = current->next;
        }
        else
        {
            if (current->level == 0)
            {
                if (current->type == TK_BLANKS ||
                    current->type == TK_NEWLINE)
                {
                    ss_fprintf(&ss, "%s", current->lexeme);
                }
            }

            current = current->next;
        }
    }

    return ss.c_str;
}

const char* _Owner _Opt print_preprocessed_to_string(const struct token* p_token)
{
    /*
    * Esta funcao imprime os tokens como o compilador ve
    * e insere um espaco ou quebra de linha para poder representar
    * a separacao entre os tokens.
    */

    struct osstream ss = { 0 };
    const struct token* _Opt current = p_token;

    /*
    * Ignora tudo o que é espaço no início
    */
    while (!(current->flags & TK_FLAG_FINAL) ||
        current->type == TK_BLANKS ||
        current->type == TK_COMMENT ||
        current->type == TK_LINE_COMMENT ||
        current->type == TK_NEWLINE ||
        current->type == TK_PREPROCESSOR_LINE)
    {
        current = current->next;
        if (current == NULL)
            return ss.c_str; /*MOVED*/
    }

    bool first = true;
    while (current)
    {
        assert(current->token_origin != NULL);
        if (current->flags & TK_FLAG_FINAL)
        {
            if (!first && current->flags & TK_FLAG_HAS_NEWLINE_BEFORE)
                ss_fprintf(&ss, "\n");
            else if (!first && current->flags & TK_FLAG_HAS_SPACE_BEFORE)
                ss_fprintf(&ss, " ");
            if (current->lexeme[0] != '\0')
                ss_fprintf(&ss, "%s", current->lexeme);
            first = false;
            current = current->next;
        }
        else
        {
            current = current->next;
        }
    }

    return ss.c_str; /*MOVED*/
}

void print_preprocessed(const struct token* p_token)
{
    const char* _Owner _Opt s = print_preprocessed_to_string(p_token);
    if (s)
    {
        printf("%s", s);
        free((void* _Owner)s);
    }
}

static bool is_screaming_case(const char* text)
{

    bool screaming_case = false;

    while (*text)
    {
        if ((*text >= 'A' && *text <= 'Z') ||
            (*text >= '0' && *text <= '9') ||
            (*text == '_'))
        {
            //ok
            screaming_case = true;
        }
        else
            return false;
        text++;
    }

    return screaming_case;
}

void print_all_macros(const struct preprocessor_ctx* prectx)
{
    for (int i = 0; i < prectx->macros.capacity; i++)
    {
        struct owner_map_entry* _Opt entry = prectx->macros.table[i];
        if (entry == NULL) continue;
        struct macro* macro = entry->p;
        printf("#define %s", macro->name);
        if (macro->is_function)
        {
            printf("(");

            struct macro_parameter* _Opt parameter = macro->parameters;
            while (parameter)
            {
                printf("%s", parameter->name);
                if (parameter->next)
                    printf(",");
                parameter = parameter->next;
            }
            printf(")");
        }
        printf(" ");

        struct token* _Opt token = macro->replacement_list.head;
        while (token)
        {
            printf("%s", token->lexeme);

            if (token == macro->replacement_list.tail)
                break;

            token = token->next;
        }
        printf("\n");
    }
}
void naming_convention_macro(struct preprocessor_ctx* ctx, struct token* token)
{
    if (!is_screaming_case(token->lexeme))
    {
        preprocessor_diagnostic_message(W_NOTE, ctx, token, "use SCREAMING_CASE for macros");
    }

}


#ifdef TEST


//#pragma once

extern int g_unit_test_error_count;
extern int g_unit_test_success_count;
static void assert_func(int condition, const char* func, const char* file, int line, const char* message)
{
    if (!condition)
    {
        const char* pos = file;
        const char* p = file;
        while (*p)
        {
            if (*p == '/' || *p == '\\')
                pos = p;
            p++;
        }
        
        if (*pos == '/' || *pos == '\\')
            pos++;

        g_unit_test_error_count++;
        printf("\x1b[97m" "%s:%d:0:" "\x1b[91m" " test failed:" "\x1b[0m" " function '%s'\n", pos, line, func);
        
        char buffer[20] = { 0 };
        int n = snprintf(buffer, sizeof buffer, "%d", line);        
        printf(" %s |", buffer);
        printf("    assert(%s);\n", message);
        printf(" %*s |\n", n, " ");
    }
    else
    {
        g_unit_test_success_count++;
        //printf("\x1b[97m" "%s:%d:0" "\x1b[92m" " OK" "\x1b[0m" " at '%s'\n", file, line, func);        
    }
}

#undef assert
#define assert(expression) assert_func(expression, __func__, __FILE__, __LINE__, #expression)




void print_asserts(struct token* p_token)
{
    struct token* current = p_token;
    printf("struct { const char* lexeme; enum token_type token; int is_active; int is_final; } result[] = { \n");
    while (current)
    {
        printf("{ %-20s, %d, ", get_token_name(current->type), (current->flags & TK_FLAG_FINAL));
        print_literal(current->lexeme);
        printf("},\n");
        current = current->next;
    }
    printf("}\n");
}

void show_all(struct token* p_token)
{
    struct token* current = p_token;
    while (current)
    {
        if (current->flags & TK_FLAG_FINAL)
        {
            if (current->level == 0)
                printf(WHITE);
            else
                printf(BROWN);
        }
        else
        {
            if (current->level == 0)
                printf(LIGHTGRAY);
            else
                printf(BLACK);
        }
        printf("%s", current->lexeme);
        printf(RESET);
        current = current->next;
    }
}





void print_preprocessed_to_file(struct token* p_token, const char* filename)
{
    FILE* f = fopen(filename, "r");
    if (f)
    {
        const char* s = print_preprocessed_to_string(p_token);
        if (s)
        {
            fprintf(f, "%s", s);
            free((void* _Owner)s);
        }
        fclose(f);
    }
}

void show_visible(struct token* p_token)
{
    printf(WHITE "visible used   / " LIGHTGRAY "visible ignored\n" RESET);
    struct token* current = p_token;
    while (current)
    {
        if (current->level == 0)
        {
            if (current->flags & TK_FLAG_FINAL)
                printf(WHITE);
            else
                printf(LIGHTGRAY);
        }
        else
        {
            if (current->level == 0)
                printf(BLACK);
            else
                printf(BLACK);
        }
        printf("%s", current->lexeme);
        printf(RESET);
        current = current->next;
    }
}

void show_visible_and_invisible(struct token* p_token)
{
    printf(LIGHTGREEN "visible used   / " LIGHTGRAY "visible ignored\n" RESET);
    printf(LIGHTBLUE  "invisible used / " BROWN     "invisible ignored\n" RESET);
    struct token* current = p_token;
    while (current)
    {
        if (current->level == 0)
        {
            if (current->flags & TK_FLAG_FINAL)
                printf(LIGHTGREEN);
            else
                printf(LIGHTGRAY);
        }
        else
        {
            if (current->flags & TK_FLAG_FINAL)
                printf(LIGHTBLUE);
            else
                printf(BROWN);
        }
        printf("%s", current->lexeme);
        printf(RESET);
        current = current->next;
    }
}

int test_preprossessor_input_output(const char* input, const char* output)
{
    struct tokenizer_ctx tctx = { 0 };
    struct token_list list = tokenizer(&tctx, input, "source", 0, TK_FLAG_NONE);

    struct preprocessor_ctx ctx = { 0 };

    struct token_list r = preprocessor(&ctx, &list, 0);
    const char* s = print_preprocessed_to_string(r.head);
    if (strcmp(s, output) != 0)
    {
        printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
        printf("expected\n%s", output);
        printf("HAS\n%s", s);
        printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
        print_tokens(r.head);
        printf("TEST 0 FAILED\n");
        return 1;
    }
    free((void* _Owner)s);
    return 0;
}

char* normalize_line_end(char* input)
{
    if (input == NULL)
        return NULL;
    char* pWrite = input;
    const char* p = input;
    while (*p)
    {
        if (p[0] == '\r' && p[1] == '\n')
        {
            *pWrite = '\n';
            p++;
            p++;
            pWrite++;
        }
        else
        {
            *pWrite = *p;
            p++;
            pWrite++;
        }
    }
    *pWrite = 0;
    return input;
}


int test_preprocessor_in_out(const char* input, const char* output)
{
    int res = 0;

    struct tokenizer_ctx tctx = { 0 };
    struct token_list list = tokenizer(&tctx, input, "source", 0, TK_FLAG_NONE);

    struct preprocessor_ctx ctx = { 0 };

    struct token_list r = preprocessor(&ctx, &list, 0);
    const char* result = print_preprocessed_to_string(r.head);
    if (result == NULL)
    {
        result = strdup("");
    }

    if (strcmp(result, output) != 0)
    {
        /*
        printf("FAILED\n");
        printf("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
        printf("assert\n");
        printf("%s`", output);
        printf("\nGOT\n");
        printf("%s`", result);
        printf("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
        print_tokens(r.head);

        */
        res = 1;
    }



    return res;
}

int test_preprocessor_in_out_using_file(const char* fileName)
{
    int res = 0;
    const char* input = normalize_line_end(read_file(fileName));
    char* output = 0;
    if (input)
    {
        char* pos = strstr(input, "\n---");
        if (pos)
        {
            *pos = 0;
            //anda ate sair ---
            pos++;
            while (*pos != '\n')
            {
                pos++;
            }
            pos++; //skip \n
            output = pos;
            /*optional*/
            pos = strstr(output, "\n---");
            if (pos)
                *pos = 0;
        }
        res = test_preprocessor_in_out(input, output);
        free((void* _Owner)input);
    }
    return res;
}

void test_lexeme_cmp()
{
    assert(lexeme_cmp("a", "\\\na") == 0);
    assert(lexeme_cmp("a", "a\\\n") == 0);
    assert(lexeme_cmp("\\\na", "a") == 0);
    assert(lexeme_cmp("a\\\n", "a") == 0);
    assert(lexeme_cmp("a\\\nb", "ab") == 0);
    assert(lexeme_cmp("define", "define") == 0);
    assert(lexeme_cmp("de\\\nfine", "define") == 0);
}

void token_list_pop_front_test()
{

    struct token_list list = { 0 };
    token_list_pop_front(&list);
    struct tokenizer_ctx tctx = { 0 };
    list = tokenizer(&tctx, "a", NULL, 0, TK_FLAG_NONE);
    token_list_pop_front(&list);

    list = tokenizer(&tctx, "a,", NULL, 0, TK_FLAG_NONE);
    token_list_pop_front(&list);

    list = tokenizer(&tctx, "a,b", NULL, 0, TK_FLAG_NONE);
    token_list_pop_front(&list);
}

void token_list_pop_back_test()
{

    struct token_list list = { 0 };
    token_list_pop_back(&list);

    /*pop back quando so tem 1*/
    token_list_clear(&list);
    struct tokenizer_ctx tctx = { 0 };
    list = tokenizer(&tctx, "a", NULL, 0, TK_FLAG_NONE);
    token_list_pop_back(&list);
    assert(list.head == NULL && list.tail == NULL);


    /*
    * pop bacl com 2
    */

    token_list_clear(&list);
    list = tokenizer(&tctx, "a,", NULL, 0, TK_FLAG_NONE);
    token_list_pop_back(&list);

    assert(strcmp(list.head->lexeme, "a") == 0);

    assert(list.head != NULL &&
        list.head->prev == NULL &&
        list.head->next == NULL &&
        list.tail->prev == NULL &&
        list.tail->next == NULL &&
        list.tail == list.head);

    /*
    * pop back com 3
    */

    list = tokenizer(&tctx, "a,b", NULL, 0, TK_FLAG_NONE);
    token_list_pop_back(&list);
    assert(strcmp(list.head->lexeme, "a") == 0);
    assert(strcmp(list.head->next->lexeme, ",") == 0);
    assert(strcmp(list.tail->lexeme, ",") == 0);
    assert(strcmp(list.tail->prev->lexeme, "a") == 0);
    assert(list.head->prev == NULL);
    assert(list.tail->next == NULL);
}

int token_list_append_list_test()
{

    struct tokenizer_ctx tctx = { 0 };
    struct token_list source = { 0 };
    struct token_list dest = tokenizer(&tctx, "a", NULL, 0, TK_FLAG_NONE);
    token_list_append_list(&dest, &source);
    assert(strcmp(dest.head->lexeme, "a") == 0);


    token_list_clear(&source);
    token_list_clear(&dest);


    dest = tokenizer(&tctx, "a", NULL, 0, TK_FLAG_NONE);
    token_list_append_list(&dest, &source);

    assert(strcmp(dest.head->lexeme, "a") == 0);

    token_list_clear(&source);
    token_list_clear(&dest);
    source = tokenizer(&tctx, "a,", NULL, 0, TK_FLAG_NONE);
    dest = tokenizer(&tctx, "1", NULL, 0, TK_FLAG_NONE);
    token_list_append_list(&dest, &source);
    assert(strcmp(dest.head->lexeme, "1") == 0);
    assert(strcmp(dest.tail->lexeme, ",") == 0);
    assert(dest.tail->next == NULL);
    assert(dest.head->next->next == dest.tail);
    assert(dest.tail->prev->prev == dest.head);

    return 0;
}

void test_collect()
{
    const char* input =
        "#define F(A, B) A ## B\n"
        "F(a \n, b)";

    const char* output =
        "ab"
        ;


    assert(test_preprocessor_in_out(input, output) == 0);

}


void test_va_opt_0()
{
    const char* input =
        "#define F(...)  f(0 __VA_OPT__(,) __VA_ARGS__)\n"
        "F(a, b, c)";
    const char* output =
        "f(0, a, b, c)";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void test_va_opt_1()
{
    const char* input =
        "#define F(...)  f(0 __VA_OPT__(,) __VA_ARGS__)\n"
        "F()";
    const char* output =
        "f(0)";
    assert(test_preprocessor_in_out(input, output) == 0);
}


void test_va_opt_2()
{
    const char* input =
        "#define empty(...) (__VA_OPT__(!)1)\n"
        "empty()";
    const char* output =
        "(1)";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void test_va_opt_3()
{
    const char* input =
        "#define empty(...) (__VA_OPT__(!)1)\n"
        "empty(1)";
    const char* output =
        "(!1)";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void test_va_opt_4()
{
    const char* input =
        "#define LPAREN() (\n"
        "#define G(Q) 42\n"
        "#define F(R, X, ...) __VA_OPT__(G R X) )\n"
        "int x = F(LPAREN(), 0, <:-);\n"
        ;
    const char* output =
        "int x = 42;";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void test_va_opt_5()
{
    const char* input =
        "#define F(...) f(0 __VA_OPT__(,) __VA_ARGS__)\n"
        "#define EMPTY\n"
        "F(EMPTY)"
        ;
    const char* output =
        "f(0)";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void test_va_opt_6()
{
    const char* input =
        "#define G(X, ...) f(0, X __VA_OPT__(,) __VA_ARGS__)\n"
        "G(a)"
        ;

    const char* output =
        "f(0, a)";

    assert(test_preprocessor_in_out(input, output) == 0);
}
void test_va_opt_7()
{
    const char* input =
        "#define H4(X, ...) __VA_OPT__(a X ## X) ## b\n"
        "H4(, 1)"
        ;

    const char* output =
        "a b";

    assert(test_preprocessor_in_out(input, output) == 0);
}

void concatenation_problem()
{
    const char* input =
        "#define H4(X, ...) a X ## X ## b\n"
        "H4()"
        ;

    const char* output =
        "a b";

    assert(test_preprocessor_in_out(input, output) == 0);
}


void test_va_opt_G2()
{
    const char* input =
        "#define G(X, ...) f(0, X __VA_OPT__(,) __VA_ARGS__)\n"
        "G(a, )"
        ;

    const char* output =
        "f(0, a)";

    assert(test_preprocessor_in_out(input, output) == 0);
}


void test_va_opt()
{
    const char* input =
        "#define F(...)  f(0 __VA_OPT__(,) __VA_ARGS__)\n"
        "#define EMPTY\n"
        "F(EMPTY)";
    const char* output =
        "f(0)";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void test_empty_va_args()
{
    const char* input = "#define M(a, ...) a, __VA_ARGS__\n"
        "M(1)\n";
    const char* output =
        "1,";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void test_va_args_single()
{
    const char* input =
        "#define F(...) __VA_ARGS__\n"
        "F(1, 2)";
    const char* output =
        "1, 2";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void test_va_args_extra_args()
{
    const char* input =
        "#define F(a, ...) a __VA_ARGS__\n"
        "F(0, 1, 2)";
    const char* output =
        "0 1, 2";
    assert(test_preprocessor_in_out(input, output) == 0);
}


void test_empty_va_args_empty()
{
    const char* input =
        "#define F(...) a __VA_ARGS__\n"
        "F()";
    const char* output =
        "a";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void test_defined()
{
    const char* input =
        "#if defined X || defined (X)\n"
        "A\n"
        "#else\n"
        "B\n"
        "#endif\n";
    const char* output =
        "B";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void testline()
{
    const char* input =
        "#define M \\\n"
        "        a\\\n"
        "        b\n"
        "M";
    const char* output =
        "a b";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void ifelse()
{
    const char* input =
        "#if 1\n"
        "A\n"
        "#else\n"
        "B\n"
        "#endif\n";
    const char* output =
        "A";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void T1()
{
    const char* input =
        "#define f(a) f(x * (a))\n"
        "f(2 * (0, 1))";
    const char* output =
        "f(x * (2 * (0, 1)))";
    //se f tivesse 2 parametros
    //error: too few arguments provided to function-like macro invocation
    //se f nao tivesse nenhum ou menus
    //too many arguments provided to function-like macro invocation
    assert(test_preprocessor_in_out(input, output) == 0);
}

int EXAMPLE5()
{
    /*
    //EXAMPLE 5 To illustrate the rules for placemarker preprocessing tokens, the sequence

    //const char* input =
    //"#define t(x,y,z) x ## y ## z\n"
    //"int j[] = {t(+1,2,3), t(,4,5), t(6,,7), t(8,9,),t(10,,), t(,11,), t(,,12), t(,,) };";

    //const char* output =
      //  "int j[] = {+123, 45, 67, 89,10, 11, 12, };";

    const char* input =
        "#define t(x,y,z) x ## y ## z\n"
        "t(+1,2,3)";

    const char* output =
        "int j[] = {+123, 45, 67, 89,10, 11, 12, };";

    //se f tivesse 2 parametros
    //error: too few arguments provided to function-like macro invocation

    //se f nao tivesse nenhum ou menus
    //too many arguments provided to function-like macro invocation
    //test_preprocessor_in_out(input, output);
    */
    return 0;
}

void recursivetest1()
{
    //acho que este vai sero caso que precisa do hidden set.
    const char* input =
        "#define x 2\n"
        "#define f(a) f(x * (a))\n"
        "#define z z[0]\n"
        "f(f(z))";
    //resultado gcc da
    //const char* output =
    //  "f(2 * (f(2 * (z[0]))))";
    const char* output =
        "f(2 * (f(z[0])))";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void rectest()
{
    const char* input =
        "#define x 2\n"
        "#define f(a) f(x * (a))\n"
        "#define g f\n"
        "#define z z[0]\n"
        "f(y + 1) + f(f(z)) % t(t(g)(0) + t)(1);";
    //GCC
    //const char* output =
    //  "f(2 * (y + 1)) + f(2 * (f(2 * (z[0])))) % t(t(f)(0) + t)(1);";
    const char* output =
        "f(2 * (y + 1)) + f(2 * (f(z[0]))) % t(t(f)(0) + t)(1);";
    assert(test_preprocessor_in_out(input, output) == 0);
}

void emptycall()
{
    const char* input =
        "#define F(x) x\n"
        "F()"
        ;
    const char* output =
        ""
        ;
    assert(test_preprocessor_in_out(input, output) == 0);
}

void semiempty()
{
    const char* input =
        "#define F(x,y) x ## y\n"
        "F(1,)"
        ;
    const char* output =
        "1"
        ;
    assert(test_preprocessor_in_out(input, output) == 0);
}

void calling_one_arg_with_empty_arg()
{
    const char* input =
        "#define F(a) # a\n"
        "F()"
        ;
    const char* output =
        "\"\""
        ;
    assert(test_preprocessor_in_out(input, output) == 0);
}


void test_argument_with_parentesis()
{
    const char* input =
        "#define F(a, b) a ## b\n"
        "F((1, 2, 3),4)"
        ;
    const char* output =
        "(1, 2, 3)4"
        ;
    assert(test_preprocessor_in_out(input, output) == 0);
}

void two_empty_arguments()
{
    const char* input =
        "#define F(a, b) a ## b\n"
        "F(,)\n"
        ;
    const char* output =
        ""
        ;
    assert(test_preprocessor_in_out(input, output) == 0);
}

void simple_object_macro()
{
    const char* input = "#define B b\n"
        "#define M a B\n"
        "M\n"
        "c\n";
    const char* output =
        "a b\n"
        "c";
    assert(test_preprocessor_in_out(input, output) == 0);
}


void test_one_file()
{
    assert(test_preprocessor_in_out_using_file("tests/pre_debug.c") == 0);
}

void test2()
{
    const char* input =
        "#define F(a, b) 1 a ## b 4\n"
        "F(  2  ,  3 )"
        ;
    const char* output =
        "1 23 4"
        ;

    assert(test_preprocessor_in_out(input, output) == 0);
}


void test3()
{
#if 0
    const char* input =
        "#define F(a, b) 1 a ## 3 4\n"
        "F(  2   )"
        ;
    const char* output =
        "1 23 4"
        ;
#endif
    //este erro falta parametro b
    //too few arguments provided to function - like macro invocation
    //test_preprocessor_in_out(input, output);
}


void tetris()
{
    const char* input =
        "#define D(a) a\n"
        "#define C(a) a\n"
        "#define F(a) a\n"
        "#define M F\n"
        "M(F)(C)(D)e"
        ;
    const char* output =
        "De"
        ;
    struct tokenizer_ctx tctx = { 0 };
    struct token_list list = tokenizer(&tctx, input, "source", 0, TK_FLAG_NONE);

    struct preprocessor_ctx ctx = { 0 };

    struct token_list r = preprocessor(&ctx, &list, 0);

    assert(test_preprocessor_in_out(input, output) == 0);
}

void recursive_macro_expansion()
{
    const char* input =
        "#define A 3 4 B\n"
        "#define B 1 2 A\n"
        "B";
    const char* output =
        "1 2 3 4 B"
        ;
    assert(test_preprocessor_in_out(input, output) == 0);
}

void empty_and_no_args()
{
    const char* input =
        "#define F() 1\n"
        "F()";
    const char* output =
        "1"
        ;
    assert(test_preprocessor_in_out(input, output) == 0);
}

void test4()
{
    const char* input =
        "#define F(a, b) 1 2 ## a 4\n"
        "F(  3   )"
        ;
    const char* output =
        "1 23 4"
        ;


    int code = test_preprocessor_in_out(input, output);

    //esperado um erro (falta mensagem)
    //too few arguments provided to function-like macro invocation F (3)
    //engracado msc eh warning  warning C4003: not enough actual parameters for macro 'F'
    assert(code != 0);
}

void test_string()
{
    const char* input =
        "#define M(a, b) a # b\n"
        "M(A, \"B\")"
        ;
    const char* output =
        "A \"\\\"B\\\"\""
        ;


    test_preprocessor_in_out(input, output);
}

void test6()
{
    /*

    #define Y
    #define X defined (Y)

    #if X
    #warning !
    #endif
    */
}

void testerror()
{
    /*
    const char* input =
        "#define F(a) #b\n"
        "F(1)\n"
        ;
    const char* output =
        ""
        ;
    //tem que dar error
    test_preprocessor_in_out(input, output);
    */
}

int test_preprocessor_expression(const char* expr, long long expected)
{

    struct preprocessor_ctx ctx = { 0 };

    struct token_list r = { 0 };
    struct tokenizer_ctx tctx = { 0 };
    struct token_list input = tokenizer(&tctx, expr, "", 0, TK_FLAG_NONE);

    long long result = preprocessor_constant_expression(&ctx, &r, &input, 0);
    return result == expected ? 0 : 1;
}

int test_expression()
{

    //TODO preprocessador eh sempre long long.. signed passadno maior
    //deve dar erro

    if (test_preprocessor_expression("true", true) != 0)
        return __LINE__;

    if (test_preprocessor_expression("false", false) != 0)
        return __LINE__;


    if (test_preprocessor_expression("'A'", 'A') != 0)
        return __LINE__;

    if (test_preprocessor_expression("'ab'", 'ab') != 0)
        return __LINE__;

    if (test_preprocessor_expression("1+2", 1 + 2) != 0)
        return __LINE__;

    if (test_preprocessor_expression("1 + 2 * 3 / 2 ^ 2 & 4 | 3 % 6 >> 2 << 5 - 4 + !7",
        1 + 2 * 3 / 2 ^ 2 & 4 | 3 % 6 >> 2 << 5 - 4 + !7) != 0)
        return __LINE__;

    if (test_preprocessor_expression("1ull + 2l * 3ll",
        1ull + 2l * 3ll) != 0)
        return __LINE__;


    return 0;
}

int test_concatenation_o()
{
    const char* input =
        "# define F(t1, t2, t3) *i_##t1##_j k\n"
        "F(A, B, C)\n";

    const char* output =
        "*i_A_j k"
        ;


    return test_preprocessor_in_out(input, output);
}

int test_concatenation()
{
    const char* input =
        "#define F(t1, t2, t3) i##j##k\n"
        "F(A, B, C)\n";

    const char* output =
        "ijk"
        ;


    return test_preprocessor_in_out(input, output);


}

void bad_test()
{
    struct tokenizer_ctx tctx = { 0 };
    struct token_list list = tokenizer(&tctx, "0xfe-BAD(3)", "source", 0, TK_FLAG_NONE);

    const char* input = "#define BAD(x) ((x) & 0xff)\n"
        "0xfe-BAD(3);";
    const char* output =
        "0xfe-BAD(3);"
        ;

    test_preprocessor_in_out(input, output);
}
/*
#define A0
#define B0
#define A1(x) x B##x(
#define B1(x) x A##x(
A1(1)1)1)1)1)0))
*/
int test_spaces()
{
    const char* input =
        "#define throw A B\n"
        "throw\n"
        ;
    const char* output =
        "A B"
        ;


    return test_preprocessor_in_out(input, output);
}

int test_stringfy()
{
    const char* input =
        "#define M(T) #T\n"
        "M(unsigned   int)\n"
        ;
    const char* output =
        "\"unsigned int\""
        ;


    return test_preprocessor_in_out(input, output);

}


int test_tokens()
{
    const char* input =
        "L\"s1\" u8\"s2\""
        ;

    struct tokenizer_ctx tctx = { 0 };
    struct token_list list = tokenizer(&tctx, input, "", 0, TK_FLAG_NONE);

    if (list.head->next->type != TK_STRING_LITERAL)
    {
        return __LINE__;
    }

    if (list.head->next->next->next->type != TK_STRING_LITERAL)
    {
        return __LINE__;
    }

    return tctx.n_errors;
}

int test_predefined_macros()
{
    const char* input =
        "__LINE__ __FILE__"
        ;
    const char* output =
        "1 \"source\""
        ;

    struct tokenizer_ctx tctx = { 0 };
    struct token_list list = tokenizer(&tctx, input, "source", 0, TK_FLAG_NONE);

    struct preprocessor_ctx prectx = { 0 };
    prectx.macros.capacity = 5000;
    add_standard_macros(&prectx);
    struct token_list list2 = preprocessor(&prectx, &list, 0);


    const char* result = print_preprocessed_to_string(list2.head);
    if (result == NULL)
    {
        result = strdup("");
    }
    if (strcmp(result, output) != 0)
    {
    }


    return 0;
}

int test_utf8()
{

    const char* input =
        "u8\"maçã\"";

    struct tokenizer_ctx tctx = { 0 };
    struct token_list list = tokenizer(&tctx, input, "source", 0, TK_FLAG_NONE);
    if (strcmp(list.head->next->lexeme, u8"u8\"maçã\"") != 0)
        return __LINE__;
    token_list_destroy(&list);
    return 0;
}


int test_line_continuation()
{


    const char* input =
        "#define A B \\\n"
        "C\n"
        "A";

    const char* output =
        "1 \"source\""
        ;


    struct tokenizer_ctx tctx = { 0 };
    struct token_list list = tokenizer(&tctx, input, "", 0, TK_FLAG_NONE);

    struct preprocessor_ctx prectx = { 0 };
    prectx.macros.capacity = 5000;

    struct token_list list2 = preprocessor(&prectx, &list, 0);

    const char* result = print_preprocessed_to_string(list2.head);
    if (result == NULL)
    {
        result = strdup("");
    }
    if (strcmp(result, output) != 0)
    {
    }


    return 0;
}

int stringify_test()
{
    char buffer[200];
    int n = stringify("\"ab\\c\"", sizeof buffer, buffer);
    assert(n == sizeof(STRINGIFY("\"ab\\c\"")));
    const char* r = STRINGIFY("\"ab\\c\"");

    assert(strcmp(buffer, r) == 0);
    return 0;

}

#endif


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

#pragma safety enable


void ss_swap(_View struct osstream* a, _View struct osstream* b)
{
    _View struct osstream r = *a;
    *a = *b;
    *b = r;
}

void ss_clear(struct osstream* stream)
{
    stream->size = 0;
}


void ss_close(struct osstream* _Obj_owner stream)
{
    free(stream->c_str);
}

static int reserve(struct osstream* stream, int size)
{
    int errorcode = 0;
    if (size > stream->capacity)
    {
        void* _Owner _Opt pnew = realloc(stream->c_str, (size + 1) * sizeof(char));
        if (pnew)
        {
            static_set(stream->c_str, "moved");
            stream->c_str = pnew;
            stream->capacity = size;
            stream->c_str[size] = 0;
        }
        else
        {
            errno = ENOMEM;
            errorcode = 1;
        }
    }
    return errorcode;
}

int ss_vafprintf(struct osstream* stream, const char* fmt, va_list args)
{
    assert(fmt != 0);
    int size = 0;

#pragma CAKE diagnostic push
#pragma CAKE diagnostic ignored "-Wnullable-to-non-nullable"
#pragma CAKE diagnostic ignored "-Wanalyzer-null-dereference"



    va_list tmpa = { 0 };

    va_copy(tmpa, args);

    size = vsnprintf(stream->c_str + stream->size, stream->capacity - stream->size, fmt, tmpa);

    va_end(tmpa);

#pragma CAKE diagnostic pop

    if (size < 0)
    {
        return -1;
    }

    if (reserve(stream, stream->size + size) != 0)
    {
        return -1;
    }

    size = vsprintf(stream->c_str + stream->size, fmt, args);
    if (size > 0)
    {
        stream->size += size;
    }
    return size;
}

/*
* Returns the character written. For fputc, a return value of EOF indicates an error
*/
int ss_putc(char ch, struct osstream* stream)
{
    if (reserve(stream, stream->size + 1) != 0)
    {
        return EOF;
    }
    stream->c_str[stream->size] = ch;
    stream->size++;

    return ch;
}

int ss_fprintf(struct osstream* stream, const char* fmt, ...)
{
#pragma CAKE diagnostic push
#pragma CAKE diagnostic ignored "-Wnullable-to-non-nullable"
#pragma CAKE diagnostic ignored "-Wanalyzer-null-dereference"

    va_list args = { 0 };
    va_start(args, fmt);
    int size = ss_vafprintf(stream, fmt, args);
    va_end(args);

#pragma CAKE diagnostic pop

    return size;
}



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

#pragma safety enable



#include <wchar.h>


#ifdef _WIN32
#endif


#if defined _MSC_VER && !defined __POCC__
#endif


#ifdef __POCC__
#define stat _stat
#endif

#ifdef _WIN32
#pragma comment (lib, "Rpcrt4.lib")

#else


#include <uuid/uuid.h>
/*
caso nao tenha este arquivos apt-get install uuid-dev
*/
#endif




bool path_is_absolute(const char* path)
{
#ifdef _WINDOWS_
    const char ch = (char)tolower(path[0]);
    if (ch >= 'a' && ch <= 'z')
    {
        /*  c:/ or c:\ */
        if (path[1] == ':' && (path[2] == '\\' || path[2] == '/'))
            return true;
    }

    if (path[0] == '\\' && path[1] == '\\')
    {
        // //server
        return true;
    }
#else
    return path[0] == '/';
#endif

    return false;
}

bool path_is_relative(const char* path)
{
    return !path_is_absolute(path);
}


#ifdef _WIN32

#ifdef __CAKE__
#pragma CAKE diagnostic push
#pragma CAKE diagnostic ignored "-Wstyle"
#endif

struct TAGDIR
{
    void* handle;
    struct dirent dirent;
};

#ifdef __CAKE__
#pragma CAKE diagnostic pop
#endif

DIR* _Owner _Opt opendir(const char* name)
{
    assert(name != 0);
    WIN32_FIND_DATAA fdfile = { 0 };

    char path[MAX_PATH] = { 0 };
    strcat(path, name);
    strcat(path, "\\*.*");

    HANDLE handle = FindFirstFileA(path, &fdfile);

    if (handle != INVALID_HANDLE_VALUE)
    {
        DIR* _Owner _Opt p = calloc(1, sizeof * p);
        if (p)
        {
            p->handle = handle;
            return p;
        }
        else
        {
            /*calloc sets errno to ENOMEM if a memory allocation fails */
            FindClose(handle);
        }
    }
    else
    {
        errno = windows_error_to_posix(GetLastError());
    }

    return NULL;
}

int closedir(DIR* _Owner dirp)
{
    FindClose(dirp->handle);
    free(dirp);
    return 0;
}

struct dirent* _Opt readdir(DIR* dirp)
{
    WIN32_FIND_DATAA fdfile = { 0 };
    BOOL b = FindNextFileA(dirp->handle, &fdfile);
    if (b)
    {
        /*clear*/
        memset(&dirp->dirent, 0, sizeof(dirp->dirent));

        if (fdfile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            dirp->dirent.d_type |= DT_DIR;
        }

        /*worst case trunks the string*/
        strncpy(dirp->dirent.d_name,
            fdfile.cFileName,
            sizeof(dirp->dirent.d_name) - 1);

        return &dirp->dirent;
    }
    else
    {
        errno = windows_error_to_posix(GetLastError());
    }
    return NULL;
}

/*
* realpath
   If there is no error, realpath() returns a pointer to the
       resolved_path.

       Otherwise, it returns NULL, the contents of the array
       resolved_path are undefined, and errno is set to indicate the
       error.
*/
char* _Opt realpath(const char* restrict path, char* restrict resolved_path)
{
    /*
    * _fullpath
    * Each of these functions returns a pointer to a buffer
      containing the absolute path name (absPath). If there's an
      error (for example, if the value passed in relPath includes a drive
      letter that isn't valid or can't be found, or if the length of the
      created absolute path name (absPath) is greater than maxLength), the function returns NULL.
    */
    #pragma CAKE diagnostic push
    #pragma CAKE diagnostic ignored "-Wflow-not-null"
    char* _Opt p = _fullpath(resolved_path, path, MAX_PATH);
    if (p)
    {
        char* p2 = resolved_path;
        while (*p2)
        {
            if (*p2 == '\\')
                *p2 = '/';
            p2++;
        }
    }
    #pragma CAKE diagnostic pop

    return p;
}

#endif //_WINDOWS_

int copy_file(const char* pathfrom, const char* pathto)
{

    FILE* _Owner _Opt fd_from = fopen(pathfrom, "rb");
    if (fd_from == NULL)
        return -1;

    FILE* _Owner _Opt fd_to = fopen(pathto, "wb");
    if (fd_to == NULL)
    {
        fclose(fd_from);
        return -1;
    }

    char buf[4096] = { 0 };
    size_t nread;
    while (nread = fread(buf, sizeof(char), sizeof buf, fd_from), nread > 0) //lint !e668  (warning -- possibly passing null pointer to function 'fread(void *, size_t, size_t, FILE *)', arg. no. 4)
    {
        char* out_ptr = buf;
        size_t nwritten;

        do
        {
            nwritten = fwrite(out_ptr, sizeof(char), nread, fd_to);//lint !e668

            nread -= nwritten;
            out_ptr += nwritten;
        } while (nread > 0);
    }

    if (nread == 0)
    {
        fclose(fd_to);
        fclose(fd_from);

        /* Success! */
        return 0;
    }

    fclose(fd_to);
    fclose(fd_from);

    return -1;
}

int copy_folder(const char* from, const char* to)
{
#if !defined __EMSCRIPTEN__
    int errcode = mkdir(to, 0700);
    if (errcode != 0)
    {
        return errcode;
    }

    DIR* _Owner _Opt dir = opendir(from);

    if (dir == NULL)
    {
        return errno;
    }

    struct dirent* _Opt dp;
    while ((dp = readdir(dir)) != NULL)
    {
        if (strcmp(dp->d_name, ".") == 0 || strcmp(dp->d_name, "..") == 0)
        {
            /* skip self and parent */
            continue;
        }

        char fromlocal[MAX_PATH] = { 0 };
        snprintf(fromlocal, MAX_PATH, "%s/%s", from, dp->d_name);

        char tolocal[MAX_PATH] = { 0 };
        snprintf(tolocal, MAX_PATH, "%s/%s", to, dp->d_name);

        if (dp->d_type & DT_DIR)
        {
            errcode = copy_folder(fromlocal, tolocal);
        }
        else
        {
            errcode = copy_file(fromlocal, tolocal);
        }

        if (errcode != 0)
            break;
    }

    closedir(dir);
    return errcode;
#else
    return -1;
#endif
}

#ifdef _WIN32
int get_self_path(char* buffer, int maxsize)
{

#pragma CAKE diagnostic push
#pragma CAKE diagnostic ignored "-Wnullable-to-non-nullable"
#pragma CAKE diagnostic ignored "-Wanalyzer-null-dereference"

    DWORD r = GetModuleFileNameA(NULL, buffer, maxsize);

#pragma CAKE diagnostic pop

    return r;
}

#else

int get_self_path(char* buffer, int maxsize)
{

    memset(buffer, 0, maxsize); // readlink does not null terminate!
    if (readlink("/proc/self/exe", buffer, maxsize) == -1)
    {
        //perror("readlink");
        return 1;
    }
    else
    {
        //printf("%s\n", dest);
    }
    return 0;

}

#endif




#if !defined __EMSCRIPTEN__

/* Find the last occurrence of c1 or c2 in s. */
char * _Opt strrchr_ex (const char *s, int c1, int c2)
{
  const char * _Opt last = NULL;
  const char * p = s;
  while (*p)
  {
    if (*p == c1 || *p == c2)
    {
        last = p;
    }
    p++;
  }
  return (char*)last;
}

char* basename(const char* filename)
{
    char* _Opt p = strrchr_ex(filename, '/', '\\'); //added \ to windows path
    return p ? p + 1 : (char*)filename;
}

char* dirname(char* path)
{
    int last = -1;
    for (int i = 0; path[i]; i++)
    {
        if (path[i] == '\\' || path[i] == '/')
            last = i;
    }

    if (last != -1)
    {
        path[last] = 0;
    }
    else
    {
        path[0] = 0;
    }
    return path;
}
#endif

#ifndef MOCKFILES

char* _Owner _Opt read_file(const char* const path)
{
    char* _Owner _Opt data = NULL;
    FILE* _Owner _Opt file = NULL;
    struct stat info = { 0 };

    if (stat(path, &info) != 0)
        return NULL;

    const int mem_size_bytes = sizeof(char) * info.st_size + 3 /*BOM*/ + 1 /* \0 */;

    data = malloc(mem_size_bytes);
    if (data == NULL)
        return NULL;

    file = fopen(path, "r");
    if (file == NULL)
    {
        free(data);
        return NULL;
    }

    /* first we read 3 bytes */
    size_t bytes_read = fread(data, 1, 3, file);

    if (bytes_read < 3)
    {
        /* we have less than 3 bytes - no BOM */

        data[bytes_read] = '\0';
        if (feof(file))
        {
            fclose(file);
            return data;
        }

        free(data);
        fclose(file);

        return NULL;
    }

    /* check byte order mark (BOM) */
    if ((unsigned char)data[0] == (unsigned char)0xEF &&
        (unsigned char)data[1] == (unsigned char)0xBB &&
        (unsigned char)data[2] == (unsigned char)0xBF)
    {
        /* in this case we skip this BOM */
        size_t bytes_read_part2 = fread(&data[0], 1, info.st_size - 3, file);
        data[bytes_read_part2] = 0;

        fclose(file);
        return data;
    }

    size_t bytes_read_part2 = fread(&data[3], 1, info.st_size - 3, file);
    data[bytes_read_part2 + 3] = 0;

    fclose(file);
    return data;
}

#else

static const char* file_assert_h =
"\n"
"#ifdef NDEBUG\n"
"#define assert(...) ((void)0)"
"#else"
"#define assert(...) assert(__VA_ARGS__)\n"
"#endif\n"
"\n"
"";


static const char* file_stdio_h =
"#pragma once\n"
"#define _IOFBF 0x0000\n"
"#define _IOLBF 0x0040\n"
"#define _IONBF 0x0004\n"
"\n"
"#define BUFSIZ  512\n"
"\n"
"#define EOF    (-1)\n"
"\n"
"#define FILENAME_MAX    260\n"
"#define FOPEN_MAX       20\n"
"\n"
"#define L_tmpnam   260 // _MAX_PATH\n"
"\n"
"/* Seek method constants */\n"
"\n"
"#define SEEK_CUR    1\n"
"#define SEEK_END    2\n"
"#define SEEK_SET    0\n"
"\n"
"\n"
"#define TMP_MAX         2147483647\n"
"\n"
"\n"
"\n"
"typedef long long fpos_t;\n"
"typedef int FILE;\n"
"\n"
"extern FILE* stdin;\n"
"extern FILE* stdout;\n"
"extern FILE* stderr;\n"
"\n"
"typedef int size_t;\n"
"typedef void* va_list;\n"
"int remove(const char* filename);\n"
"int rename(const char* old, const char* news);\n"
"FILE* _Opt tmpfile(void);\n"
"char* tmpnam(char* s);\n"
"#if defined(__STDC_OWNERSHIP__) \n"
"int fclose(FILE* _Owner stream);\n"
"#else\n"
"int fclose(FILE* stream);\n"
"#endif\n"
"int fflush(FILE* stream);\n"
"#if defined(__STDC_OWNERSHIP__) \n"
"FILE* _Owner _Opt fopen(const char* restrict filename, const char* restrict mode);\n"
"FILE* _Owner _Opt freopen(const char* restrict filename, const char* restrict mode, FILE* restrict stream);\n"
"#else\n"
"FILE* fopen(const char* restrict filename, const char* restrict mode);\n"
"FILE* freopen(const char* restrict filename, const char* restrict mode, FILE* restrict stream);\n"
"#endif\n"
"void setbuf(FILE* restrict stream, char* restrict buf);\n"
"int setvbuf(FILE* restrict stream, char* restrict buf, int mode, size_t size);\n"
"int fprintf(FILE* restrict stream, const char* restrict format, ...);\n"
"int fscanf(FILE* restrict stream, const char* restrict format, ...);\n"
"int printf(const char* restrict format, ...);\n"
"int scanf(const char* restrict format, ...);\n"
"int snprintf(char* restrict s, size_t n, const char* restrict format, ...);\n"
"int sprintf(char* restrict s, const char* restrict format, ...);\n"
"int sscanf(const char* restrict s, const char* restrict format, ...);\n"
"int vfprintf(FILE* restrict stream, const char* restrict format, va_list arg);\n"
"int vfscanf(FILE* restrict stream, const char* restrict format, va_list arg);\n"
"int vprintf(const char* restrict format, va_list arg);\n"
"int vscanf(const char* restrict format, va_list arg);\n"
"int puts(const char* str);\n"
"int fputs(const char* restrict s, FILE* restrict stream);\n"
"int getc(FILE* stream);\n"
"int getchar(void);\n"
"int putc(int c, FILE* stream);\n"
"int putchar(int c);\n"
"int puts(const char* s);\n"
"int ungetc(int c, FILE* stream);\n"
"int fgetc(FILE* stream);\n"
"size_t fread(void* restrict ptr, size_t size, size_t nmemb, FILE* restrict stream);\n"
"size_t fwrite(const void* restrict ptr, size_t size, size_t nmemb, FILE* restrict stream);\n"
"int fgetpos(FILE* restrict stream, fpos_t* restrict pos);\n"
"int fseek(FILE* stream, long int offset, int whence);\n"
"int fsetpos(FILE* stream, const fpos_t* pos);\n"
"long int ftell(FILE* stream);\n"
"void rewind(FILE* stream);\n"
"void clearerr(FILE* stream);\n"
"int feof(FILE* stream);\n"
"int ferror(FILE* stream);\n"
"void perror(const char* s);\n"
"\n"
"\n"
"\n"
"#ifndef NULL\n"
"#define NULL ((void*)0)\n"
"#endif\n"
"";

static const char* file_errno_h =
"#pragma once\n"
"\n"
"int* _errno(void);\n"
"#define errno (*_errno())\n"
"\n"
"\n"
"#define EPERM           1\n"
"#define ENOENT          2\n"
"#define ESRCH           3\n"
"#define EINTR           4\n"
"#define EIO             5\n"
"#define ENXIO           6\n"
"#define E2BIG           7\n"
"#define ENOEXEC         8\n"
"#define EBADF           9\n"
"#define ECHILD          10\n"
"#define EAGAIN          11\n"
"#define ENOMEM          12\n"
"#define EACCES          13\n"
"#define EFAULT          14\n"
"#define EBUSY           16\n"
"#define EEXIST          17\n"
"#define EXDEV           18\n"
"#define ENODEV          19\n"
"#define ENOTDIR         20\n"
"#define EISDIR          21\n"
"#define ENFILE          23\n"
"#define EMFILE          24\n"
"#define ENOTTY          25\n"
"#define EFBIG           27\n"
"#define ENOSPC          28\n"
"#define ESPIPE          29\n"
"#define EROFS           30\n"
"#define EMLINK          31\n"
"#define EPIPE           32\n"
"#define EDOM            33\n"
"#define EDEADLK         36\n"
"#define ENAMETOOLONG    38\n"
"#define ENOLCK          39\n"
"#define ENOSYS          40\n"
"#define ENOTEMPTY       41\n"
"\n"
"\n"
"// Support EDEADLOCK for compatibility with older Microsoft C versions\n"
"#define EDEADLOCK       EDEADLK\n"
"\n"
"#define EADDRINUSE      100\n"
"#define EADDRNOTAVAIL   101\n"
"#define EAFNOSUPPORT    102\n"
"#define EALREADY        103\n"
"#define EBADMSG         104\n"
"#define ECANCELED       105\n"
"#define ECONNABORTED    106\n"
"#define ECONNREFUSED    107\n"
"#define ECONNRESET      108\n"
"#define EDESTADDRREQ    109\n"
"#define EHOSTUNREACH    110\n"
"#define EIDRM           111\n"
"#define EINPROGRESS     112\n"
"#define EISCONN         113\n"
"#define ELOOP           114\n"
"#define EMSGSIZE        115\n"
"#define ENETDOWN        116\n"
"#define ENETRESET       117\n"
"#define ENETUNREACH     118\n"
"#define ENOBUFS         119\n"
"#define ENODATA         120\n"
"#define ENOLINK         121\n"
"#define ENOMSG          122\n"
"#define ENOPROTOOPT     123\n"
"#define ENOSR           124\n"
"#define ENOSTR          125\n"
"#define ENOTCONN        126\n"
"#define ENOTRECOVERABLE 127\n"
"#define ENOTSOCK        128\n"
"#define ENOTSUP         129\n"
"#define EOPNOTSUPP      130\n"
"#define EOTHER          131\n"
"#define EOVERFLOW       132\n"
"#define EOWNERDEAD      133\n"
"#define EPROTO          134\n"
"#define EPROTONOSUPPORT 135\n"
"#define EPROTOTYPE      136\n"
"#define ETIME           137\n"
"#define ETIMEDOUT       138\n"
"#define ETXTBSY         139\n"
"#define EWOULDBLOCK     140\n"
"\n"
"";



static const char* file_string_h =
" \n"
"typedef int errno_t;\n"
"typedef unsigned long long size_t;\n"
"typedef unsigned long long rsize_t;\n"
"typedef unsigned short wchar_t;\n"
"void* memchr(void const* _Buf, int _Val, size_t _MaxCount);\n"
"int memcmp(void const* _Buf1, void const* _Buf2, size_t _Size);\n"
"void* memcpy(void* _Dst, void const* _Src, size_t _Size);\n"
"void* memmove(void* _Dst, void const* _Src, size_t _Size);\n"
"void* memset(void* _Dst, int _Val, size_t _Size);\n"
"char* strchr(char const* _Str, int _Val);\n"
"char *strcpy(_Out char *restrict dest, const char *restrict src );\n"
"char* strrchr(char const* _Str, int _Ch);\n"
"char* strstr(char const* _Str, char const* _SubStr);\n"
"wchar_t* wcschr(wchar_t const* _Str, wchar_t _Ch);\n"
"wchar_t* wcsrchr(wchar_t const* _Str, wchar_t _Ch);\n"
"wchar_t* wcsstr(wchar_t const* _Str, wchar_t const* _SubStr);\n"
"static inline errno_t memcpy_s(void* const _Destination, rsize_t const _DestinationSize, void const* const _Source, rsize_t const _SourceSize);\n"
"static inline errno_t memmove_s(void* const _Destination, rsize_t const _DestinationSize, void const* const _Source, rsize_t const _SourceSize);\n"
"int _memicmp(void const* _Buf1, void const* _Buf2, size_t _Size);\n"
"void* memccpy(void* _Dst, void const* _Src, int _Val, size_t _Size);\n"
"int memicmp(void const* _Buf1, void const* _Buf2, size_t _Size);\n"
"errno_t wcscat_s(wchar_t* _Destination, rsize_t _SizeInWords, wchar_t const* _Source);\n"
"errno_t wcscpy_s(wchar_t* _Destination, rsize_t _SizeInWords, wchar_t const* _Source);\n"
"errno_t wcsncat_s(wchar_t* _Destination, rsize_t _SizeInWords, wchar_t const* _Source, rsize_t _MaxCount);\n"
"errno_t wcsncpy_s(wchar_t* _Destination, rsize_t _SizeInWords, wchar_t const* _Source, rsize_t _MaxCount);\n"
"wchar_t* wcstok_s(wchar_t* _String, wchar_t const* _Delimiter, wchar_t** _Context);\n"
"wchar_t* _wcsdup(wchar_t const* _String);\n"
"wchar_t* wcscat(wchar_t* _Destination, wchar_t const* _Source); int wcscmp(wchar_t const* _String1, wchar_t const* _String2);\n"
"wchar_t* wcscpy(wchar_t* _Destination, wchar_t const* _Source); size_t wcscspn(wchar_t const* _String, wchar_t const* _Control);\n"
"size_t wcslen(wchar_t const* _String);\n"
"size_t wcsnlen(wchar_t const* _Source, size_t _MaxCount);\n"
"static inline size_t wcsnlen_s(wchar_t const* _Source, size_t _MaxCount);\n"
"wchar_t* wcsncat(wchar_t* _Destination, wchar_t const* _Source, size_t _Count);\n"
"int wcsncmp(wchar_t const* _String1, wchar_t const* _String2, size_t _MaxCount);\n"
"wchar_t* wcsncpy(wchar_t* _Destination, wchar_t const* _Source, size_t _Count);\n"
"wchar_t* wcspbrk(wchar_t const* _String, wchar_t const* _Control);\n"
"size_t wcsspn(wchar_t const* _String, wchar_t const* _Control);\n"
"wchar_t* wcstok(wchar_t* _String, wchar_t const* _Delimiter, wchar_t** _Context);\n"
"size_t wcsxfrm(wchar_t* _Destination, wchar_t const* _Source, size_t _MaxCount);\n"
"int wcscoll(wchar_t const* _String1, wchar_t const* _String2);\n"
"wchar_t* wcsdup(wchar_t const* _String);\n"
"int wcsicmp(wchar_t const* _String1, wchar_t const* _String2);\n"
"int wcsnicmp(wchar_t const* _String1, wchar_t const* _String2, size_t _MaxCount);\n"
"wchar_t* wcsnset(wchar_t* _String, wchar_t _Value, size_t _MaxCount);\n"
"wchar_t* wcsrev(wchar_t* _String);\n"
"wchar_t* wcsset(wchar_t* _String, wchar_t _Value);\n"
"wchar_t* wcslwr(wchar_t* _String); wchar_t* wcsupr(wchar_t* _String);\n"
"int wcsicoll(wchar_t const* _String1, wchar_t const* _String2);\n"
"char* strtok_s(char* _String, char const* _Delimiter, char** _Context);\n"
"void* _memccpy(void* _Dst, void const* _Src, int _Val, size_t _MaxCount);\n"
"char* strcat(char* _Destination, char const* _Source);\n"
"int strcmp(char const* _Str1, char const* _Str2);\n"
"int strcoll(char const* _String1, char const* _String2);\n"
"char* strerror(int _ErrorMessage);\n"
"size_t strlen(char const* _Str);\n"
"char* strncat(char* _Destination, char const* _Source, size_t _Count);\n"
"int strncmp(char const* _Str1, char const* _Str2, size_t _MaxCount);\n"
"char* strncpy(char* _Destination, char const* _Source, size_t _Count);\n"
"size_t strnlen(char const* _String, size_t _MaxCount);\n"
"static inline size_t strnlen_s(char const* _String, size_t _MaxCount);\n"
"char* strpbrk(char const* _Str, char const* _Control);\n"
"size_t strspn(char const* _Str, char const* _Control);\n"
"char* strtok(char* _String, char const* _Delimiter);\n"
"#if defined(__STDC_OWNERSHIP__) \n"
"char* _Owner _Opt strdup(char const* _String);\n"
"#else\n"
"char* strdup(char const* _String);\n"
"#endif\n"
"int strcmpi(char const* _String1, char const* _String2);\n"
"int stricmp(char const* _String1, char const* _String2);\n"
"char* strlwr(char* _String);\n"
"int strnicmp(char const* _String1, char const* _String2, size_t _MaxCount);\n"
"char* strnset(char* _String, int _Value, size_t _MaxCount);\n"
"char* strrev(char* _String);\n"
"char* strset(char* _String, int _Value); char* strupr(char* _String);";


static const char* file_math_h
=
"#pragma once\n"
"\n"
"double acos(double __x);\n"
"double asin(double __x);\n"
"double atan(double __x);\n"
"double atan2(double __y, double __x);\n"
"double cos(double __x);\n"
"double sin(double __x);\n"
"double tan(double __x);\n"
"double cosh(double __x);\n"
"double sinh(double __x);\n"
"double tanh(double __x);\n"
"double acosh(double __x);\n"
"double asinh(double __x);\n"
"double atanh(double __x);\n"
"double exp(double __x);\n"
"double frexp(double __x, int* __exponent);\n"
"double ldexp(double __x, int __exponent);\n"
"double log(double __x);\n"
"double log10(double __x);\n"
"double modf(double __x, double* __iptr);\n"
"double expm1(double __x);\n"
"double log1p(double __x);\n"
"double logb(double __x);\n"
"double exp2(double __x);\n"
"double log2(double __x);\n"
"double pow(double __x, double __y);\n"
"double sqrt(double __x);\n"
"double hypot(double __x, double __y);\n"
"double cbrt(double __x);\n"
"double ceil(double __x);\n"
"double fabs(double __x);\n"
"double floor(double __x);\n"
"double fmod(double __x, double __y);\n"
"int isinf(double __value);\n"
"int finite(double __value);\n"
"double drem(double __x, double __y);\n"
"double significand(double __x);\n"
"double copysign(double __x, double __y);\n"
"double nan(const char* __tagb);\n"
"int isnan(double __value);\n"
"double j0(double);\n"
"double j1(double);\n"
"double jn(int, double);\n"
"double y0(double);\n"
"double y1(double);\n"
"double yn(int, double);\n"
"double erf(double);\n"
"double erfc(double);\n"
"double lgamma(double);\n"
"double tgamma(double);\n"
"double gamma(double);\n"
"double lgamma_r(double, int* __signgamp);\n"
"double rint(double __x);\n"
"double nextafter(double __x, double __y);\n"
"double nexttoward(double __x, long double __y);\n"
"double remainder(double __x, double __y);\n"
"double scalbn(double __x, int __n);\n"
"int ilogb(double __x);\n"
"double scalbln(double __x, long int __n);\n"
"double nearbyint(double __x);\n"
"double round(double __x);\n"
"double trunc(double __x);\n"
"double remquo(double __x, double __y, int* __quo);\n"
"long int lrint(double __x);\n"
"long long int llround(double __x);\n"
"double fdim(double __x, double __y);\n"
"double fmax(double __x, double __y);\n"
"double fmin(double __x, double __y);\n"
"double fma(double __x, double __y, double __z);\n"
"double scalb(double __x, double __n);\n"
"float acosf(float __x);\n"
"float asinf(float __x);\n"
"float atanf(float __x);\n"
"float atan2f(float __y, float __x);\n"
"float cosf(float __x);\n"
"float sinf(float __x);\n"
"float tanf(float __x);\n"
"float coshf(float __x);\n"
"float sinhf(float __x);\n"
"float tanhf(float __x);\n"
"float acoshf(float __x);\n"
"float asinhf(float __x);\n"
"float atanhf(float __x);\n"
"float expf(float __x);\n"
"float frexpf(float __x, int* __exponent);\n"
"float ldexpf(float __x, int __exponent);\n"
"float logf(float __x);\n"
"float log10f(float __x); float __log10f(float __x);\n"
"float modff(float __x, float* __iptr);\n"
"float expm1f(float __x);\n"
"float log1pf(float __x);\n"
"float logbf(float __x);\n"
"float exp2f(float __x);\n"
"float log2f(float __x);\n"
"float powf(float __x, float __y);\n"
"float sqrtf(float __x);\n"
"float hypotf(float __x, float __y);\n"
"float cbrtf(float __x);\n"
"float ceilf(float __x);\n"
"float fabsf(float __x);\n"
"float floorf(float __x);\n"
"float fmodf(float __x, float __y); \n"
"int isinff(float __value);\n"
"int finitef(float __value);\n"
"float dremf(float __x, float __y);\n"
"float significandf(float __x); \n"
"float copysignf(float __x, float __y); \n"
"float nanf(const char* __tagb); \n"
"int isnanf(float __value);\n"
"float j0f(float); \n"
"float j1f(float); \n"
"float jnf(int, float); \n"
"float y0f(float); \n"
"float y1f(float); \n"
"float ynf(int, float); \n"
"float erff(float); \n"
"float erfcf(float);\n"
"float lgammaf(float);\n"
"float tgammaf(float);\n"
"float gammaf(float); \n"
"float lgammaf_r(float, int* __signgamp); \n"
"float rintf(float __x); \n"
"float nextafterf(float __x, float __y); \n"
"float nexttowardf(float __x, long double __y); \n"
"float remainderf(float __x, float __y); \n"
"float scalbnf(float __x, int __n); \n"
"int ilogbf(float __x); \n"
"float scalblnf(float __x, long int __n); \n"
"float nearbyintf(float __x); \n"
"float roundf(float __x); \n"
"float truncf(float __x); \n"
"float remquof(float __x, float __y, int* __quo); \n"
"long int lrintf(float __x); \n"
"long long int llroundf(float __x); \n"
"float fdimf(float __x, float __y);\n"
"float fmaxf(float __x, float __y); \n"
"float fminf(float __x, float __y);\n"
"float fmaf(float __x, float __y, float __z); \n"
"float scalbf(float __x, float __n); \n"
"long double acosl(long double __x); \n"
"long double asinl(long double __x); \n"
"long double atanl(long double __x); \n"
"long double atan2l(long double __y, long double __x); \n"
"long double cosl(long double __x); \n"
"long double sinl(long double __x); \n"
"long double tanl(long double __x); \n"
"long double coshl(long double __x);\n"
"long double sinhl(long double __x);\n"
"long double tanhl(long double __x);\n"
"long double acoshl(long double __x); \n"
"long double asinhl(long double __x); \n"
"long double atanhl(long double __x); \n"
"long double expl(long double __x); \n"
"long double frexpl(long double __x, int* __exponent); \n"
"long double ldexpl(long double __x, int __exponent); \n"
"long double logl(long double __x); \n"
"long double log10l(long double __x); \n"
"long double modfl(long double __x, long double* __iptr); \n"
"long double expm1l(long double __x); \n"
"long double log1pl(long double __x); \n"
"long double logbl(long double __x); \n"
"long double exp2l(long double __x); \n"
"long double log2l(long double __x); \n"
"long double powl(long double __x, long double __y); \n"
"long double sqrtl(long double __x); \n"
"long double hypotl(long double __x, long double __y); \n"
"long double cbrtl(long double __x); \n"
"long double ceill(long double __x); \n"
"long double fabsl(long double __x); \n"
"long double floorl(long double __x);\n"
"long double fmodl(long double __x, long double __y); \n"
"int isinfl(long double __value);\n"
"int finitel(long double __value);\n"
"long double dreml(long double __x, long double __y); \n"
"long double significandl(long double __x); \n"
"long double copysignl(long double __x, long double __y); \n"
"long double nanl(const char* __tagb); \n"
"int isnanl(long double __value);\n"
"long double j0l(long double); \n"
"long double j1l(long double); \n"
"long double jnl(int, long double);\n"
"long double y0l(long double); \n"
"long double y1l(long double); \n"
"long double ynl(int, long double);\n"
"long double erfl(long double); \n"
"long double erfcl(long double);\n"
"long double lgammal(long double); \n"
"long double tgammal(long double); \n"
"long double gammal(long double); \n"
"long double lgammal_r(long double, int* __signgamp); \n"
"long double rintl(long double __x); \n"
"long double nextafterl(long double __x, long double __y); \n"
"long double nexttowardl(long double __x, long double __y);\n"
"long double remainderl(long double __x, long double __y); \n"
"long double scalbnl(long double __x, int __n); \n"
"int ilogbl(long double __x); \n"
"long double scalblnl(long double __x, long int __n); \n"
"long double nearbyintl(long double __x);\n"
"long double roundl(long double __x);\n"
"long double truncl(long double __x);\n"
"long double remquol(long double __x, long double __y, int* __quo);\n"
"long int lrintl(long double __x);\n"
"long long int llroundl(long double __x);\n"
"long double fdiml(long double __x, long double __y);\n"
"long double fmaxl(long double __x, long double __y);\n"
"long double fminl(long double __x, long double __y);\n"
"long double fmal(long double __x, long double __y, long double __z);\n"
"long double scalbl(long double __x, long double __n);\n"
"";

static const char* file_stdlib_h =
"typedef long long fpos_t;\n"
"typedef unsigned size_t;\n"
"\n"
"#define EXIT_SUCCESS 0\n"
"#define EXIT_FAILURE 1\n"
"#define NULL ((void*)0)\n"
"typedef int wchar_t;\n"
"[[nodiscard]] double atof(const char* nptr);\n"
"[[nodiscard]] int atoi(const char* nptr);\n"
"[[nodiscard]] long int atol(const char* nptr);\n"
"[[nodiscard]] long long int atoll(const char* nptr);\n"
"double strtod(const char* restrict nptr, char** restrict endptr);\n"
"float strtof(const char* restrict nptr, char** restrict endptr);\n"
"long double strtold(const char* restrict nptr, char** restrict endptr);\n"
"long int strtol(const char* restrict nptr, char** restrict endptr, int base);\n"
"long long int strtoll(const char* restrict nptr, char** restrict endptr, int base);\n"
"unsigned long int strtoul(const char* restrict nptr, char** restrict endptr, int base);\n"
"unsigned long long int strtoull(const char* restrict nptr, char** restrict endptr, int base);\n"
"int rand(void);\n"
"void srand(unsigned int seed);\n"
"void* aligned_alloc(size_t alignment, size_t size);\n"
"#if defined(__STDC_OWNERSHIP__) \n"
"[[nodiscard]] void* _Owner _Opt calloc(size_t nmemb, size_t size);\n"
"void free(void* _Owner _Opt ptr);\n"
"[[nodiscard]] void* _Owner _Opt malloc(size_t size);\n"
"[[nodiscard]] void* _Owner _Opt realloc(void* _Opt ptr, size_t size);\n"
"#else\n"
"[[nodiscard]] void* calloc(size_t nmemb, size_t size);\n"
"void free(void* ptr);\n"
"[[nodiscard]] void* malloc(size_t size);\n"
"[[nodiscard]] void* realloc(void* ptr, size_t size);\n"
"#endif\n"
"[[noreturn]] void abort(void);\n"
"int atexit(void (*func)(void));\n"
"int at_quick_exit(void (*func)(void));\n"
"[[noreturn]] void exit(int status);\n"
"[[noreturn]] void _Exit(int status);\n"
"char* getenv(const char* name);\n"
"[[noreturn]] void quick_exit(int status);\n"
"int system(const char* string);";

static const char* file_stddef_h =
"\n"
"#define unreachable() do {} while(0) \n"
"typedef long int ptrdiff_t;\n"
"typedef long unsigned int size_t;\n"
"typedef int wchar_t;\n"
"typedef struct {\n"
"  long long __max_align_ll;\n"
"  long double __max_align_ld;\n"
"} max_align_t;\n"
"\n"
"typedef typeof(nullptr) nullptr_t;\n"
"\n";


const char* file_limits_h =
"//\n"
"#pragma once\n"
"#define CHAR_BIT      8\n"
"#define SCHAR_MIN   (-128)\n"
"#define SCHAR_MAX     127\n"
"#define UCHAR_MAX     0xff\n"
"\n"
"#ifndef _CHAR_UNSIGNED\n"
"    #define CHAR_MIN    SCHAR_MIN\n"
"    #define CHAR_MAX    SCHAR_MAX\n"
"#else\n"
"    #define CHAR_MIN    0\n"
"    #define CHAR_MAX    UCHAR_MAX\n"
"#endif\n"
"\n"
"#define MB_LEN_MAX    5\n"
"#define SHRT_MIN    (-32768)\n"
"#define SHRT_MAX      32767\n"
"#define USHRT_MAX     0xffff\n"
"#define INT_MIN     (-2147483647 - 1)\n"
"#define INT_MAX       2147483647\n"
"#define UINT_MAX      0xffffffff\n"
"#define LONG_MIN    (-2147483647L - 1)\n"
"#define LONG_MAX      2147483647L\n"
"#define ULONG_MAX     0xffffffffUL\n"
"#define LLONG_MAX     9223372036854775807i64\n"
"#define LLONG_MIN   (-9223372036854775807i64 - 1)\n"
"#define ULLONG_MAX    0xffffffffffffffffui64\n"
"\n"
"#define _I8_MIN     (-127i8 - 1)\n"
"#define _I8_MAX       127i8\n"
"#define _UI8_MAX      0xffui8\n"
"\n"
"#define _I16_MIN    (-32767i16 - 1)\n"
"#define _I16_MAX      32767i16\n"
"#define _UI16_MAX     0xffffui16\n"
"\n"
"#define _I32_MIN    (-2147483647i32 - 1)\n"
"#define _I32_MAX      2147483647i32\n"
"#define _UI32_MAX     0xffffffffui32\n"
"\n"
"#define _I64_MIN    (-9223372036854775807i64 - 1)\n"
"#define _I64_MAX      9223372036854775807i64\n"
"#define _UI64_MAX     0xffffffffffffffffui64\n"
"        #define SIZE_MAX 0xffffffff\n"
"";

const char* file_locale_h =
 "#pragma once\n"
 "typedef int wchar_t;\n"
 "// Locale categories\n"
 "#define LC_ALL          0\n"
 "#define LC_COLLATE      1\n"
 "#define LC_CTYPE        2\n"
 "#define LC_MONETARY     3\n"
 "#define LC_NUMERIC      4\n"
 "#define LC_TIME         5\n"
 "\n"
 "#define LC_MIN          LC_ALL\n"
 "#define LC_MAX          LC_TIME\n"
 "\n"
 "// Locale convention structure\n"
 "struct lconv\n"
 "{\n"
 "    char*    decimal_point;\n"
 "    char*    thousands_sep;\n"
 "    char*    grouping;\n"
 "    char*    int_curr_symbol;\n"
 "    char*    currency_symbol;\n"
 "    char*    mon_decimal_point;\n"
 "    char*    mon_thousands_sep;\n"
 "    char*    mon_grouping;\n"
 "    char*    positive_sign;\n"
 "    char*    negative_sign;\n"
 "    char     int_frac_digits;\n"
 "    char     frac_digits;\n"
 "    char     p_cs_precedes;\n"
 "    char     p_sep_by_space;\n"
 "    char     n_cs_precedes;\n"
 "    char     n_sep_by_space;\n"
 "    char     p_sign_posn;\n"
 "    char     n_sign_posn;\n"
 "    wchar_t* _W_decimal_point;\n"
 "    wchar_t* _W_thousands_sep;\n"
 "    wchar_t* _W_int_curr_symbol;\n"
 "    wchar_t* _W_currency_symbol;\n"
 "    wchar_t* _W_mon_decimal_point;\n"
 "    wchar_t* _W_mon_thousands_sep;\n"
 "    wchar_t* _W_positive_sign;\n"
 "    wchar_t* _W_negative_sign;\n"
 "};\n"
 "\n"
 "struct tm;\n"
 "\n"
 "    char* setlocale(\n"
 "        int         _Category,\n"
 "        char const* _Locale\n"
 "        );\n"
 "\n"
 "    struct lconv* localeconv(void);\n"
 "";


const char* file_wchar_h = 
 "#pragma once\n"
 "\n"
 "#define WCHAR_MIN 0x0000\n"
 "#define WCHAR_MAX 0xffff\n"
 "typedef long unsigned int size_t;\n"
 "typedef int wchar_t;\n"
 "\n"
 "typedef struct\n"
 "{\n"
 "  int __count;\n"
 "  union\n"
 "  {\n"
 "    unsigned int __wch;\n"
 "    char __wchb[4];\n"
 "  } __value;\n"
 "} __mbstate_t;\n"
 "\n"
 "typedef __mbstate_t mbstate_t;\n"
 "struct _IO_FILE;\n"
 "typedef struct _IO_FILE __FILE;\n"
 "struct _IO_FILE;\n"
 "typedef struct _IO_FILE FILE;\n"
 "struct __locale_struct\n"
 "{\n"
 "\n"
 "  struct __locale_data *__locales[13];\n"
 "\n"
 "  const unsigned short int *__ctype_b;\n"
 "  const int *__ctype_tolower;\n"
 "  const int *__ctype_toupper;\n"
 "\n"
 "  const char *__names[13];\n"
 "};\n"
 "\n"
 "typedef struct __locale_struct *__locale_t;\n"
 "\n"
 "typedef __locale_t locale_t;\n"
 "\n"
 "struct tm;\n"
 "\n"
 "extern wchar_t *wcscpy (wchar_t *__restrict __dest,\n"
 "   const wchar_t *__restrict __src);\n"
  "\n"
 "extern wchar_t *wcsncpy (wchar_t *__restrict __dest,\n"
 "    const wchar_t *__restrict __src, size_t __n);\n"
  "\n"
 "extern wchar_t *wcscat (wchar_t *__restrict __dest,\n"
 "   const wchar_t *__restrict __src);\n"
  "\n"
 "extern wchar_t *wcsncat (wchar_t *__restrict __dest,\n"
 "    const wchar_t *__restrict __src, size_t __n);\n"
 "\n"
 "extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2);\n"
 "\n"
 "extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n);\n"
  "\n"
 "extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2);\n"
 "\n"
 "extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,\n"
 "   size_t __n) ;\n"
 "\n"
 "extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,\n"
 "    locale_t __loc) ;\n"
 "\n"
 "extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,\n"
 "     size_t __n, locale_t __loc) ;\n"
 "\n"
 "extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2);\n"
 "\n"
 "extern size_t wcsxfrm (wchar_t *__restrict __s1,\n"
 "         const wchar_t *__restrict __s2, size_t __n);\n"
 "\n"
 "extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,\n"
 "        locale_t __loc) ;\n"
 "\n"
 "extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,\n"
 "    size_t __n, locale_t __loc) ;\n"
 "\n"
 "extern wchar_t *wcsdup (const wchar_t *__s) ;\n"
 "extern wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc);\n"
 "extern wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc);\n"
 "extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject);\n"
  "\n"
 "extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept);\n"
 "extern wchar_t *wcspbrk (const wchar_t *__wcs, const wchar_t *__accept);\n"
 "extern wchar_t *wcsstr (const wchar_t *__haystack, const wchar_t *__needle);\n"
 "\n"
 "extern wchar_t *wcstok (wchar_t *__restrict __s,\n"
 "   const wchar_t *__restrict __delim,\n"
 "   wchar_t **__restrict __ptr);\n"
 "\n"
 "extern size_t wcslen (const wchar_t *__s);\n"
 "extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen);\n"
 "extern wchar_t *wmemchr (const wchar_t *__s, wchar_t __c, size_t __n);\n"
 "\n"
 "extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n);\n"
 "\n"
 "extern wchar_t *wmemcpy (wchar_t *__restrict __s1,\n"
 "    const wchar_t *__restrict __s2, size_t __n) ;\n"
 "\n"
 "extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n);\n"
 "\n"
 "extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n);\n"
 
 "extern wint_t btowc (int __c);\n"
 "\n"
 "extern int wctob (wint_t __c);\n"
 "\n"
 "extern int mbsinit (const mbstate_t *__ps);\n"
 "\n"
 "extern size_t mbrtowc (wchar_t *__restrict __pwc,\n"
 "         const char *__restrict __s, size_t __n,\n"
 "         mbstate_t *__restrict __p) ;\n"
 "\n"
 "extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,\n"
 "         mbstate_t *__restrict __ps);\n"
 "\n"
 "extern size_t __mbrlen (const char *__restrict __s, size_t __n,\n"
 "   mbstate_t *__restrict __ps) ;\n"
 "extern size_t mbrlen (const char *__restrict __s, size_t __n,\n"
 "        mbstate_t *__restrict __ps) ;\n"
 
 "extern size_t mbsrtowcs (wchar_t *__restrict __dst,\n"
 "    const char **__restrict __src, size_t __len,\n"
 "    mbstate_t *__restrict __ps) ;\n"
 "\n"
 "extern size_t wcsrtombs (char *__restrict __dst,\n"
 "    const wchar_t **__restrict __src, size_t __len,\n"
 "    mbstate_t *__restrict __ps) ;\n"
 "\n"
 "extern size_t mbsnrtowcs (wchar_t *__restrict __dst,\n"
 "     const char **__restrict __src, size_t __nmc,\n"
 "     size_t __len, mbstate_t *__restrict __ps) ;\n"
 "\n"
 "extern size_t wcsnrtombs (char *__restrict __dst,\n"
 "     const wchar_t **__restrict __src,\n"
 "     size_t __nwc, size_t __len,\n"
 "     mbstate_t *__restrict __ps) ;\n"
 
 "extern double wcstod (const wchar_t *__restrict __nptr,\n"
 "        wchar_t **__restrict __endptr) ;\n"
 "\n"
 "extern float wcstof (const wchar_t *__restrict __nptr,\n"
 "       wchar_t **__restrict __endptr) ;\n"
 "extern long double wcstold (const wchar_t *__restrict __nptr,\n"
 "       wchar_t **__restrict __endptr) ;\n"
  "extern long int wcstol (const wchar_t *__restrict __nptr,\n"
 "   wchar_t **__restrict __endptr, int __base) ;\n"
 "\n"
 "extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,\n"
 "      wchar_t **__restrict __endptr, int __base);\n"
 "\n"
 "extern long long int wcstoll (const wchar_t *__restrict __nptr,\n"
 "         wchar_t **__restrict __endptr, int __base);\n"
  "\n"
 "extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,\n"
 "     wchar_t **__restrict __endptr,\n"
 "     int __base) ;\n"
 
 "extern wchar_t *wcpcpy (wchar_t *__restrict __dest,\n"
 "   const wchar_t *__restrict __src) ;\n"
 "\n"
 "extern wchar_t *wcpncpy (wchar_t *__restrict __dest,\n"
 "    const wchar_t *__restrict __src, size_t __n);\n"
 "extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc);\n"
 "\n"
 "extern int fwide (__FILE *__fp, int __mode);\n"
 "\n"
 "extern int fwprintf (__FILE *__restrict __stream,\n"
 "       const wchar_t *__restrict __format, ...);\n"
 "extern int wprintf (const wchar_t *__restrict __format, ...);\n"
 "\n"
 "extern int swprintf (wchar_t *__restrict __s, size_t __n,\n"
 "       const wchar_t *__restrict __format, ...);\n"
 "\n"
 "\n";
 //TODO incomplete


char* _Owner read_file(const char* path)
{
    if (strcmp(path, "c:/stdio.h") == 0)
        return strdup(file_stdio_h);
    else if (strcmp(path, "c:/stdlib.h") == 0)
        return strdup(file_stdlib_h);
    else if (strcmp(path, "c:/stddef.h") == 0)
        return strdup(file_stddef_h);
    else if (strcmp(path, "c:/math.h") == 0)
        return strdup(file_math_h);
    else if (strcmp(path, "c:/errno.h") == 0)
        return strdup(file_errno_h);
    else if (strcmp(path, "c:/string.h") == 0)
        return strdup(file_string_h);
    else if (strcmp(path, "c:/assert.h") == 0)
        return strdup(file_assert_h);
    else if (strcmp(path, "c:/limits.h") == 0)
        return strdup(file_limits_h);
    else if (strcmp(path, "c:/locale.h") == 0)
        return strdup(file_locale_h);
    else if (strcmp(path, "c:/wchar.h") == 0)
        return strdup(file_wchar_h);
        
    return NULL;
}
#endif




/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

#pragma safety enable



int diagnostic_stack_push_empty(struct diagnostic_stack* diagnostic_stack)
{
    int index = diagnostic_stack->top_index;
    diagnostic_stack->top_index++;
    diagnostic_stack->stack[diagnostic_stack->top_index].warnings = 0;
    diagnostic_stack->stack[diagnostic_stack->top_index].errors = 0;
    diagnostic_stack->stack[diagnostic_stack->top_index].notes = 0;
    return index;
}

void diagnostic_stack_pop(struct diagnostic_stack* diagnostic_stack)
{
    if (diagnostic_stack->top_index > 0)
      diagnostic_stack->top_index--;
    else
    {
        assert(false);
    }
}


struct diagnostic default_diagnostic = {
      .warnings = (~0ULL) & ~(
        NULLABLE_DISABLE_REMOVED_WARNINGS |
        (1ULL << W_NOTE) |
        (1ULL << W_STYLE) |
        (1ULL << W_UNUSED_PARAMETER) |
        (1ULL << W_UNUSED_VARIABLE))
};

static struct w {
    enum diagnostic_id w;
    const char* name;
}
s_warnings[] = {
    {W_UNUSED_VARIABLE, "unused-variable"},
    {W_DEPRECATED, "deprecated"},
    {W_ENUN_CONVERSION,"enum-conversion"},

    {W_ADDRESS, "address"},
    {W_UNUSED_PARAMETER, "unused-parameter"},
    {W_DECLARATOR_HIDE, "hide-declarator"},
    {W_TYPEOF_ARRAY_PARAMETER, "typeof-parameter"},
    {W_ATTRIBUTES, "attributes"},
    {W_UNUSED_VALUE, "unused-value"},
    {W_STYLE, "style"},
    {W_COMMENT,"comment"},
    {W_LINE_SLICING,"line-slicing"},
    {W_SWITCH, "switch"},
    {W_UNSUAL_NULL_POINTER_CONSTANT, "unusual-null"},

    {W_DISCARDED_QUALIFIERS, "discarded-qualifiers"},
    {W_UNINITIALZED, "uninitialized"},
    {W_RETURN_LOCAL_ADDR, "return-local-addr"},
    {W_DIVIZION_BY_ZERO,"div-by-zero"},
    {W_CONSTANT_VALUE, "constant-value"},
    {W_SIZEOF_ARRAY_ARGUMENT, "sizeof-array-argument"},

    {W_STRING_SLICED,"string-slicing"},
    {W_DECLARATOR_STATE,"declarator-state"},
    {W_OWNERSHIP_MISSING_OWNER_QUALIFIER, "missing-owner-qualifier"},
    {W_OWNERSHIP_NOT_OWNER,"not-owner"},
    {W_OWNERSHIP_USING_TEMPORARY_OWNER,"temp-owner"},
    {W_OWNERSHIP_MOVE_ASSIGNMENT_OF_NON_OWNER, "non-owner-move"},
    {W_OWNERSHIP_NON_OWNER_TO_OWNER_ASSIGN, "non-owner-to-owner-move"},
    {W_OWNERSHIP_DISCARDING_OWNER, "discard-owner"},

    {W_OWNERSHIP_NON_OWNER_MOVE, "non-owner-move"},
    {W_FLOW_DIVIZION_BY_ZERO, "flow-div-by-zero"},

    /////////////////////////////////////////////////////////////////////////
    {W_FLOW_NON_NULL, "flow-not-null"},
    {W_FLOW_MISSING_DTOR, "missing-destructor"},
    {W_FLOW_MOVED, "using-moved-object"},
    {W_FLOW_UNINITIALIZED, "analyzer-maybe-uninitialized"},
    {W_FLOW_NULL_DEREFERENCE, "analyzer-null-dereference"}, // -fanalyzer
    {W_FLOW_MAYBE_NULL_TO_NON_OPT_ARG, "analyzer-non-opt-arg"},
    {W_FLOW_LIFETIME_ENDED, "lifetime-ended"},
    {W_FLOW_NULLABLE_TO_NON_NULLABLE, "nullable-to-non-nullable"},

    /////////////////////////////////////////////////////////////////////
    {W_MUST_USE_ADDRESSOF, "must-use-address-of"},
    {W_PASSING_NULL_AS_ARRAY, "null-as-array"},
    {W_INCOMPATIBLE_ENUN_TYPES, "incompatible-enum"},
    {W_MULTICHAR_ERROR, "multi-char"},
    {W_ARRAY_INDIRECTION,"array-indirection"},
    {W_OUT_OF_BOUNDS, "out-of-bounds"},
    {W_ASSIGNMENT_OF_ARRAY_PARAMETER, "array-parameter-assignment"},
    {W_CONDITIONAL_IS_CONSTANT,"conditional-constant"},

    {W_CONST_NOT_INITIALIZED, "const-init"},
    {W_NULL_CONVERTION, "null-conversion"},
    {W_IMPLICITLY_UNSIGNED_LITERAL, "implicitly-unsigned-literal"},
    {W_INTEGER_OVERFLOW, "overflow"},
    {W_ARRAY_SIZE, "array-size"},
    {W_EMPTY_STATEMENT, "empty-statement"},
};

_Static_assert((sizeof(s_warnings) / sizeof(s_warnings[0])) < 64, "");

void diagnostic_remove(struct diagnostic* d, enum diagnostic_id w)
{
    if ((d->errors & (1ULL << w)) != 0)
        d->errors &= ~(1ULL << w);

    if ((d->warnings & (1ULL << w)) != 0)
        d->warnings &= ~(1ULL << w);

    if ((d->notes & (1ULL << w)) != 0)
        d->notes &= ~(1ULL << w);
}

int get_diagnostic_type(struct diagnostic* d, enum diagnostic_id w)
{
    if (w >= 0 && w <= W_NOTE)
    {
        if ((d->errors & (1ULL << w)) != 0)
            return 3;

        if ((d->warnings & (1ULL << w)) != 0)
            return 2;

        if ((d->notes & (1ULL << w)) != 0)
            return 1;
    }

    return 3; //errors

}

int get_diagnostic_phase(enum diagnostic_id w)
{
    switch (w)
    {
        //TODO should be everything that starts with FLOW
    case W_FLOW_MISSING_DTOR:
    case W_FLOW_UNINITIALIZED:
    case W_FLOW_MOVED:
    case W_FLOW_NULL_DEREFERENCE:
    case W_FLOW_MAYBE_NULL_TO_NON_OPT_ARG:
    case W_FLOW_NON_NULL:
    case W_FLOW_LIFETIME_ENDED:
    case W_FLOW_DIVIZION_BY_ZERO:

        return 2; /*returns 2 if it flow analysis*/
    default:
        break;
    }
    return 0;
}


enum diagnostic_id  get_warning(const char* wname)
{
    if (!(wname[0] == '-' || wname[0] == 'E'))
    {
        return 0;
    }

    if (wname[0] == '-' && wname[1] == 'W')
    {
        for (int j = 0; j < sizeof(s_warnings) / sizeof(s_warnings[0]); j++)
        {
            if (strncmp(s_warnings[j].name, wname + 2, strlen(s_warnings[j].name)) == 0)
            {
                return s_warnings[j].w;
            }
        }
    }
    else if (wname[1] == 'E')
    {
        int ec = atoi(wname + 2);
        return ec;

    }
    return 0;
}

unsigned long long  get_warning_bit_mask(const char* wname)
{
    const bool disable_warning = wname[2] == 'n' && wname[3] == 'o';
    const char* final_name = disable_warning ? wname + 5 : wname + 2;
    assert(wname[0] == '-');
    for (int j = 0; j < sizeof(s_warnings) / sizeof(s_warnings[0]); j++)
    {

        if (strncmp(s_warnings[j].name, final_name, strlen(s_warnings[j].name)) == 0)
        {
            return (1ULL << ((unsigned long long)s_warnings[j].w));
        }
    }
    return 0;
}

int get_warning_name(enum diagnostic_id w, int n, char buffer[/*n*/])
{
    if (w >= 0 && w <= W_NOTE)
    {
        //TODO because s_warnings is _Out of order ....
        //this is a linear seatch instead of just index! TODOD
        for (int j = 0; j < sizeof(s_warnings) / sizeof(s_warnings[0]); j++)
        {
            if (s_warnings[j].w == w)
            {
                snprintf(buffer, n, "-W%s", s_warnings[j].name);
                return 0;
            }
        }
    }
    else
    {
        snprintf(buffer, n, "E%d", w);
    }

    return 0;//"";
}

int fill_options(struct options* options,
    int argc,
    const char** argv)
{

    /*
       default at this moment is same as -Wall
    */
    options->diagnostic_stack.stack[0] = default_diagnostic;

    options->diagnostic_stack.stack[0].warnings &= ~(1ULL << W_STYLE);
    //&~items;


    /*first loop used to collect options*/
    for (int i = 1; i < argc; i++)
    {
        if (argv[i][0] != '-')
            continue;

        if (argv[i][1] == 'I' ||
            argv[i][1] == 'D')
        {
            /*
              Valid, but handled with preprocessor
            */
            continue;
        }

        if (strcmp(argv[i], "-no-output") == 0)
        {
            options->no_output = true;
            continue;
        }

        if (strcmp(argv[i], "-o") == 0)
        {
            if (i + 1 < argc)
            {
                strcpy(options->output, argv[i + 1]);
                i++;
            }
            else
            {
                //ops
            }
            continue;
        }

        if (strcmp(argv[i], "-sarif-path") == 0)
        {
            if (i + 1 < argc)
            {
                strcpy(options->sarifpath, argv[i + 1]);
                i++;
            }
            else
            {
                //ops
            }
            continue;
        }

        if (strcmp(argv[i], "-show-includes") == 0)
        {
            options->show_includes = true;
            continue;
        }
        if (strcmp(argv[i], "-E") == 0)
        {
            options->preprocess_only = true;
            continue;
        }

        if (strcmp(argv[i], "-sarif") == 0)
        {
            options->sarif_output = true;
            continue;
        }

        if (strcmp(argv[i], "-fanalyzer") == 0)
        {
            options->flow_analysis = true;
            continue;
        }

        if (strcmp(argv[i], "-nullchecks") == 0)
        {
            options->null_checks_enabled = true;
            continue;
        }

        if (strcmp(argv[i], "-ownership=enable") == 0)
        {
            options->ownership_enabled = true;
            continue;
        }

        if (strcmp(argv[i], "-ownership=disable") == 0)
        {
            options->ownership_enabled = false;
            continue;
        }

        if (strcmp(argv[i], "-remove-comments") == 0)
        {
            options->remove_comments = true;
            continue;
        }

        if (strcmp(argv[i], "-test-mode") == 0)
        {
            options->test_mode = true;
            continue;
        }

        if (strcmp(argv[i], "-direct-compilation") == 0 ||
            strcmp(argv[i], "-rm") == 0)
        {
            options->direct_compilation = true;
            continue;
        }

        if (strcmp(argv[i], "-fi") == 0)
        {
            options->format_input = true;
            continue;
        }

        if (strcmp(argv[i], "-fo") == 0)
        {
            options->format_ouput = true;
            continue;
        }


        if (strcmp(argv[i], "-msvc-output") == 0 ||
            strcmp(argv[i], "-fdiagnostics-format=msvc") == 0) //same as clang
        {
            options->visual_studio_ouput_format = true;
            continue;
        }


        //
        if (strcmp(argv[i], "-style=cake") == 0)
        {
            options->style = STYLE_CAKE;
            continue;
        }

        if (strcmp(argv[i], "-style=gnu") == 0)
        {
            options->style = STYLE_GNU;
            continue;
        }

        if (strcmp(argv[i], "-style=microsoft") == 0)
        {
            options->style = STYLE_GNU;
            continue;
        }

        if (strcmp(argv[i], "-nullable=disable") == 0)
        {
            options->null_checks_enabled = false;
            unsigned long long w = NULLABLE_DISABLE_REMOVED_WARNINGS;
            options->diagnostic_stack.stack[0].warnings &= ~w;
            continue;
        }

        if (strcmp(argv[i], "-nullable=enabled") == 0)
        {
            options->null_checks_enabled = true;
            continue;
        }

        if (strcmp(argv[i], "-autoconfig") == 0 ||
            strcmp(argv[i], "-auto-config") == 0)
        {
            options->auto_config = true;
            continue;
        }

        //
        if (strcmp(argv[i], "-target=c89") == 0)
        {
            options->target = LANGUAGE_C89;
            continue;
        }

        if (strcmp(argv[i], "-target=c99") == 0)
        {
            options->target = LANGUAGE_C99;
            continue;
        }
        if (strcmp(argv[i], "-target=c11") == 0)
        {
            options->target = LANGUAGE_C11;
            continue;
        }

        if (strcmp(argv[i], "-target=c2x") == 0 ||
            strcmp(argv[i], "-target=c23") == 0)
        {
            options->target = LANGUAGE_C23;
            continue;
        }

        if (strcmp(argv[i], "-target=c2y") == 0)
        {
            options->target = LANGUAGE_C2Y;
            continue;
        }

        if (strcmp(argv[i], "-target=cxx") == 0)
        {
            options->target = LANGUAGE_CAK;
            continue;
        }



        //
        if (strcmp(argv[i], "-std=c99") == 0)
        {
            options->input = LANGUAGE_C99;
            continue;
        }
        if (strcmp(argv[i], "-std=c11") == 0)
        {
            options->input = LANGUAGE_C11;
            continue;
        }
        if (strcmp(argv[i], "-std=c2x") == 0 ||
            strcmp(argv[i], "-std=c23") == 0)
        {
            options->input = LANGUAGE_C23;
            continue;
        }
        if (strcmp(argv[i], "-std=cxx") == 0)
        {
            options->input = LANGUAGE_CAK;
            continue;
        }

        //warnings
        if (argv[i][1] == 'W')
        {
            if (strcmp(argv[i], "-Wall") == 0)
            {
                options->diagnostic_stack.stack[0].warnings = ~0ULL;
                continue;
            }
            const bool disable_warning = (argv[i][2] == 'n' && argv[i][3] == 'o');

            unsigned long long w = get_warning_bit_mask(argv[i]);

            if (w == 0)
            {
                printf("unknown warning '%s'", argv[i]);
                return 1;
            }


            if (disable_warning)
            {
                options->diagnostic_stack.stack[0].warnings &= ~w;
            }
            else
            {
                if (w == W_STYLE)
                    options->diagnostic_stack.stack[0].warnings |= w;
                else
                    options->diagnostic_stack.stack[0].notes |= w;
            }
            continue;
        }

        if (strcmp(argv[i], "-dump-tokens") == 0)
        {
            options->dump_tokens = true;
            continue;
        }

        if (strcmp(argv[i], "-dump-pp-tokens") == 0)
        {
            options->dump_pptokens = true;
            continue;
        }

        if (strcmp(argv[i], "-disable-assert") == 0)
        {
            options->disable_assert = true;
            continue;
        }

        printf("unknown option '%s'", argv[i]);
        return 1;
    }
    return 0;
}


void print_help()
{
#define CAKE LIGHTCYAN "cake " RESET 

    const char* options =
        LIGHTGREEN "Usage :" RESET CAKE LIGHTBLUE "[OPTIONS] source1.c source2.c ...\n" RESET
        "\n"
        LIGHTGREEN "Samples:\n" RESET
        "\n"
        WHITE "    " CAKE " source.c\n" RESET
        "    Compiles source.c and outputs /out/source.c\n"
        "\n"
        WHITE "    " CAKE " -target=c11 source.c\n" RESET
        "    Compiles source.c and outputs C11 code at /out/source.c\n"
        "\n"
        WHITE "    " CAKE " file.c -o file.cc && cl file.cc\n" RESET
        "    Compiles file.c and outputs file.cc then use cl to compile file.cc\n"
        "\n"
        WHITE "    " CAKE " file.c -direct-compilation -o file.cc && cl file.cc\n" RESET
        "    Compiles file.c and outputs file.cc for direct compilation then use cl to compile file.cc\n"
        "\n"
        LIGHTGREEN "Options:\n" RESET
        "\n"
        LIGHTCYAN "  -I                   " RESET " Adds a directory to the list of directories searched for include files \n"
        "                        (On windows, if you run cake at the visual studio command prompt cake \n"
        "                        uses the same include files used by msvc )\n"
        "\n"
        LIGHTCYAN "  -auto-config           " RESET "Generates cakeconfig.h with include directories\n"
        "\n"
        LIGHTCYAN "  -no-output            " RESET "Cake will not generate output\n"
        "\n"
        LIGHTCYAN "  -D                    " RESET "Defines a preprocessing symbol for a source file \n"
        "\n"
        LIGHTCYAN "  -E                    " RESET "Copies preprocessor output to standard output \n"
        "\n"
        LIGHTCYAN "  -o name.c             " RESET "Defines the output name. used when we compile one file\n"
        "\n"
        LIGHTCYAN "  -remove-comments      " RESET "Remove all comments from the output file \n"
        "\n"
        LIGHTCYAN "  -direct-compilation   " RESET "output without macros/preprocessor parts\n"
        "\n"
        LIGHTCYAN "  -target=standard      " RESET "Output target C standard (c89, c99, c11, c23, c2y, cxx) \n"
        "                        C99 is the default and C89 (ANSI C) is the minimum target \n"
        "\n"
        LIGHTCYAN "  -std=standard         " RESET "Assume that the input sources are for standard (c89, c99, c11, c2x, cxx) \n"
        "                        (not implemented yet, input is considered C23)                    \n"
        "\n"
        LIGHTCYAN "  -fi                   " RESET "Format input (format before language conversion)\n"
        "\n"
        LIGHTCYAN "  -fo                   " RESET "Format output (format after language conversion, result parsed again)\n"
        "\n"
        LIGHTCYAN "  -no-discard           " RESET "Makes [[nodiscard]] default implicitly \n"
        "\n"
        LIGHTCYAN "  -Wname -Wno-name      " RESET "Enables or disable warning\n"
        "\n"
        LIGHTCYAN "  -fanalyzer            " RESET "Runs flow analysis -  required for ownership\n"
        "\n"
        LIGHTCYAN "  -sarif                " RESET "Generates sarif files\n"
        "\n"
        LIGHTCYAN "  -sarif-path           " RESET "Set sarif output dir\n"
        "\n"
        LIGHTCYAN "  -msvc-output          " RESET "Output is compatible with visual studio\n"
        "\n"
        LIGHTCYAN "  -dump-tokens          " RESET "Output tokens before preprocessor\n"
        "\n"
        LIGHTCYAN "  -dump-pp-tokens       " RESET "Output tokens after preprocessor\n"
        "\n"
        LIGHTCYAN "  -disable-assert       " RESET "disables built-in assert\n"
        "\n"
        "More details at http://thradams.com/cake/manual.html\n"
        ;

    printf("%s", options);
}

#ifdef TEST

void test_get_warning_name()
{
    char dbg_name[100];
    get_warning_name(W_FLOW_MISSING_DTOR, sizeof dbg_name, dbg_name);
    assert(strcmp(dbg_name, "-Wmissing-destructor") == 0);

    unsigned long long  flags = get_warning_bit_mask(dbg_name);
    assert(flags == (1ULL << W_FLOW_MISSING_DTOR));


    get_warning_name(W_STYLE, sizeof dbg_name, dbg_name);
    assert(strcmp(dbg_name, "-Wstyle") == 0);

    unsigned long long  flags2 = get_warning_bit_mask(dbg_name);
    assert(flags2 == (1ULL << W_STYLE));
}

#endif


#pragma safety enable



//#pragma once


enum constant_value_type {
    TYPE_NOT_CONSTANT,
    TYPE_BOOL,

    TYPE_SIGNED_CHAR,
    TYPE_UNSIGNED_CHAR,

    TYPE_SIGNED_SHORT,
    TYPE_UNSIGNED_SHORT,

    TYPE_SIGNED_INT,
    TYPE_UNSIGNED_INT,

    TYPE_SIGNED_LONG,
    TYPE_UNSIGNED_LONG,

    TYPE_SIGNED_LONG_LONG,
    TYPE_UNSIGNED_LONG_LONG,

    TYPE_FLOAT,
    TYPE_DOUBLE,
    TYPE_LONG_DOUBLE
};

struct constant_value {
    enum constant_value_type type;
    union {
        _Bool bool_value;

        signed char signed_char_value;
        unsigned char unsigned_char_value;

        signed short signed_short_value;
        unsigned short unsigned_short_value;

        signed int signed_int_value;
        unsigned int unsigned_int_value;

        signed long signed_long_value;
        unsigned long unsigned_long_value;

        signed long long signed_long_long_value;
        unsigned long long unsigned_long_long_value;

        float float_value;
        double double_value;
        long double long_double_value;
    };
};

bool constant_value_is_valid(const struct constant_value* a);
void constant_value_to_string(const struct constant_value* a, char buffer[], int sz);

//Make constant value
struct constant_value            constant_value_make_wchar_t(wchar_t value);
struct constant_value             constant_value_make_size_t(size_t value);
struct constant_value               constant_value_make_bool(bool value);
struct constant_value            constant_value_make_nullptr();
struct constant_value        constant_value_make_signed_char(signed char value);
struct constant_value      constant_value_make_unsigned_char(unsigned char value);
struct constant_value       constant_value_make_signed_short(signed short value);
struct constant_value     constant_value_make_unsigned_short(unsigned short value);
struct constant_value         constant_value_make_signed_int(signed int value);
struct constant_value       constant_value_make_unsigned_int(unsigned int value);
struct constant_value        constant_value_make_signed_long(signed long value);
struct constant_value      constant_value_make_unsigned_long(unsigned long value);
struct constant_value   constant_value_make_signed_long_long(signed long long value);
struct constant_value constant_value_make_unsigned_long_long(unsigned long long value);
struct constant_value              constant_value_make_float(float value);
struct constant_value             constant_value_make_double(double value);
struct constant_value        constant_value_make_long_double(long double value);

//dynamic cast
struct constant_value constant_value_cast(enum constant_value_type e, const struct constant_value* a);

//static cast
signed char constant_value_to_signed_char(const struct constant_value* a);
unsigned char constant_value_to_unsigned_char(const struct constant_value* a);
signed short constant_value_to_signed_short(const struct constant_value* a);
unsigned short constant_value_to_unsigned_short(const struct constant_value* a);
signed int constant_value_to_signed_int(const struct constant_value* a);
unsigned int constant_value_to_unsigned_int(const struct constant_value* a);
signed long constant_value_to_signed_long(const struct constant_value* a);
unsigned long constant_value_to_unsigned_long(const struct constant_value* a);
signed long long constant_value_to_signed_long_long(const struct constant_value* a);
unsigned long long constant_value_to_unsigned_long_long(const struct constant_value* a);
float constant_value_to_float(const struct constant_value* a);
double constant_value_to_double(const struct constant_value* a);
long double constant_value_to_long_double(const struct constant_value* a);
bool constant_value_to_bool(const struct constant_value* a);

//Oveflow checks
bool unsigned_long_long_sub(_Out unsigned long long* result, unsigned long long a, unsigned long long b);
bool unsigned_long_long_mul(_Out unsigned long long* result, unsigned long long a, unsigned long long b);
bool unsigned_long_long_add(_Out unsigned long long* result, unsigned long long a, unsigned long long b);
bool signed_long_long_sub(_Out signed long long* result, signed long long a, signed long long b);
bool signed_long_long_add(_Out signed long long* result, signed long long a, signed long long b);
bool signed_long_long_mul(_Out signed long long* result, signed long long a, signed long long b);


#include <limits.h>

bool unsigned_long_long_sub(_Out unsigned long long* result, unsigned long long a, unsigned long long b)
{
    *result = 0;

    if (a < b)
        return false;

    *result = a - b;
    return true;
}

bool unsigned_long_long_mul(_Out unsigned long long* result, unsigned long long a, unsigned long long b)
{
    *result = 0;

    if (b == 0)
    {
        /*
          b cannot be zero in the next test
          so we solve this case here
        */
        *result = 0;
        return true;
    }

    if (a > ULLONG_MAX / b)
        return false;

    *result = a * b;
    return true;
}

bool unsigned_long_long_add(_Out unsigned long long* result, unsigned long long a, unsigned long long b)
{
    *result = 0;

    if (a > ULLONG_MAX - b)
    {
        //a=2
        //b=254
        return false;
    }
    *result = a + b;
    return true;
}

bool signed_long_long_sub(_Out signed long long* result, signed long long a, signed long long b)
{
    *result = 0;

    if (a >= 0 && b >= 0)
    {
    }
    else if (a < 0 && b < 0)
    {
    }
    else
    {
        if (a < 0)
        {
            if (a < LLONG_MIN + b)
            {
                // (-128) - (-1)
                return false;
            }
        }
        else
        {
            if (b == LLONG_MIN)
            {
                // 0 - (-128)                
                return false;
            }

            if (a > LLONG_MAX - (-b))
            {
                /*
                *  1 - (-127)
                *  2 - (-126)
                */
                return false;
            }
        }
    }

    *result = a - b;
    return true;
}

bool signed_long_long_add(_Out signed long long* result, signed long long a, signed long long b)
{
    *result = 0;

    if (a >= 0 && b >= 0)
    {
        /*both positive*/
        if (a > LLONG_MAX - b)
        {
            //2+126
            return false;
        }
    }
    else if (a < 0 && b < 0)
    {

        if (a == LLONG_MIN || b == LLONG_MIN)
        {
            //(-128) + (-128)
            return false;
        }

        if (a < LLONG_MIN - b)
        {
            // (-127) + (-127)
            return false;
        }
    }
    else
    {
        /*one positive another negative*/

    }

    *result = a + b;
    return true;
}

bool signed_long_long_mul(_Out signed long long* result, signed long long a, signed long long b)
{
    *result = 0;

    if (a > 0 && b > 0)
    {
        if (a > LLONG_MAX / b)
        {
            //2*64
            return false;
        }
    }
    else if (a < 0 && b < 0)
    {

        if (a == LLONG_MIN || b == LLONG_MIN)
        {
            //(-128)*(-128)
            return false;
        }

        if (-a > LLONG_MAX / -b)
        {
            //-127 * -127
            return false;
        }
    }
    else
    {
        if (a == 0 || b == 0)
        {
            *result = 0;
            return true;
        }
        if (b > 0)
        {
            if (a < LLONG_MIN / b)
                //(-127) * (2)
                return false;
        }
        else
        {
            if (b < LLONG_MIN / a)
            {
                //2*(-128)
                return false;
            }
        }
    }

    *result = a * b;
    return true;
}

bool constant_value_is_valid(const struct constant_value* a)
{
    return a->type != TYPE_NOT_CONSTANT;
}

void constant_value_to_string(const struct constant_value* a, char buffer[], int sz)
{
    buffer[0] = 0;
    switch (a->type)
    {

    case TYPE_NOT_CONSTANT:
        snprintf(buffer, sz, "(not-const)");
        break;

    case TYPE_BOOL:
        snprintf(buffer, sz, "%s", a->signed_char_value ? "true" : "false");
        break;

    case TYPE_SIGNED_CHAR:
        snprintf(buffer, sz, "%c", a->signed_char_value);
        break;

    case TYPE_UNSIGNED_CHAR:
        snprintf(buffer, sz, "%c", a->unsigned_char_value);
        break;

    case TYPE_SIGNED_SHORT:
        snprintf(buffer, sz, "%c", a->signed_short_value);
        break;
    case TYPE_UNSIGNED_SHORT:
        snprintf(buffer, sz, "%c", a->signed_short_value);
        break;

    case TYPE_SIGNED_INT:
        snprintf(buffer, sz, "%d", a->signed_int_value);
        break;

    case TYPE_UNSIGNED_INT:
        snprintf(buffer, sz, "%u", a->signed_int_value);
        break;

    case TYPE_SIGNED_LONG:
        snprintf(buffer, sz, "%ld", a->signed_long_value);
        break;

    case TYPE_UNSIGNED_LONG:
        break;

    case TYPE_SIGNED_LONG_LONG:
        snprintf(buffer, sz, "%lud", a->signed_long_value);
        break;

    case TYPE_UNSIGNED_LONG_LONG:
        snprintf(buffer, sz, "%llu", a->signed_long_long_value);
        break;

    case TYPE_FLOAT:
        snprintf(buffer, sz, "%f", a->float_value);
        break;

    case TYPE_DOUBLE:
        snprintf(buffer, sz, "%f", a->double_value);
        break;

    case TYPE_LONG_DOUBLE:
        snprintf(buffer, sz, "%Lf", a->long_double_value);
        break;
    }
}

struct constant_value constant_value_make_size_t(size_t value)
{
    struct constant_value r = { 0 };

#if defined(_WIN64) || defined(__x86_64__) 
    r.type = TYPE_UNSIGNED_LONG_LONG;
    r.unsigned_long_long_value = value;
#else
    r.type = TYPE_UNSIGNED_INT;
    r.unsigned_int_value = value;
#endif

    return r;
}

struct constant_value constant_value_make_nullptr()
{
    struct constant_value r = { 0 };
    r.type = TYPE_SIGNED_INT;
    r.signed_short_value = 0;
    return r;
}

struct constant_value constant_value_make_wchar_t(wchar_t value)
{
    struct constant_value r = { 0 };
#ifdef _WIN32
    static_assert(_Generic(L' ', unsigned short : 1), "");
    r.type = TYPE_SIGNED_SHORT;
    r.signed_short_value = value;
#else
    static_assert(_Generic(L' ', int : 1), "");
    r.type = TYPE_SIGNED_INT;
    r.signed_int_value = value;
#endif

    return r;
}

struct constant_value constant_value_make_bool(bool value)
{
    struct constant_value r = { 0 };
    r.type = TYPE_BOOL;
    r.bool_value = value;
    return r;
}

#pragma warning( push )
#pragma warning( disable : 4244 )

bool constant_value_to_bool(const struct constant_value* a)
{
    switch (a->type)
    {
    case TYPE_NOT_CONSTANT:break;
    case TYPE_BOOL: return a->bool_value;
    case TYPE_SIGNED_CHAR: return a->signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->unsigned_short_value;
    case TYPE_SIGNED_INT: return a->signed_int_value;
    case TYPE_UNSIGNED_INT: return a->unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->unsigned_long_long_value;
    case TYPE_FLOAT: return a->float_value;
    case TYPE_DOUBLE: return a->double_value;
    case TYPE_LONG_DOUBLE: return a->long_double_value;
    }
    assert(0);
    return 0;
}
struct constant_value constant_value_make_signed_char(signed char value)
{
    struct constant_value r = { 0 };
    r.type = TYPE_SIGNED_CHAR;
    r.signed_char_value = value;
    return r;
}

signed char constant_value_to_signed_char(const struct constant_value* a)
{


    switch (a->type)
    {
    case TYPE_NOT_CONSTANT:break;
    case TYPE_BOOL: return a->bool_value;
    case TYPE_SIGNED_CHAR: return a->signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->unsigned_short_value;
    case TYPE_SIGNED_INT: return a->signed_int_value;
    case TYPE_UNSIGNED_INT: return a->unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->unsigned_long_long_value;
    case TYPE_FLOAT: return a->float_value;
    case TYPE_DOUBLE: return a->double_value;
    case TYPE_LONG_DOUBLE: return a->long_double_value;
    }
    assert(0);
    return 0;
}

struct constant_value constant_value_make_unsigned_char(unsigned char value)
{
    struct constant_value r = { 0 };
    r.type = TYPE_UNSIGNED_CHAR;
    r.unsigned_char_value = value;
    return r;
}

unsigned char constant_value_to_unsigned_char(const struct constant_value* a)
{
    switch (a->type)
    {
    case TYPE_NOT_CONSTANT:break;
    case TYPE_BOOL: return a->bool_value;
    case TYPE_SIGNED_CHAR: return a->signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->unsigned_short_value;
    case TYPE_SIGNED_INT: return a->signed_int_value;
    case TYPE_UNSIGNED_INT: return a->unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->unsigned_long_long_value;
    case TYPE_FLOAT: return a->float_value;
    case TYPE_DOUBLE: return a->double_value;
    case TYPE_LONG_DOUBLE: return a->long_double_value;
    }
    assert(0);
    return 0;
}
struct constant_value constant_value_make_signed_short(signed short value)
{
    struct constant_value r = { 0 };
    r.type = TYPE_SIGNED_SHORT;
    r.signed_short_value = value;
    return r;
}

signed short constant_value_to_signed_short(const struct constant_value* a)
{
    switch (a->type)
    {
    case TYPE_NOT_CONSTANT:break;
    case TYPE_BOOL: return a->bool_value;
    case TYPE_SIGNED_CHAR: return a->signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->unsigned_short_value;
    case TYPE_SIGNED_INT: return a->signed_int_value;
    case TYPE_UNSIGNED_INT: return a->unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->unsigned_long_long_value;
    case TYPE_FLOAT: return a->float_value;
    case TYPE_DOUBLE: return a->double_value;
    case TYPE_LONG_DOUBLE: return a->long_double_value;
    }
    assert(0);
    return 0;
}
struct constant_value constant_value_make_unsigned_short(unsigned short value)
{
    struct constant_value r = { 0 };
    r.type = TYPE_UNSIGNED_SHORT;
    r.unsigned_short_value = value;
    return r;
}

unsigned short constant_value_to_unsigned_short(const struct constant_value* a)
{
    switch (a->type)
    {
    case TYPE_NOT_CONSTANT:break;
    case TYPE_BOOL: return a->bool_value;
    case TYPE_SIGNED_CHAR: return a->signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->unsigned_short_value;
    case TYPE_SIGNED_INT: return a->signed_int_value;
    case TYPE_UNSIGNED_INT: return a->unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->unsigned_long_long_value;
    case TYPE_FLOAT: return a->float_value;
    case TYPE_DOUBLE: return a->double_value;
    case TYPE_LONG_DOUBLE: return a->long_double_value;
    }
    assert(0);
    return 0;
}
struct constant_value constant_value_make_signed_int(signed int value)
{
    struct constant_value r = { 0 };
    r.type = TYPE_SIGNED_INT;
    r.signed_int_value = value;
    return r;
}

signed int constant_value_to_signed_int(const struct constant_value* a)
{
    switch (a->type)
    {
    case TYPE_NOT_CONSTANT:break;
    case TYPE_BOOL: return a->bool_value;
    case TYPE_SIGNED_CHAR: return a->signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->unsigned_short_value;
    case TYPE_SIGNED_INT: return a->signed_int_value;
    case TYPE_UNSIGNED_INT: return a->unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->unsigned_long_long_value;
    case TYPE_FLOAT: return a->float_value;
    case TYPE_DOUBLE: return a->double_value;
    case TYPE_LONG_DOUBLE: return a->long_double_value;
    }
    assert(0);
    return 0;
}
struct constant_value constant_value_make_unsigned_int(unsigned int value)
{
    struct constant_value r = { 0 };
    r.type = TYPE_UNSIGNED_INT;
    r.unsigned_int_value = value;
    return r;
}

unsigned int constant_value_to_unsigned_int(const struct constant_value* a)
{
    switch (a->type)
    {
    case TYPE_NOT_CONSTANT:break;
    case TYPE_BOOL: return a->bool_value;
    case TYPE_SIGNED_CHAR: return a->signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->unsigned_short_value;
    case TYPE_SIGNED_INT: return a->signed_int_value;
    case TYPE_UNSIGNED_INT: return a->unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->unsigned_long_long_value;
    case TYPE_FLOAT: return a->float_value;
    case TYPE_DOUBLE: return a->double_value;
    case TYPE_LONG_DOUBLE: return a->long_double_value;
    }
    assert(0);
    return 0;
}
struct constant_value constant_value_make_signed_long(signed long value)
{
    struct constant_value r = { 0 };
    r.type = TYPE_SIGNED_LONG;
    r.signed_long_value = value;
    return r;
}

signed long constant_value_to_signed_long(const struct constant_value* a)
{
    switch (a->type)
    {
    case TYPE_NOT_CONSTANT:break;
    case TYPE_BOOL: return a->bool_value;
    case TYPE_SIGNED_CHAR: return a->signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->unsigned_short_value;
    case TYPE_SIGNED_INT: return a->signed_int_value;
    case TYPE_UNSIGNED_INT: return a->unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->unsigned_long_long_value;
    case TYPE_FLOAT: return a->float_value;
    case TYPE_DOUBLE: return a->double_value;
    case TYPE_LONG_DOUBLE: return a->long_double_value;
    }
    assert(0);
    return 0;
}
struct constant_value constant_value_make_unsigned_long(unsigned long value)
{
    struct constant_value r = { 0 };
    r.type = TYPE_UNSIGNED_LONG;
    r.unsigned_long_value = value;
    return r;
}

unsigned long constant_value_to_unsigned_long(const struct constant_value* a)
{
    switch (a->type)
    {
    case TYPE_NOT_CONSTANT:break;
    case TYPE_BOOL: return a->bool_value;
    case TYPE_SIGNED_CHAR: return a->signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->unsigned_short_value;
    case TYPE_SIGNED_INT: return a->signed_int_value;
    case TYPE_UNSIGNED_INT: return a->unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->unsigned_long_long_value;
    case TYPE_FLOAT: return a->float_value;
    case TYPE_DOUBLE: return a->double_value;
    case TYPE_LONG_DOUBLE: return a->long_double_value;
    }
    assert(0);
    return 0;
}
struct constant_value constant_value_make_signed_long_long(signed long long value)
{
    struct constant_value r = { 0 };
    r.type = TYPE_SIGNED_LONG_LONG;
    r.signed_long_long_value = value;
    return r;
}

signed long long constant_value_to_signed_long_long(const struct constant_value* a)
{
    switch (a->type)
    {
    case TYPE_NOT_CONSTANT:break;
    case TYPE_BOOL: return a->bool_value;
    case TYPE_SIGNED_CHAR: return a->signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->unsigned_short_value;
    case TYPE_SIGNED_INT: return a->signed_int_value;
    case TYPE_UNSIGNED_INT: return a->unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->unsigned_long_long_value;
    case TYPE_FLOAT: return a->float_value;
    case TYPE_DOUBLE: return a->double_value;
    case TYPE_LONG_DOUBLE: return a->long_double_value;
    }
    assert(0);
    return 0;
}
struct constant_value constant_value_make_unsigned_long_long(unsigned long long value)
{
    struct constant_value r = { 0 };
    r.type = TYPE_UNSIGNED_LONG_LONG;
    r.unsigned_long_long_value = value;
    return r;
}

unsigned long long constant_value_to_unsigned_long_long(const struct constant_value* a)
{
    switch (a->type)
    {
    case TYPE_NOT_CONSTANT:break;
    case TYPE_BOOL: return a->bool_value;
    case TYPE_SIGNED_CHAR: return a->signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->unsigned_short_value;
    case TYPE_SIGNED_INT: return a->signed_int_value;
    case TYPE_UNSIGNED_INT: return a->unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->unsigned_long_long_value;
    case TYPE_FLOAT: return a->float_value;
    case TYPE_DOUBLE: return a->double_value;
    case TYPE_LONG_DOUBLE: return a->long_double_value;
    }
    assert(0);
    return 0;
}
struct constant_value constant_value_make_float(float value)
{
    struct constant_value r = { 0 };
    r.type = TYPE_FLOAT;
    r.float_value = value;
    return r;
}

float constant_value_to_float(const struct constant_value* a)
{
    switch (a->type)
    {
    case TYPE_NOT_CONSTANT:break;
    case TYPE_BOOL: return a->bool_value;
    case TYPE_SIGNED_CHAR: return a->signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->unsigned_short_value;
    case TYPE_SIGNED_INT: return a->signed_int_value;
    case TYPE_UNSIGNED_INT: return a->unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->unsigned_long_long_value;
    case TYPE_FLOAT: return a->float_value;
    case TYPE_DOUBLE: return a->double_value;
    case TYPE_LONG_DOUBLE: return a->long_double_value;
    }
    assert(0);
    return 0;
}
struct constant_value constant_value_make_double(double value)
{
    struct constant_value r = { 0 };
    r.type = TYPE_DOUBLE;
    r.double_value = value;
    return r;
}

double constant_value_to_double(const struct constant_value* a)
{
    switch (a->type)
    {
    case TYPE_NOT_CONSTANT:break;
    case TYPE_BOOL: return a->bool_value;
    case TYPE_SIGNED_CHAR: return a->signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->unsigned_short_value;
    case TYPE_SIGNED_INT: return a->signed_int_value;
    case TYPE_UNSIGNED_INT: return a->unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->unsigned_long_long_value;
    case TYPE_FLOAT: return a->float_value;
    case TYPE_DOUBLE: return a->double_value;
    case TYPE_LONG_DOUBLE: return a->long_double_value;
    }
    assert(0);
    return 0;
}
struct constant_value constant_value_make_long_double(long double value)
{
    struct constant_value r = { 0 };
    r.type = TYPE_LONG_DOUBLE;
    r.long_double_value = value;
    return r;
}

long double constant_value_to_long_double(const struct constant_value* a)
{
    switch (a->type)
    {
    case TYPE_NOT_CONSTANT:break;
    case TYPE_BOOL: return a->bool_value;
    case TYPE_SIGNED_CHAR: return a->signed_char_value;
    case TYPE_UNSIGNED_CHAR: return a->unsigned_char_value;
    case TYPE_SIGNED_SHORT: return a->signed_short_value;
    case TYPE_UNSIGNED_SHORT: return a->unsigned_short_value;
    case TYPE_SIGNED_INT: return a->signed_int_value;
    case TYPE_UNSIGNED_INT: return a->unsigned_int_value;
    case TYPE_SIGNED_LONG: return a->signed_long_value;
    case TYPE_UNSIGNED_LONG: return a->unsigned_long_value;
    case TYPE_SIGNED_LONG_LONG: return a->signed_long_long_value;
    case TYPE_UNSIGNED_LONG_LONG: return a->unsigned_long_long_value;
    case TYPE_FLOAT: return a->float_value;
    case TYPE_DOUBLE: return a->double_value;
    case TYPE_LONG_DOUBLE: return a->long_double_value;
    }
    assert(0);
    return 0;
}



#pragma warning( pop )



struct constant_value constant_value_cast(enum constant_value_type t, const struct constant_value* v)
{
    //No changes
    if (v->type == t)
        return *v;


    //This function is generated by this program
    /*
            struct type
            {
                const char * type;
                const char * name;
                const char * value_type;
            };
            struct type types[] =
            {
                {"bool", "bool", "TYPE_BOOL"},
                {"signed char", "signed_char", "TYPE_SIGNED_CHAR"},
                {"unsigned char", "unsigned_char", "TYPE_UNSIGNED_CHAR"},
                {"signed short", "signed_short", "TYPE_SIGNED_SHORT"},
                {"unsigned short", "unsigned_short", "TYPE_UNSIGNED_SHORT"},
                {"signed int", "signed_int", "TYPE_SIGNED_INT"},
                {"unsigned int", "unsigned_int", "TYPE_UNSIGNED_INT"},
                {"signed long", "signed_long", "TYPE_SIGNED_LONG"},
                {"unsigned long", "unsigned_long", "TYPE_UNSIGNED_LONG"},
                {"signed long long", "signed_long_long", "TYPE_SIGNED_LONG_LONG"},
                {"unsigned long long", "unsigned_long_long", "TYPE_UNSIGNED_LONG_LONG"},
                {"float", "float", "TYPE_FLOAT"},
                {"double", "double", "TYPE_DOUBLE"},
                {"long double", "long_double", "TYPE_LONG_DOUBLE"}
            };


            int main()
            {
                FILE * f = fopen("imp.c", "w");
                if (f == NULL)
                    return;

                fprintf(f, "struct constant_value cast(enum constant_value_type t, struct constant_value * v)\n");
                fprintf(f, "{\n");
                for (int i = 0; i < sizeof(types) / sizeof(types[0]); i++)
                {
                    fprintf(f, "if (t == %s)\n", types[i].value_type);
                    fprintf(f, "{\n");
                    for (int j = 0; j < sizeof(types) / sizeof(types[0]); j++)
                    {
                        if (i == j)
                            continue;
                        fprintf(f, "if (v->type == %s)\n", types[j].value_type);
                        fprintf(f, " return constant_value_make_%s((%s)v->%s_value);\n", types[i].name, types[i].type, types[j].name);
                    }
                    fprintf(f, "}\n");
                }
                fprintf(f, "}\n");

                fclose(f);
            }
    */
    if (t == TYPE_BOOL)
    {
        if (v->type == TYPE_SIGNED_CHAR)
            return constant_value_make_bool((bool)v->signed_char_value);
        if (v->type == TYPE_UNSIGNED_CHAR)
            return constant_value_make_bool((bool)v->unsigned_char_value);
        if (v->type == TYPE_SIGNED_SHORT)
            return constant_value_make_bool((bool)v->signed_short_value);
        if (v->type == TYPE_UNSIGNED_SHORT)
            return constant_value_make_bool((bool)v->unsigned_short_value);
        if (v->type == TYPE_SIGNED_INT)
            return constant_value_make_bool((bool)v->signed_int_value);
        if (v->type == TYPE_UNSIGNED_INT)
            return constant_value_make_bool((bool)v->unsigned_int_value);
        if (v->type == TYPE_SIGNED_LONG)
            return constant_value_make_bool((bool)v->signed_long_value);
        if (v->type == TYPE_UNSIGNED_LONG)
            return constant_value_make_bool((bool)v->unsigned_long_value);
        if (v->type == TYPE_SIGNED_LONG_LONG)
            return constant_value_make_bool((bool)v->signed_long_long_value);
        if (v->type == TYPE_UNSIGNED_LONG_LONG)
            return constant_value_make_bool((bool)v->unsigned_long_long_value);
        if (v->type == TYPE_FLOAT)
            return constant_value_make_bool((bool)v->float_value);
        if (v->type == TYPE_DOUBLE)
            return constant_value_make_bool((bool)v->double_value);
        if (v->type == TYPE_LONG_DOUBLE)
            return constant_value_make_bool((bool)v->long_double_value);
    }
    if (t == TYPE_SIGNED_CHAR)
    {
        if (v->type == TYPE_BOOL)
            return constant_value_make_signed_char((signed char)v->bool_value);
        if (v->type == TYPE_UNSIGNED_CHAR)
            return constant_value_make_signed_char((signed char)v->unsigned_char_value);
        if (v->type == TYPE_SIGNED_SHORT)
            return constant_value_make_signed_char((signed char)v->signed_short_value);
        if (v->type == TYPE_UNSIGNED_SHORT)
            return constant_value_make_signed_char((signed char)v->unsigned_short_value);
        if (v->type == TYPE_SIGNED_INT)
            return constant_value_make_signed_char((signed char)v->signed_int_value);
        if (v->type == TYPE_UNSIGNED_INT)
            return constant_value_make_signed_char((signed char)v->unsigned_int_value);
        if (v->type == TYPE_SIGNED_LONG)
            return constant_value_make_signed_char((signed char)v->signed_long_value);
        if (v->type == TYPE_UNSIGNED_LONG)
            return constant_value_make_signed_char((signed char)v->unsigned_long_value);
        if (v->type == TYPE_SIGNED_LONG_LONG)
            return constant_value_make_signed_char((signed char)v->signed_long_long_value);
        if (v->type == TYPE_UNSIGNED_LONG_LONG)
            return constant_value_make_signed_char((signed char)v->unsigned_long_long_value);
        if (v->type == TYPE_FLOAT)
            return constant_value_make_signed_char((signed char)v->float_value);
        if (v->type == TYPE_DOUBLE)
            return constant_value_make_signed_char((signed char)v->double_value);
        if (v->type == TYPE_LONG_DOUBLE)
            return constant_value_make_signed_char((signed char)v->long_double_value);
    }
    if (t == TYPE_UNSIGNED_CHAR)
    {
        if (v->type == TYPE_BOOL)
            return constant_value_make_unsigned_char((unsigned char)v->bool_value);
        if (v->type == TYPE_SIGNED_CHAR)
            return constant_value_make_unsigned_char((unsigned char)v->signed_char_value);
        if (v->type == TYPE_SIGNED_SHORT)
            return constant_value_make_unsigned_char((unsigned char)v->signed_short_value);
        if (v->type == TYPE_UNSIGNED_SHORT)
            return constant_value_make_unsigned_char((unsigned char)v->unsigned_short_value);
        if (v->type == TYPE_SIGNED_INT)
            return constant_value_make_unsigned_char((unsigned char)v->signed_int_value);
        if (v->type == TYPE_UNSIGNED_INT)
            return constant_value_make_unsigned_char((unsigned char)v->unsigned_int_value);
        if (v->type == TYPE_SIGNED_LONG)
            return constant_value_make_unsigned_char((unsigned char)v->signed_long_value);
        if (v->type == TYPE_UNSIGNED_LONG)
            return constant_value_make_unsigned_char((unsigned char)v->unsigned_long_value);
        if (v->type == TYPE_SIGNED_LONG_LONG)
            return constant_value_make_unsigned_char((unsigned char)v->signed_long_long_value);
        if (v->type == TYPE_UNSIGNED_LONG_LONG)
            return constant_value_make_unsigned_char((unsigned char)v->unsigned_long_long_value);
        if (v->type == TYPE_FLOAT)
            return constant_value_make_unsigned_char((unsigned char)v->float_value);
        if (v->type == TYPE_DOUBLE)
            return constant_value_make_unsigned_char((unsigned char)v->double_value);
        if (v->type == TYPE_LONG_DOUBLE)
            return constant_value_make_unsigned_char((unsigned char)v->long_double_value);
    }
    if (t == TYPE_SIGNED_SHORT)
    {
        if (v->type == TYPE_BOOL)
            return constant_value_make_signed_short((signed short)v->bool_value);
        if (v->type == TYPE_SIGNED_CHAR)
            return constant_value_make_signed_short((signed short)v->signed_char_value);
        if (v->type == TYPE_UNSIGNED_CHAR)
            return constant_value_make_signed_short((signed short)v->unsigned_char_value);
        if (v->type == TYPE_UNSIGNED_SHORT)
            return constant_value_make_signed_short((signed short)v->unsigned_short_value);
        if (v->type == TYPE_SIGNED_INT)
            return constant_value_make_signed_short((signed short)v->signed_int_value);
        if (v->type == TYPE_UNSIGNED_INT)
            return constant_value_make_signed_short((signed short)v->unsigned_int_value);
        if (v->type == TYPE_SIGNED_LONG)
            return constant_value_make_signed_short((signed short)v->signed_long_value);
        if (v->type == TYPE_UNSIGNED_LONG)
            return constant_value_make_signed_short((signed short)v->unsigned_long_value);
        if (v->type == TYPE_SIGNED_LONG_LONG)
            return constant_value_make_signed_short((signed short)v->signed_long_long_value);
        if (v->type == TYPE_UNSIGNED_LONG_LONG)
            return constant_value_make_signed_short((signed short)v->unsigned_long_long_value);
        if (v->type == TYPE_FLOAT)
            return constant_value_make_signed_short((signed short)v->float_value);
        if (v->type == TYPE_DOUBLE)
            return constant_value_make_signed_short((signed short)v->double_value);
        if (v->type == TYPE_LONG_DOUBLE)
            return constant_value_make_signed_short((signed short)v->long_double_value);
    }
    if (t == TYPE_UNSIGNED_SHORT)
    {
        if (v->type == TYPE_BOOL)
            return constant_value_make_unsigned_short((unsigned short)v->bool_value);
        if (v->type == TYPE_SIGNED_CHAR)
            return constant_value_make_unsigned_short((unsigned short)v->signed_char_value);
        if (v->type == TYPE_UNSIGNED_CHAR)
            return constant_value_make_unsigned_short((unsigned short)v->unsigned_char_value);
        if (v->type == TYPE_SIGNED_SHORT)
            return constant_value_make_unsigned_short((unsigned short)v->signed_short_value);
        if (v->type == TYPE_SIGNED_INT)
            return constant_value_make_unsigned_short((unsigned short)v->signed_int_value);
        if (v->type == TYPE_UNSIGNED_INT)
            return constant_value_make_unsigned_short((unsigned short)v->unsigned_int_value);
        if (v->type == TYPE_SIGNED_LONG)
            return constant_value_make_unsigned_short((unsigned short)v->signed_long_value);
        if (v->type == TYPE_UNSIGNED_LONG)
            return constant_value_make_unsigned_short((unsigned short)v->unsigned_long_value);
        if (v->type == TYPE_SIGNED_LONG_LONG)
            return constant_value_make_unsigned_short((unsigned short)v->signed_long_long_value);
        if (v->type == TYPE_UNSIGNED_LONG_LONG)
            return constant_value_make_unsigned_short((unsigned short)v->unsigned_long_long_value);
        if (v->type == TYPE_FLOAT)
            return constant_value_make_unsigned_short((unsigned short)v->float_value);
        if (v->type == TYPE_DOUBLE)
            return constant_value_make_unsigned_short((unsigned short)v->double_value);
        if (v->type == TYPE_LONG_DOUBLE)
            return constant_value_make_unsigned_short((unsigned short)v->long_double_value);
    }
    if (t == TYPE_SIGNED_INT)
    {
        if (v->type == TYPE_BOOL)
            return constant_value_make_signed_int((signed int)v->bool_value);
        if (v->type == TYPE_SIGNED_CHAR)
            return constant_value_make_signed_int((signed int)v->signed_char_value);
        if (v->type == TYPE_UNSIGNED_CHAR)
            return constant_value_make_signed_int((signed int)v->unsigned_char_value);
        if (v->type == TYPE_SIGNED_SHORT)
            return constant_value_make_signed_int((signed int)v->signed_short_value);
        if (v->type == TYPE_UNSIGNED_SHORT)
            return constant_value_make_signed_int((signed int)v->unsigned_short_value);
        if (v->type == TYPE_UNSIGNED_INT)
            return constant_value_make_signed_int((signed int)v->unsigned_int_value);
        if (v->type == TYPE_SIGNED_LONG)
            return constant_value_make_signed_int((signed int)v->signed_long_value);
        if (v->type == TYPE_UNSIGNED_LONG)
            return constant_value_make_signed_int((signed int)v->unsigned_long_value);
        if (v->type == TYPE_SIGNED_LONG_LONG)
            return constant_value_make_signed_int((signed int)v->signed_long_long_value);
        if (v->type == TYPE_UNSIGNED_LONG_LONG)
            return constant_value_make_signed_int((signed int)v->unsigned_long_long_value);
        if (v->type == TYPE_FLOAT)
            return constant_value_make_signed_int((signed int)v->float_value);
        if (v->type == TYPE_DOUBLE)
            return constant_value_make_signed_int((signed int)v->double_value);
        if (v->type == TYPE_LONG_DOUBLE)
            return constant_value_make_signed_int((signed int)v->long_double_value);
    }
    if (t == TYPE_UNSIGNED_INT)
    {
        if (v->type == TYPE_BOOL)
            return constant_value_make_unsigned_int((unsigned int)v->bool_value);
        if (v->type == TYPE_SIGNED_CHAR)
            return constant_value_make_unsigned_int((unsigned int)v->signed_char_value);
        if (v->type == TYPE_UNSIGNED_CHAR)
            return constant_value_make_unsigned_int((unsigned int)v->unsigned_char_value);
        if (v->type == TYPE_SIGNED_SHORT)
            return constant_value_make_unsigned_int((unsigned int)v->signed_short_value);
        if (v->type == TYPE_UNSIGNED_SHORT)
            return constant_value_make_unsigned_int((unsigned int)v->unsigned_short_value);
        if (v->type == TYPE_SIGNED_INT)
            return constant_value_make_unsigned_int((unsigned int)v->signed_int_value);
        if (v->type == TYPE_SIGNED_LONG)
            return constant_value_make_unsigned_int((unsigned int)v->signed_long_value);
        if (v->type == TYPE_UNSIGNED_LONG)
            return constant_value_make_unsigned_int((unsigned int)v->unsigned_long_value);
        if (v->type == TYPE_SIGNED_LONG_LONG)
            return constant_value_make_unsigned_int((unsigned int)v->signed_long_long_value);
        if (v->type == TYPE_UNSIGNED_LONG_LONG)
            return constant_value_make_unsigned_int((unsigned int)v->unsigned_long_long_value);
        if (v->type == TYPE_FLOAT)
            return constant_value_make_unsigned_int((unsigned int)v->float_value);
        if (v->type == TYPE_DOUBLE)
            return constant_value_make_unsigned_int((unsigned int)v->double_value);
        if (v->type == TYPE_LONG_DOUBLE)
            return constant_value_make_unsigned_int((unsigned int)v->long_double_value);
    }
    if (t == TYPE_SIGNED_LONG)
    {
        if (v->type == TYPE_BOOL)
            return constant_value_make_signed_long((signed long)v->bool_value);
        if (v->type == TYPE_SIGNED_CHAR)
            return constant_value_make_signed_long((signed long)v->signed_char_value);
        if (v->type == TYPE_UNSIGNED_CHAR)
            return constant_value_make_signed_long((signed long)v->unsigned_char_value);
        if (v->type == TYPE_SIGNED_SHORT)
            return constant_value_make_signed_long((signed long)v->signed_short_value);
        if (v->type == TYPE_UNSIGNED_SHORT)
            return constant_value_make_signed_long((signed long)v->unsigned_short_value);
        if (v->type == TYPE_SIGNED_INT)
            return constant_value_make_signed_long((signed long)v->signed_int_value);
        if (v->type == TYPE_UNSIGNED_INT)
            return constant_value_make_signed_long((signed long)v->unsigned_int_value);
        if (v->type == TYPE_UNSIGNED_LONG)
            return constant_value_make_signed_long((signed long)v->unsigned_long_value);
        if (v->type == TYPE_SIGNED_LONG_LONG)
            return constant_value_make_signed_long((signed long)v->signed_long_long_value);
        if (v->type == TYPE_UNSIGNED_LONG_LONG)
            return constant_value_make_signed_long((signed long)v->unsigned_long_long_value);
        if (v->type == TYPE_FLOAT)
            return constant_value_make_signed_long((signed long)v->float_value);
        if (v->type == TYPE_DOUBLE)
            return constant_value_make_signed_long((signed long)v->double_value);
        if (v->type == TYPE_LONG_DOUBLE)
            return constant_value_make_signed_long((signed long)v->long_double_value);
    }
    if (t == TYPE_UNSIGNED_LONG)
    {
        if (v->type == TYPE_BOOL)
            return constant_value_make_unsigned_long((unsigned long)v->bool_value);
        if (v->type == TYPE_SIGNED_CHAR)
            return constant_value_make_unsigned_long((unsigned long)v->signed_char_value);
        if (v->type == TYPE_UNSIGNED_CHAR)
            return constant_value_make_unsigned_long((unsigned long)v->unsigned_char_value);
        if (v->type == TYPE_SIGNED_SHORT)
            return constant_value_make_unsigned_long((unsigned long)v->signed_short_value);
        if (v->type == TYPE_UNSIGNED_SHORT)
            return constant_value_make_unsigned_long((unsigned long)v->unsigned_short_value);
        if (v->type == TYPE_SIGNED_INT)
            return constant_value_make_unsigned_long((unsigned long)v->signed_int_value);
        if (v->type == TYPE_UNSIGNED_INT)
            return constant_value_make_unsigned_long((unsigned long)v->unsigned_int_value);
        if (v->type == TYPE_SIGNED_LONG)
            return constant_value_make_unsigned_long((unsigned long)v->signed_long_value);
        if (v->type == TYPE_SIGNED_LONG_LONG)
            return constant_value_make_unsigned_long((unsigned long)v->signed_long_long_value);
        if (v->type == TYPE_UNSIGNED_LONG_LONG)
            return constant_value_make_unsigned_long((unsigned long)v->unsigned_long_long_value);
        if (v->type == TYPE_FLOAT)
            return constant_value_make_unsigned_long((unsigned long)v->float_value);
        if (v->type == TYPE_DOUBLE)
            return constant_value_make_unsigned_long((unsigned long)v->double_value);
        if (v->type == TYPE_LONG_DOUBLE)
            return constant_value_make_unsigned_long((unsigned long)v->long_double_value);
    }
    if (t == TYPE_SIGNED_LONG_LONG)
    {
        if (v->type == TYPE_BOOL)
            return constant_value_make_signed_long_long((signed long long)v->bool_value);
        if (v->type == TYPE_SIGNED_CHAR)
            return constant_value_make_signed_long_long((signed long long)v->signed_char_value);
        if (v->type == TYPE_UNSIGNED_CHAR)
            return constant_value_make_signed_long_long((signed long long)v->unsigned_char_value);
        if (v->type == TYPE_SIGNED_SHORT)
            return constant_value_make_signed_long_long((signed long long)v->signed_short_value);
        if (v->type == TYPE_UNSIGNED_SHORT)
            return constant_value_make_signed_long_long((signed long long)v->unsigned_short_value);
        if (v->type == TYPE_SIGNED_INT)
            return constant_value_make_signed_long_long((signed long long)v->signed_int_value);
        if (v->type == TYPE_UNSIGNED_INT)
            return constant_value_make_signed_long_long((signed long long)v->unsigned_int_value);
        if (v->type == TYPE_SIGNED_LONG)
            return constant_value_make_signed_long_long((signed long long)v->signed_long_value);
        if (v->type == TYPE_UNSIGNED_LONG)
            return constant_value_make_signed_long_long((signed long long)v->unsigned_long_value);
        if (v->type == TYPE_UNSIGNED_LONG_LONG)
            return constant_value_make_signed_long_long((signed long long)v->unsigned_long_long_value);
        if (v->type == TYPE_FLOAT)
            return constant_value_make_signed_long_long((signed long long)v->float_value);
        if (v->type == TYPE_DOUBLE)
            return constant_value_make_signed_long_long((signed long long)v->double_value);
        if (v->type == TYPE_LONG_DOUBLE)
            return constant_value_make_signed_long_long((signed long long)v->long_double_value);
    }
    if (t == TYPE_UNSIGNED_LONG_LONG)
    {
        if (v->type == TYPE_BOOL)
            return constant_value_make_unsigned_long_long((unsigned long long)v->bool_value);
        if (v->type == TYPE_SIGNED_CHAR)
            return constant_value_make_unsigned_long_long((unsigned long long)v->signed_char_value);
        if (v->type == TYPE_UNSIGNED_CHAR)
            return constant_value_make_unsigned_long_long((unsigned long long)v->unsigned_char_value);
        if (v->type == TYPE_SIGNED_SHORT)
            return constant_value_make_unsigned_long_long((unsigned long long)v->signed_short_value);
        if (v->type == TYPE_UNSIGNED_SHORT)
            return constant_value_make_unsigned_long_long((unsigned long long)v->unsigned_short_value);
        if (v->type == TYPE_SIGNED_INT)
            return constant_value_make_unsigned_long_long((unsigned long long)v->signed_int_value);
        if (v->type == TYPE_UNSIGNED_INT)
            return constant_value_make_unsigned_long_long((unsigned long long)v->unsigned_int_value);
        if (v->type == TYPE_SIGNED_LONG)
            return constant_value_make_unsigned_long_long((unsigned long long)v->signed_long_value);
        if (v->type == TYPE_UNSIGNED_LONG)
            return constant_value_make_unsigned_long_long((unsigned long long)v->unsigned_long_value);
        if (v->type == TYPE_SIGNED_LONG_LONG)
            return constant_value_make_unsigned_long_long((unsigned long long)v->signed_long_long_value);
        if (v->type == TYPE_FLOAT)
            return constant_value_make_unsigned_long_long((unsigned long long)v->float_value);
        if (v->type == TYPE_DOUBLE)
            return constant_value_make_unsigned_long_long((unsigned long long)v->double_value);
        if (v->type == TYPE_LONG_DOUBLE)
            return constant_value_make_unsigned_long_long((unsigned long long)v->long_double_value);
    }
    if (t == TYPE_FLOAT)
    {
        if (v->type == TYPE_BOOL)
            return constant_value_make_float((float)v->bool_value);
        if (v->type == TYPE_SIGNED_CHAR)
            return constant_value_make_float((float)v->signed_char_value);
        if (v->type == TYPE_UNSIGNED_CHAR)
            return constant_value_make_float((float)v->unsigned_char_value);
        if (v->type == TYPE_SIGNED_SHORT)
            return constant_value_make_float((float)v->signed_short_value);
        if (v->type == TYPE_UNSIGNED_SHORT)
            return constant_value_make_float((float)v->unsigned_short_value);
        if (v->type == TYPE_SIGNED_INT)
            return constant_value_make_float((float)v->signed_int_value);
        if (v->type == TYPE_UNSIGNED_INT)
            return constant_value_make_float((float)v->unsigned_int_value);
        if (v->type == TYPE_SIGNED_LONG)
            return constant_value_make_float((float)v->signed_long_value);
        if (v->type == TYPE_UNSIGNED_LONG)
            return constant_value_make_float((float)v->unsigned_long_value);
        if (v->type == TYPE_SIGNED_LONG_LONG)
            return constant_value_make_float((float)v->signed_long_long_value);
        if (v->type == TYPE_UNSIGNED_LONG_LONG)
            return constant_value_make_float((float)v->unsigned_long_long_value);
        if (v->type == TYPE_DOUBLE)
            return constant_value_make_float((float)v->double_value);
        if (v->type == TYPE_LONG_DOUBLE)
            return constant_value_make_float((float)v->long_double_value);
    }
    if (t == TYPE_DOUBLE)
    {
        if (v->type == TYPE_BOOL)
            return constant_value_make_double((double)v->bool_value);
        if (v->type == TYPE_SIGNED_CHAR)
            return constant_value_make_double((double)v->signed_char_value);
        if (v->type == TYPE_UNSIGNED_CHAR)
            return constant_value_make_double((double)v->unsigned_char_value);
        if (v->type == TYPE_SIGNED_SHORT)
            return constant_value_make_double((double)v->signed_short_value);
        if (v->type == TYPE_UNSIGNED_SHORT)
            return constant_value_make_double((double)v->unsigned_short_value);
        if (v->type == TYPE_SIGNED_INT)
            return constant_value_make_double((double)v->signed_int_value);
        if (v->type == TYPE_UNSIGNED_INT)
            return constant_value_make_double((double)v->unsigned_int_value);
        if (v->type == TYPE_SIGNED_LONG)
            return constant_value_make_double((double)v->signed_long_value);
        if (v->type == TYPE_UNSIGNED_LONG)
            return constant_value_make_double((double)v->unsigned_long_value);
        if (v->type == TYPE_SIGNED_LONG_LONG)
            return constant_value_make_double((double)v->signed_long_long_value);
        if (v->type == TYPE_UNSIGNED_LONG_LONG)
            return constant_value_make_double((double)v->unsigned_long_long_value);
        if (v->type == TYPE_FLOAT)
            return constant_value_make_double((double)v->float_value);
        if (v->type == TYPE_LONG_DOUBLE)
            return constant_value_make_double((double)v->long_double_value);
    }
    if (t == TYPE_LONG_DOUBLE)
    {
        if (v->type == TYPE_BOOL)
            return constant_value_make_long_double((long double)v->bool_value);
        if (v->type == TYPE_SIGNED_CHAR)
            return constant_value_make_long_double((long double)v->signed_char_value);
        if (v->type == TYPE_UNSIGNED_CHAR)
            return constant_value_make_long_double((long double)v->unsigned_char_value);
        if (v->type == TYPE_SIGNED_SHORT)
            return constant_value_make_long_double((long double)v->signed_short_value);
        if (v->type == TYPE_UNSIGNED_SHORT)
            return constant_value_make_long_double((long double)v->unsigned_short_value);
        if (v->type == TYPE_SIGNED_INT)
            return constant_value_make_long_double((long double)v->signed_int_value);
        if (v->type == TYPE_UNSIGNED_INT)
            return constant_value_make_long_double((long double)v->unsigned_int_value);
        if (v->type == TYPE_SIGNED_LONG)
            return constant_value_make_long_double((long double)v->signed_long_value);
        if (v->type == TYPE_UNSIGNED_LONG)
            return constant_value_make_long_double((long double)v->unsigned_long_value);
        if (v->type == TYPE_SIGNED_LONG_LONG)
            return constant_value_make_long_double((long double)v->signed_long_long_value);
        if (v->type == TYPE_UNSIGNED_LONG_LONG)
            return constant_value_make_long_double((long double)v->unsigned_long_long_value);
        if (v->type == TYPE_FLOAT)
            return constant_value_make_long_double((long double)v->float_value);
        if (v->type == TYPE_DOUBLE)
            return constant_value_make_long_double((long double)v->double_value);
    }
    struct constant_value empty = { 0 };
    return empty;
}



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

#pragma safety enable



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

//#pragma once



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

//#pragma once


struct parser_ctx;


enum type_category
{
    TYPE_CATEGORY_ITSELF,
    TYPE_CATEGORY_FUNCTION,
    TYPE_CATEGORY_ARRAY,
    TYPE_CATEGORY_POINTER,
};


enum attribute_flags
{
    STD_ATTRIBUTE_NONE = 0,
    STD_ATTRIBUTE_DEPRECATED = 1 << 0,
    STD_ATTRIBUTE_FALLTHROUGH = 1 << 1,
    STD_ATTRIBUTE_MAYBE_UNUSED = 1 << 2,
    STD_ATTRIBUTE_NODISCARD = 1 << 3,
    STD_ATTRIBUTE_NORETURN = 1 << 4,
    STD_ATTRIBUTE_UNSEQUENCED = 1 << 5,
    STD_ATTRIBUTE_REPRODUCIBLE = 1 << 6,
    
    /*
     1 == 2 results in int in C
     lets add extra flag here
     not sure what is the best place to put in
     type specifier my generate some error
    */
    CAKE_HIDDEN_ATTRIBUTE_LIKE_BOOL = 1 << 25,
    // 'a'
    CAKE_HIDDEN_ATTRIBUTE_LIKE_CHAR = 1 << 26
};

enum type_specifier_flags
{
    TYPE_SPECIFIER_NONE = 0,
    TYPE_SPECIFIER_VOID = 1 << 0,
    TYPE_SPECIFIER_CHAR = 1 << 1,
    TYPE_SPECIFIER_SHORT = 1 << 2,
    TYPE_SPECIFIER_INT = 1 << 3,
    TYPE_SPECIFIER_LONG = 1 << 4,

    TYPE_SPECIFIER_FLOAT = 1 << 5,
    TYPE_SPECIFIER_DOUBLE = 1 << 6,
    TYPE_SPECIFIER_SIGNED = 1 << 7,
    TYPE_SPECIFIER_UNSIGNED = 1 << 8,
    TYPE_SPECIFIER_BOOL = 1 << 9,
    TYPE_SPECIFIER_COMPLEX = 1 << 10,
    TYPE_SPECIFIER_DECIMAL32 = 1 << 11,
    TYPE_SPECIFIER_DECIMAL64 = 1 << 12,
    TYPE_SPECIFIER_DECIMAL128 = 1 << 13,
    TYPE_SPECIFIER_ATOMIC = 1 << 14,
    TYPE_SPECIFIER_STRUCT_OR_UNION = 1 << 15,
    TYPE_SPECIFIER_ENUM = 1 << 16,
    TYPE_SPECIFIER_TYPEDEF = 1 << 17,

    //MICROSOFT
    TYPE_SPECIFIER_INT8 = 1 << 18,
    TYPE_SPECIFIER_INT16 = 1 << 19,
    TYPE_SPECIFIER_INT32 = 1 << 20,
    TYPE_SPECIFIER_INT64 = 1 << 21,

    TYPE_SPECIFIER_LONG_LONG = 1 << 22,

    TYPE_SPECIFIER_TYPEOF = 1 << 23,

    TYPE_SPECIFIER_NULLPTR_T = 1 << 24,
};

#ifdef _WIN32

    #define CAKE_WCHAR_T_TYPE_SPECIFIER (TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_SHORT)

    #ifdef _WIN64
    #define  CAKE_SIZE_T_TYPE_SPECIFIER (TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT64)    
    #else
    #define  CAKE_SIZE_T_TYPE_SPECIFIER (TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT)    
    #endif

#else 

    #define CAKE_WCHAR_T_TYPE_SPECIFIER (TYPE_SPECIFIER_INT)

    #ifdef __x86_64__
    /* 64-bit */
    #define  CAKE_SIZE_T_TYPE_SPECIFIER (TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_LONG)    
    #else
    #define  CAKE_SIZE_T_TYPE_SPECIFIER (TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT)    
    #endif


#endif


enum type_qualifier_flags
{
    TYPE_QUALIFIER_NONE,
    TYPE_QUALIFIER_CONST = 1 << 0,
    TYPE_QUALIFIER_RESTRICT = 1 << 1,
    TYPE_QUALIFIER_VOLATILE = 1 << 2,
    TYPE_QUALIFIER__ATOMIC = 1 << 3,

    /*ownership extensions*/
    TYPE_QUALIFIER_OWNER = 1 << 4,
    TYPE_QUALIFIER_OBJ_OWNER = 1 << 5,
    TYPE_QUALIFIER_VIEW = 1 << 6,
    TYPE_QUALIFIER_NULLABLE = 1 << 7,
    
    TYPE_QUALIFIER_OUT = 1 << 9,
};

enum storage_class_specifier_flags
{
    STORAGE_SPECIFIER_NONE = 0,
    STORAGE_SPECIFIER_TYPEDEF = 1 << 0,
    STORAGE_SPECIFIER_EXTERN = 1 << 1,
    STORAGE_SPECIFIER_STATIC = 1 << 2,
    STORAGE_SPECIFIER_THREAD_LOCAL = 1 << 3,
    STORAGE_SPECIFIER_AUTO = 1 << 4,
    STORAGE_SPECIFIER_REGISTER = 1 << 5,
    STORAGE_SPECIFIER_CONSTEXPR = 1 << 6,

    /*extra flag just to annotate this*/
    STORAGE_SPECIFIER_CONSTEXPR_STATIC = 1 << 7,

    /*it is a function parameter*/
    STORAGE_SPECIFIER_PARAMETER = 1 << 11,

    STORAGE_SPECIFIER_AUTOMATIC_STORAGE = 1 << 12,
    STORAGE_SPECIFIER_FUNCTION_RETURN = 1 << 13,
    STORAGE_SPECIFIER_FUNCTION_RETURN_NODISCARD = 1 << 14,
};


struct declarator;
struct type;

enum assigment_type
{
    ASSIGMENT_TYPE_RETURN,    // T f() { return b; }
    ASSIGMENT_TYPE_PARAMETER, // void f(T a); f(b);
    ASSIGMENT_TYPE_OBJECTS,   // a = b
};


struct type_list {
    struct type* _Owner _Opt head;
    struct type* _Opt tail;
};

void type_list_destroy(struct type_list* _Obj_owner p_type_list);
void type_list_push_back(struct type_list* books, struct type* _Owner new_book);
void type_list_push_front(struct type_list* books, struct type* _Owner new_book);


struct param;

struct param_list {
    bool is_var_args;
    bool is_void;
    struct param* _Owner _Opt head;
    struct param* _Opt tail;
};

void param_list_destroy(struct param_list* _Obj_owner p);
void param_list_add(struct param_list*  p, struct param* _Owner p_item);

struct type
{
    enum type_category category;

    enum attribute_flags  attributes_flags;
    enum type_specifier_flags type_specifier_flags;
    enum type_qualifier_flags type_qualifier_flags;
    enum storage_class_specifier_flags storage_class_specifier_flags;

    const char* _Owner _Opt name_opt;

    struct struct_or_union_specifier* _Opt struct_or_union_specifier;
    const struct enum_specifier* _Opt enum_specifier;

    //Expression used as array size. Can be constant or not constant (VLA)
    const struct expression* _Opt array_num_elements_expression;

    int num_of_elements;
    bool static_array;

    /*
      address_of is true when the type is created by address of operator.
      This is used to create _Obj_owner pointer.
    */
    bool address_of;

    struct param_list params;
    struct type* _Owner _Opt next;
};

const struct param_list* _Opt type_get_func_or_func_ptr_params(const struct type* p_type);

struct param {
    struct type type;
    struct param* _Owner _Opt next;
};

void print_type(struct osstream* ss, const  struct type* type);
void print_type_no_names(struct osstream* ss, const struct type* p_type);

void print_item(struct osstream* ss, bool* first, const char* item);
struct type type_dup(const struct type* p_type);
void type_set(struct type* a, const struct type* b);
void type_destroy(_Opt struct type* _Obj_owner p_type);

struct type type_common(const struct type* p_type1, const struct type* p_type2);
struct type get_array_item_type(const struct type* p_type);
struct type type_remove_pointer(const struct type* p_type);

bool type_is_essential_bool(const struct type* p_type);
bool type_is_essential_char(const struct type* p_type);

bool type_is_enum(const struct type* p_type);
bool type_is_array(const struct type* p_type);

bool type_is_out(const struct type* p_type);
bool type_is_const(const struct type* p_type);
bool type_is_nullable(const struct type* p_type, bool nullable_enabled);
bool type_is_view(const struct type* p_type);

bool type_is_owner(const struct type* p_type);
bool type_is_obj_owner(const struct type* p_type);
bool type_is_any_owner(const struct type* p_type);

bool type_is_pointer_to_const(const struct type* p_type);
bool type_is_pointer(const struct type* p_type);
bool type_is_pointer_to_out(const struct type* p_type);
bool type_is_out(const struct type* p_type);
bool type_is_nullptr_t(const struct type* p_type);
bool type_is_void_ptr(const struct type* p_type);
bool type_is_integer(const struct type* p_type);
bool type_is_unsigned_integer(const struct type* p_type);
bool type_is_signed_integer(const struct type* p_type);
bool type_is_floating_point(const struct type* p_type);
int type_get_integer_rank(const struct type* p_type1);

bool type_is_arithmetic(const struct type* p_type);

bool type_is_struct_or_union(const struct type* p_type);
bool type_is_void(const struct type* p_type);
bool type_is_function_or_function_pointer(const struct type* p_type);
bool type_is_function(const struct type* p_type);
bool type_is_nodiscard(const struct type* p_type);

bool type_is_deprecated(const struct type* p_type);
bool type_is_maybe_unused(const struct type* p_type);
bool type_is_pointer_or_array(const struct type* p_type);
bool type_is_same(const struct type* a, const struct type* b, bool compare_qualifiers);
bool type_is_scalar(const struct type* p_type);
bool type_has_attribute(const struct type* p_type, enum attribute_flags attributes);
bool type_is_bool(const struct type* p_type);
bool type_is_decimal128(const struct type* p_type);
bool type_is_decimal64(const struct type* p_type);
bool type_is_decimal32(const struct type* p_type);
bool type_is_long_double(const struct type* p_type);
bool type_is_double(const struct type* p_type);
bool type_is_float(const struct type* p_type);

bool type_is_vla(const struct type* p_type);

struct type type_get_enum_type(const struct type* p_type);

struct argument_expression;
void check_argument_and_parameter(struct parser_ctx* ctx,
    struct argument_expression* current_argument,
    struct type* paramer_type,
    int param_num);

struct type type_convert_to(const struct type* p_type, enum language_version target);
struct type type_lvalue_conversion(const struct type* p_type, bool nullchecks_enabled);
void type_remove_qualifiers(struct type* p_type);
void type_add_const(struct type* p_type);
void type_swap(struct type* a, struct type* b);
void type_integer_promotion(struct type* a);


struct type type_remove_pointer(const struct type* p_type);
struct type get_array_item_type(const struct type* p_type);

struct type type_param_array_to_pointer(const struct type* p_type, bool null_checks_enabled);

struct type type_make_literal_string(int size, enum type_specifier_flags chartype);
struct type type_make_int();
struct type type_make_int_bool_like();
struct type type_make_size_t();
struct type type_make_long_double();
struct type type_make_double();
struct type type_make_float();


struct type type_make_enumerator(const struct enum_specifier* enum_specifier);
struct type make_void_type();
struct type make_void_ptr_type();
struct type make_size_t_type();

struct type get_function_return_type(const struct type* p_type);

size_t type_get_sizeof(const struct type* p_type);

size_t type_get_alignof(const struct type* p_type);

struct type type_add_pointer(const struct type* p_type, bool null_checks_enabled);
void type_print(const struct type* a);
void type_println(const struct type* a);

enum type_category type_get_category(const struct type* p_type);
void print_type_qualifier_specifiers(struct osstream* ss, const struct type* type);

void type_visit_to_mark_anonymous(struct type* p_type);

void type_set_qualifiers_using_declarator(struct type* p_type, struct declarator* pdeclarator);
void type_merge_qualifiers_using_declarator(struct type* p_type, struct declarator* pdeclarator);

void print_type_declarator(struct osstream* ss, const struct type* p_type);
void type_remove_names(struct type* p_type);
const struct type* type_get_specifer_part(const struct type* p_type);


struct parser_ctx;

enum expression_type
{
    EXPRESSION_TYPE_INVALID, 

    PRIMARY_EXPRESSION_ENUMERATOR,
    PRIMARY_EXPRESSION_DECLARATOR,
    PRIMARY_EXPRESSION_STRING_LITERAL,
    PRIMARY_EXPRESSION__FUNC__, /*predefined identifier __func__ */
    PRIMARY_EXPRESSION_CHAR_LITERAL,
    PRIMARY_EXPRESSION_PREDEFINED_CONSTANT, /*true false*/
    PRIMARY_EXPRESSION_GENERIC,
    PRIMARY_EXPRESSION_NUMBER,
    PRIMARY_EXPRESSION_PARENTESIS,

    POSTFIX_EXPRESSION_FUNCTION_LITERAL,
    POSTFIX_EXPRESSION_COMPOUND_LITERAL,

    POSTFIX_FUNCTION_CALL, // ( ) 
    POSTFIX_ARRAY, // [ ]
    POSTFIX_DOT, // .
    POSTFIX_ARROW, // .
    POSTFIX_INCREMENT,
    POSTFIX_DECREMENT,


    UNARY_EXPRESSION_SIZEOF_EXPRESSION,
    UNARY_EXPRESSION_SIZEOF_TYPE,
    UNARY_EXPRESSION_NELEMENTSOF_TYPE,

    UNARY_EXPRESSION_TRAITS,
    UNARY_EXPRESSION_IS_SAME,
    UNARY_DECLARATOR_ATTRIBUTE_EXPR,
    UNARY_EXPRESSION_ALIGNOF,
    UNARY_EXPRESSION_ASSERT,

    UNARY_EXPRESSION_INCREMENT,
    UNARY_EXPRESSION_DECREMENT,

    UNARY_EXPRESSION_NOT,
    UNARY_EXPRESSION_BITNOT,
    UNARY_EXPRESSION_NEG,
    UNARY_EXPRESSION_PLUS,
    UNARY_EXPRESSION_CONTENT,
    UNARY_EXPRESSION_ADDRESSOF,

    CAST_EXPRESSION,

    MULTIPLICATIVE_EXPRESSION_MULT,
    MULTIPLICATIVE_EXPRESSION_DIV,
    MULTIPLICATIVE_EXPRESSION_MOD,

    ADDITIVE_EXPRESSION_PLUS,
    ADDITIVE_EXPRESSION_MINUS,

    SHIFT_EXPRESSION_RIGHT,
    SHIFT_EXPRESSION_LEFT,

    RELATIONAL_EXPRESSION_BIGGER_THAN,
    RELATIONAL_EXPRESSION_LESS_THAN,
    RELATIONAL_EXPRESSION_BIGGER_OR_EQUAL_THAN,
    RELATIONAL_EXPRESSION_LESS_OR_EQUAL_THAN,

    EQUALITY_EXPRESSION_EQUAL,
    EQUALITY_EXPRESSION_NOT_EQUAL,

    AND_EXPRESSION,
    EXCLUSIVE_OR_EXPRESSION,
    INCLUSIVE_OR_EXPRESSION,

    LOGICAL_OR_EXPRESSION,
    LOGICAL_AND_EXPRESSION,
    ASSIGNMENT_EXPRESSION,

    CONDITIONAL_EXPRESSION,
};

struct argument_expression_list
{
    /*
     argument-expression-list:
        assignment-expression
        argument-expression-list , assignment-expression
    */
    struct argument_expression* _Owner _Opt head;
    struct argument_expression* _Opt tail;
};

void argument_expression_list_destroy(struct argument_expression_list* _Obj_owner p);
void argument_expression_list_push(struct argument_expression_list* list, struct argument_expression* _Owner p);

struct generic_association
{
    /*
     generic-association:
       type-name : assignment-expression
       "default" : assignment-expression
    */

    struct type type;
    struct type_name* _Owner _Opt p_type_name;
    struct expression* _Owner expression;

    struct token* first_token;
    struct token* last_token;

    struct generic_association* _Owner _Opt next;
};

void generic_association_delete(struct generic_association* _Owner _Opt p);

struct generic_assoc_list
{
    struct generic_association* _Owner _Opt head;
    struct generic_association* _Opt tail;
};

void generic_assoc_list_add(struct generic_assoc_list* p, struct generic_association* _Owner item);
void generic_assoc_list_destroy(struct generic_assoc_list* _Obj_owner p);

struct generic_selection
{
    /*
      generic-selection:
        "_Generic" ( assignment-expression , generic-assoc-list )
    */


    /*
      Extension
      generic-selection:
        "_Generic" ( generic-argument, generic-assoc-list )

        generic-argument:
          assignment-expression
          type-name
    */


    struct expression* _Owner _Opt expression;
    struct type_name* _Owner _Opt type_name;
    /*
    * Points to the matching expression
    */
    struct expression* _Opt p_view_selected_expression;

    struct generic_assoc_list generic_assoc_list;
    struct token* first_token;
    struct token* last_token;
};

void generic_selection_delete(struct generic_selection* _Owner _Opt p);

struct expression
{
    enum expression_type expression_type;
    struct type type;

    struct constant_value constant_value;

    struct type_name* _Owner _Opt type_name;

    struct braced_initializer* _Owner _Opt braced_initializer;
    struct compound_statement* _Owner _Opt compound_statement; //function literal (lambda)
    struct generic_selection* _Owner _Opt generic_selection; //_Generic

    struct token* first_token;
    struct token* last_token;


    /*if expression is an identifier it points to its declaration*/
    struct declarator* _Opt declarator;
    int member_index; //used in post_fix .

    /*se for POSTFIX_FUNCTION_CALL post*/
    struct argument_expression_list argument_expression_list; //este node eh uma  chamada de funcao

    struct expression* _Owner _Opt condition_expr;
    struct expression* _Owner _Opt left;
    struct expression* _Owner _Opt right;

    bool is_assignment_expression;
};

//built-in semantics
bool expression_is_malloc(const struct expression* p);
bool expression_is_calloc(const struct expression* p);

void expression_delete(struct expression* _Owner _Opt p);

struct expression* _Owner _Opt assignment_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt constant_expression(struct parser_ctx* ctx, bool show_error_if_not_constant);
bool expression_is_subjected_to_lvalue_conversion(const struct expression*);

bool expression_is_lvalue(const struct expression* expr);

bool expression_is_one(const struct expression* expression);
bool expression_is_zero(const struct expression* expression);
bool expression_is_null_pointer_constant(const struct expression* expression);
void expression_evaluate_equal_not_equal(const struct expression* left,
    const struct expression* right,
    struct expression* result,
    int op,
    bool disabled);

void check_diferent_enuns(struct parser_ctx* ctx,
                          const struct token* operator_token,
                          const struct expression* left,
                          const struct expression* right,
                          const char* message);

void check_assigment(struct parser_ctx* ctx,
    const struct type* left_type,
    const struct expression* right,
    enum assigment_type assigment_type);

void check_comparison(struct parser_ctx* ctx,
    struct expression* p_a_expression,
    struct expression* p_b_expression,
    const struct token* op_token);


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

//#pragma once



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/


/*
   Object represents "memory" and state. Used by flow analysis
*/

//#pragma once


struct flow_visit_ctx;

extern unsigned int s_visit_number; //creates a unique number


enum object_state
{
    /*
       Not applicable. The state cannot be used.
       struct...
       TODO we need empty state when object does not exist
       and the merge it is not a problem
       merge with nothing then
    */
    OBJECT_STATE_NOT_APPLICABLE = 0,

    OBJECT_STATE_UNINITIALIZED = 1 << 0,

    OBJECT_STATE_NULL = 1 << 1,
    OBJECT_STATE_NOT_NULL = 1 << 2,

    //means not-null moved at same time
    OBJECT_STATE_MOVED = 1 << 3,

    OBJECT_STATE_ZERO = 1 << 5,
    OBJECT_STATE_NOT_ZERO = 1 << 6,

    OBJECT_STATE_LIFE_TIME_ENDED = 1 << 7,
};


struct objects {
    struct flow_object* _Owner* _Owner _Opt data;
    int size;
    int capacity;
};

void objects_clear(struct objects* p);
void objects_destroy(struct objects* _Obj_owner p);
int objects_push_back(struct objects* p, struct flow_object* _Owner p_object);
const struct flow_object* objects_find(const struct objects* p, const struct flow_object* p_object);


struct objects_view {
    struct flow_object** _Owner _Opt data;
    int size;
    int capacity;
};

void objects_view_destroy(struct objects_view* _Obj_owner p);
int objects_view_push_back(struct objects_view* p, struct flow_object* p_object);
bool objects_view_find(const struct objects_view* p, const struct flow_object* p_object);
void objects_view_copy(struct objects_view* dest, const struct objects_view* source);
void objects_view_merge(struct objects_view* dest, const struct objects_view* source);
void objects_view_clear(struct objects_view* p);


struct flow_object_state {
    const char* dbg_name;
    int state_number;

    struct flow_object* _Opt pointed;
    enum object_state state;
    struct objects_view alternatives;
    struct flow_object_state* _Owner _Opt next;
};

void flow_object_state_copy(struct flow_object_state* to, const struct flow_object_state* from);
void flow_object_state_delete(struct flow_object_state* _Owner _Opt p);


/*
  Used in flow analysis to represent the object instance
*/
struct flow_object
{
    //used to avoid infinite recursion
    unsigned int visit_number;

    struct flow_object* _Opt parent;

    /*object are the result of expressions or they are declarators*/
    const struct declarator* _Opt p_declarator_origin;
    const struct expression* _Opt p_expression_origin;

    struct objects_view members;

    struct flow_object_state current;

    int id; //helps debugging
    bool is_temporary;
};

void flow_object_set_is_moved(struct flow_object* p_object);
void flow_object_set_can_be_uninitialized(struct flow_object* p_object);
void flow_object_set_is_unitialized(struct flow_object* p_object);
void flow_object_update_current(struct flow_object* p);
void flow_object_set_current_state_to_can_be_null(struct flow_object* p);
void flow_object_set_current_state_to_is_null(struct flow_object* p);

int flow_object_add_state(struct flow_object* p, struct flow_object_state* _Owner pnew);

bool flow_object_is_zero_or_null(const struct flow_object* p_object);

bool flow_object_is_not_null(const struct flow_object* p);
bool flow_object_can_be_not_null_or_moved(const struct flow_object* p);

bool flow_object_is_null(const struct flow_object* p);
bool flow_object_can_be_null(const struct flow_object* p);
bool flow_object_can_be_moved(const struct flow_object* p);
bool flow_object_can_be_zero(const struct flow_object* p);



bool flow_object_is_not_zero(const struct flow_object* p);
bool flow_object_is_zero(const struct flow_object* p);

bool flow_object_is_uninitialized(const struct flow_object* p);
bool flow_object_can_be_uninitialized(const struct flow_object* p);

bool flow_object_can_have_its_lifetime_ended(const struct flow_object* p);

void flow_object_print_state(struct flow_object* p);

void object_set_pointer(struct flow_object* p_object, struct flow_object* p_object2);

void object_destroy(struct flow_object* _Obj_owner p);
void object_delete(struct flow_object* _Owner _Opt p);
void object_swap(struct flow_object* a, struct flow_object* b);
void print_object_line(struct flow_object* p_object, int cols);
void print_object_state_to_str(enum object_state e, char str[], int sz);

struct declarator;
struct flow_object* _Opt make_object(struct flow_visit_ctx* ctx,
                                     struct type* p_type,
                                     const struct declarator* _Opt p_declarator_opt,
                                     const struct expression* _Opt p_expression_origin);

void flow_object_add_new_state_as_a_copy_of_current_state(struct flow_object* object, const char* name, int state_number);
struct token* object_get_token(const struct flow_object* object);
void object_remove_state(struct flow_object* object, int state_number);


int object_restore_current_state_from(struct flow_object* object, int state_number);

void object_merge_state(struct flow_object* pdest, struct flow_object* object1, struct flow_object* object2);


struct flow_visit_ctx;
struct token;


void print_object(struct type* p_type, struct flow_object* p_object, bool short_version);

struct marker;

void flow_check_assignment(struct flow_visit_ctx* ctx,
    const struct token* error_position,
    const struct marker* p_a_marker,
    const struct marker* p_b_marker,
    enum  assigment_type assigment_type,
    bool check_uninitialized_b,
    bool a_type_is_view,
    bool a_type_is_nullable,
    struct type* p_a_type, struct flow_object* p_a_object,
    struct type* p_b_type, struct flow_object* p_b_object,
    bool * _Opt set_argument_to_unkown);

void object_set_end_of_lifetime(struct type* p_type, struct flow_object* p_object);
void object_set_zero(struct type* p_type, struct flow_object* p_object);
void object_set_uninitialized(struct type* p_type, struct flow_object* p_object);
void object_set_moved(struct type* p_type, struct flow_object* p_object);

void object_set_unknown(struct type* p_type, bool t_is_nullable, struct flow_object* p_object, bool nullable_enabled);


void checked_read_object(struct flow_visit_ctx* ctx,
    struct type* p_type,
    bool is_nullable,
    struct flow_object* p_object,
    const struct token* position_token,
    const struct marker* p_marker,
    bool check_pointed_object);


void flow_end_of_block_visit(struct flow_visit_ctx* ctx,
    struct type* p_type,
    bool type_is_view,
    struct flow_object* p_object,
    const struct token* position_token,
    const char* previous_names);


bool object_is_expansible(const struct flow_object* p_object);
void expand_pointer_object(struct flow_visit_ctx* ctx, struct type* p_type, struct flow_object* p_object);
void object_push_states_from(const struct flow_object* p_object_from, struct flow_object* p_object_to);

struct flow_object* _Opt expression_get_object(struct flow_visit_ctx* ctx, struct expression* p_expression, bool nullable_enabled);




struct scope
{
    int scope_level;
    struct hash_map tags;
    struct hash_map variables;

    struct scope* _Opt next;
    struct scope* _Opt previous;
};

void scope_destroy(struct scope* _Obj_owner p);

struct scope_list
{
    struct scope* _Opt head;
    struct scope* _Opt tail;
};
void scope_list_push(struct scope_list* list, struct scope* s);
void scope_list_pop(struct scope_list* list);

struct report
{
    int no_files;
    double cpu_time_used_sec;
    int error_count;
    int warnings_count;
    int info_count;

    bool test_mode;
    int test_failed;
    int test_succeeded;

    /*
     Warnings are removed (-test-mode) on demand at next line,
     but we can have more than one warning at same line then we need this array
    */
    enum diagnostic_id last_diagnostics_ids[2];

    //this error is expected in test-mode
    //it is used when the error aborts parsing
    enum diagnostic_id fatal_error_expected;

    /*
      direct commands like -autoconfig doesnt use report
    */
    bool ignore_this_report;
};

struct switch_value
{
    long long value;
    struct label* _Opt p_label;
    struct switch_value* _Owner _Opt next;
};

struct  switch_value_list
{
    struct switch_value* _Owner _Opt head;
    struct switch_value* _Opt tail;
    struct switch_value* _Owner _Opt p_default;
};

void switch_value_destroy(struct switch_value_list* _Obj_owner list);
void switch_value_list_push(struct switch_value_list* list, struct switch_value* _Owner pnew);
struct switch_value* _Opt switch_value_list_find(struct switch_value_list* list, long long value);

struct parser_ctx
{
    struct options options;

    /*
      file scope -> function params -> function -> inner scope
    */
    struct scope_list scopes;

    /*
    * Points to the function we're in. Or null in file scope.
    */
    struct declaration* _Opt p_current_function_opt;

    /*
    * Points to the try-block we're in. Or null.
    */
    const struct try_statement* _Opt p_current_try_statement_opt;

    /*
    * Points to the selection_statement we're in. Or null.
    */
    const struct selection_statement* _Opt p_current_selection_statement;

    struct  switch_value_list* _Opt p_switch_value_list;

    FILE* _Owner _Opt sarif_file;
    unsigned int sarif_entries;

    _View struct token_list input_list;
    struct token* _Opt current;
    struct token* _Opt previous;
    int try_catch_block_index;

    /*
       Expression inside sizeof etc.. are not evaluated
    */
    bool evaluation_is_disabled;

    bool inside_generic_association;


    struct report* p_report;

};

///////////////////////////////////////////////////////

void parser_ctx_destroy(struct parser_ctx* _Obj_owner ctx);


struct token* _Opt parser_look_ahead(const struct parser_ctx* ctx);

void parser_match(struct parser_ctx* ctx);
NODISCARD
int parser_match_tk(struct parser_ctx* ctx, enum token_type type);

struct token* _Opt previous_parser_token(const struct token* token);
struct declarator* _Opt find_declarator(const struct parser_ctx* ctx, const char* lexeme, struct scope** _Opt ppscope_opt);
struct enumerator* _Opt find_enumerator(const struct parser_ctx* ctx, const char* lexeme, struct scope** _Opt ppscope_opt);
struct map_entry* _Opt find_variables(const struct parser_ctx* ctx, const char* lexeme, struct scope* _Opt * _Opt ppscope_opt);

struct struct_or_union_specifier* _Opt find_struct_or_union_specifier(struct parser_ctx* ctx, const char* lexeme);

void print_scope(struct scope_list* e);

char* _Opt _Owner CompileText(const char* options, const char* content);



_Bool compiler_diagnostic_message(enum diagnostic_id w,
    const struct parser_ctx* ctx,
    const struct token* _Opt p_token,
    const struct marker* _Opt p_marker,
    const char* fmt, ...);


int compile(int argc, const char** argv, struct report* error);


void print_type_qualifier_flags(struct osstream* ss, bool* first, enum type_qualifier_flags e_type_qualifier_flags);

bool print_type_specifier_flags(struct osstream* ss, bool* first, enum type_specifier_flags e_type_specifier_flags);


struct expression_ctx;

struct declaration_specifier
{
    /*
       declaration-specifier:
         storage-class-specifier
         type-specifier-qualifier
         function-specifier
    */
    struct storage_class_specifier* _Owner _Opt storage_class_specifier;

    struct type_specifier_qualifier* _Owner _Opt type_specifier_qualifier;

    struct function_specifier* _Owner _Opt function_specifier;

    struct declaration_specifier* _Owner _Opt next;
};

struct declaration_specifier* _Owner _Opt declaration_specifier(struct parser_ctx* ctx);
void declaration_specifier_delete(struct declaration_specifier* _Owner _Opt p);

struct declaration_specifiers
{
    /*
     declaration-specifiers:
       declaration-specifier attribute-specifier-sequence _Opt
       declaration-specifier declaration-specifiers
    */

    /*cumulative flags*/
    enum attribute_flags  attributes_flags;
    enum type_specifier_flags type_specifier_flags;
    enum type_qualifier_flags type_qualifier_flags;
    enum storage_class_specifier_flags storage_class_specifier_flags;

    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt;

    /*shortcuts*/
    struct struct_or_union_specifier* _Opt struct_or_union_specifier;
    struct enum_specifier* _Opt enum_specifier;
    struct declarator* _Opt typedef_declarator;
    struct typeof_specifier* _Opt typeof_specifier;

    struct token* first_token; /*not _Owner*/
    struct token* last_token; /*not _Owner*/

    struct declaration_specifier* _Owner _Opt head;
    struct declaration_specifier* _Opt tail;
};

void print_declaration_specifiers(struct osstream* ss, struct declaration_specifiers* p);
struct declaration_specifiers* _Owner _Opt declaration_specifiers(struct parser_ctx* ctx, enum storage_class_specifier_flags default_storage_flag);
void declaration_specifiers_delete(struct declaration_specifiers* _Owner _Opt p);
void declaration_specifiers_add(struct declaration_specifiers* p, struct declaration_specifier* _Owner item);

struct static_assert_declaration
{
    /*
     static_assert-declaration:
       "static_assert" ( constant-expression , string-literal ) ;
       "static_assert" ( constant-expression ) ;
    */

    /*
      I am keeping the name static_assert_declaration but better is

      static_declaration:
       static_assert_declaration
       static_debug_declaration

      extension:
      "static_debug" ( constant-expression ) ;
      "static_set" ( constant-expression , string-literal) ;
    */

    struct token* first_token;
    struct token* last_token;
    struct expression* _Owner constant_expression;
    struct token* _Opt string_literal_opt;
};
struct static_assert_declaration* _Owner static_assert_declaration(struct parser_ctx* ctx);
void static_assert_declaration_delete(struct static_assert_declaration* _Owner _Opt p);

/*
  extension, pragma survives the preprocessor and become
  a pragma_declaration that can be used on the AST visit
*/

struct pragma_declaration {
    struct token* first_token;
    struct token* last_token;
};

struct pragma_declaration* _Owner pragma_declaration(struct parser_ctx* ctx);
void pragma_declaration_delete(struct pragma_declaration* _Owner _Opt p);

void execute_pragma(struct parser_ctx* ctx, struct pragma_declaration* p_pragma, bool on_flow_analysis);

struct attribute_specifier_sequence
{
    /*
     attribute-specifier-sequence:
       attribute-specifier-sequence _Opt attribute-specifier
    */

    struct token* first_token;
    struct token* last_token;
    enum attribute_flags  attributes_flags;
    struct attribute_specifier* _Owner _Opt head;
    struct attribute_specifier* _Opt tail;
};
struct attribute_specifier_sequence* _Owner attribute_specifier_sequence_opt(struct parser_ctx* ctx);
void attribute_specifier_sequence_delete(struct attribute_specifier_sequence* _Owner _Opt p);
void attribute_specifier_sequence_add(struct attribute_specifier_sequence* list, struct attribute_specifier* _Owner p_item);

struct attribute_specifier
{
    /*
     attribute-specifier:
        [ [ attribute-list ] ]
    */
    struct token* first_token;
    struct token* last_token;
    struct attribute_list* _Owner attribute_list;
    struct attribute_specifier* _Owner _Opt  next;
};

struct attribute_specifier* _Owner _Opt attribute_specifier(struct parser_ctx* ctx);
void attribute_specifier_delete(struct attribute_specifier* _Owner _Opt p);

struct attribute* _Owner _Opt attribute(struct parser_ctx* ctx);


struct storage_class_specifier
{
    /*
     storage-class-specifier:
      "auto"
      "constexpr"
      "extern"
      "register"
      "static"
      "thread_local"
      "typedef"
    */
    enum storage_class_specifier_flags flags;
    struct token* token;
};

struct storage_class_specifier* _Owner _Opt storage_class_specifier(struct parser_ctx* ctx);
void storage_class_specifier_delete(struct storage_class_specifier* _Owner _Opt p);

struct function_specifier
{
    /*
     function-specifier:
       inline
       _Noreturn
    */
    struct token* token;
};
struct function_specifier* _Owner _Opt  function_specifier(struct parser_ctx* ctx);
void function_specifier_delete(struct function_specifier* _Owner _Opt  p);

struct typeof_specifier_argument
{
    /*
     typeof-specifier-argument:
       expression
       type-name
    */
    struct expression* _Owner _Opt expression;
    struct type_name* _Owner _Opt type_name;
};

void typeof_specifier_argument_delete(struct typeof_specifier_argument* _Owner _Opt p);

struct typeof_specifier
{
    /*
     typeof-specifier:
       "typeof" ( typeof-specifier-argument )
    */
    struct token* first_token;
    struct token* last_token;
    struct typeof_specifier_argument* _Owner typeof_specifier_argument;
    struct type type;
};
void typeof_specifier_delete(struct typeof_specifier* _Owner _Opt p);

struct type_specifier
{
    /*
     type-specifier:
        "void"
        "char"
        "short"
        "int"
        "long"
        "float"
        "double"
        "signed"
        "unsigned"
        "_BitInt" ( constant-expression )
        "bool"
        "_Complex"
        "_Decimal32"
        "_Decimal64"
        "_Decimal128"
        atomic-type-specifier
        struct-or-union-specifier
        enum-specifier
        typedef-name
        typeof-specifier
    */
    enum type_specifier_flags flags;
    struct token* token;
    struct struct_or_union_specifier* _Owner _Opt struct_or_union_specifier;
    struct typeof_specifier* _Owner _Opt  typeof_specifier;
    struct enum_specifier* _Owner _Opt enum_specifier;
    struct declarator* _Opt typedef_declarator;
    struct atomic_type_specifier* _Owner _Opt  atomic_type_specifier;
};

struct type_specifier* _Owner _Opt type_specifier(struct parser_ctx* ctx);
void type_specifier_delete(struct type_specifier* _Owner _Opt p);

struct init_declarator_list
{
    /*
     init-declarator-list:
       init-declarator
       init-declarator-list , init-declarator
    */
    struct init_declarator* _Owner _Opt head;
    struct init_declarator* _Opt tail;
};

struct init_declarator_list init_declarator_list(struct parser_ctx* ctx,
    struct declaration_specifiers* p_declaration_specifiers);

void init_declarator_list_destroy(struct init_declarator_list* _Obj_owner p);
void init_declarator_list_add(struct init_declarator_list* list, struct init_declarator* _Owner p_item);

struct declaration
{
    /*
      declaration:
        declaration-specifiers init-declarator-list _Opt ;
        attribute-specifier-sequence declaration-specifiers init-declarator-list ;
        static_assert-declaration
        attribute-declaration
    */
    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt;

    struct static_assert_declaration* _Owner _Opt static_assert_declaration;
    struct pragma_declaration* _Owner _Opt pragma_declaration;


    struct declaration_specifiers* _Owner _Opt  declaration_specifiers;
    struct init_declarator_list init_declarator_list;

    struct compound_statement* _Owner _Opt  function_body;
    struct declarator* _Opt  contract_declarator;

    struct token* first_token;
    struct token* last_token;

    struct declaration* _Owner _Opt next;
};
void declaration_delete(struct declaration* _Owner _Opt p);
struct declaration* _Owner _Opt external_declaration(struct parser_ctx* ctx);

struct simple_declaration
{
    /*
    This is an extension to support C++ 17 if with initialization

    simple-declaration:
      declaration-specifiers init-declarator-list _Opt ;
      attribute-specifier-sequence declaration-specifiers init-declarator-list ;
    */
    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt;
    struct declaration_specifiers* _Owner p_declaration_specifiers;
    struct init_declarator_list init_declarator_list;
    struct token* first_token;
    struct token* last_token;
};

void simple_declaration_delete(struct simple_declaration* _Owner _Opt p);

struct simple_declaration* _Owner _Opt simple_declaration(struct parser_ctx* ctx,
    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt,
    bool ignore_semicolon);

struct condition {
    /*
      This is an extension to support C++ 17 if with initialization

      condition :
       expression
       attribute-specifier-seq _Opt decl-specifier-seq declarator initializer
    */
    struct expression* _Owner _Opt expression;
    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt;
    struct declaration_specifiers* _Owner _Opt p_declaration_specifiers;

    /*
      OBS:
      We must use p_init_declarator because it is kept on the scope
      as init_declarator when we are trying to parse init-statement or condition that
      are very similar
    */
    struct init_declarator* _Owner _Opt p_init_declarator;

    struct token* first_token;
    struct token* last_token;
};

void condition_delete(struct condition* _Owner _Opt p);
struct condition* _Owner _Opt condition(struct parser_ctx* ctx);

struct init_statement
{
    /*
        This is an extension to support C++ 17 if with initialization

        init-statement :
          expression-statement
          simple-declaration
    */
    struct expression_statement* _Owner _Opt p_expression_statement;
    struct simple_declaration* _Owner _Opt p_simple_declaration;
};

void init_statement_delete(struct init_statement* _Owner _Opt p);
struct init_statement* _Owner _Opt init_statement(struct parser_ctx* ctx, bool ignore_semicolon);

struct atomic_type_specifier
{
    /*
      atomic-type-specifier:
        "_Atomic" ( type-name )
    */
    struct token* token;
    struct type_name* _Owner type_name;
};

struct atomic_type_specifier* _Owner _Opt atomic_type_specifier(struct parser_ctx* ctx);
void atomic_type_specifier_delete(struct atomic_type_specifier* _Owner _Opt  p);

struct enumerator_list
{
    /*
     enumerator-list:
       enumerator
       enumerator-list , enumerator
    */
    struct enumerator* _Owner _Opt head;
    struct enumerator* _Opt tail;
};

struct enumerator_list enumerator_list(struct parser_ctx* ctx,
    const struct enum_specifier* p_enum_specifier
);

void enumerator_list_destroy(struct enumerator_list* _Obj_owner p_enum_specifier);
void enumerator_list_add(struct enumerator_list* list, struct enumerator* _Owner p_item);

struct enum_specifier
{
    /*
     enum-type-specifier:
       : specifier-qualifier-lis

     enum-specifier:
       "enum" attribute-specifier-sequence _Opt identifier _Opt enum-type-specifier _Opt  { enumerator-list }
       "enum" attribute-specifier-sequence _Opt identifier _Opt enum-type-specifier _Opt  { enumerator-list , }
       "enum" identifier enum-type-specifier _Opt
    */
    struct attribute_specifier_sequence* _Owner _Opt attribute_specifier_sequence_opt;
    struct specifier_qualifier_list* _Owner _Opt specifier_qualifier_list;

    char tag_name[200];

    struct enumerator_list enumerator_list;

    struct token* _Opt tag_token;
    struct token* first_token;
    /*points to the complete enum (can be self pointed)*/
    struct enum_specifier* _Opt complete_enum_specifier2;
};

struct enum_specifier* _Owner _Opt enum_specifier(struct parser_ctx*);
void enum_specifier_delete(struct enum_specifier* _Owner _Opt p);
const struct enum_specifier* _Opt get_complete_enum_specifier(const struct enum_specifier* p_enum_specifier);

const struct enumerator* _Opt find_enumerator_by_value(const struct enum_specifier* p_enum_specifier, long long value);



struct member_declaration_list
{
    /*
     member-declaration-list:
       member-declaration
       member-declaration-list member-declaration
    */

    struct token* first_token; /*TODO ? necessary*/
    struct token* last_token;
    struct member_declaration* _Owner _Opt head;
    struct member_declaration* _Opt tail;
};

struct member_declaration_list member_declaration_list(struct parser_ctx* ctx, struct struct_or_union_specifier*);
void member_declaration_list_destroy(struct member_declaration_list* _Obj_owner p);
void member_declaration_list_add(struct member_declaration_list* list, struct member_declaration* _Owner p_item);

struct member_declarator* _Opt find_member_declarator(struct member_declaration_list* list, const char* name, int* p_member_index);

struct struct_or_union_specifier
{
    /*
     struct-or-union-specifier:
       struct-or-union attribute-specifier-sequence _Opt identifier _Opt { member-declaration-list }
       struct-or-union attribute-specifier-sequence _Opt identifier
    */
    struct attribute_specifier_sequence* _Owner _Opt attribute_specifier_sequence_opt;
    struct member_declaration_list member_declaration_list;

    struct token* first_token;
    struct token* last_token;

    bool is_owner;

    /*
    * Token que possui tag da struct
    */
    struct token* _Opt tagtoken;

    char tag_name[200];
    /*geramos um tag name para anomimas, mas colocamos banonymousTag para true*/
    bool has_anonymous_tag;
    /*it was asked to show struct tag created for anonymous*/
    bool show_anonymous_tag;

    int scope_level; /*nivel escopo 0 global*/
    int visit_moved; /*nivel escopo 0 global*/

    /*
    * This points to the first struct_or_union_specifier that will have it´s
    * complete_struct_or_union_specifier_indirection pointing to the complete
    * struct_or_union_specifier.
    */
    struct struct_or_union_specifier* _Opt complete_struct_or_union_specifier_indirection;
};

struct struct_or_union_specifier* _Owner _Opt struct_or_union_specifier(struct parser_ctx* ctx);
void struct_or_union_specifier_delete(struct struct_or_union_specifier* _Owner _Opt  p);

bool struct_or_union_specifier_is_complete(struct struct_or_union_specifier* p_struct_or_union_specifier);
struct struct_or_union_specifier* _Opt get_complete_struct_or_union_specifier(struct struct_or_union_specifier* p_struct_or_union_specifier);

struct init_declarator
{
    /*
     init-declarator:
        declarator
        declarator = initializer
    */

    struct declarator* _Owner p_declarator;
    struct initializer* _Owner _Opt initializer;
    struct init_declarator* _Owner _Opt next;
};

void init_declarator_delete(struct init_declarator* _Owner _Opt p);
struct init_declarator* _Owner _Opt init_declarator(struct parser_ctx* ctx,
    struct declaration_specifiers* p_declaration_specifiers
);

struct initializer
{
    /*
     initializer:
       assignment-expression
       braced-initializer
    */
    struct token* first_token;
    struct designation* _Owner _Opt designation; /*auxiliar para list??*/
    struct braced_initializer* _Owner _Opt braced_initializer;
    struct expression* _Owner _Opt assignment_expression;
    struct initializer* _Owner _Opt  next;    
};

struct initializer* _Owner _Opt initializer(struct parser_ctx* ctx);
void initializer_delete(struct initializer* _Owner _Opt  p);



struct declarator
{
    /*
      declarator:
        pointer _Opt direct-declarator
    */

    struct token* _Opt first_token_opt;
    struct token* _Opt last_token_opt;


    struct pointer* _Owner _Opt pointer;
    struct direct_declarator* _Owner _Opt direct_declarator;


    struct declaration_specifiers* _Opt declaration_specifiers;
    const struct specifier_qualifier_list* _Opt specifier_qualifier_list;

    struct token* _Opt name_opt; //shortcut , null for abstract declarator

    struct compound_statement* _Opt function_body;

    int num_uses; /*used to show not used warnings*/

    /*user by flow analysis*/
    struct flow_object* _Opt p_object;

    /*final declarator type (after auto, typeof etc)*/
    struct type type;
};

enum type_specifier_flags declarator_get_type_specifier_flags(const struct declarator* p);

struct declarator;
void print_declarator(struct osstream* ss, struct declarator* declarator, bool is_abstract);

struct declarator* _Owner _Opt declarator(struct parser_ctx* ctx,
    const struct specifier_qualifier_list* _Opt specifier_qualifier_list,
    struct declaration_specifiers* _Opt declaration_specifiers,
    bool abstract_acceptable,
    struct token** pptokenname);

void declarator_delete(struct declarator* _Owner _Opt  p);
struct array_declarator
{
    /*
     array-declarator:
        direct-declarator [ type-qualifier-list _Opt assignment-expression _Opt ]
        direct-declarator [ "static" type-qualifier-list _Opt assignment-expression ]
        direct-declarator [ type-qualifier-list "static" assignment-expression ]
        direct-declarator [ type-qualifier-listopt * ]
    */
    struct direct_declarator* _Owner _Opt direct_declarator;
    struct expression* _Owner _Opt  assignment_expression;
    struct expression* _Owner _Opt expression;
    struct type_qualifier_list* _Owner _Opt type_qualifier_list_opt;

    struct token* token;
    struct token* _Opt static_token_opt;
};
void array_declarator_delete(struct array_declarator* _Owner _Opt p);
/*
  Return a value > 0 if it has constant size
*/
unsigned long long  array_declarator_get_size(const struct array_declarator* p_array_declarator);

struct function_declarator
{
    /*
     function-declarator:
       direct-declarator ( parameter-type-list _Opt )
    */
    struct direct_declarator* _Owner _Opt direct_declarator;
    struct scope parameters_scope; //usado para escopo parametros
    struct parameter_type_list* _Owner _Opt parameter_type_list_opt;
};
void function_declarator_delete(struct function_declarator* _Owner _Opt p);

struct direct_declarator
{
    /*
     direct-declarator:
        identifier attribute-specifier-sequence _Opt
        ( declarator )
        array-declarator attribute-specifier-sequence _Opt
        function-declarator attribute-specifier-sequence _Opt
    */
    struct token* _Opt name_opt;
    struct declarator* _Owner _Opt declarator;
    struct array_declarator* _Owner _Opt array_declarator;
    struct function_declarator* _Owner _Opt function_declarator;
    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt;
};

void direct_declarator_delete(struct direct_declarator* _Owner _Opt p);

struct direct_declarator* _Owner _Opt direct_declarator(struct parser_ctx* ctx,
    const struct specifier_qualifier_list* _Opt specifier_qualifier_list,
    struct declaration_specifiers* _Opt declaration_specifiers,
    bool abstract_acceptable,
    struct token** pptoken_name
);

struct parameter_type_list
{
    /*
    parameter-type-list:
        parameter-list
        parameter-list , ...
        ...
    */
    bool is_var_args; /*(...)*/
    bool is_void;/*(void)*/
    struct parameter_list* _Owner _Opt parameter_list;
};

struct parameter_type_list* _Owner _Opt parameter_type_list(struct parser_ctx* ctx);
void parameter_type_list_delete(struct parameter_type_list* _Owner _Opt  p);

struct pointer
{
    /*
     pointer:
        * attribute-specifier-sequence _Opt type-qualifier-list _Opt
        * attribute-specifier-sequence _Opt type-qualifier-list _Opt pointer
    */
    struct attribute_specifier_sequence* _Owner _Opt  attribute_specifier_sequence_opt;
    struct type_qualifier_list* _Owner _Opt type_qualifier_list_opt;

    struct pointer* _Owner _Opt pointer;
};

struct pointer* _Owner _Opt  pointer_opt(struct parser_ctx* ctx);
void pointer_delete(struct pointer* _Owner _Opt p);
struct parameter_list
{
    /*
     parameter-list:
        parameter-declaration
        parameter-list , parameter-declaration
    */
    struct parameter_declaration* _Owner _Opt head;
    struct parameter_declaration* _Opt tail;
};
struct parameter_list* _Owner _Opt  parameter_list(struct parser_ctx* ctx);
void parameter_list_delete(struct parameter_list* _Owner _Opt  p);
void parameter_list_add(struct parameter_list* list, struct parameter_declaration* _Owner p_item);

struct parameter_declaration
{
    /*
     parameter-declaration:
      attribute-specifier-sequence opt declaration-specifiers declarator
      attribute-specifier-sequence opt declaration-specifiers abstract-declarator opt
    */
    struct attribute_specifier_sequence* _Owner _Opt  attribute_specifier_sequence_opt;

    struct declaration_specifiers* _Owner declaration_specifiers;
    struct declarator* _Owner _Opt  declarator;
    struct parameter_declaration* _Owner _Opt next;
};
struct parameter_declaration* _Owner _Opt parameter_declaration(struct parser_ctx* ctx);
void parameter_declaration_delete(struct parameter_declaration* _Owner _Opt  p);


struct type_name
{
    /*
     type-name:
       specifier-qualifier-list abstract-declarator opt
    */

    struct token* first_token;
    struct token* last_token;
    struct specifier_qualifier_list* _Owner specifier_qualifier_list;
    struct declarator* _Owner abstract_declarator; //TODO OPT
    struct type type;
};

struct type_name* _Owner _Opt type_name(struct parser_ctx* ctx);
void type_name_delete(struct type_name* _Owner _Opt p);
void print_type_name(struct osstream* ss, struct type_name* p);

struct argument_expression
{
    struct expression* _Owner expression;
    struct argument_expression* _Owner _Opt next;
    bool set_unkown; //used in flow analysis need to be removed..
};

void argument_expression_delete(struct argument_expression* _Owner _Opt  p);

struct braced_initializer
{
    /*
      { }
      { initializer-list }
      { initializer-list , }
    */

    struct token* first_token;
    struct token* last_token;
    struct initializer_list* _Owner _Opt initializer_list;
};
struct braced_initializer* _Owner _Opt braced_initializer(struct parser_ctx* ctx);
void braced_initializer_delete(struct braced_initializer* _Owner _Opt p);

struct type_specifier_qualifier
{
    /*
     type-specifier-qualifier:
       type-specifier
       type-qualifier
       alignment-specifier
    */

    struct type_specifier* _Owner _Opt type_specifier;
    struct type_qualifier* _Owner _Opt type_qualifier;
    struct alignment_specifier* _Owner _Opt alignment_specifier;

    struct type_specifier_qualifier* _Owner _Opt next;
};
struct type_specifier_qualifier* _Owner _Opt type_specifier_qualifier(struct parser_ctx* ctx);
void type_specifier_qualifier_delete(struct type_specifier_qualifier* _Owner _Opt  p);


struct specifier_qualifier_list
{
    /*
      specifier-qualifier-list:
        type-specifier-qualifier attribute-specifier-sequence _Opt
        type-specifier-qualifier specifier-qualifier-list
    */

    /*cumulative flags*/
    enum type_specifier_flags type_specifier_flags;
    enum type_qualifier_flags type_qualifier_flags;

    /*shortcuts*/
    struct struct_or_union_specifier* _Opt struct_or_union_specifier;
    struct enum_specifier* _Opt enum_specifier;
    struct typeof_specifier* _Opt typeof_specifier;
    struct declarator* _Opt typedef_declarator;

    struct type_specifier_qualifier* _Owner _Opt head;
    struct type_specifier_qualifier* _Opt tail;
    struct token* first_token;
    struct token* last_token;

    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence;

};

struct specifier_qualifier_list* _Owner _Opt specifier_qualifier_list(struct parser_ctx* ctx);
void specifier_qualifier_list_delete(struct specifier_qualifier_list* _Owner _Opt p);
void specifier_qualifier_list_add(struct specifier_qualifier_list* list, struct type_specifier_qualifier* _Owner p_item);


void print_specifier_qualifier_list(struct osstream* ss, bool* first, struct specifier_qualifier_list* p_specifier_qualifier_list);


struct alignment_specifier
{
    /*
     alignment-specifier:
       "alignas" ( type-name )
       "alignas" ( constant-expression )
    */
    struct type_name* _Owner _Opt type_name;
    struct expression* _Owner _Opt constant_expression;
    struct token* token;
};
struct alignment_specifier* _Owner _Opt alignment_specifier(struct parser_ctx* ctx);
void alignment_specifier_delete(struct alignment_specifier* _Owner _Opt p);


struct type_qualifier
{
    /*
     type-qualifier:
       "const"
       "restrict"
       "volatile"
       "_Atomic"
    */
    enum type_qualifier_flags flags;
    struct token* token;

    /*
      Next is used when inside struct type_qualifier_list
      Not used when inside struct type_specifier_qualifier
    */
    struct type_qualifier* _Owner _Opt next;
};

struct type_qualifier* _Owner _Opt type_qualifier(struct parser_ctx* ctx);
void type_qualifier_delete(struct type_qualifier* _Owner _Opt p);

struct member_declaration
{
    /*
     member-declaration:
       attribute-specifier-sequence opt specifier-qualifier-list member-declarator-list opt ;
       static_assert-declaration
    */
    struct specifier_qualifier_list* _Owner _Opt specifier_qualifier_list;
    struct member_declarator_list* _Owner _Opt member_declarator_list_opt;

    struct static_assert_declaration* _Owner _Opt static_assert_declaration;
    struct pragma_declaration* _Owner _Opt pragma_declaration;

    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt;
    struct member_declaration* _Owner _Opt next;

};

struct member_declaration* _Owner _Opt member_declaration(struct parser_ctx* ctx,
    struct struct_or_union_specifier*);
void member_declaration_delete(struct member_declaration* _Owner _Opt p);

struct member_declarator
{
    /*
     member-declarator:
       declarator
       declarator opt : constant-expression
    */

    struct declarator* _Owner _Opt declarator;
    struct expression* _Owner _Opt constant_expression;
    struct member_declarator* _Owner _Opt next;
};
void member_declarator_delete(struct member_declarator* _Owner _Opt p);

struct member_declarator_list
{
    /*
     member-declarator-list:
        member-declarator
        member-declarator-list , member-declarator
    */

    struct member_declarator* _Owner _Opt head;
    struct member_declarator* _Opt tail;
};

struct member_declarator_list* _Owner _Opt member_declarator_list(struct parser_ctx* ctx,
    struct struct_or_union_specifier*, /*not const*/
    const struct specifier_qualifier_list* specifier_qualifier_list
);
void member_declarator_list_delete(struct member_declarator_list* _Owner _Opt p);
void member_declarator_list_add(struct member_declarator_list* list, struct member_declarator* _Owner p_item);

struct block_item_list
{
    /*
     block-item-list:
       block-item
       block-item-list block-item
    */
    struct block_item* _Owner _Opt head;
    struct block_item* _Opt tail;
};

struct block_item_list block_item_list(struct parser_ctx* ctx, bool* error);
void block_item_list_destroy(struct block_item_list* _Obj_owner p);
void block_item_list_add(struct block_item_list* list, struct block_item* _Owner p_item);

struct compound_statement
{
    /*
     compound-statement:
       { block-item-list _Opt }
    */
    struct token* first_token; /*{*/
    struct token* last_token; /*}*/

    struct block_item_list block_item_list;

    //flow analysys flags
    struct diagnostic diagnostic_flags;
};
struct compound_statement* _Owner _Opt compound_statement(struct parser_ctx* ctx);
void compound_statement_delete(struct compound_statement* _Owner _Opt p);

struct defer_statement
{
    /*
     defer-statement: (extension)
       "defer" secondary-block
    */
    struct token* first_token;
    struct token* last_token;
    struct secondary_block* _Owner secondary_block;
};

void defer_statement_delete(struct defer_statement* _Owner _Opt p);

struct try_statement
{
    /*
      try-statement: (extension)
       "try" secondary-block
       "try" secondary-block "catch" secondary-block
    */
    struct secondary_block* _Owner secondary_block;
    struct secondary_block* _Owner _Opt catch_secondary_block_opt;
    struct token* first_token; /*try*/
    struct token* last_token;
    struct token* _Opt catch_token_opt; /*catch*/
    /*Used to generate label names*/
    int try_catch_block_index;
};

struct try_statement* _Owner _Opt try_statement(struct parser_ctx* ctx);
void try_statement_delete(struct try_statement* _Owner _Opt p);

struct selection_statement
{
    /*
      selection-statement:
        "if" ( expression ) secondary-block
        "if" ( expression ) secondary-block "else" secondary-block
        "switch" ( expression ) secondary-block
    */

    /*
    Extension to support C++ 17 if with initialization

    selection-statement:
       "if" ( init-statement _Opt condition ) secondary-block
       "if" ( init-statement _Opt condition ) secondary-block "else" secondary-block
       switch ( init-statement _Opt condition ) secondary-block
    */
    struct init_statement* _Owner _Opt p_init_statement;
    struct condition* _Owner _Opt _Opt condition;

    struct secondary_block* _Owner secondary_block;
    struct secondary_block* _Owner _Opt else_secondary_block_opt;

    struct token* open_parentesis_token;
    struct token* close_parentesis_token;

    struct token* first_token;
    struct token* last_token;
    struct token* _Opt else_token_opt;
};

struct selection_statement* _Owner _Opt selection_statement(struct parser_ctx* ctx);
void selection_statement_delete(struct selection_statement* _Owner _Opt  p);
struct iteration_statement
{
    /*
      iteration-statement:
        "while" ( expression ) secondary-block
        "do" secondary-block "while" ( expression ) ;
        "for" ( expression _Opt ; expression _Opt ; expression _Opt ) secondary-block
        "for" ( declaration expression _Opt ; expression _Opt ) secondary-block        
    */

    struct token* first_token;
    struct token* second_token; /*do {} while*/

    struct secondary_block* _Owner secondary_block;

    struct expression* _Owner _Opt expression1;
    struct expression* _Owner _Opt expression2;
    struct expression* _Owner _Opt expression0;
    struct declaration* _Owner _Opt declaration;
};

struct iteration_statement* _Owner _Opt iteration_statement(struct parser_ctx* ctx);
void iteration_statement_delete(struct iteration_statement* _Owner _Opt p);

struct jump_statement
{
    /*
     jump-statement:
       "goto" identifier ;
       "continue" ;
       "break" ;
       "return" expression _Opt ;
    */

    struct token* _Opt label;
    struct token* first_token;
    struct token* last_token;
    struct expression* _Owner _Opt expression_opt;

    int try_catch_block_index;
};

struct jump_statement* _Owner _Opt jump_statement(struct parser_ctx* ctx);
void jump_statement_delete(struct jump_statement* _Owner _Opt p);

struct expression_statement
{
    /*
     expression-statement:
       expression _Opt;
       attribute-specifier-sequence expression ;
    */

    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt;
    struct expression* _Owner _Opt expression_opt;
};

struct expression_statement* _Owner _Opt expression_statement(struct parser_ctx* ctx, bool ignore_semicolon);
void expression_statement_delete(struct expression_statement* _Owner _Opt  p);

struct block_item
{
    /*
     block-item:
      declaration
      unlabeled-statement
      label
    */
    struct token* first_token; //?necessary
    struct declaration* _Owner _Opt declaration;
    struct unlabeled_statement* _Owner _Opt unlabeled_statement;
    struct label* _Owner _Opt label;

    struct block_item* _Owner _Opt next;
};

struct block_item* _Owner _Opt block_item(struct parser_ctx* ctx);
void block_item_delete(struct block_item* _Owner _Opt p);

struct compound_statement* _Owner _Opt function_body(struct parser_ctx* ctx);

struct designator
{
    /*
     designator:
       [ constant-expression ]
       . identifier
    */
    struct expression* _Owner _Opt constant_expression_opt;
    struct token* token;
    struct designator* _Owner _Opt next;
};
struct designator* _Owner _Opt designator(struct parser_ctx* ctx);
void designator_delete(struct designator* _Owner _Opt p);
struct initializer_list
{
    /*
      initializer-list:
        designation _Opt initializer
        initializer-list , designation _Opt initializer
    */
    struct token* first_token;
    struct initializer* _Owner _Opt head;
    struct initializer* _Opt tail;
    int size;
};
struct initializer_list* _Owner _Opt initializer_list(struct parser_ctx* ctx);
void initializer_list_delete(struct initializer_list* _Owner _Opt p);
void initializer_list_add(struct initializer_list* list, struct initializer* _Owner p_item);

struct primary_block
{
    /*
       primary-block:
         compound-statement
         selection-statement
         iteration-statement
         defer-statement (extension)
         try-statement (extension)
    */

    struct compound_statement* _Owner _Opt compound_statement;
    struct selection_statement* _Owner _Opt selection_statement;
    struct iteration_statement* _Owner _Opt iteration_statement;
    struct defer_statement* _Owner _Opt defer_statement;
    struct try_statement* _Owner _Opt try_statement;
};

void primary_block_delete(struct primary_block* _Owner _Opt p);

struct secondary_block
{
    /*
     secondary-block:
       statement
    */
    struct token* first_token;
    struct token* last_token;
    struct statement* _Owner statement;
};

void secondary_block_delete(struct secondary_block* _Owner _Opt p);
bool secondary_block_ends_with_jump(struct secondary_block* _Opt p_secondary_block);

struct unlabeled_statement
{
    /*
      unlabeled-statement:
        expression-statement
        attribute-specifier-sequence _Opt primary-block
        attribute-specifier-sequence _Opt jump-statement
     */

    struct expression_statement* _Owner _Opt expression_statement;
    struct primary_block* _Owner _Opt primary_block;
    struct jump_statement* _Owner _Opt jump_statement;
};

struct unlabeled_statement* _Owner _Opt unlabeled_statement(struct parser_ctx* ctx);
void unlabeled_statement_delete(struct unlabeled_statement* _Owner _Opt p);

struct labeled_statement
{
    /*
     label statement:
       label statement
    */
    struct label* _Owner label;
    struct statement* _Owner statement;
};
struct labeled_statement* _Owner _Opt labeled_statement(struct parser_ctx* ctx);
void labeled_statement_delete(struct labeled_statement* _Owner _Opt p);

struct statement
{
    /*
     statement:
       labeled-statement
       unlabeled-statemen
    */
    struct labeled_statement* _Owner _Opt labeled_statement;
    struct unlabeled_statement* _Owner _Opt unlabeled_statement;
};
struct statement* _Owner _Opt statement(struct parser_ctx* ctx);
void statement_delete(struct statement* _Owner _Opt  p);

struct designator_list
{
    /*
     designator-list:
       designator
       designator-list designator
    */
    struct designator* _Owner _Opt head;
    struct designator* _Opt tail;
};

struct designator_list* _Owner _Opt designator_list(struct parser_ctx* ctx);
void designator_list_delete(struct designator_list* _Owner _Opt p);
void designator_list_add(struct designator_list* list, struct designator* _Owner p_item);

struct designation
{
    /*
     designation:
       designator-list =
    */
    struct designator_list* _Owner designator_list;
    struct token* token;
};
struct designation* _Owner _Opt designation(struct parser_ctx* ctx);
void designation_delete(struct designation* _Owner _Opt p);

struct type_qualifier_list
{
    /*
     type-qualifier-list:
       type-qualifier
       type-qualifier-list type-qualifier
    */
    enum type_qualifier_flags flags;
    struct type_qualifier* _Owner _Opt head;
    struct type_qualifier* _Opt tail;
};

struct type_qualifier_list* _Owner _Opt type_qualifier_list(struct parser_ctx* ctx);
void type_qualifier_list_delete(struct type_qualifier_list* _Owner _Opt p);
void type_qualifier_list_add(struct type_qualifier_list* list, struct type_qualifier* _Owner p_item);

struct attribute_token
{
    enum attribute_flags attributes_flags;
    struct token* token;
};
struct attribute_token* _Owner _Opt attribute_token(struct parser_ctx* ctx);
void attribute_token_delete(struct attribute_token* _Owner _Opt p);
struct attribute
{
    enum attribute_flags  attributes_flags;
    struct attribute_token* _Owner attribute_token;
    struct attribute_argument_clause* _Owner attribute_argument_clause;
    struct attribute* _Owner _Opt next;
};
void attribute_delete(struct attribute* _Owner _Opt p);

struct attribute_list
{
    enum attribute_flags  attributes_flags;
    struct attribute* _Owner _Opt head;
    struct attribute* _Opt tail;
};
struct attribute_list* _Owner _Opt attribute_list(struct parser_ctx* ctx);
void attribute_list_destroy(struct attribute_list* _Obj_owner p);
void attribute_list_delete(struct attribute_list* _Owner _Opt p);

void attribute_list_add(struct attribute_list* list, struct attribute* _Owner p_item);

struct enumerator
{
    /*
      enumeration-constant:
        identifier

      enumerator:
        enumeration-constant attribute-specifier-sequence _Opt
        enumeration-constant attribute-specifier-sequence _Opt = constant-expression
    */

    struct token* token;
    struct attribute_specifier_sequence* _Owner _Opt attribute_specifier_sequence_opt;

    struct expression* _Owner _Opt constant_expression_opt;

    /*
      having the enum specifier we have better information about the type
    */
    const struct enum_specifier* enum_specifier;

    struct enumerator* _Owner _Opt next;
    struct constant_value value;
};

struct enumerator* _Owner _Opt enumerator(struct parser_ctx* ctx, const struct enum_specifier* p_enum_specifier, long long* p_enumerator_value);
void enumerator_delete(struct enumerator* _Owner _Opt  p);

struct attribute_argument_clause
{
    /*
     attribute-argument-clause:
       ( balanced-token-sequence _Opt )
    */
    struct balanced_token_sequence* _Owner _Opt p_balanced_token_sequence;
    struct token* token;
};

struct attribute_argument_clause* _Owner _Opt attribute_argument_clause(struct parser_ctx* ctx);
void attribute_argument_clause_delete(struct attribute_argument_clause* _Owner _Opt p);

bool first_of_attribute(const struct parser_ctx* ctx);

struct balanced_token
{
    struct token* token;
    struct balanced_token* _Owner _Opt next;
};

struct balanced_token_sequence
{
    struct balanced_token* _Owner _Opt head;
    struct balanced_token* _Opt tail;
};
struct balanced_token_sequence* _Owner _Opt balanced_token_sequence_opt(struct parser_ctx* ctx);
void balanced_token_sequence_delete(struct balanced_token_sequence* _Owner _Opt  p);

bool is_first_of_conditional_expression(struct parser_ctx* ctx);
bool first_of_type_name(const struct parser_ctx* ctx);
bool first_of_type_name_ahead(const struct parser_ctx* ctx);

struct argument_expression_list argument_expression_list(struct parser_ctx* ctx);

struct declaration_list
{
    struct declaration* _Owner _Opt head;
    struct declaration* _Opt tail;
};

struct declaration_list translation_unit(struct parser_ctx* ctx, bool* berror);
void declaration_list_destroy(struct declaration_list* _Obj_owner list);

struct label
{
    /*
     label:
       attribute-specifier-sequence _Opt identifier :
       attribute-specifier-sequence _Opt "case" constant-expression :
       attribute-specifier-sequence _Opt "default" :
    */
    struct expression* _Owner _Opt constant_expression;
    struct token* _Opt p_identifier_opt;
};

struct label* _Owner _Opt label(struct parser_ctx* ctx);
void label_delete(struct label* _Owner _Opt p);

struct ast
{
    struct token_list token_list;
    struct declaration_list declaration_list;
};


struct ast get_ast(struct options* options, const char* filename, const char* source, struct report* report);
void ast_destroy(struct ast* _Obj_owner ast);
struct type make_type_using_declarator(struct parser_ctx* ctx, struct declarator* pdeclarator);


struct declaration_list parse(struct parser_ctx* ctx, struct token_list* list, bool* berror);
const char* _Owner _Opt compile_source(const char* pszoptions, const char* content, struct report* report);



#include <math.h>

#ifdef _WIN32
#endif

#if defined _MSC_VER && !defined __POCC__
#endif

#if ULONG_MAX == UINT_MAX

#define TYPE_SIGNED_INT_OR_SIGNED_LONG      TYPE_SIGNED_INT:    case TYPE_SIGNED_LONG
#define TYPE_UNSIGNED_INT_OR_UNSIGNEG_LONG  TYPE_UNSIGNED_INT:  case TYPE_UNSIGNED_LONG

#define TYPE_SIGNED_LONG_LONG_OR_SIGNED_LONG     TYPE_SIGNED_LONG_LONG
#define TYPE_UNSIGNED_LONG_LONG_OR_UNSIGNEG_LONG TYPE_UNSIGNED_LONG_LONG

#else

#define TYPE_SIGNED_INT_OR_SIGNED_LONG     TYPE_SIGNED_INT
#define TYPE_UNSIGNED_INT_OR_UNSIGNEG_LONG TYPE_UNSIGNED_INT

#define TYPE_SIGNED_LONG_LONG_OR_SIGNED_LONG     TYPE_SIGNED_LONG_LONG:case TYPE_SIGNED_LONG
#define TYPE_UNSIGNED_LONG_LONG_OR_UNSIGNEG_LONG TYPE_UNSIGNED_LONG_LONG:case TYPE_UNSIGNED_LONG

#endif


enum constant_value_type type_to_constant_value_type(const struct type* type)
{
    if (type_is_pointer(type))
    {
#if defined(_WIN64) || defined(__x86_64__) 
        return TYPE_UNSIGNED_LONG_LONG;
#else
        return TYPE_UNSIGNED_INT;
#endif
    }
    const enum type_specifier_flags type_specifier_flags = type->type_specifier_flags;


    if (type_specifier_flags & TYPE_SPECIFIER_BOOL)
        return TYPE_BOOL;

    if (type_specifier_flags & TYPE_SPECIFIER_FLOAT)
        return TYPE_FLOAT;

    if (type_specifier_flags & TYPE_SPECIFIER_DOUBLE)
    {
        if (type_specifier_flags & TYPE_SPECIFIER_LONG)
            return TYPE_LONG_DOUBLE;
        return TYPE_DOUBLE;
    }


    if (type_specifier_flags & TYPE_SPECIFIER_UNSIGNED)
    {
        if (type_specifier_flags & TYPE_SPECIFIER_CHAR)
            return TYPE_UNSIGNED_CHAR;
        if (type_specifier_flags & TYPE_SPECIFIER_SHORT)
            return TYPE_UNSIGNED_SHORT;
        if (type_specifier_flags & TYPE_SPECIFIER_LONG)
            return TYPE_UNSIGNED_LONG; /*check before int*/
        if (type_specifier_flags & TYPE_SPECIFIER_INT)
            return TYPE_UNSIGNED_INT;
        if (type_specifier_flags & TYPE_SPECIFIER_LONG_LONG)
            return TYPE_UNSIGNED_LONG_LONG;
    }
    else
    {
        if (type_specifier_flags & TYPE_SPECIFIER_CHAR)
            return TYPE_SIGNED_CHAR;
        if (type_specifier_flags & TYPE_SPECIFIER_SHORT)
            return TYPE_SIGNED_SHORT;
        if (type_specifier_flags & TYPE_SPECIFIER_LONG)
            return TYPE_SIGNED_LONG; /*check before int*/
        if (type_specifier_flags & TYPE_SPECIFIER_INT)
            return TYPE_SIGNED_INT;
        if (type_specifier_flags & TYPE_SPECIFIER_LONG_LONG)
            return TYPE_SIGNED_LONG_LONG;
    }

    //assert(0);
    return TYPE_NOT_CONSTANT;
}




struct expression* _Owner _Opt postfix_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt cast_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt multiplicative_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt unary_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt additive_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt shift_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt relational_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt equality_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt and_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt exclusive_or_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt inclusive_or_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt logical_and_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt logical_or_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt conditional_expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt expression(struct parser_ctx* ctx);
struct expression* _Owner _Opt conditional_expression(struct parser_ctx* ctx);

NODISCARD
static errno_t execute_bitwise_operator(struct parser_ctx* ctx, struct expression* new_expression, int op);

static int compare_function_arguments(struct parser_ctx* ctx,
                                      struct type* p_type,
                                      struct argument_expression_list* p_argument_expression_list)
{
    try
    {
        struct param* _Opt p_current_parameter_type = NULL;

        const struct param_list* _Opt p_param_list = type_get_func_or_func_ptr_params(p_type);
        if (p_param_list == NULL) throw;

        p_current_parameter_type = p_param_list->head;

        struct argument_expression* _Opt p_current_argument = p_argument_expression_list->head;

        while (p_current_argument && p_current_parameter_type)
        {
            check_assigment(ctx, &p_current_parameter_type->type, p_current_argument->expression, ASSIGMENT_TYPE_PARAMETER);
            p_current_argument = p_current_argument->next;
            p_current_parameter_type = p_current_parameter_type->next;
        }

        if (p_current_argument != NULL && !p_param_list->is_var_args)
        {
            compiler_diagnostic_message(C_ERROR_TOO_MANY_ARGUMENTS, ctx,
                                        p_current_argument->expression->first_token, NULL,
                                        "too many arguments");
            throw;
        }

        if (p_current_parameter_type != NULL && !p_param_list->is_void)
        {
            if (p_argument_expression_list->tail)
            {
                compiler_diagnostic_message(C_ERROR_TOO_FEW_ARGUMENTS, ctx,
                                            p_argument_expression_list->tail->expression->first_token,
                    NULL,
                                            "too few arguments");
            }
            else
            {
                compiler_diagnostic_message(C_ERROR_TOO_FEW_ARGUMENTS, ctx, ctx->current, NULL, "too few arguments");
            }
            throw;
        }
    }
    catch
    {
        return 1; /*error*/
    }

    return 0;
}

bool is_enumeration_constant(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
    {
        return false;
    }

    if (ctx->current->type != TK_IDENTIFIER)
    {
        return false;
    }

    if (ctx->current->flags & TK_FLAG_IDENTIFIER_IS_ENUMERATOR)
        return true;

    if (ctx->current->flags & TK_FLAG_IDENTIFIER_IS_NOT_ENUMERATOR)
        return false;

    const bool is_enumerator = find_enumerator(ctx, ctx->current->lexeme, NULL) != NULL;

    if (is_enumerator)
    {
        ctx->current->flags |= TK_FLAG_IDENTIFIER_IS_ENUMERATOR;
    }
    else
    {
        ctx->current->flags |= TK_FLAG_IDENTIFIER_IS_NOT_ENUMERATOR;
    }

    return is_enumerator;
}

bool is_first_of_floating_constant(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    /*
     floating-constant:
      decimal-floating-constant
      hexadecimal-floating-constan
    */
    return ctx->current->type == TK_COMPILER_DECIMAL_FLOATING_CONSTANT ||
        ctx->current->type == TK_COMPILER_HEXADECIMAL_FLOATING_CONSTANT;
}

bool is_first_of_integer_constant(const struct parser_ctx* ctx)
{
    /*
     integer-constant:
      decimal-constant integer-suffixopt
      octal-constant integer-suffixopt
      hexadecimal-constant integer-suffixopt
      binary-constant integer-suffixop
    */

    if (ctx->current == NULL)
        return false;

    return ctx->current->type == TK_COMPILER_DECIMAL_CONSTANT ||
        ctx->current->type == TK_COMPILER_OCTAL_CONSTANT ||
        ctx->current->type == TK_COMPILER_HEXADECIMAL_CONSTANT ||
        ctx->current->type == TK_COMPILER_BINARY_CONSTANT;
}

bool is_predefined_constant(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return ctx->current->type == TK_KEYWORD_TRUE ||
        ctx->current->type == TK_KEYWORD_FALSE ||
        ctx->current->type == TK_KEYWORD_NULLPTR;
}

bool is_first_of_constant(const struct parser_ctx* ctx)
{
    /*
     constant:
      integer-constant
      floating-constant
      enumeration-constant
      character-constant
      predefined-constant
    */
    if (ctx->current == NULL)
        return false;

    return is_first_of_integer_constant(ctx) ||
        is_first_of_floating_constant(ctx) ||
        is_enumeration_constant(ctx) ||
        (ctx->current->type == TK_CHAR_CONSTANT) ||
        is_predefined_constant(ctx);
}

bool is_first_of_primary_expression(const struct parser_ctx* ctx)
{
    /*
     primary-expression:
      identifier
      constant
      string-literal
      ( expression )
      generic-selection
      typeid (expression )
    */
    if (ctx->current == NULL)
        return false;

    return ctx->current->type == TK_IDENTIFIER ||
        is_first_of_constant(ctx) ||
        ctx->current->type == TK_STRING_LITERAL ||
        ctx->current->type == '(' ||
        ctx->current->type == TK_KEYWORD__GENERIC;
}

struct generic_association* _Owner _Opt generic_association(struct parser_ctx* ctx)
{
    struct generic_association* _Owner _Opt p_generic_association = NULL;
    try
    {
        if (ctx->current == NULL)
            throw;

        p_generic_association = calloc(1, sizeof * p_generic_association);
        if (p_generic_association == NULL)
            throw;

        p_generic_association->first_token = ctx->current;
        /*generic - association:
            type-name : assignment-expression
            default : assignment-expression
            */
        if (ctx->current->type == TK_KEYWORD_DEFAULT)
        {
            parser_match(ctx);
            if (ctx->current == NULL) throw;
        }
        else if (first_of_type_name(ctx))
        {
            bool old = ctx->inside_generic_association;
            ctx->inside_generic_association = true;


            p_generic_association->p_type_name = type_name(ctx);
            if (p_generic_association->p_type_name == NULL) throw;

            assert(p_generic_association->p_type_name->abstract_declarator != NULL);

            ctx->inside_generic_association = old;
            p_generic_association->type = make_type_using_declarator(ctx, p_generic_association->p_type_name->abstract_declarator);
        }
        else
        {
            compiler_diagnostic_message(C_ERROR_UNEXPECTED, ctx, ctx->current, NULL, "unexpected");
        }
        if (parser_match_tk(ctx, ':') != 0)
            throw;

        struct expression* _Owner _Opt p_expression_temp = assignment_expression(ctx);
        if (p_expression_temp == NULL)
        {
            throw;
        }

        p_generic_association->expression = p_expression_temp;

        if (ctx->current == NULL)
        {
            throw;
        }
        p_generic_association->last_token = ctx->current;
    }
    catch
    {
        generic_association_delete(p_generic_association);
        p_generic_association = NULL;
    }

    return p_generic_association;
}

struct generic_assoc_list generic_association_list(struct parser_ctx* ctx)
{
    struct generic_assoc_list list = { 0 };
    try
    {
        struct generic_association* _Owner _Opt p_generic_association =
            generic_association(ctx);

        if (p_generic_association == NULL)
            throw;

        generic_assoc_list_add(&list, p_generic_association);

        if (ctx->current == NULL)
            throw;

        while (ctx->current->type == ',')
        {
            parser_match(ctx);
            if (ctx->current == NULL) throw;

            struct generic_association* _Owner _Opt p_generic_association2 = generic_association(ctx);
            if (p_generic_association2 == NULL)
                throw;

            generic_assoc_list_add(&list, p_generic_association2);
            if (ctx->current == NULL)
                throw;
        }
    }
    catch
    {
    }
    return list;
}
void generic_association_delete(struct generic_association* _Owner _Opt p)
{
    if (p)
    {
        assert(p->next == NULL);
        type_name_delete(p->p_type_name);
        expression_delete(p->expression);
        type_destroy(&p->type);
        free(p);
    }
}

void generic_assoc_list_add(struct generic_assoc_list* list, struct generic_association* _Owner pitem)
{
    if (list->head == NULL)
    {
        list->head = pitem;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = pitem;
    }
    list->tail = pitem;
}

void generic_assoc_list_destroy(struct generic_assoc_list* _Obj_owner p)
{
    struct generic_association* _Owner _Opt item = p->head;
    while (item)
    {
        struct generic_association* _Owner _Opt next = item->next;
        item->next = NULL;
        generic_association_delete(item);
        item = next;
    }
}
void generic_selection_delete(struct generic_selection* _Owner _Opt p)
{
    if (p)
    {
        expression_delete(p->expression);
        type_name_delete(p->type_name);
        generic_assoc_list_destroy(&p->generic_assoc_list);
        free(p);
    }
}
struct generic_selection* _Owner _Opt generic_selection(struct parser_ctx* ctx)
{
    /*C23
      generic-selection:
        _Generic ( assignment-expression , generic-assoc-ctx )
    */

    /*
      Extension
      generic-selection:
        "_Generic" ( generic-argument, generic-assoc-list )

        generic-argument:
          assignment-expression
          type-name
    */

    struct generic_selection* _Owner _Opt p_generic_selection = NULL;
    try
    {
        if (ctx->current == NULL) throw;

        p_generic_selection = calloc(1, sizeof * p_generic_selection);
        if (p_generic_selection == NULL)
            throw;

        p_generic_selection->first_token = ctx->current;

        if (parser_match_tk(ctx, TK_KEYWORD__GENERIC) != 0)
            throw;
        if (parser_match_tk(ctx, '(') != 0)
            throw;

        if (first_of_type_name(ctx))
        {
            /*extension*/
            p_generic_selection->type_name = type_name(ctx);
            if (p_generic_selection->type_name == NULL)
                throw;
        }
        else
        {
            p_generic_selection->expression = assignment_expression(ctx);
            if (p_generic_selection->expression == NULL)
                throw;
        }

        if (parser_match_tk(ctx, ',') != 0)
            throw;

        p_generic_selection->generic_assoc_list = generic_association_list(ctx);
        if (p_generic_selection->generic_assoc_list.head == NULL) throw;

        struct type lvalue_type = { 0 };

        struct type* _Opt p_type = NULL;

        if (p_generic_selection->expression)
        {
            p_type = &p_generic_selection->expression->type;

            if (expression_is_subjected_to_lvalue_conversion(p_generic_selection->expression))
            {
                lvalue_type = type_lvalue_conversion(&p_generic_selection->expression->type, ctx->options.null_checks_enabled);
                p_type = &lvalue_type;
            }
        }
        else if (p_generic_selection->type_name)
        {
            p_type = &p_generic_selection->type_name->abstract_declarator->type;
        }
        else
        {
            throw;
        }

        struct generic_association* _Opt current = p_generic_selection->generic_assoc_list.head;
        while (current)
        {
            if (current->p_type_name)
            {
                if (type_is_same(p_type, &current->type, true))
                {
                    p_generic_selection->p_view_selected_expression = current->expression;
                    break;
                }
            }
            else
            {
                /*default*/
                p_generic_selection->p_view_selected_expression = current->expression;
            }
            current = current->next;
        }

        type_destroy(&lvalue_type);

        if (ctx->current == NULL) throw;
        p_generic_selection->last_token = ctx->current;

        if (parser_match_tk(ctx, ')') != 0)
        {
            throw;
        }
    }
    catch
    {
        generic_selection_delete(p_generic_selection);
        p_generic_selection = NULL;
    }
    return p_generic_selection;
}



struct expression* _Owner _Opt character_constant_expression(struct parser_ctx* ctx)
{
    struct expression* _Owner _Opt p_expression_node = NULL;
    try
    {
        if (ctx->current == NULL)
            throw;

        p_expression_node = calloc(1, sizeof * p_expression_node);
        if (p_expression_node == NULL)
            throw;

        p_expression_node->expression_type = PRIMARY_EXPRESSION_CHAR_LITERAL;
        p_expression_node->first_token = ctx->current;
        p_expression_node->last_token = p_expression_node->first_token;
        p_expression_node->type.attributes_flags |= CAKE_HIDDEN_ATTRIBUTE_LIKE_CHAR;
        p_expression_node->type.category = TYPE_CATEGORY_ITSELF;

        const unsigned char* _Opt p = (const unsigned char*)ctx->current->lexeme;

        if (p[0] == 'u' && p[1] == '8')
        {
            p++;
            p++;
            p++;

            // A UTF-8 character constant has type char8_t.
            p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_CHAR;

            unsigned int c = 0;
            p = utf8_decode(p, &c);
            if (p == NULL)
            {
                throw;
            }

            if (c == '\\')
            {
                p = escape_sequences_decode_opt(p, &c);
                if (p == NULL) throw;
            }

            if (*p != '\'')
            {
                compiler_diagnostic_message(C_MULTICHAR_ERROR, ctx, ctx->current, NULL, "Unicode character literals may not contain multiple characters.");
            }

            if (c > 0x80)
            {
                compiler_diagnostic_message(C_CHARACTER_NOT_ENCODABLE_IN_A_SINGLE_CODE_UNIT, ctx, ctx->current, NULL, "character not encodable in a single code unit.");
            }

            p_expression_node->constant_value = constant_value_make_wchar_t((wchar_t)c);//, ctx->evaluation_is_disabled);
        }
        else if (p[0] == 'u')
        {
            p++;
            p++;

            // A UTF-16 character constant has type char16_t which is an unsigned integer types defined in the <uchar.h> header
            p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_SHORT;

            unsigned int c = 0;
            p = utf8_decode(p, &c);
            if (p == NULL)
            {
                throw;
            }

            if (c == '\\')
            {
                p = escape_sequences_decode_opt(p, &c);
                if (p == NULL) throw;
            }

            if (*p != '\'')
            {
                compiler_diagnostic_message(W_MULTICHAR_ERROR, ctx, ctx->current, NULL, "Unicode character literals may not contain multiple characters.");
            }

            if (c > USHRT_MAX)
            {
                compiler_diagnostic_message(W_MULTICHAR_ERROR, ctx, ctx->current, NULL, "Character too large for enclosing character literal type.");
            }

            p_expression_node->constant_value = constant_value_make_wchar_t((wchar_t)c);
        }
        else if (p[0] == 'U')
        {
            p++;
            p++;

            // A UTF-16 character constant has type char16_t which is an unsigned integer types defined in the <uchar.h> header
            p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT;

            unsigned int c = 0;
            p = utf8_decode(p, &c);
            if (p == NULL)
            {
                throw;
            }

            if (c == '\\')
            {
                p = escape_sequences_decode_opt(p, &c);
                if (p == NULL) throw;
            }

            if (*p != '\'')
            {
                compiler_diagnostic_message(W_MULTICHAR_ERROR, ctx, ctx->current, NULL, "Unicode character literals may not contain multiple characters.");
            }

            if (c > UINT_MAX)
            {
                compiler_diagnostic_message(W_MULTICHAR_ERROR, ctx, ctx->current, NULL, "Character too large for enclosing character literal type.");
            }

            p_expression_node->constant_value = constant_value_make_wchar_t((wchar_t)c);
        }
        else if (p[0] == 'L')
        {
            // A wchar_t character constant is prefixed by the letter L
            p++;
            p++;

            p_expression_node->type.type_specifier_flags = CAKE_WCHAR_T_TYPE_SPECIFIER;

            /*
             wchar_t character constant prefixed by the letter L has type wchar_t, an integer type defined in
             the <stddef.h> header. The value of a wchar_t character constant containing a single multibyte
             character that maps to a single member of the extended execution character set is the wide character
             corresponding to that multibyte character in the implementation-defined wide literal encoding
             (6.2.9). The value of a wchar_t character constant containing more than one multibyte character or a
             single multibyte character that maps to multiple members of the extended execution character set,
             or containing a multibyte character or escape sequence not represented in the extended execution
             character set, is implementation-defined.
            */
            long long value = 0;
            while (*p != '\'')
            {
                unsigned int c = 0;
                p = utf8_decode(p, &c);
                if (p == NULL)
                {
                    throw;
                }

                if (c == '\\')
                {
                    p = escape_sequences_decode_opt(p, &c);
                    if (p == NULL) throw;
                }

                if (c < 0x80)
                {
                    value = value * 256 + c;
                }
                else
                {
                    //decoded
                    value = c;
                }
#ifdef _WIN32
                if (value > USHRT_MAX)
                {
                    compiler_diagnostic_message(W_OUT_OF_BOUNDS, ctx, ctx->current, NULL, "character constant too long for its type", ctx->current->lexeme);
                    break;
                }
#else
                if (value > UINT_MAX)
                {
                    compiler_diagnostic_message(W_OUT_OF_BOUNDS, ctx, ctx->current, NULL, "character constant too long for its type", ctx->current->lexeme);
                    break;
                }
#endif
            }

            p_expression_node->constant_value = constant_value_make_wchar_t((wchar_t)value);
        }
        else
        {
            p++;
            p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_INT;

            /*
              An integer character constant has type int. The value of an integer character constant containing
              a single character that maps to a single value in the literal encoding (6.2.9) is the numerical value
              of the representation of the mapped character in the literal encoding interpreted as an integer.
              The value of an integer character constant containing more than one character (e.g., ’ab’), or
              containing a character or escape sequence that does not map to a single value in the literal encoding,
              is implementation-defined. If an integer character constant contains a single character or escape
              sequence, its value is the one that results when an object with type char whose value is that of the
              single character or escape sequence is converted to type int.
            */
            long long value = 0;
            while (*p != '\'')
            {
                unsigned int c = 0;
                p = utf8_decode(p, &c);
                if (p == NULL)
                {
                    throw;
                }

                if (c == '\\')
                {
                    p = escape_sequences_decode_opt(p, &c);
                    if (p == NULL) throw;
                }

                value = value * 256 + c;
                if (value > INT_MAX)
                {
                    compiler_diagnostic_message(W_OUT_OF_BOUNDS, ctx, ctx->current, NULL, "character constant too long for its type", ctx->current->lexeme);
                    break;
                }
            }
            p_expression_node->constant_value = constant_value_make_wchar_t((wchar_t)value);
        }

        parser_match(ctx);
        if (ctx->current == NULL) throw;

        // warning: character constant too long for its type
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }
    return p_expression_node;
}

int convert_to_number(struct parser_ctx* ctx, struct expression* p_expression_node, bool disabled)
{
    if (ctx->current == NULL)
        return 1;

    struct token* token = ctx->current;

    /*copy removing separators*/
    // one of the largest buffers needed would be 128 bits binary... 
    // 0xb1'1'1....
    int c = 0;
    char buffer[128 * 2 + 4] = { 0 };
    const char* s = token->lexeme;
    while (*s)
    {
        if (*s != '\'')
        {
            buffer[c] = *s;
            c++;
        }
        s++;
    }

    char errormsg[100] = {0};
    char suffix[4] = { 0 };
    enum token_type r = parse_number(buffer, suffix, errormsg);
    if (r == TK_NONE)
    {
        compiler_diagnostic_message(
            C_INVALID_TOKEN,
            ctx,
            token,
            NULL,
            errormsg);
        return 0;
    }

    switch (token->type)
    {
    case TK_COMPILER_DECIMAL_CONSTANT:
    case TK_COMPILER_OCTAL_CONSTANT:
    case TK_COMPILER_HEXADECIMAL_CONSTANT:
    case TK_COMPILER_BINARY_CONSTANT:
    {
        unsigned long long value = 0;
        switch (token->type)
        {
        case TK_COMPILER_DECIMAL_CONSTANT:
            value = strtoull(buffer, NULL, 10);
            break;
        case TK_COMPILER_OCTAL_CONSTANT:
            if (buffer[1] == 'o' || buffer[1] == 'O')
            {       
                //C2Y
                //https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3319.htm
                value = strtoull(buffer + 2, NULL, 8);
            }
            else
            {
                value = strtoull(buffer + 1, NULL, 8);
            }            
            break;
        case TK_COMPILER_HEXADECIMAL_CONSTANT:
            value = strtoull(buffer + 2, NULL, 16);
            break;
        case TK_COMPILER_BINARY_CONSTANT:
            value = strtoull(buffer + 2, NULL, 2);
            break;
        default:
            break;
        }

        if (value == ULLONG_MAX && errno == ERANGE)
        {
            compiler_diagnostic_message(
            C_ERROR_LITERAL_OVERFLOW,
            ctx,
            token,
            NULL,
            "integer literal is too large to be represented in any integer type");
        }

        ///////////////MICROSOFT ////////////////////////
        //TODO i64 etc
        ////////////////////////////////////////////////

        if (suffix[0] == 'U')
        {
            /*fixing the type that fits the size*/
            if (value <= UINT_MAX && suffix[1] != 'L')
            {
                p_expression_node->constant_value = constant_value_make_unsigned_int((unsigned int)value);
                p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_INT | TYPE_SPECIFIER_UNSIGNED;
            }
            else if (value <= ULONG_MAX && suffix[2] != 'L')
            {
                p_expression_node->constant_value = constant_value_make_unsigned_long((unsigned long)value);
                p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_LONG | TYPE_SPECIFIER_UNSIGNED;
            }
            else //if (value <= ULLONG_MAX)
            {
                p_expression_node->constant_value = constant_value_make_unsigned_long_long((unsigned long long)value);
                p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_LONG_LONG | TYPE_SPECIFIER_UNSIGNED;
            }
        }
        else
        {
            /*fixing the type that fits the size*/
            if (value <= INT_MAX && suffix[0] != 'L')
            {
                p_expression_node->constant_value = constant_value_make_signed_int((int)value);
                p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_INT;
            }
            else if (value <= LONG_MAX && suffix[1] != 'L' /*!= LL*/)
            {
                p_expression_node->constant_value = constant_value_make_signed_long((long)value);
                p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_LONG;
            }
            else if (value <= LLONG_MAX)
            {
                p_expression_node->constant_value = constant_value_make_signed_long_long((long long)value);
                p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_LONG_LONG;
            }
            else
            {
                compiler_diagnostic_message(
                    W_IMPLICITLY_UNSIGNED_LITERAL,
                    ctx,
                    token,
                    NULL,
                    "integer literal is too large to be represented in a signed integer type, interpreting as unsigned");
                p_expression_node->constant_value = constant_value_make_signed_long_long(value);
                p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_LONG_LONG | TYPE_SPECIFIER_UNSIGNED;
            }
        }

    }
    break;

    case TK_COMPILER_DECIMAL_FLOATING_CONSTANT:
    case TK_COMPILER_HEXADECIMAL_FLOATING_CONSTANT:
    {
        if (suffix[0] == 'F')
        {
            float value = strtof(buffer, NULL);
            if (value == HUGE_VALF && errno == ERANGE)
            {
            }
            p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_FLOAT;
            p_expression_node->constant_value = constant_value_make_float(value);
        }
        else if (suffix[0] == 'L')
        {
            long double value = strtold(buffer, NULL);
            if (value == HUGE_VALL && errno == ERANGE)
            {
            }

            p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_DOUBLE | TYPE_SPECIFIER_LONG;
            p_expression_node->constant_value = constant_value_make_long_double(value);
        }
        else
        {
            double value = strtod(buffer, NULL);
            if (value == HUGE_VAL && errno == ERANGE)
            {
            }
            p_expression_node->constant_value = constant_value_make_double(value);
            p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_DOUBLE;
        }
    }
    break;

    default:
        assert(false);
    }

    return 0;
}

static bool is_integer_or_floating_constant(enum token_type type)
{
    return type == TK_COMPILER_DECIMAL_CONSTANT ||
        type == TK_COMPILER_OCTAL_CONSTANT ||
        type == TK_COMPILER_HEXADECIMAL_CONSTANT ||
        type == TK_COMPILER_BINARY_CONSTANT ||
        type == TK_COMPILER_DECIMAL_FLOATING_CONSTANT ||
        type == TK_COMPILER_HEXADECIMAL_FLOATING_CONSTANT;
}

struct expression* _Owner _Opt primary_expression(struct parser_ctx* ctx)
{
    /*
     primary-expression:
      identifier
      constant
      string-literal
      ( expression )
      generic-selection
    */

    if (ctx->current == NULL)
        return NULL;

    struct expression* _Owner _Opt p_expression_node = NULL;
    try
    {
        if (ctx->current->type == TK_IDENTIFIER)
        {
            p_expression_node = calloc(1, sizeof * p_expression_node);

            if (p_expression_node == NULL)
                throw;

            p_expression_node->first_token = ctx->current;
            p_expression_node->last_token = ctx->current;

            struct map_entry* _Opt p_entry = find_variables(ctx, ctx->current->lexeme, NULL);

            if (p_entry && p_entry->type == TAG_TYPE_ENUMERATOR)
            {
                struct enumerator* p_enumerator = p_entry->p;
                p_expression_node->expression_type = PRIMARY_EXPRESSION_ENUMERATOR;
                p_expression_node->constant_value = p_enumerator->value;

                p_expression_node->type = type_make_enumerator(p_enumerator->enum_specifier);
            }
            else if (p_entry &&
                     (p_entry->type == TAG_TYPE_ONLY_DECLARATOR || p_entry->type == TAG_TYPE_INIT_DECLARATOR))
            {
                struct declarator* _Opt p_declarator = NULL;
                struct init_declarator* _Opt p_init_declarator = NULL;
                if (p_entry->type == TAG_TYPE_INIT_DECLARATOR)
                {
                    p_init_declarator = p_entry->p;
                    p_declarator = p_init_declarator->p_declarator;
                }
                else
                {
                    p_declarator = p_entry->p;
                }

                if (type_is_deprecated(&p_declarator->type))
                {
                    compiler_diagnostic_message(W_DEPRECATED, ctx, ctx->current, NULL, "'%s' is deprecated", ctx->current->lexeme);
                }

                p_declarator->num_uses++;
                p_expression_node->declarator = p_declarator;
                p_expression_node->expression_type = PRIMARY_EXPRESSION_DECLARATOR;

                p_expression_node->type = type_dup(&p_declarator->type);
                if (p_init_declarator)
                {
                    if (/*
                         p_init_declarator->p_declarator && */
                         p_init_declarator->p_declarator->declaration_specifiers &&
                         p_init_declarator->p_declarator->declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_CONSTEXPR)
                    {
                        if (p_init_declarator->initializer &&
                            p_init_declarator->initializer->assignment_expression)
                        {
                            p_expression_node->constant_value =
                                p_init_declarator->initializer->assignment_expression->constant_value;
                        }
                    }
                }
            }
            else if (ctx->p_current_function_opt &&
                     strcmp(ctx->current->lexeme, "__func__") == 0)
            {

                const char* func_str = "?";


                if (ctx->p_current_function_opt->init_declarator_list.head != NULL &&
                    ctx->p_current_function_opt->init_declarator_list.head->p_declarator->name_opt)
                {
                    func_str =
                        ctx->p_current_function_opt->init_declarator_list.head->p_declarator->name_opt->lexeme;
                }


                p_expression_node->expression_type = PRIMARY_EXPRESSION__FUNC__;
                p_expression_node->first_token = ctx->current;
                p_expression_node->last_token = ctx->current;

                p_expression_node->type = type_make_literal_string(strlen(func_str) + 1, TYPE_SPECIFIER_CHAR);
            }
            else
            {
                compiler_diagnostic_message(C_ERROR_NOT_FOUND, ctx, ctx->current, NULL, "not found '%s'", ctx->current->lexeme);
                throw;
            }
            parser_match(ctx);
            if (ctx->current == NULL) throw;
        }
        else if (ctx->current->type == TK_STRING_LITERAL)
        {
            p_expression_node = calloc(1, sizeof * p_expression_node);
            if (p_expression_node == NULL)
                throw;

            p_expression_node->expression_type = PRIMARY_EXPRESSION_STRING_LITERAL;
            p_expression_node->first_token = ctx->current;
            p_expression_node->last_token = ctx->current;

            enum type_specifier_flags char_type = TYPE_SPECIFIER_CHAR;

            if (get_char_type(ctx->current->lexeme) == 2)
            {
                /*
                   automatically finding out the type of wchar_t to copy
                   GCC or MSVC.
                   windows it is short linux is
                */
                char_type = CAKE_WCHAR_T_TYPE_SPECIFIER;
            }
            /*
              string concatenation should have been done in a previous phase
              but since we keep the source format here it was an alternative
            */

            const int char_byte_size = string_literal_char_byte_size(ctx->current->lexeme);
            int number_of_bytes = 0;
            while (ctx->current->type == TK_STRING_LITERAL)
            {
                //"part1" "part2" TODO check different types
                number_of_bytes += string_literal_byte_size_not_zero_included(ctx->current->lexeme);
                parser_match(ctx);
                if (ctx->current == NULL) throw;
            }
            p_expression_node->type = type_make_literal_string(number_of_bytes + (1 * char_byte_size), char_type);
        }
        else if (ctx->current->type == TK_CHAR_CONSTANT)
        {
            p_expression_node = character_constant_expression(ctx);
        }

        else if (ctx->current->type == TK_KEYWORD_TRUE ||
                 ctx->current->type == TK_KEYWORD_FALSE)
        {
            p_expression_node = calloc(1, sizeof * p_expression_node);
            if (p_expression_node == NULL)
                throw;

            p_expression_node->expression_type = PRIMARY_EXPRESSION_PREDEFINED_CONSTANT;
            p_expression_node->first_token = ctx->current;
            p_expression_node->last_token = ctx->current;

            p_expression_node->constant_value =
                constant_value_make_signed_int(ctx->current->type == TK_KEYWORD_TRUE ? (_Bool)true : (_Bool)false);

            p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_BOOL;
            p_expression_node->type.type_qualifier_flags = 0;

            parser_match(ctx);
            if (ctx->current == NULL) throw;
        }
        else if (ctx->current->type == TK_KEYWORD_NULLPTR)
        {
            p_expression_node = calloc(1, sizeof * p_expression_node);
            if (p_expression_node == NULL)
                throw;

            p_expression_node->expression_type = PRIMARY_EXPRESSION_PREDEFINED_CONSTANT;
            p_expression_node->first_token = ctx->current;
            p_expression_node->last_token = ctx->current;

            p_expression_node->constant_value = constant_value_make_nullptr();

            /*TODO nullptr type*/
            p_expression_node->type.type_specifier_flags = TYPE_SPECIFIER_NULLPTR_T;
            p_expression_node->type.type_qualifier_flags = 0;

            parser_match(ctx);
            if (ctx->current == NULL) throw;
        }
        else if (is_integer_or_floating_constant(ctx->current->type))
        {
            p_expression_node = calloc(1, sizeof * p_expression_node);
            if (p_expression_node == NULL)
                throw;

            p_expression_node->first_token = ctx->current;
            p_expression_node->last_token = ctx->current;
            p_expression_node->expression_type = PRIMARY_EXPRESSION_NUMBER;

            convert_to_number(ctx, p_expression_node, false /*ctx->evaluation_is_disabled*/);

            parser_match(ctx);
            if (ctx->current == NULL) throw;
        }
        else if (ctx->current->type == TK_KEYWORD__GENERIC)
        {
            p_expression_node = calloc(1, sizeof * p_expression_node);
            if (p_expression_node == NULL)
                throw;
            p_expression_node->first_token = ctx->current;

            p_expression_node->expression_type = PRIMARY_EXPRESSION_GENERIC;

            p_expression_node->generic_selection = generic_selection(ctx);
            if (p_expression_node->generic_selection == NULL)
                throw;

            p_expression_node->last_token = p_expression_node->generic_selection->last_token;

            if (p_expression_node->generic_selection->p_view_selected_expression)
            {
                p_expression_node->type = type_dup(&p_expression_node->generic_selection->p_view_selected_expression->type);

                p_expression_node->constant_value = p_expression_node->generic_selection->p_view_selected_expression->constant_value;
            }
            else
            {
                compiler_diagnostic_message(C_ERROR_NO_MATCH_FOR_GENERIC, ctx, ctx->current, NULL, "no match for generic");
            }
        }
        else if (ctx->current->type == '(')
        {
            p_expression_node = calloc(1, sizeof * p_expression_node);
            if (p_expression_node == NULL) throw;

            p_expression_node->expression_type = PRIMARY_EXPRESSION_PARENTESIS;
            p_expression_node->first_token = ctx->current;
            parser_match(ctx);
            if (ctx->current == NULL) throw;

            p_expression_node->right = expression(ctx);
            if (p_expression_node->right == NULL)
                throw;

            p_expression_node->type = type_dup(&p_expression_node->right->type);
            p_expression_node->constant_value = p_expression_node->right->constant_value;

            if (ctx->current == NULL) throw;

            p_expression_node->last_token = ctx->current;
            if (parser_match_tk(ctx, ')') != 0)
                throw;
        }
        else
        {
            compiler_diagnostic_message(C_ERROR_UNEXPECTED, ctx, ctx->current, NULL, "unexpected");
            throw;
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    assert(p_expression_node == NULL || (p_expression_node->first_token && p_expression_node->last_token));

    return p_expression_node;
}

void argument_expression_delete(struct argument_expression* _Owner _Opt p)
{
    if (p)
    {
        expression_delete(p->expression);
        assert(p->next == NULL);
        free(p);
    }
}

struct argument_expression_list argument_expression_list(struct parser_ctx* ctx)
{
    /*
     argument-expression-list:
      assignment-expression
      argument-expression-ctx , assignment-expression
    */

    /*
     argument-expression-list: (extended)
      assignment-expression
      move assignment-expression
      argument-expression-ctx , assignment-expression
      argument-expression-ctx , assignment-expression
    */

    struct argument_expression_list list = { 0 };
    struct argument_expression* _Owner _Opt p_argument_expression = NULL;

    try
    {
        p_argument_expression = calloc(1, sizeof(struct argument_expression));
        if (p_argument_expression == NULL)
            throw;

        struct expression* _Owner _Opt p_assignment_expression = assignment_expression(ctx);
        if (p_assignment_expression == NULL)
        {
            argument_expression_delete(p_argument_expression);
            throw;
        }

        p_argument_expression->expression = p_assignment_expression;
        argument_expression_list_push(&list, p_argument_expression);

        if (ctx->current == NULL)
            throw;

        while (ctx->current->type == ',')
        {
            parser_match(ctx);
            if (ctx->current == NULL) throw;

            struct argument_expression* _Owner _Opt p_argument_expression_2 = calloc(1, sizeof * p_argument_expression_2);
            if (p_argument_expression_2 == NULL)
                throw;
            struct expression* _Owner _Opt p_assignment_expression_2 = assignment_expression(ctx);
            if (p_assignment_expression_2 == NULL)
            {
                argument_expression_delete(p_argument_expression_2);
                throw;
            }
            p_argument_expression_2->expression = p_assignment_expression_2;

            argument_expression_list_push(&list, p_argument_expression_2);

            if (ctx->current == NULL)
            {
                //unexpected end of file
                throw;
            }
        }
    }
    catch
    {
    }
    return list;
}

bool first_of_postfix_expression(const struct parser_ctx* ctx)
{
    //( type-name )  postfix confunde com (expression) primary
    if (first_of_type_name_ahead(ctx))
        return true;// I don't think it's necessary because primary also works for postfix
    return is_first_of_primary_expression(ctx);
}

static void fix_member_type(struct type* p_type, const struct type* struct_type, const struct type* member_type)
{
    if (struct_type->type_qualifier_flags & TYPE_QUALIFIER_CONST)
    {
        /*
          struct X { int i; };
          const struct X x;
          x.i ;//x.i is const
        */
        p_type->type_qualifier_flags |= TYPE_QUALIFIER_CONST;
    }

    /*
          struct X { int i; };
          const struct X x;
          x.i ;//x.i is also local, or parameter etc.
    */
    p_type->storage_class_specifier_flags = struct_type->storage_class_specifier_flags;

    if (struct_type->type_qualifier_flags & TYPE_QUALIFIER_VIEW)
    {
        /*
          struct X { _Owner int i; };
          _View struct X x;
          x.i ;//is is not _Owner
        */
        p_type->type_qualifier_flags &= ~TYPE_QUALIFIER_OWNER;
    }

    if (struct_type->type_qualifier_flags & TYPE_QUALIFIER_NULLABLE)
    {
        /*
          struct X { _Owner int i; };
          _View struct X x;
          x.i ;//is is not _Owner
        */
        p_type->type_qualifier_flags |= TYPE_QUALIFIER_NULLABLE;
    }

}

static void fix_arrow_member_type(struct type* p_type, const struct type* left, const struct type* member_type)
{
    struct type t = type_remove_pointer(left);

    if (t.type_qualifier_flags & TYPE_QUALIFIER_CONST)
    {
        /*
           const struct X * p;
        */

        p_type->type_qualifier_flags |= TYPE_QUALIFIER_CONST;
    }

    if (t.type_qualifier_flags & TYPE_QUALIFIER_NULLABLE)
    {
        /*
           const struct X * p;
        */

        p_type->type_qualifier_flags |= TYPE_QUALIFIER_NULLABLE;
    }

    if (t.type_qualifier_flags & TYPE_QUALIFIER_VIEW)
    {
        /*
          _View struct X * p;
        */
        p_type->type_qualifier_flags &= ~TYPE_QUALIFIER_OWNER;
    }

    type_destroy(&t);
}

struct expression* _Owner _Opt postfix_expression_tail(struct parser_ctx* ctx, struct expression* _Owner p_expression_node_param)
{

    /*
       argument cannot be null, but here p_expression_node can be null
    */
    struct expression* _Owner _Opt p_expression_node = p_expression_node_param;

    try
    {
        while (ctx->current != NULL)
        {
            if (ctx->current->type == '[')
            {
                struct expression* _Owner _Opt p_expression_node_new = calloc(1, sizeof * p_expression_node_new);
                if (p_expression_node_new == NULL) throw;
                p_expression_node->last_token = ctx->current;
                p_expression_node_new->first_token = ctx->current;
                p_expression_node_new->expression_type = POSTFIX_ARRAY;
                // the result of the subscription operator ([])

                if (!type_is_pointer_or_array(&p_expression_node->type))
                {
                    compiler_diagnostic_message(C_ERROR_SUBSCRIPTED_VALUE_IS_NEITHER_ARRAY_NOR_POINTER,
                                                ctx,
                                                ctx->current, NULL,
                                                "subscripted value is neither array nor pointer");
                }

                if (type_is_pointer(&p_expression_node->type))
                {
                    p_expression_node_new->type = type_remove_pointer(&p_expression_node->type);
                }
                else if (type_is_array(&p_expression_node->type))
                {
                    p_expression_node_new->type = get_array_item_type(&p_expression_node->type);
                }

                parser_match(ctx);
                if (ctx->current == NULL)
                {
                    expression_delete(p_expression_node_new);
                    throw;
                }

                /*contem a expresao de dentro do  [ ] */
                p_expression_node_new->right = expression(ctx);
                if (p_expression_node_new->right == NULL)
                {
                    expression_delete(p_expression_node_new);
                    throw;
                }

                if (constant_value_is_valid(&p_expression_node_new->right->constant_value))
                {
                    unsigned long long index =
                        constant_value_to_unsigned_long_long(&p_expression_node_new->right->constant_value);
                    if (type_is_array(&p_expression_node->type))
                    {
                        if (p_expression_node->type.num_of_elements > 0)
                        {
                            if (index >= (unsigned long long)p_expression_node->type.num_of_elements)
                            {
                                compiler_diagnostic_message(W_OUT_OF_BOUNDS,
                                                            ctx,
                                                            ctx->current, NULL,
                                                            "index %d is past the end of the array", index);
                            }
                        }
                    }
                }
                if (parser_match_tk(ctx, ']') != 0)
                {
                    expression_delete(p_expression_node_new);
                    p_expression_node_new = NULL;
                    throw;
                }

                p_expression_node_new->left = p_expression_node;
                p_expression_node = p_expression_node_new;
            }
            else if (ctx->current->type == '(')
            {
                struct expression* _Owner _Opt p_expression_node_new = calloc(1, sizeof * p_expression_node_new);
                if (p_expression_node_new == NULL) throw;
                p_expression_node->last_token = ctx->current;
                p_expression_node_new->first_token = p_expression_node->first_token;
                p_expression_node_new->expression_type = POSTFIX_FUNCTION_CALL;

                if (!type_is_function_or_function_pointer(&p_expression_node->type))
                {
                    compiler_diagnostic_message(C_ERROR_CALLED_OBJECT_IS_NOT_FUNCTION_OR_FUNCTION_POINTER,
                                                ctx,
                                                ctx->current,
                                                NULL,
                                                "called object is not attr function or function pointer");
                }

                p_expression_node_new->type = get_function_return_type(&p_expression_node->type);

                parser_match(ctx);
                if (ctx->current == NULL)
                {
                    expression_delete(p_expression_node_new);
                    p_expression_node_new = NULL;
                    throw;
                }

                if (ctx->current->type != ')')
                {
                    p_expression_node_new->argument_expression_list = argument_expression_list(ctx);
                }
                if (parser_match_tk(ctx, ')') != 0)
                {
                    expression_delete(p_expression_node_new);
                    p_expression_node_new = NULL;
                    throw;
                }

                compare_function_arguments(ctx, &p_expression_node->type, &p_expression_node_new->argument_expression_list);

                if (ctx->previous == NULL)
                {
                    expression_delete(p_expression_node_new);
                    p_expression_node_new = NULL;
                    throw;
                }

                p_expression_node_new->last_token = ctx->previous;

                p_expression_node_new->left = p_expression_node;
                p_expression_node = p_expression_node_new;
            }
            else if (ctx->current->type == '.')
            {
                struct expression* _Owner _Opt p_expression_node_new = calloc(1, sizeof * p_expression_node_new);
                if (p_expression_node_new == NULL) throw;
                p_expression_node->last_token = ctx->current;
                p_expression_node_new->first_token = ctx->current;
                p_expression_node_new->expression_type = POSTFIX_DOT;
                p_expression_node_new->left = p_expression_node;
                p_expression_node = NULL; /*MOVED*/

                p_expression_node_new->declarator = p_expression_node_new->left->declarator;

                parser_match(ctx);
                if (ctx->current == NULL)
                {
                    expression_delete(p_expression_node_new);
                    p_expression_node_new = NULL;
                    throw;
                }

                if (p_expression_node_new->left->type.type_specifier_flags & TYPE_SPECIFIER_STRUCT_OR_UNION)
                {
                    assert(p_expression_node_new->left->type.struct_or_union_specifier != NULL);

                    struct struct_or_union_specifier* _Opt p =
                        find_struct_or_union_specifier(ctx, p_expression_node_new->left->type.struct_or_union_specifier->tag_name);

                    if (p)
                        p = get_complete_struct_or_union_specifier(p);

                    if (p)
                    {
                        assert(ctx->current != NULL);

                        int member_index = 0;
                        struct member_declarator* _Opt p_member_declarator =
                            find_member_declarator(&p->member_declaration_list, ctx->current->lexeme, &member_index);

                        if (p_member_declarator)
                        {
                            p_expression_node_new->member_index = member_index;

                            if (p_member_declarator->declarator)
                            {
                                p_expression_node_new->type = make_type_using_declarator(ctx, p_member_declarator->declarator);
                            }
                            else
                            {
                                /*
                                struct X {
                                    int : 1;
                                };
                                */
                            }

                            if (p_member_declarator->declarator != NULL)
                            {
                                fix_member_type(&p_expression_node_new->type,
                                                &p_expression_node_new->left->type,
                                                &p_member_declarator->declarator->type);
                            }
                        }
                        else
                        {
                            compiler_diagnostic_message(C_ERROR_STRUCT_MEMBER_NOT_FOUND,
                                                    ctx,
                                                    ctx->current, NULL,
                                                    "member '%s' not found in 'struct %s'",
                                                    ctx->current->lexeme,
                                                    p->tag_name);
                        }
                    }
                    else
                    {
                        compiler_diagnostic_message(C_ERROR_STRUCT_MEMBER_NOT_FOUND,
                                                 ctx,
                                                 ctx->current, NULL,
                                                 "incomplete struct type '%s'",
                                                 p_expression_node_new->left->type.struct_or_union_specifier->tag_name);
                        //print_scope(&ctx->scopes);
                    }
                    if (parser_match_tk(ctx, TK_IDENTIFIER) != 0)
                    {
                        expression_delete(p_expression_node_new);
                        p_expression_node_new = NULL;
                        throw;
                    }
                }
                else
                {
                    compiler_diagnostic_message(C_ERROR_STRUCTURE_OR_UNION_REQUIRED,
                                                ctx,
                                                ctx->current, NULL,
                                                "structure or union required");
                }
                // todo apontar pro nome?
                p_expression_node = p_expression_node_new;
            }
            else if (ctx->current->type == '->')
            {
                /*
                             p_expression_node_new
                           (left)   /  \  (right)
                                   /    \
                  p_expression_node      NULL
                */

                struct expression* _Owner _Opt p_expression_node_new = calloc(1, sizeof * p_expression_node_new);
                if (p_expression_node_new == NULL) throw;

                p_expression_node->last_token = ctx->current;
                p_expression_node_new->first_token = p_expression_node->first_token;
                p_expression_node_new->last_token = ctx->current;
                p_expression_node_new->expression_type = POSTFIX_ARROW;

                // the result of a member access through pointer -> operator is lvalue

                parser_match(ctx);
                if (ctx->current == NULL)
                {
                    expression_delete(p_expression_node_new);
                    p_expression_node_new = NULL;
                    throw;
                }

                if (type_is_pointer_or_array(&p_expression_node->type))
                {
                    struct type item_type = { 0 };
                    if (type_is_array(&p_expression_node->type))
                    {
                        compiler_diagnostic_message(W_ARRAY_INDIRECTION, ctx, ctx->current, NULL, "using indirection '->' in array");
                        item_type = get_array_item_type(&p_expression_node->type);
                    }
                    else
                    {
                        item_type = type_remove_pointer(&p_expression_node->type);
                    }

                    if (type_is_struct_or_union(&item_type))
                    {
                        assert(p_expression_node->type.next);
                        assert(p_expression_node->type.next->struct_or_union_specifier);

                        struct struct_or_union_specifier* _Opt p_complete =
                            get_complete_struct_or_union_specifier(p_expression_node->type.next->struct_or_union_specifier);

                        if (p_complete)
                        {
                            int member_index = 0;
                            struct member_declarator* _Opt p_member_declarator =
                                find_member_declarator(&p_complete->member_declaration_list, ctx->current->lexeme, &member_index);

                            if (p_member_declarator)
                            {
                                if (p_member_declarator->declarator)
                                {
                                    p_expression_node_new->member_index = member_index;
                                    p_expression_node_new->type = make_type_using_declarator(ctx, p_member_declarator->declarator);
                                    fix_arrow_member_type(&p_expression_node_new->type, &p_expression_node->type, &p_expression_node_new->type);
                                }
                                else
                                {
                                    assert(false); //TODO
                                }
                            }
                            else
                            {
                                compiler_diagnostic_message(C_ERROR_STRUCT_MEMBER_NOT_FOUND,
                                                            ctx,
                                                            ctx->current, NULL,
                                                            "member '%s' not found in struct '%s'",
                                                            ctx->current->lexeme,
                                                            p_expression_node->type.next->struct_or_union_specifier->tag_name);
                            }
                        }
                        else
                        {
                            compiler_diagnostic_message(C_ERROR_STRUCT_IS_INCOMPLETE,
                                                        ctx,
                                                        ctx->current, NULL,
                                                        "struct '%s' is incomplete.",
                                                        ctx->current->lexeme);
                        }
                        if (parser_match_tk(ctx, TK_IDENTIFIER) != 0)
                        {
                            type_destroy(&item_type);
                            expression_delete(p_expression_node_new);
                            p_expression_node_new = NULL;
                            throw;
                        }
                    }
                    else
                    {
                        compiler_diagnostic_message(C_ERROR_STRUCTURE_OR_UNION_REQUIRED,
                                                    ctx,
                                                    ctx->current, NULL,
                                                    "structure or union required");
                    }
                    type_destroy(&item_type);
                }
                else
                {
                    compiler_diagnostic_message(C_ERROR_STRUCTURE_OR_UNION_REQUIRED,
                                                ctx,
                                                ctx->current, NULL,
                                                "structure or union required");
                }

                p_expression_node_new->left = p_expression_node;
                p_expression_node = p_expression_node_new;
            }
            else if (ctx->current->type == '++')
            {
                p_expression_node->last_token = ctx->current;

                if (type_is_owner(&p_expression_node->type))
                {
                    compiler_diagnostic_message(C_ERROR_OPERATOR_INCREMENT_CANNOT_BE_USED_IN_OWNER,
                                                ctx,
                                                p_expression_node->first_token, NULL,
                                                "operator ++ cannot be used in _Owner pointers");
                }

                if (!expression_is_lvalue(p_expression_node))
                {
                    compiler_diagnostic_message(C_ERROR_OPERATOR_NEEDS_LVALUE,
                                                ctx,
                                                p_expression_node->first_token, NULL,
                                                "lvalue required as increment operand");
                }


                struct expression* _Owner _Opt p_expression_node_new = calloc(1, sizeof * p_expression_node_new);
                if (p_expression_node_new == NULL) throw;

                p_expression_node->last_token = ctx->current;
                p_expression_node_new->first_token = ctx->current;
                p_expression_node_new->expression_type = POSTFIX_INCREMENT;

                p_expression_node_new->type = type_dup(&p_expression_node->type);
                parser_match(ctx);
                if (ctx->current == NULL)
                {
                    expression_delete(p_expression_node_new);
                    p_expression_node_new = NULL;
                    throw;
                }

                p_expression_node_new->left = p_expression_node;
                p_expression_node = p_expression_node_new;
            }
            else if (ctx->current->type == '--')
            {
                p_expression_node->last_token = ctx->current;

                if (type_is_owner(&p_expression_node->type))
                {
                    compiler_diagnostic_message(C_ERROR_OPERATOR_DECREMENT_CANNOT_BE_USED_IN_OWNER,
                                                ctx,
                                                p_expression_node->first_token, NULL,
                                                "operator -- cannot be used in owner pointers");
                }

                if (!expression_is_lvalue(p_expression_node))
                {
                    compiler_diagnostic_message(C_ERROR_OPERATOR_NEEDS_LVALUE,
                                                ctx,
                                                p_expression_node->first_token, NULL,
                                                "lvalue required as decrement operand");
                }

                struct expression* _Owner _Opt p_expression_node_new = calloc(1, sizeof * p_expression_node_new);
                if (p_expression_node_new == NULL) throw;


                p_expression_node_new->first_token = ctx->current;
                p_expression_node_new->expression_type = POSTFIX_DECREMENT;

                p_expression_node_new->type = type_dup(&p_expression_node->type);
                parser_match(ctx);
                if (ctx->current == NULL)
                {
                    expression_delete(p_expression_node_new);
                    p_expression_node_new = NULL;
                    throw;
                }

                p_expression_node_new->left = p_expression_node;
                p_expression_node = p_expression_node_new;
            }
            else
            {
                struct token* _Opt p_last = previous_parser_token(ctx->current);
                if (p_last == NULL)
                    throw; //unexpected

                p_expression_node->last_token = p_last;
                break;
            }
        }
    }
    catch
    {
    }

    return p_expression_node;
}

struct expression* _Owner _Opt postfix_expression_type_name(struct parser_ctx* ctx, struct type_name* _Owner p_type_name_par)
{
    /*
        ( type-name ) { initializer-ctx }
        ( type-name ) { initializer-ctx , }

        //My extension : if type-name is function then follow is compound-statement
        ( type-name ) compound-statement

    */
    struct type_name* _Owner _Opt p_type_name = p_type_name_par; //MOVED
    struct expression* _Owner _Opt p_expression_node = NULL;

    try
    {
        p_expression_node = calloc(1, sizeof * p_expression_node);
        if (p_expression_node == NULL)
            throw;

        assert(p_expression_node->type_name == NULL);

        struct token* _Opt p_previous = previous_parser_token(p_type_name->first_token);
        if (p_previous == NULL)
            throw;

        p_expression_node->first_token = p_previous;
        assert(p_expression_node->first_token->type == '(');

        p_expression_node->type_name = p_type_name; /*MOVED*/
        p_type_name = NULL; /*MOVED*/
        p_expression_node->type = make_type_using_declarator(ctx, p_expression_node->type_name->abstract_declarator);

        if (type_is_function(&p_expression_node->type_name->abstract_declarator->type))
        {
            p_expression_node->expression_type = POSTFIX_EXPRESSION_FUNCTION_LITERAL;

            struct scope* parameters_scope =
                &p_expression_node->type_name->abstract_declarator->direct_declarator->function_declarator->parameters_scope;

            scope_list_push(&ctx->scopes, parameters_scope);
            p_expression_node->compound_statement = function_body(ctx);
            scope_list_pop(&ctx->scopes);
        }
        else
        {
            p_expression_node->expression_type = POSTFIX_EXPRESSION_COMPOUND_LITERAL;
            p_expression_node->braced_initializer = braced_initializer(ctx);
        }

        if (ctx->previous == NULL)
            throw;

        p_expression_node->last_token = ctx->previous;

        p_expression_node = postfix_expression_tail(ctx, p_expression_node);
        if (p_expression_node == NULL)
            throw;
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }
    type_name_delete(p_type_name);
    return p_expression_node;
}

struct expression* _Owner _Opt postfix_expression(struct parser_ctx* ctx)
{
    /*
      postfix-expression:
        primary-expression
        postfix-expression [ expression ]
        postfix-expression ( argument-expression-list_opt)
        postfix-expression . identifier
        postfix-expression -> identifier
        postfix-expression ++
        postfix-expression --
        ( type-name ) { initializer-ctx }
        ( type-name ) { initializer-ctx , }

        //My extension : if type-name is function then follow is compound-statement
        ( type-name ) compound-statement

        */
    struct expression* _Owner _Opt p_expression_node = NULL;
    try
    {


        if (first_of_type_name_ahead(ctx)) // aqui preciso ver se nao eh primary
        {
            assert(false); // este caso esta pegando lá dentro deo cast expression.
            p_expression_node = calloc(1, sizeof * p_expression_node);
            if (p_expression_node == NULL)
                throw;


            assert(ctx->current != NULL);
            p_expression_node->first_token = ctx->current;
            if (parser_match_tk(ctx, '(') != 0)
                throw;

            p_expression_node->type_name = type_name(ctx);
            if (p_expression_node->type_name == NULL)
                throw;

            p_expression_node->type = make_type_using_declarator(ctx, p_expression_node->type_name->abstract_declarator);

            if (parser_match_tk(ctx, ')') != 0)
                throw;
            // printf("\n");
            // print_type(&p_expression_node->type);
            bool is_function_type = type_is_function(&p_expression_node->type);

            if (is_function_type)
            {
                p_expression_node->expression_type = POSTFIX_EXPRESSION_FUNCTION_LITERAL;
                p_expression_node->compound_statement = compound_statement(ctx);
                if (p_expression_node->compound_statement == NULL)
                    throw;

                p_expression_node->last_token = p_expression_node->compound_statement->last_token;
            }
            else
            {
                p_expression_node->expression_type = POSTFIX_EXPRESSION_COMPOUND_LITERAL;
                p_expression_node->braced_initializer = braced_initializer(ctx);
                if (p_expression_node->braced_initializer == NULL) throw;
                if (ctx->current == NULL) throw;

                p_expression_node->last_token = ctx->current;
            }
        }
        else
        {
            p_expression_node = primary_expression(ctx);
            if (p_expression_node == NULL)
                throw;
        }

        p_expression_node = postfix_expression_tail(ctx, p_expression_node);
        if (p_expression_node == NULL)
            throw;
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }
    return p_expression_node;
}

bool is_first_of_compiler_function(struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return
        // traits
        ctx->current->type == TK_KEYWORD_IS_LVALUE ||
        ctx->current->type == TK_KEYWORD_IS_OWNER ||
        ctx->current->type == TK_KEYWORD_IS_CONST ||
        ctx->current->type == TK_KEYWORD_IS_POINTER ||
        ctx->current->type == TK_KEYWORD_IS_ARRAY ||
        ctx->current->type == TK_KEYWORD_IS_FUNCTION ||

        ctx->current->type == TK_KEYWORD_ASSERT ||

        ctx->current->type == TK_KEYWORD_IS_SCALAR ||
        ctx->current->type == TK_KEYWORD_IS_ARITHMETIC ||
        ctx->current->type == TK_KEYWORD_IS_FLOATING_POINT ||
        ctx->current->type == TK_KEYWORD_IS_INTEGRAL;
}

bool is_first_of_unary_expression(struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;
    return first_of_postfix_expression(ctx) ||
        ctx->current->type == '++' ||
        ctx->current->type == '--' ||
        ctx->current->type == '&' ||
        ctx->current->type == '*' ||
        ctx->current->type == '+' ||
        ctx->current->type == '-' ||
        ctx->current->type == '~' ||
        ctx->current->type == '!' ||
        ctx->current->type == TK_KEYWORD_SIZEOF ||
        ctx->current->type == TK_KEYWORD_NELEMENTSOF ||
        ctx->current->type == TK_KEYWORD__ALIGNOF ||
        is_first_of_compiler_function(ctx);
}

static int check_sizeof_argument(struct parser_ctx* ctx,
    const struct expression* p_expression,
    const struct type* const p_type)
{
    //sizeof(type)  p_expression is the sizeof expression
    //sizeof(expression) p_expression is expression


    enum type_category category = type_get_category(p_type);

    if (category == TYPE_CATEGORY_FUNCTION)
    {
        //In GCC returns 1

        //The sizeof operator shall not be applied to an expression that has function type or an incomplete type
    }
    else if (category == TYPE_CATEGORY_ITSELF &&
            p_type->type_specifier_flags & TYPE_SPECIFIER_STRUCT_OR_UNION)
    {
        assert(p_type->struct_or_union_specifier);

        struct struct_or_union_specifier* _Opt p_complete =
            get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);
        if (p_complete == NULL)
        {
            //The sizeof operator shall not be applied to an expression that has function type or an incomplete type
            compiler_diagnostic_message(C_ERROR_STRUCT_IS_INCOMPLETE,
                                       ctx,
                                       p_expression->first_token,
                                       NULL,
                                       "struct is incomplete type");
            return -1;
        }
    }
    else if (category == TYPE_CATEGORY_ARRAY)
    {
        if (type_is_vla(p_type))
        {
            return 0;
        }

        if (p_type->storage_class_specifier_flags & STORAGE_SPECIFIER_PARAMETER)
        {
            //GCC
            //<source>:4:21: warning: 'sizeof' on array function parameter 'a' will return size of 'int *' [-Wsizeof-array-argument]
            //CLANG
            //<source>:4:21: warning: sizeof on array function parameter will return size of 'int *' instead of 'int[]' [-Wsizeof-array-argument]

            compiler_diagnostic_message(W_SIZEOF_ARRAY_ARGUMENT,
                                        ctx,
                                        p_expression->first_token,
                                        NULL,
                                        "sizeof applied to array function parameter");

        }
    }

    return 0; //ok
}

struct expression* _Owner _Opt unary_expression(struct parser_ctx* ctx)
{
    /*
    unary-expression:
      postfix-expression
      ++ unary-expression
      -- unary-expression

      one of (& * + - ~ !) cast-expression

      sizeof unary-expression
      sizeof ( type-name )
      _Alignof ( type-name )



      */
    struct expression* _Owner _Opt p_expression_node = NULL;
    try
    {
        if (ctx->current == NULL)
            throw;

        if (ctx->current->type == '++' || ctx->current->type == '--')
        {
            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL) throw;

            new_expression->first_token = ctx->current;

            if (ctx->current->type == '++')
                new_expression->expression_type = UNARY_EXPRESSION_INCREMENT;
            else
                new_expression->expression_type = UNARY_EXPRESSION_DECREMENT;
            parser_match(ctx);
            if (ctx->current == NULL)
            {
                expression_delete(new_expression);
                throw;
            }
            new_expression->right = unary_expression(ctx);
            if (new_expression->right == NULL)
            {
                expression_delete(new_expression);
                throw;
            }

            new_expression->type = type_dup(&new_expression->right->type);
            p_expression_node = new_expression;
        }
        else if (ctx->current->type == '&' ||
                 ctx->current->type == '*' ||
                 ctx->current->type == '+' ||
                 ctx->current->type == '-' ||
                 ctx->current->type == '~' ||
                 ctx->current->type == '!')
        {

            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL) throw;

            new_expression->first_token = ctx->current;

            struct token* op_position = ctx->current; // marcar posicao
            enum token_type op = ctx->current->type;
            parser_match(ctx);
            if (ctx->current == NULL)
            {
                expression_delete(new_expression);
                throw;
            }
#if 0
            //visual studio formater is adding spaces..
            if (style_has_space(ctx->current))
            {
                compiler_diagnostic_message(W_STYLE, ctx, ctx->current, "don't use spaces");
            }
#endif

            new_expression->right = cast_expression(ctx);
            if (new_expression->right == NULL)
            {
                expression_delete(new_expression);
                throw;
            }

            new_expression->last_token = new_expression->right->last_token;
            if (op == '!')
            {
                new_expression->expression_type = UNARY_EXPRESSION_NOT;
                if (!ctx->evaluation_is_disabled &&
                    constant_value_is_valid(&new_expression->right->constant_value))
                {
                    const bool v = constant_value_to_bool(&new_expression->right->constant_value);
                    new_expression->constant_value = constant_value_make_signed_int(!v);
                }
                new_expression->type = type_make_int_bool_like();
            }
            else if (op == '~')
            {
                if (!type_is_integer(&new_expression->right->type))
                {
                    compiler_diagnostic_message(C_ERROR_RIGHT_IS_NOT_INTEGER,
                                               ctx,
                                               op_position,
                                               NULL,
                                               "requires integer type");

                    expression_delete(new_expression);
                    throw;
                }

                new_expression->expression_type = UNARY_EXPRESSION_BITNOT;

                /*
                The result of the ~ operator is the bitwise complement of its (promoted) operand (that is, each bit in
                the result is set if and only if the corresponding bit in the converted operand is not set). The integer
                promotions are performed on the operand, and the result has the promoted type. If the promoted
                type is an unsigned type, the expression ~E is equivalent to the maximum value representable in
                that type minus E.
                */
                struct type promoted = type_dup(&new_expression->right->type);
                type_integer_promotion(&promoted);
                new_expression->type = promoted;

                if (!ctx->evaluation_is_disabled &&
                  constant_value_is_valid(&new_expression->right->constant_value))
                {
                    enum constant_value_type vt = type_to_constant_value_type(&new_expression->type);
                    switch (vt)
                    {
                    case TYPE_SIGNED_INT:
                    {
                        signed int r = constant_value_to_signed_int(&new_expression->right->constant_value);
                        new_expression->constant_value = constant_value_make_signed_int(~r);
                    }
                    break;

                    case TYPE_UNSIGNED_INT:
                    {
                        unsigned int r = constant_value_to_unsigned_int(&new_expression->right->constant_value);
                        new_expression->constant_value = constant_value_make_unsigned_int(~r);
                    }
                    break;

                    case TYPE_SIGNED_LONG:
                    {
                        signed long r = constant_value_to_signed_long(&new_expression->right->constant_value);
                        new_expression->constant_value = constant_value_make_signed_long(~r);
                    }
                    break;
                    case TYPE_UNSIGNED_LONG:
                    {
                        unsigned long r = constant_value_to_unsigned_long(&new_expression->right->constant_value);
                        new_expression->constant_value = constant_value_make_unsigned_long(~r);
                    }
                    break;

                    case TYPE_SIGNED_LONG_LONG:
                    {
                        signed long long r = constant_value_to_signed_long_long(&new_expression->right->constant_value);
                        new_expression->constant_value = constant_value_make_signed_long_long(~r);
                    }
                    break;
                    case TYPE_UNSIGNED_LONG_LONG:
                    {
                        unsigned long long r = constant_value_to_unsigned_long_long(&new_expression->right->constant_value);
                        new_expression->constant_value = constant_value_make_unsigned_long_long(~r);
                    }
                    break;

                    case TYPE_SIGNED_SHORT:
                    case TYPE_UNSIGNED_SHORT:
                    case TYPE_SIGNED_CHAR:
                    case TYPE_UNSIGNED_CHAR:
                    case TYPE_NOT_CONSTANT:
                    case TYPE_BOOL:
                    case TYPE_FLOAT:
                    case TYPE_DOUBLE:
                    case TYPE_LONG_DOUBLE:
                        break;
                    };
                }
            }
            else if (op == '-' || op == '+')
            {
                if (op == '-')
                    new_expression->expression_type = UNARY_EXPRESSION_NEG;
                else
                    new_expression->expression_type = UNARY_EXPRESSION_PLUS;

                //promote
                new_expression->type = type_common(&new_expression->right->type, &new_expression->right->type);

                if (!ctx->evaluation_is_disabled &&
                    constant_value_is_valid(&new_expression->right->constant_value))
                {
                    enum constant_value_type vt = type_to_constant_value_type(&new_expression->type);
                    switch (vt)
                    {
                    case TYPE_SIGNED_INT_OR_SIGNED_LONG:
                    {
                        const int a = constant_value_to_signed_int(&new_expression->right->constant_value);
                        if (op == '-')
                            new_expression->constant_value = constant_value_make_signed_int(-a);
                        else
                            new_expression->constant_value = constant_value_make_signed_int(+a);
                    }
                    break;

                    case TYPE_UNSIGNED_INT_OR_UNSIGNEG_LONG:
                    {
                        unsigned int a = constant_value_to_unsigned_int(&new_expression->right->constant_value);
                        if (op == '-')
                        {
                            //error C4146: unary minus operator applied to unsigned type, result still unsigned
                            new_expression->constant_value = constant_value_make_unsigned_int(-a);
                        }
                        else
                            new_expression->constant_value = constant_value_make_unsigned_int(+a);
                    }
                    break;

                    case TYPE_SIGNED_LONG_LONG_OR_SIGNED_LONG:
                    {
                        long long a = constant_value_to_signed_long_long(&new_expression->right->constant_value);
                        if (op == '-')
                            new_expression->constant_value = constant_value_make_signed_long_long(-a);
                        else
                            new_expression->constant_value = constant_value_make_signed_long_long(+a);
                    }
                    break;

                    case TYPE_UNSIGNED_LONG_LONG_OR_UNSIGNEG_LONG:
                    {
                        unsigned long long a = constant_value_to_unsigned_long_long(&new_expression->right->constant_value);

                        if (op == '-')
                        {
                            //error C4146: unary minus operator applied to unsigned type, result still unsigned
                            new_expression->constant_value = constant_value_make_unsigned_long_long(-a);
                        }
                        else
                            new_expression->constant_value = constant_value_make_unsigned_long_long(+a);
                    }
                    break;

                    case TYPE_BOOL:
                    case TYPE_SIGNED_CHAR:
                    case TYPE_UNSIGNED_CHAR:
                    case TYPE_SIGNED_SHORT:
                    case TYPE_UNSIGNED_SHORT:
                        assert(false); //they are promoted
                        expression_delete(new_expression);
                        throw;
                        break;

                    case TYPE_NOT_CONSTANT:
                        assert(false); //they are promoted
                        expression_delete(new_expression);
                        throw;
                        break;

                    case TYPE_FLOAT:
                    {
                        float a = constant_value_to_float(&new_expression->right->constant_value);
                        if (op == '-')
                            new_expression->constant_value = constant_value_make_float(-a);
                        else
                            new_expression->constant_value = constant_value_make_float(+a);
                    }
                    break;
                    case TYPE_DOUBLE:
                    {
                        double a = constant_value_to_double(&new_expression->right->constant_value);
                        if (op == '-')
                            new_expression->constant_value = constant_value_make_double(-a);
                        else
                            new_expression->constant_value = constant_value_make_double(+a);
                    }
                    break;
                    case TYPE_LONG_DOUBLE:
                    {
                        long double a = constant_value_to_long_double(&new_expression->right->constant_value);
                        if (op == '-')
                            new_expression->constant_value = constant_value_make_long_double(-a);
                        else
                            new_expression->constant_value = constant_value_make_long_double(+a);
                    }
                    break;
                    };
                }
                //'//'new_expression->type = type_dup(&new_expression->right->type);
                //type_integer_promotion(&new_expression->type);
            }
            else if (op == '*')
            {
                new_expression->expression_type = UNARY_EXPRESSION_CONTENT;
                // the result of the indirection(unary*) operator applied to a pointer to object

                if (!type_is_pointer_or_array(&new_expression->right->type))
                {
                    compiler_diagnostic_message(C_ERROR_INDIRECTION_REQUIRES_POINTER_OPERAND,
                                                ctx,
                                                op_position,
                        NULL,
                                                "indirection requires pointer operand");
                }
                if (type_is_pointer(&new_expression->right->type))
                {
                    new_expression->type = type_remove_pointer(&new_expression->right->type);
                }
                else
                {
                    compiler_diagnostic_message(W_ARRAY_INDIRECTION,
                                                ctx,
                                                op_position, NULL,
                                                "array indirection");
                    new_expression->type = get_array_item_type(&new_expression->right->type);
                }
            }
            else if (op == '&')
            {
                /*
                  The result of the unary & operator is a pointer to the object referred to by the lvalue-expression.
                  If the type of the lvalue-expression is " . . . ", the type of the result is
                  "pointer to . . ."
                */
                new_expression->expression_type = UNARY_EXPRESSION_ADDRESSOF;

                if (!expression_is_lvalue(new_expression->right))
                {
                    compiler_diagnostic_message(C_ERROR_ADDRESS_OF_REGISTER,
                                                ctx,
                                                new_expression->right->first_token,
                                                NULL,
                                                "lvalue required as unary '&' operand");
                }

                if (new_expression->right->type.storage_class_specifier_flags & STORAGE_SPECIFIER_REGISTER)
                {
                    const char* variable_name = "?";

                    if (new_expression->right->declarator &&
                        new_expression->right->declarator->name_opt)
                    {
                        variable_name = new_expression->right->declarator->name_opt->lexeme;
                    }

                    compiler_diagnostic_message(C_ERROR_ADDRESS_OF_REGISTER,
                                                ctx,
                                                new_expression->right->first_token,
                                                NULL,
                                                "address of register variable 'x' requested",
                                                variable_name);

                }

                new_expression->type = type_add_pointer(&new_expression->right->type, ctx->options.null_checks_enabled);
                new_expression->type.address_of = true;
            }
            else
            {
                expression_delete(new_expression);
                compiler_diagnostic_message(C_ERROR_INVALID_TOKEN,
                                            ctx,
                                            ctx->current,
                    NULL,
                                            "invalid token");
                throw;
            }
            p_expression_node = new_expression;
        }
        else if (ctx->current->type == TK_KEYWORD_SIZEOF)
        {
            const bool disable_evaluation_copy = ctx->evaluation_is_disabled;
            ctx->evaluation_is_disabled = true;
            // defer would be nice here...

            parser_match(ctx);
            if (ctx->current == NULL) throw;

            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL) throw;

            new_expression->first_token = ctx->current;

            if (first_of_type_name_ahead(ctx))
            {
                new_expression->expression_type = UNARY_EXPRESSION_SIZEOF_TYPE;
                if (parser_match_tk(ctx, '(') != 0)
                {
                    expression_delete(new_expression);
                    new_expression = NULL;
                    throw;
                }
                new_expression->type_name = type_name(ctx);
                if (new_expression->type_name == NULL)
                {
                    expression_delete(new_expression);
                    new_expression = NULL;
                    throw;
                }

                new_expression->type = make_size_t_type();

                if (ctx->current == NULL)
                {
                    expression_delete(new_expression);
                    throw;
                }

                new_expression->last_token = ctx->current;

                if (parser_match_tk(ctx, ')') != 0)
                {
                    expression_delete(new_expression);
                    throw;
                }

                if (check_sizeof_argument(ctx, new_expression, &new_expression->type_name->type) != 0)
                {
                    //not fatal error
                    //fatal will be if someone need the sizeof at compile time
                    //but we don't have the constant_value set here
                }
                else
                {
                    if (type_is_vla(&new_expression->type_name->abstract_declarator->type))
                    {
                        //not constant
                    }
                    else
                    {
                        new_expression->constant_value = constant_value_make_size_t(type_get_sizeof(&new_expression->type_name->abstract_declarator->type));
                    }
                }
            }
            else
            {
                new_expression->right = unary_expression(ctx);
                if (new_expression->right == NULL)
                {
                    /*restore*/
                    ctx->evaluation_is_disabled = disable_evaluation_copy;
                    expression_delete(new_expression);
                    throw;
                }

                new_expression->expression_type = UNARY_EXPRESSION_SIZEOF_EXPRESSION;

                if (check_sizeof_argument(ctx, new_expression->right, &new_expression->right->type) != 0)
                {
                    expression_delete(new_expression);
                    throw;
                }

                if (type_is_vla(&new_expression->right->type))
                {
                    //not constant
                }
                else
                {
                    new_expression->constant_value = constant_value_make_size_t(type_get_sizeof(&new_expression->right->type));
                }
            }

            type_destroy(&new_expression->type);
            new_expression->type = type_make_size_t();
            p_expression_node = new_expression;

            /*restore*/
            ctx->evaluation_is_disabled = disable_evaluation_copy;
        }
        else if (ctx->current->type == TK_KEYWORD_NELEMENTSOF)//C2Y
        {
            // defer would be nice here...


            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL) throw;

            new_expression->first_token = ctx->current;

            parser_match(ctx);
            if (ctx->current == NULL)
            {
                expression_delete(new_expression);
                throw;
            }

            new_expression->expression_type = UNARY_EXPRESSION_NELEMENTSOF_TYPE;

            if (first_of_type_name_ahead(ctx))
            {
                if (parser_match_tk(ctx, '(') != 0)
                {
                    expression_delete(new_expression);
                    throw;
                }
                new_expression->type_name = type_name(ctx);
                if (new_expression->type_name == NULL)
                {
                    expression_delete(new_expression);
                    throw;
                }

                new_expression->type = make_size_t_type();

                if (ctx->current == NULL)
                {
                    expression_delete(new_expression);
                    throw;
                }

                new_expression->last_token = ctx->current;

                if (parser_match_tk(ctx, ')') != 0)
                {
                    expression_delete(new_expression);
                    throw;
                }

                if (!type_is_array(&new_expression->type_name->abstract_declarator->type))
                {
                    compiler_diagnostic_message(C_INVALID_ARGUMENT_NELEMENTSOF,
                        ctx,
                        new_expression->type_name->first_token,
                        NULL,
                        "argument of nelementsof must be an array");

                    expression_delete(new_expression);
                    throw;
                }


                int nelements = new_expression->type_name->abstract_declarator->type.num_of_elements;
                if (nelements > 0)
                    new_expression->constant_value = constant_value_make_size_t(nelements);

            }
            else
            {
                if (parser_match_tk(ctx, '(') != 0)
                {
                    expression_delete(new_expression);
                    new_expression = NULL;
                    throw;
                }

                const bool disable_evaluation_copy = ctx->evaluation_is_disabled;
                ctx->evaluation_is_disabled = true;
                new_expression->right = unary_expression(ctx);
                /*restore*/
                ctx->evaluation_is_disabled = disable_evaluation_copy;

                if (new_expression->right == NULL)
                {
                    expression_delete(new_expression);
                    throw;
                }

                if (ctx->current == NULL)
                {
                    expression_delete(new_expression);
                    throw;
                }

                new_expression->last_token = ctx->current;

                if (parser_match_tk(ctx, ')') != 0)
                {
                    expression_delete(new_expression);
                    throw;
                }

                if (!type_is_array(&new_expression->right->type))
                {
                    compiler_diagnostic_message(C_INVALID_ARGUMENT_NELEMENTSOF,
                        ctx,
                        new_expression->right->first_token,
                        NULL,
                        "argument of nelementsof must be an array");

                    expression_delete(new_expression);
                    throw;
                }


                int nelements = new_expression->right->type.num_of_elements;
                if (nelements > 0)
                {
                    new_expression->constant_value = constant_value_make_size_t(nelements);
                }
                else
                {
                    //vla [n][2] but not vla[2][n]
                }

            }

            type_destroy(&new_expression->type);
            new_expression->type = type_make_size_t();
            p_expression_node = new_expression;

        }
        else if (
            ctx->current->type == TK_KEYWORD_IS_LVALUE ||
            ctx->current->type == TK_KEYWORD_IS_OWNER ||
            ctx->current->type == TK_KEYWORD_IS_CONST ||
            ctx->current->type == TK_KEYWORD_IS_POINTER ||
            ctx->current->type == TK_KEYWORD_IS_ARRAY ||
            ctx->current->type == TK_KEYWORD_IS_FUNCTION ||
            ctx->current->type == TK_KEYWORD_IS_ARITHMETIC ||
            ctx->current->type == TK_KEYWORD_IS_SCALAR ||
            ctx->current->type == TK_KEYWORD_IS_FLOATING_POINT ||
            ctx->current->type == TK_KEYWORD_IS_INTEGRAL)
        {
            const bool disable_evaluation_copy = ctx->evaluation_is_disabled;
            ctx->evaluation_is_disabled = true;


            struct token* traits_token = ctx->current;

            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL) throw;

            new_expression->first_token = ctx->current;
            new_expression->expression_type = UNARY_EXPRESSION_TRAITS;

            parser_match(ctx);
            if (ctx->current == NULL)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }

            struct type* _Opt p_type = NULL;
            if (first_of_type_name_ahead(ctx))
            {
                if (parser_match_tk(ctx, '(') != 0)
                {
                    expression_delete(new_expression);
                    new_expression = NULL;
                    throw;
                }
                new_expression->type_name = type_name(ctx);
                if (new_expression->type_name == NULL)
                {
                    expression_delete(new_expression);
                    new_expression = NULL;
                    throw;
                }

                if (ctx->current == NULL)
                {
                    expression_delete(new_expression);
                    new_expression = NULL;
                    throw;
                }

                new_expression->last_token = ctx->current;
                if (parser_match_tk(ctx, ')') != 0)
                {
                    expression_delete(new_expression);
                    new_expression = NULL;
                    throw;
                }
                p_type = &new_expression->type_name->abstract_declarator->type;
            }
            else
            {

                new_expression->right = unary_expression(ctx);
                if (new_expression->right == NULL)
                {
                    /*restore*/
                    ctx->evaluation_is_disabled = disable_evaluation_copy;
                    expression_delete(new_expression);
                    throw;
                }

                p_type = &new_expression->right->type;
                if (ctx->previous == NULL)
                {
                    expression_delete(new_expression);
                    new_expression = NULL;
                    throw;
                }

                new_expression->last_token = ctx->previous;
            }

            switch (traits_token->type)
            {
            case TK_KEYWORD_IS_LVALUE:
                new_expression->constant_value = constant_value_make_signed_int(expression_is_lvalue(new_expression->right));
                break;

            case TK_KEYWORD_IS_CONST:
                new_expression->constant_value = constant_value_make_signed_int(type_is_const(p_type));
                break;
            case TK_KEYWORD_IS_OWNER:
                new_expression->constant_value = constant_value_make_signed_int(type_is_owner(p_type));
                break;

            case TK_KEYWORD_IS_POINTER:
                new_expression->constant_value = constant_value_make_signed_int(type_is_pointer(p_type));

                break;
            case TK_KEYWORD_IS_FUNCTION:
                new_expression->constant_value = constant_value_make_signed_int(type_is_function(p_type));

                break;
            case TK_KEYWORD_IS_ARRAY:
                new_expression->constant_value = constant_value_make_signed_int(type_is_array(p_type));

                break;
            case TK_KEYWORD_IS_ARITHMETIC:
                new_expression->constant_value = constant_value_make_signed_int(type_is_arithmetic(p_type));

                break;
            case TK_KEYWORD_IS_SCALAR:
                new_expression->constant_value = constant_value_make_signed_int(type_is_scalar(p_type));

                break;
            case TK_KEYWORD_IS_FLOATING_POINT:
                new_expression->constant_value = constant_value_make_signed_int(type_is_floating_point(p_type));

                break;
            case TK_KEYWORD_IS_INTEGRAL:
                new_expression->constant_value = constant_value_make_signed_int(type_is_integer(p_type));

                break;

            default:
                assert(false);
            }

            new_expression->type = type_make_int_bool_like();
            p_expression_node = new_expression;
            /*restore*/
            ctx->evaluation_is_disabled = disable_evaluation_copy;
        }
        else if (ctx->current->type == TK_KEYWORD_ASSERT)
        {
            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL) throw;

            new_expression->expression_type = UNARY_EXPRESSION_ASSERT;
            new_expression->first_token = ctx->current;

            parser_match(ctx);

            if (ctx->current == NULL || parser_match_tk(ctx, '(') != 0)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }
            new_expression->right = expression(ctx);

            if (parser_match_tk(ctx, ')') != 0)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }
            return new_expression;
        }
        else if (ctx->current->type == TK_KEYWORD__ALIGNOF)
        {
            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL) throw;

            new_expression->expression_type = UNARY_EXPRESSION_ALIGNOF;
            new_expression->first_token = ctx->current;
            parser_match(ctx);

            if (ctx->current == NULL || parser_match_tk(ctx, '(') != 0)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }
            new_expression->type_name = type_name(ctx);
            if (parser_match_tk(ctx, ')') != 0)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }

            if (!ctx->evaluation_is_disabled)
            {
                new_expression->constant_value = constant_value_make_size_t(type_get_alignof(&new_expression->type_name->type));
            }
            new_expression->type = type_make_int();

            assert(ctx->previous != NULL);
            new_expression->last_token = ctx->previous;

            p_expression_node = new_expression;
        }
        else if (ctx->current->type == TK_KEYWORD__ALIGNAS)
        {
        }
        else // if (is_first_of_primary_expression(ctx))
        {
            p_expression_node = postfix_expression(ctx);
            if (p_expression_node == NULL)
                throw;
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    return p_expression_node;
}

struct expression* _Owner _Opt cast_expression(struct parser_ctx* ctx)
{
    /*
     cast-expression:
      unary-expression
      ( type-name ) cast-expression


      ( type-name ) //<- extension void value
    */

    struct expression* _Owner _Opt p_expression_node = NULL;
    try
    {
        if (ctx->current == NULL)
            throw;

        if (first_of_type_name_ahead(ctx))
        {
            p_expression_node = calloc(1, sizeof * p_expression_node);
            if (p_expression_node == NULL)
                throw;

            p_expression_node->first_token = ctx->current;
            p_expression_node->expression_type = CAST_EXPRESSION;
            if (parser_match_tk(ctx, '(') != 0)
                throw;

            p_expression_node->type_name = type_name(ctx);
            if (p_expression_node->type_name == NULL)
            {
                expression_delete(p_expression_node);
                p_expression_node = NULL;
                throw;
            }

            p_expression_node->type = type_dup(&p_expression_node->type_name->type);


            if (parser_match_tk(ctx, ')') != 0)
                throw;

            if (ctx->current == NULL)
            {
                //unexpected end of file
                throw;
            }

            if (ctx->current->type == '{')
            {
                // Thinking it was a cast expression was a mistake... 
                // because the { appeared then it is a compound literal which is a postfix.
                struct expression* _Owner _Opt new_expression = postfix_expression_type_name(ctx, p_expression_node->type_name);
                if (new_expression == NULL) throw;

                p_expression_node->type_name = NULL; // MOVED

                expression_delete(p_expression_node);
                p_expression_node = new_expression;
            }
            else if (is_first_of_unary_expression(ctx))
            {
                p_expression_node->left = cast_expression(ctx);
                if (p_expression_node->left == NULL)
                {
                    expression_delete(p_expression_node);
                    p_expression_node = NULL;
                    throw;
                }

                if (p_expression_node->left->type.storage_class_specifier_flags & STORAGE_SPECIFIER_FUNCTION_RETURN &&
                    type_is_owner(&p_expression_node->left->type))
                {
                    if (!type_is_owner(&p_expression_node->type))
                    {
                        if (type_is_pointer(&p_expression_node->left->type))
                        {
                            //(int*) malloc(1)
                            compiler_diagnostic_message(W_OWNERSHIP_DISCARDING_OWNER, ctx, p_expression_node->first_token, NULL, "discarding _Owner pointer");
                        }
                        else
                        {
                            compiler_diagnostic_message(W_OWNERSHIP_DISCARDING_OWNER, ctx, p_expression_node->first_token, NULL, "discarding _Owner");
                        }
                    }
                }

                type_destroy(&p_expression_node->type);
                p_expression_node->type = make_type_using_declarator(ctx, p_expression_node->type_name->abstract_declarator);

                if (!ctx->evaluation_is_disabled &&
                    constant_value_is_valid(&p_expression_node->left->constant_value))
                {
                    enum constant_value_type vt = type_to_constant_value_type(&p_expression_node->type);
                    if (vt != TYPE_NOT_CONSTANT)
                    {
                        p_expression_node->constant_value =
                            constant_value_cast(vt, &p_expression_node->left->constant_value);
                    }
                }



                p_expression_node->type.storage_class_specifier_flags =
                    p_expression_node->left->type.storage_class_specifier_flags;
            }
            else
            {
                compiler_diagnostic_message(C_ERROR_UNEXPECTED, ctx, ctx->current, NULL, "expected expression");
            }
        }
        else if (is_first_of_unary_expression(ctx))
        {
            p_expression_node = unary_expression(ctx);
            if (p_expression_node == NULL)
            {
                throw;
            }
        }
        else
        {
            compiler_diagnostic_message(C_ERROR_UNEXPECTED, ctx, ctx->current, NULL, "expected expression");
            assert(p_expression_node == NULL);
            throw;
        }

        if (ctx->current == NULL || ctx->previous == NULL)
            throw;

        p_expression_node->last_token = ctx->previous;
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    return p_expression_node;
}


NODISCARD
errno_t execute_arithmetic(const struct parser_ctx* ctx,
                      const struct expression* new_expression,
                      int op,
                      struct constant_value* result)
{

    struct type common_type = { 0 };

    try
    {
        if (new_expression->left == NULL || new_expression->right == NULL)
        {
            assert(false);
            throw;
        }

        struct constant_value value = { 0 };
        switch (op)
        {
        case '+':
        case '-':

        case '*':
        case '/':
        case '%':
            //
        case '>':
        case '<':
        case '>=':
        case '<=':
            //
        case '==':
        case '!=':
            break;
        default:
            assert(false);
            throw;
        }

        //Each of the operands shall have arithmetic type
        if (!type_is_arithmetic(&new_expression->left->type))
        {
            compiler_diagnostic_message(C_ERROR_LEFT_IS_NOT_INTEGER, ctx, ctx->current, NULL, "left type must be an arithmetic type");
            throw;
        }

        if (!type_is_arithmetic(&new_expression->right->type))
        {
            compiler_diagnostic_message(C_ERROR_LEFT_IS_NOT_INTEGER, ctx, ctx->current, NULL, "right type must be an arithmetic type");
            throw;
        }


        if (!ctx->evaluation_is_disabled &&
            constant_value_is_valid(&new_expression->left->constant_value) &&
            constant_value_is_valid(&new_expression->right->constant_value))
        {

            const struct marker m =
            {
                .p_token_begin = new_expression->left->first_token,
                .p_token_end = new_expression->right->last_token
            };

            common_type = type_common(&new_expression->left->type,
                                                  &new_expression->right->type);

            enum constant_value_type vt = type_to_constant_value_type(&common_type);
            switch (vt)
            {
            case TYPE_SIGNED_INT_OR_SIGNED_LONG:
            {
                const int a = constant_value_to_signed_int(&new_expression->left->constant_value);
                const int b = constant_value_to_signed_int(&new_expression->right->constant_value);

                if (op == '+')
                {
                    const int computed_result = a + b;
                    signed long long exact_result;
                    if (signed_long_long_add(&exact_result, a, b))
                    {
                        if (computed_result != exact_result)
                        {
                            compiler_diagnostic_message(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow results in '%d'. Exactly result is '%lld'.", computed_result, exact_result);
                        }
                    }
                    else
                    {
                        assert(false);
                    }
                    value = constant_value_make_signed_int(computed_result);
                }
                else if (op == '-')
                {
                    const int computed_result = a - b;
                    signed long long exact_result;
                    if (signed_long_long_sub(&exact_result, a, b))
                    {
                        if (computed_result != exact_result)
                        {
                            compiler_diagnostic_message(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow results in '%d'. Exactly result is '%lld'.", computed_result, exact_result);
                        }
                    }
                    else
                    {
                        assert(false);
                    }
                    value = constant_value_make_signed_int(computed_result);
                }
                else if (op == '*')
                {
                    const int computed_result = a * b;
                    signed long long exact_result;
                    if (signed_long_long_mul(&exact_result, a, b))
                    {
                        if (computed_result != exact_result)
                        {
                            compiler_diagnostic_message(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow results in '%d'. Exactly result is '%lld'.", computed_result, exact_result);
                        }
                    }
                    else
                    {
                        assert(false);
                    }
                    value = constant_value_make_signed_int(computed_result);
                }
                else if (op == '/')
                {
                    if (b == 0)
                        compiler_diagnostic_message(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                    else
                        value = constant_value_make_signed_int(a / b);
                }
                else if (op == '%')
                {
                    if (b == 0)
                        compiler_diagnostic_message(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                    else
                        value = constant_value_make_signed_int(a % b);
                }
                //////////
                else if (op == '>')
                {
                    value = constant_value_make_signed_int(a > b);
                }
                else if (op == '<')
                {
                    value = constant_value_make_signed_int(a < b);
                }
                else if (op == '>=')
                {
                    value = constant_value_make_signed_int(a >= b);
                }
                else if (op == '<=')
                {
                    value = constant_value_make_signed_int(a <= b);
                }
                //
                else if (op == '==')
                {
                    value = constant_value_make_signed_int(a == b);
                }
                else if (op == '!=')
                {
                    value = constant_value_make_signed_int(a != b);
                }
            }
            break;

            case TYPE_UNSIGNED_INT_OR_UNSIGNEG_LONG:
            {
                unsigned int a = constant_value_to_unsigned_int(&new_expression->left->constant_value);
                unsigned int b = constant_value_to_unsigned_int(&new_expression->right->constant_value);

                if (op == '+')
                {
                    const unsigned int computed_result = a + b;
                    unsigned long long exact_result;
                    if (unsigned_long_long_add(&exact_result, a, b))
                    {
                        if (computed_result != exact_result)
                        {
                            compiler_diagnostic_message(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow results in '%d'. Exactly result is '%lld'.", computed_result, exact_result);
                        }
                    }
                    else
                    {
                        assert(false);
                    }
                    value = constant_value_make_signed_int(computed_result);
                }
                else if (op == '-')
                {
                    const unsigned int computed_result = a - b;
                    unsigned long long exact_result;
                    if (unsigned_long_long_sub(&exact_result, a, b))
                    {
                        if (computed_result != exact_result)
                        {
                            compiler_diagnostic_message(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow results in '%d'. Exactly result is '%lld'.", computed_result, exact_result);
                        }
                    }
                    else
                    {
                        assert(false);
                    }
                    value = constant_value_make_signed_int(computed_result);
                }
                else if (op == '*')
                {
                    const unsigned int computed_result = a * b;
                    unsigned long long exact_result;
                    if (unsigned_long_long_mul(&exact_result, a, b))
                    {
                        if (computed_result != exact_result)
                        {
                            compiler_diagnostic_message(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow results in '%d'. Exactly result is '%lld'.", computed_result, exact_result);
                        }
                    }
                    else
                    {
                        assert(false);
                    }
                    value = constant_value_make_signed_int(computed_result);
                }
                else if (op == '/')
                {
                    if (b == 0)
                        compiler_diagnostic_message(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                    else
                        value = constant_value_make_unsigned_int(a / b);
                }
                else if (op == '%')
                {
                    if (b == 0)
                    {
                        compiler_diagnostic_message(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                        throw;
                    }

                    value = constant_value_make_unsigned_int(a % b);
                }
                //////////                
                else if (op == '>')
                {
                    value = constant_value_make_signed_int(a > b);
                }
                else if (op == '<')
                {
                    value = constant_value_make_signed_int(a < b);
                }
                else if (op == '>=')
                {
                    value = constant_value_make_signed_int(a >= b);
                }
                else if (op == '<=')
                {
                    value = constant_value_make_signed_int(a <= b);
                }
                //
                else if (op == '==')
                {
                    value = constant_value_make_signed_int(a == b);
                }
                else if (op == '!=')
                {
                    value = constant_value_make_signed_int(a != b);
                }

            }
            break;

            case TYPE_SIGNED_LONG_LONG_OR_SIGNED_LONG:
            {
                long long a = constant_value_to_signed_long_long(&new_expression->left->constant_value);
                long long b = constant_value_to_signed_long_long(&new_expression->right->constant_value);

                if (op == '+')
                {
                    const long long computed_result = a + b;
                    signed long long exact_result;
                    if (!signed_long_long_add(&exact_result, a, b))
                    {
                        compiler_diagnostic_message(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow results in '%dll'. ", computed_result);
                    }
                    value = constant_value_make_signed_long_long(computed_result);
                }
                else if (op == '-')
                {
                    const long long computed_result = a - b;
                    signed long long exact_result;
                    if (!signed_long_long_sub(&exact_result, a, b))
                    {
                        compiler_diagnostic_message(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow results in '%dll'.", computed_result);
                    }
                    value = constant_value_make_signed_long_long(computed_result);
                }
                else if (op == '*')
                {
                    const long long computed_result = a * b;
                    signed long long exact_result;
                    if (!signed_long_long_mul(&exact_result, a, b))
                    {
                        compiler_diagnostic_message(W_INTEGER_OVERFLOW, ctx, NULL, &m, "integer overflow results in '%dll", computed_result);
                    }
                    value = constant_value_make_signed_long_long(computed_result);
                }
                else if (op == '/')
                {
                    if (b == 0)
                    {
                        compiler_diagnostic_message(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                        throw;
                    }

                    value = constant_value_make_signed_long_long(a / b);

                }
                else if (op == '%')
                {

                    if (b == 0)
                    {
                        compiler_diagnostic_message(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                        throw;
                    }

                    value = constant_value_make_signed_long_long(a % b);
                }
                //////////                
                else if (op == '>')
                {
                    value = constant_value_make_signed_int(a > b);
                }
                else if (op == '<')
                {
                    value = constant_value_make_signed_int(a < b);
                }
                else if (op == '>=')
                {
                    value = constant_value_make_signed_int(a >= b);
                }
                else if (op == '<=')
                {
                    value = constant_value_make_signed_int(a <= b);
                }
                //
                else if (op == '==')
                {
                    value = constant_value_make_signed_int(a == b);
                }
                else if (op == '!=')
                {
                    value = constant_value_make_signed_int(a != b);
                }
            }
            break;

            case TYPE_UNSIGNED_LONG_LONG_OR_UNSIGNEG_LONG:
            {
                unsigned long long a = constant_value_to_unsigned_long(&new_expression->left->constant_value);
                unsigned long long b = constant_value_to_unsigned_long(&new_expression->right->constant_value);


                if (op == '+')
                {
                    value = constant_value_make_unsigned_long_long(a + b);
                }
                else if (op == '-')
                {
                    value = constant_value_make_unsigned_long_long(a - b);
                }
                else if (op == '*')
                {
                    value = constant_value_make_unsigned_long_long(a * b);
                }
                else if (op == '/')
                {

                    if (b == 0)
                    {
                        compiler_diagnostic_message(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                        throw;
                    }

                    value = constant_value_make_unsigned_long_long(a / b);
                }
                else if (op == '%')
                {
                    if (b == 0)
                    {
                        compiler_diagnostic_message(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                        throw;
                    }
                    value = constant_value_make_unsigned_long_long(a % b);
                }
                //////////
                //////////                
                else if (op == '>')
                {
                    value = constant_value_make_signed_int(a > b);
                }
                else if (op == '<')
                {
                    value = constant_value_make_signed_int(a < b);
                }
                else if (op == '>=')
                {
                    value = constant_value_make_signed_int(a >= b);
                }
                else if (op == '<=')
                {
                    value = constant_value_make_signed_int(a <= b);
                }
                //
                else if (op == '==')
                {
                    value = constant_value_make_signed_int(a == b);
                }
                else if (op == '!=')
                {
                    value = constant_value_make_signed_int(a != b);
                }

            }
            break;

            case TYPE_BOOL:
            case TYPE_SIGNED_CHAR:
            case TYPE_UNSIGNED_CHAR:
            case TYPE_SIGNED_SHORT:
            case TYPE_UNSIGNED_SHORT:
                assert(false); //they are promoted
                throw;
                break;

            case TYPE_NOT_CONSTANT:
                //assert(false); //they are promoted
                throw;
                break;

            case TYPE_FLOAT:
            {
                float a = constant_value_to_float(&new_expression->left->constant_value);
                float b = constant_value_to_float(&new_expression->right->constant_value);


                if (op == '+')
                {
                    value = constant_value_make_float(a + b);
                }
                else if (op == '-')
                {
                    value = constant_value_make_float(a - b);
                }
                else if (op == '*')
                {
                    value = constant_value_make_float(a * b);
                }
                else if (op == '/')
                {
                    if (b == 0)
                    {
                        compiler_diagnostic_message(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                        throw;
                    }

                    value = constant_value_make_float(a / b);
                }
                else if (op == '%')
                {
                    //error C2296: '%': not valid as left operand has type 'float'
                    compiler_diagnostic_message(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "'%': not valid as left operand has type 'float'");
                    throw;
                    //r = a % b;
                }
                //////////                
                else if (op == '>')
                {
                    value = constant_value_make_signed_int(a > b);
                }
                else if (op == '<')
                {
                    value = constant_value_make_signed_int(a < b);
                }
                else if (op == '>=')
                {
                    value = constant_value_make_signed_int(a >= b);
                }
                else if (op == '<=')
                {
                    value = constant_value_make_signed_int(a <= b);
                }
                //
                else if (op == '==')
                {
                    value = constant_value_make_signed_int(a == b);
                }
                else if (op == '!=')
                {
                    value = constant_value_make_signed_int(a != b);
                }

            }
            break;
            case TYPE_DOUBLE:
            {
                double a = constant_value_to_double(&new_expression->left->constant_value);
                double b = constant_value_to_double(&new_expression->right->constant_value);

                if (op == '+')
                {
                    value = constant_value_make_double(a + b);
                }
                else if (op == '-')
                {
                    value = constant_value_make_double(a - b);
                }
                else if (op == '*')
                {
                    value = constant_value_make_double(a * b);
                }
                else if (op == '/')
                {
                    if (b == 0)
                        compiler_diagnostic_message(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                    else
                        value = constant_value_make_double(a / b);
                }
                else if (op == '%')
                {
                    //value = constant_value_make_double(r);
                    //error C2296: '%': not valid as left operand has type 'float'
                    compiler_diagnostic_message(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "'%': not valid as left operand has type 'float'");
                    throw;
                    //r = a % b;
                }
                //////////                
                else if (op == '>')
                {
                    value = constant_value_make_signed_int(a > b);
                }
                else if (op == '<')
                {
                    value = constant_value_make_signed_int(a < b);
                }
                else if (op == '>=')
                {
                    value = constant_value_make_signed_int(a >= b);
                }
                else if (op == '<=')
                {
                    value = constant_value_make_signed_int(a <= b);
                }
                //
                else if (op == '==')
                {
                    value = constant_value_make_signed_int(a == b);
                }
                else if (op == '!=')
                {
                    value = constant_value_make_signed_int(a != b);
                }

            }
            break;
            case TYPE_LONG_DOUBLE:
            {
                long double a = constant_value_to_long_double(&new_expression->left->constant_value);
                long double b = constant_value_to_long_double(&new_expression->right->constant_value);

                if (op == '+')
                {
                    value = constant_value_make_long_double(a + b);
                }
                else if (op == '-')
                {
                    value = constant_value_make_long_double(a - b);
                }
                else if (op == '*')
                {
                    value = constant_value_make_long_double(a * b);
                }
                else if (op == '/')
                {
                    if (b == 0)
                        compiler_diagnostic_message(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "division by zero");
                    else
                        value = constant_value_make_long_double(a / b);
                }
                else if (op == '%')
                {
                    //error C2296: '%': not valid as left operand has type 'float'
                    //value = constant_value_make_long_double(a % b);
                    compiler_diagnostic_message(W_DIVIZION_BY_ZERO, ctx, new_expression->right->first_token, NULL, "'%': not valid as left operand has type 'float'");
                    //r = a % b;
                    throw;
                }
                //////////                
                else if (op == '>')
                {
                    value = constant_value_make_signed_int(a > b);
                }
                else if (op == '<')
                {
                    value = constant_value_make_signed_int(a < b);
                }
                else if (op == '>=')
                {
                    value = constant_value_make_signed_int(a >= b);
                }
                else if (op == '<=')
                {
                    value = constant_value_make_signed_int(a <= b);
                }
                //
                else if (op == '==')
                {
                    value = constant_value_make_signed_int(a == b);
                }
                else if (op == '!=')
                {
                    value = constant_value_make_signed_int(a != b);
                }

            }
            break;

            };


        }

        type_destroy(&common_type);
        *result = value;
        return 0;//ok
    }
    catch
    {
    }

    type_destroy(&common_type);

    struct constant_value empty = { 0 };
    *result = empty;
    return 1; //error
}

struct expression* _Owner _Opt multiplicative_expression(struct parser_ctx* ctx)
{

    /*
     multiplicative-expression:
    cast-expression
    multiplicative-expression * cast-expression
    multiplicative-expression / cast-expression
    multiplicative-expression % cast-expression
    */
    struct expression* _Owner _Opt p_expression_node = NULL;
    try
    {
        p_expression_node = cast_expression(ctx);
        if (p_expression_node == NULL)
        {
            throw;
        }

        while (ctx->current != NULL &&
               (ctx->current->type == '*' ||
                   ctx->current->type == '/' ||
                   ctx->current->type == '%'))
        {
            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL)
            {
                expression_delete(p_expression_node);
                p_expression_node = NULL;
                throw;
            }

            new_expression->first_token = ctx->current;
            const enum token_type op = ctx->current->type;
            parser_match(ctx);
            if (ctx->current == NULL)
            {
                expression_delete(new_expression);
                throw;
            }

            switch (op)
            {
            case '*':
                new_expression->expression_type = MULTIPLICATIVE_EXPRESSION_MULT;
                break;
            case '/':
                new_expression->expression_type = MULTIPLICATIVE_EXPRESSION_DIV;
                break;
            case '%':
                new_expression->expression_type = MULTIPLICATIVE_EXPRESSION_MOD;
                break;
            default:
                assert(false);
                break;
            }


            new_expression->left = p_expression_node;
            p_expression_node = NULL; // MOVED

            new_expression->right = cast_expression(ctx);

            if (new_expression->right == NULL)
            {
                expression_delete(new_expression);
                throw;
            }
            new_expression->last_token = new_expression->right->last_token;


            new_expression->type = type_common(&new_expression->left->type, &new_expression->right->type);

            if (execute_arithmetic(ctx, new_expression, op, &new_expression->constant_value) != 0)
            {
                expression_delete(new_expression);
                throw;
            }

            p_expression_node = new_expression;
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }
    return p_expression_node;
}


struct expression* _Owner _Opt additive_expression(struct parser_ctx* ctx)
{
    /*
     additive-expression:
    multiplicative-expression
    additive-expression + multiplicative-expression
    additive-expression - multiplicative-expression
    */

    struct expression* _Owner _Opt p_expression_node = NULL;

    try
    {
        p_expression_node = multiplicative_expression(ctx);
        if (p_expression_node == NULL)
        {
            throw;
        }

        while (ctx->current != NULL &&
               (ctx->current->type == '+' ||
                   ctx->current->type == '-'))
        {
            struct token* operator_position = ctx->current;

            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL)
            {
                compiler_diagnostic_message(C_ERROR_OUT_OF_MEM, ctx, ctx->current, NULL, "_Out of mem");
                throw;
            }

            new_expression->first_token = ctx->current;

            enum token_type op = ctx->current->type;
            parser_match(ctx);
            if (ctx->current == NULL)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }

            new_expression->left = p_expression_node;
            p_expression_node = NULL; /*MOVED*/


            new_expression->right = multiplicative_expression(ctx);
            if (new_expression->right == NULL)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }

            new_expression->last_token = new_expression->right->last_token;



            if (!type_is_scalar(&new_expression->left->type))
            {
                compiler_diagnostic_message(C_ERROR_LEFT_IS_NOT_SCALAR, ctx, operator_position, NULL, "left operator is not scalar");
            }
            if (!type_is_scalar(&new_expression->right->type))
            {
                compiler_diagnostic_message(C_ERROR_RIGHT_IS_NOT_SCALAR, ctx, operator_position, NULL, "right operator is not scalar");
            }

            const bool b_left_is_arithmetic = type_is_arithmetic(&new_expression->left->type);
            const bool b_right_is_arithmetic = type_is_arithmetic(&new_expression->right->type);

            const enum type_category left_category = type_get_category(&new_expression->left->type);
            const enum type_category right_category = type_get_category(&new_expression->right->type);

            if (op == '+')
            {
                new_expression->expression_type = ADDITIVE_EXPRESSION_PLUS;

                /*
                 For addition, either both operands shall have arithmetic type,
                 or one operand shall be a pointer to a complete object type and
                 the other shall have integer type. (Incrementing is equivalent to adding 1.)
                */
                if (b_left_is_arithmetic && b_right_is_arithmetic)
                {
                    new_expression->type = type_common(&new_expression->left->type, &new_expression->right->type);
                    if (execute_arithmetic(ctx, new_expression, op, &new_expression->constant_value) != 0)
                    {
                        expression_delete(new_expression);
                        throw;
                    }
                }
                else
                {
                    if (left_category == TYPE_CATEGORY_POINTER || left_category == TYPE_CATEGORY_ARRAY /* || left_category == TYPE_CATEGORY_FUNCTION*/)
                    {
                        if (type_is_integer(&new_expression->right->type))
                        {
                            if (left_category == TYPE_CATEGORY_ARRAY)
                            {
                                struct type t = get_array_item_type(&new_expression->left->type);
                                new_expression->type = type_add_pointer(&t, ctx->options.null_checks_enabled);
                                //new_expression->type.type_qualifier_flags |= not_nu;
                                type_destroy(&t);
                            }
                            else
                            {
                                new_expression->type = type_dup(&new_expression->left->type);
                            }
                        }
                        else
                        {
                            compiler_diagnostic_message(C_ERROR_RIGHT_IS_NOT_INTEGER, ctx, ctx->current, NULL, "expected integer type on right");
                        }
                    }
                    else if (right_category == TYPE_CATEGORY_POINTER || right_category == TYPE_CATEGORY_ARRAY /*|| right_category == TYPE_CATEGORY_FUNCTION*/)
                    {
                        if (type_is_integer(&new_expression->left->type))
                        {
                            if (right_category == TYPE_CATEGORY_ARRAY)
                            {
                                new_expression->type = get_array_item_type(&new_expression->right->type);
                            }
                            else
                            {
                                new_expression->type = type_dup(&new_expression->right->type);
                            }
                        }
                        else
                        {
                            compiler_diagnostic_message(C_ERROR_LEFT_IS_NOT_INTEGER, ctx, ctx->current, NULL, "expected integer type on left");
                        }
                    }
                    else
                    {
                        compiler_diagnostic_message(C_ERROR_INVALID_TYPE, ctx, ctx->current, NULL, "invalid types additive expression");
                    }
                }
            }
            else if (op == '-')
            {
                new_expression->expression_type = ADDITIVE_EXPRESSION_MINUS;

                /*
                 For subtraction, one of the following shall hold:
                    — both operands have arithmetic type;
                    — both operands are pointers to qualified or unqualified versions of compatible complete object
                    types; or
                    — the left operand is a pointer to a complete object type and the right operand has integer type.
                    (Decrementing is equivalent to subtracting 1.)
                */
                if (b_left_is_arithmetic && b_right_is_arithmetic)
                {
                    new_expression->type = type_common(&new_expression->left->type, &new_expression->right->type);
                    if (execute_arithmetic(ctx, new_expression, op, &new_expression->constant_value) != 0)
                    {
                        expression_delete(new_expression);
                        throw;
                    }
                }
                else
                {
                    if (left_category == TYPE_CATEGORY_POINTER || left_category == TYPE_CATEGORY_ARRAY)
                    {
                        if (right_category == TYPE_CATEGORY_POINTER || right_category == TYPE_CATEGORY_ARRAY)
                        {
                            // — both operands are pointers to qualified or unqualified versions of compatible complete object
                            //  types;
                            struct type t1 = type_lvalue_conversion(&new_expression->left->type, ctx->options.null_checks_enabled);
                            struct type t2 = type_lvalue_conversion(&new_expression->right->type, ctx->options.null_checks_enabled);

                            if (!type_is_same(&t1, &t2, false))
                            {
                                compiler_diagnostic_message(C_ERROR_INCOMPATIBLE_POINTER_TYPES, ctx, ctx->current, NULL, "incompatible pointer types");
                            }

                            new_expression->type = type_make_int();
                            type_destroy(&t1);
                            type_destroy(&t2);
                        }
                        else
                        {
                            if (type_is_integer(&new_expression->right->type))
                            {
                                //- the left operand is a pointer to a complete object typeand the right operand has integer type.
                                new_expression->type = type_dup(&new_expression->left->type);
                            }
                            else
                            {
                                compiler_diagnostic_message(C_ERROR_RIGHT_IS_NOT_INTEGER, ctx, ctx->current, NULL, "right must be integer type");
                            }
                        }
                    }
                    else
                    {
                        compiler_diagnostic_message(C_ERROR_INVALID_TYPE, ctx, ctx->current, NULL, "invalid types for operator -");
                    }
                }
            }

            p_expression_node = new_expression;
            new_expression = NULL; /*MOVED*/
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    return p_expression_node;
}

struct expression* _Owner _Opt shift_expression(struct parser_ctx* ctx)
{
    /*
     shift-expression:
       additive-expression
       shift-expression << additive-expression
       shift-expression >> additive-expression
    */
    struct expression* _Owner _Opt p_expression_node = NULL;
    try
    {
        p_expression_node = additive_expression(ctx);
        if (p_expression_node == NULL)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '>>' ||
                   ctx->current->type == '<<'))
        {
            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL) throw;

            new_expression->first_token = ctx->current;

            enum token_type op = ctx->current->type;
            parser_match(ctx);
            if (ctx->current == NULL)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }

            new_expression->left = p_expression_node;
            p_expression_node = NULL; /*MOVED*/

            new_expression->right = multiplicative_expression(ctx);
            if (new_expression->right == NULL)
            {
                expression_delete(new_expression);
                throw;
            }

            new_expression->last_token = new_expression->right->last_token;

            if (op == '>>')
            {
                new_expression->expression_type = SHIFT_EXPRESSION_RIGHT;
            }
            else if (op == '<<')
            {
                new_expression->expression_type = SHIFT_EXPRESSION_LEFT;
            }
            if (execute_bitwise_operator(ctx, new_expression, op) != 0)
            {
                expression_delete(new_expression);
                throw;
            }


            p_expression_node = new_expression;
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    return p_expression_node;
}

struct expression* _Owner _Opt relational_expression(struct parser_ctx* ctx)
{
    /*
    relational-expression:
        shift-expression
        relational-expression < shift-expression
        relational-expression > shift-expression
        relational-expression <= shift-expression
        relational-expression >= shift-expression
    */

    struct expression* _Owner _Opt p_expression_node = NULL;
    struct expression* _Owner _Opt new_expression = NULL;
    try
    {
        p_expression_node = shift_expression(ctx);
        if (p_expression_node == NULL)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '>' ||
                   ctx->current->type == '<' ||
                   ctx->current->type == '>=' ||
                   ctx->current->type == '<='))
        {
            assert(new_expression == NULL);
            new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL)
            {
                throw;
            }
            new_expression->first_token = ctx->current;
            enum token_type op = ctx->current->type;
            parser_match(ctx);
            if (ctx->current == NULL) throw;

            new_expression->left = p_expression_node;
            p_expression_node = NULL; /*MOVED*/

            new_expression->right = shift_expression(ctx);
            if (new_expression->right == NULL)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }

            new_expression->last_token = new_expression->right->last_token;
            if (ctx->current == NULL)
            {
                expression_delete(new_expression);
                new_expression = NULL;
                throw;
            }

            check_comparison(ctx,
              new_expression->left,
              new_expression->right,
              ctx->current);

            if (op == '>')
            {
                new_expression->expression_type = RELATIONAL_EXPRESSION_BIGGER_THAN;
            }
            else if (op == '<')
            {
                new_expression->expression_type = RELATIONAL_EXPRESSION_LESS_THAN;
            }
            else if (op == '>=')
            {
                new_expression->expression_type = RELATIONAL_EXPRESSION_BIGGER_OR_EQUAL_THAN;
            }
            else if (op == '<=')
            {
                new_expression->expression_type = RELATIONAL_EXPRESSION_LESS_OR_EQUAL_THAN;
            }

            //Each of the operands shall have arithmetic type
            if (type_is_arithmetic(&new_expression->left->type) &&
                type_is_arithmetic(&new_expression->right->type))
            {
                new_expression->type = type_common(&new_expression->left->type, &new_expression->right->type);
                if (execute_arithmetic(ctx, new_expression, op, &new_expression->constant_value) != 0)
                {
                    expression_delete(new_expression);
                    new_expression = NULL;
                    throw;
                }
            }

            type_destroy(&new_expression->type);
            new_expression->type = type_make_int_bool_like();

            p_expression_node = new_expression;
            new_expression = NULL; /*MOVED*/
        }
    }
    catch
    {
        expression_delete(new_expression);
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    return p_expression_node;
}

void check_diferent_enuns(struct parser_ctx* ctx,
                                 const struct token* operator_token,
                                 const struct expression* left,
                                 const struct expression* right,
                                 const char* message)
{
    if (left->type.type_specifier_flags & TYPE_SPECIFIER_ENUM &&
        right->type.type_specifier_flags & TYPE_SPECIFIER_ENUM)
    {
        assert(left->type.enum_specifier);
        assert(right->type.enum_specifier);

        if (get_complete_enum_specifier(left->type.enum_specifier) !=
            get_complete_enum_specifier(right->type.enum_specifier))
        {
            assert(left->type.enum_specifier != NULL);
            assert(right->type.enum_specifier != NULL);

            const char* lefttag = "";
            if (left->type.enum_specifier->tag_token)
                lefttag = left->type.enum_specifier->tag_token->lexeme;

            const char* righttag = "";
            if (right->type.enum_specifier->tag_token)
                righttag = right->type.enum_specifier->tag_token->lexeme;

            char finalmessage[200] = { 0 };
            snprintf(finalmessage,
                sizeof finalmessage,
                "%s (enum %s, enum %s)",
                message,
                lefttag,
                righttag);

            compiler_diagnostic_message(W_ENUN_CONVERSION,
                                        ctx,
                                        operator_token, NULL,
                                        finalmessage,
                                        lefttag,
                                        righttag);
        }
    }
}
void expression_evaluate_equal_not_equal(const struct expression* left,
                                         const struct expression* right,
                                         struct expression* result,
                                         int op,
                                         bool disabled)
{
    assert(op == '==' || op == '!=');
    //result->constant_value =
        //constant_value_op(&left->constant_value, &right->constant_value, op);
}

struct expression* _Owner _Opt equality_expression(struct parser_ctx* ctx)
{
    /*
      equality-expression:
       relational-expression
       equality-expression == relational-expression
       equality-expression != relational-expression
    */
    /*
    * Equality operators
    One of the following shall hold:
    — both operands have arithmetic type;
    — both operands are pointers to qualified or unqualified versions of compatible types;
    — one operand is a pointer to an object type and the other is a pointer to a qualified or unqualified
    version of void; or
    — one operand is a pointer and the other is a null pointer constant.
    */
    struct expression* _Owner _Opt  p_expression_node = NULL;
    struct expression* _Owner _Opt new_expression = NULL;

    try
    {
        p_expression_node = relational_expression(ctx);
        if (p_expression_node == NULL)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '==' ||
                   ctx->current->type == '!='))
        {
            assert(new_expression == NULL);
            new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL)
                throw;

            new_expression->first_token = ctx->current;

            struct token* operator_token = ctx->current;
            parser_match(ctx);
            if (ctx->current == NULL) throw;

            if (operator_token->type == '==')
                new_expression->expression_type = EQUALITY_EXPRESSION_EQUAL;
            else
                new_expression->expression_type = EQUALITY_EXPRESSION_NOT_EQUAL;

            new_expression->left = p_expression_node;
            p_expression_node = NULL; /*MOVED*/

            new_expression->right = relational_expression(ctx);
            if (new_expression->right == NULL)
                throw;

            if (ctx->current == NULL)
            {
                throw;
            }

            check_comparison(ctx,
              new_expression->left,
              new_expression->right,
              ctx->current);

            new_expression->last_token = new_expression->right->last_token;
            new_expression->first_token = operator_token;

            if (type_is_arithmetic(&new_expression->left->type) &&
                type_is_arithmetic(&new_expression->right->type))
            {

                if (execute_arithmetic(ctx, new_expression, operator_token->type, &new_expression->constant_value) != 0)
                    throw;
            }


            new_expression->type = type_make_int_bool_like();
            p_expression_node = new_expression;
            new_expression = NULL; /*MOVED*/
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    expression_delete(new_expression);
    return p_expression_node;
}

struct expression* _Owner _Opt and_expression(struct parser_ctx* ctx)
{
    /*
     AND-expression:
      equality-expression
      AND-expression & equality-expression
    */
    struct expression* _Owner _Opt p_expression_node = NULL;
    struct expression* _Owner _Opt new_expression = NULL;

    try
    {
        p_expression_node = equality_expression(ctx);
        if (p_expression_node == NULL)
            throw;

        while (ctx->current != NULL && ctx->current->type == '&')
        {
            parser_match(ctx);
            if (ctx->current == NULL) throw;

            assert(new_expression == NULL);
            new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL)
                throw;

            new_expression->first_token = ctx->current;
            new_expression->expression_type = AND_EXPRESSION;
            new_expression->left = p_expression_node;
            p_expression_node = NULL; /*MOVED*/

            new_expression->right = equality_expression(ctx);
            if (new_expression->right == NULL)
                throw;

            new_expression->last_token = new_expression->right->last_token;

            if (execute_bitwise_operator(ctx, new_expression, '&') != 0)
                throw;

            p_expression_node = new_expression;
            new_expression = NULL; /*MOVED*/
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    expression_delete(new_expression);
    return p_expression_node;
}

struct expression* _Owner _Opt  exclusive_or_expression(struct parser_ctx* ctx)
{
    /*
     exclusive-OR-expression:
      AND-expression
      exclusive-OR-expression ^ AND-expression
    */
    struct expression* _Owner _Opt p_expression_node = NULL;
    struct expression* _Owner _Opt new_expression = NULL;

    try
    {
        p_expression_node = and_expression(ctx);
        if (p_expression_node == NULL)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '^'))
        {
            parser_match(ctx);
            if (ctx->current == NULL) throw;

            assert(new_expression == NULL);
            new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL)
                throw;

            new_expression->first_token = ctx->current;
            new_expression->expression_type = EXCLUSIVE_OR_EXPRESSION;
            new_expression->left = p_expression_node;
            p_expression_node = NULL; /*MOVED*/

            new_expression->right = and_expression(ctx);
            if (new_expression->right == NULL)
                throw;

            new_expression->last_token = new_expression->right->last_token;

            if (execute_bitwise_operator(ctx, new_expression, '^') != 0)
                throw;

            p_expression_node = new_expression;
            new_expression = NULL;
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    expression_delete(new_expression);
    return p_expression_node;
}


NODISCARD
static errno_t execute_bitwise_operator(struct parser_ctx* ctx, struct expression* new_expression, int op)
{
    try
    {
        switch (op)
        {
        case '&':
        case '^':
        case '|':
        case '>>':
        case '<<':
            break;
        default:
            assert(false);
            throw;
        }


        //Each of the operands shall have integer type.
        if (!type_is_integer(&new_expression->left->type))
        {
            compiler_diagnostic_message(C_ERROR_LEFT_IS_NOT_INTEGER, ctx, ctx->current, NULL, "left type must be an integer type");
            throw;
        }

        if (!type_is_integer(&new_expression->right->type))
        {
            compiler_diagnostic_message(C_ERROR_LEFT_IS_NOT_INTEGER, ctx, ctx->current, NULL, "right type must be an integer type");
            throw;
        }

        type_destroy(&new_expression->type);
        new_expression->type = type_common(&new_expression->left->type, &new_expression->right->type);

        if (!ctx->evaluation_is_disabled &&
            constant_value_is_valid(&new_expression->left->constant_value) &&
            constant_value_is_valid(&new_expression->right->constant_value))
        {
            enum constant_value_type vt = type_to_constant_value_type(&new_expression->type);
            switch (vt)
            {
            case TYPE_SIGNED_INT_OR_SIGNED_LONG:
            {
                int a = constant_value_to_signed_int(&new_expression->left->constant_value);
                int b = constant_value_to_signed_int(&new_expression->right->constant_value);

                int r = 0;
                if (op == '|')
                    r = a | b;
                else if (op == '^')
                    r = a ^ b;
                else if (op == '&')
                    r = a & b;
                //
                else if (op == '>>')
                    r = a >> b;
                else if (op == '<<')
                    r = a << b;

                new_expression->constant_value = constant_value_make_signed_int(r);
            }
            break;

            case TYPE_UNSIGNED_INT_OR_UNSIGNEG_LONG:
            {
                unsigned int a = constant_value_to_unsigned_int(&new_expression->left->constant_value);
                unsigned int b = constant_value_to_unsigned_int(&new_expression->right->constant_value);
                int r = 0;
                if (op == '|')
                    r = a | b;
                else if (op == '^')
                    r = a ^ b;
                else if (op == '&')
                    r = a & b;
                //
                else if (op == '>>')
                    r = a >> b;
                else if (op == '<<')
                    r = a << b;
                new_expression->constant_value = constant_value_make_unsigned_int(r);
            }
            break;

            case TYPE_SIGNED_LONG_LONG_OR_SIGNED_LONG:
            {
                long long a = constant_value_to_signed_long(&new_expression->left->constant_value);
                long long b = constant_value_to_signed_long(&new_expression->right->constant_value);
                long long r = 0;
                if (op == '|')
                    r = a | b;
                else if (op == '^')
                    r = a ^ b;
                else if (op == '&')
                    r = a & b;
                //
                else if (op == '>>')
                    r = a >> b;
                else if (op == '<<')
                    r = a << b;
                new_expression->constant_value = constant_value_make_signed_long_long(r);

            }
            break;

            case TYPE_UNSIGNED_LONG_LONG_OR_UNSIGNEG_LONG:
            {
                unsigned long long a = constant_value_to_unsigned_long(&new_expression->left->constant_value);
                unsigned long long b = constant_value_to_unsigned_long(&new_expression->right->constant_value);
                unsigned long long r = 0;
                if (op == '|')
                    r = a | b;
                else if (op == '^')
                    r = a ^ b;
                else if (op == '&')
                    r = a & b;
                //
                else if (op == '>>')
                    r = a >> b;
                else if (op == '<<')
                    r = a << b;
                new_expression->constant_value = constant_value_make_unsigned_long_long(r);
            }
            break;

            case TYPE_BOOL:
            case TYPE_SIGNED_CHAR:
            case TYPE_UNSIGNED_CHAR:
            case TYPE_SIGNED_SHORT:
            case TYPE_UNSIGNED_SHORT:
                assert(false); //they are promoted
                throw;
                break;

            case TYPE_NOT_CONSTANT:
            case TYPE_FLOAT:
            case TYPE_DOUBLE:
            case TYPE_LONG_DOUBLE:
                assert(false); //works for integers only
                throw;
                break;
            };
        }
        return 0;//ok
    }
    catch
    {
    }
    return 1; //error
}

struct expression* _Owner _Opt inclusive_or_expression(struct parser_ctx* ctx)
{
    /*
    inclusive-OR-expression:
        exclusive-OR-expression
        inclusive-OR-expression | exclusive-OR-expression
    */
    struct expression* _Owner _Opt p_expression_node = NULL;
    try
    {
        p_expression_node = exclusive_or_expression(ctx);
        if (p_expression_node == NULL)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '|'))
        {
            struct token* operator_token = ctx->current;
            parser_match(ctx);
            if (ctx->current == NULL) throw;

            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL)
                throw;


            new_expression->first_token = ctx->current;
            new_expression->expression_type = INCLUSIVE_OR_EXPRESSION;
            new_expression->left = p_expression_node;
            p_expression_node = NULL; /*MOVED*/

            new_expression->right = exclusive_or_expression(ctx);
            if (new_expression->right == NULL)
            {
                expression_delete(new_expression);
                throw;
            }

            check_diferent_enuns(ctx,
                                operator_token,
                                new_expression->left,
                                new_expression->right,
                                "operator '|' between enumerations of different types.");

            new_expression->last_token = new_expression->right->last_token;

            if (execute_bitwise_operator(ctx, new_expression, '|') != 0)
            {
                expression_delete(new_expression);
                throw;
            }

            p_expression_node = new_expression;
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    return p_expression_node;
}

struct expression* _Owner _Opt logical_and_expression(struct parser_ctx* ctx)
{
    /*
    logical-AND-expression:
     inclusive-OR-expression
     logical-AND-expression && inclusive-OR-expression
    */
    struct expression* _Owner _Opt p_expression_node = NULL;
    try
    {
        p_expression_node = inclusive_or_expression(ctx);
        if (p_expression_node == NULL)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '&&'))
        {
            parser_match(ctx);
            if (ctx->current == NULL) throw;

            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL)
                throw;

            new_expression->first_token = ctx->current;
            new_expression->expression_type = LOGICAL_AND_EXPRESSION;
            new_expression->left = p_expression_node;
            p_expression_node = NULL; /*MOVED*/

            new_expression->right = inclusive_or_expression(ctx);
            if (new_expression->right == NULL)
            {
                expression_delete(new_expression);
                throw;
            }
            new_expression->last_token = new_expression->right->last_token;

            if (!ctx->evaluation_is_disabled &&
                constant_value_is_valid(&new_expression->left->constant_value) &&
                constant_value_is_valid(&new_expression->right->constant_value))
            {
                //The && operator shall yield 1 if both of its operands compare unequal to 0;
                // otherwise, it yields 0. The result has type int
                bool a = constant_value_to_bool(&new_expression->left->constant_value);
                bool b = constant_value_to_bool(&new_expression->right->constant_value);
                new_expression->constant_value = constant_value_make_signed_int(a && b);
            }

            //Each of the operands shall have scalar type
            if (!type_is_scalar(&new_expression->left->type))
            {
                expression_delete(new_expression);
                compiler_diagnostic_message(C_ERROR_LEFT_IS_NOT_SCALAR, ctx, ctx->current, NULL, "left type is not scalar for or expression");
                throw;
            }

            if (!type_is_scalar(&new_expression->right->type))
            {
                expression_delete(new_expression);
                compiler_diagnostic_message(C_ERROR_RIGHT_IS_NOT_SCALAR, ctx, ctx->current, NULL, "right type is not scalar for or expression");
                throw;
            }

            //The result has type int
            new_expression->type = type_make_int_bool_like();

            p_expression_node = new_expression;
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    return p_expression_node;
}

struct expression* _Owner _Opt logical_or_expression(struct parser_ctx* ctx)
{
    /*
      logical-OR-expression:
       logical-AND-expression
       logical-OR-expression || logical-AND-expression
    */
    struct expression* _Owner _Opt p_expression_node = NULL;
    try
    {


        p_expression_node = logical_and_expression(ctx);
        if (p_expression_node == NULL)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '||'))
        {



            parser_match(ctx);
            if (ctx->current == NULL) throw;

            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL)
                throw;

            new_expression->first_token = ctx->current;
            new_expression->expression_type = LOGICAL_OR_EXPRESSION;
            new_expression->left = p_expression_node;
            p_expression_node = NULL; /*MOVED*/

            new_expression->right = logical_and_expression(ctx);
            if (new_expression->right == NULL)
            {
                expression_delete(new_expression);
                throw;
            }

            new_expression->last_token = new_expression->right->last_token;

            if (!ctx->evaluation_is_disabled &&
                constant_value_is_valid(&new_expression->left->constant_value) &&
                constant_value_is_valid(&new_expression->right->constant_value))
            {
                bool a = constant_value_to_bool(&new_expression->left->constant_value);
                bool b = constant_value_to_bool(&new_expression->right->constant_value);
                new_expression->constant_value = constant_value_make_signed_int(a || b);
            }

            //Each of the operands shall have scalar type
            if (!type_is_scalar(&new_expression->left->type))
            {
                expression_delete(new_expression);
                compiler_diagnostic_message(C_ERROR_LEFT_IS_NOT_SCALAR, ctx, ctx->current, NULL, "left type is not scalar for or expression");
                throw;
            }

            if (!type_is_scalar(&new_expression->right->type))
            {
                expression_delete(new_expression);
                compiler_diagnostic_message(C_ERROR_RIGHT_IS_NOT_SCALAR, ctx, ctx->current, NULL, "right type is not scalar for or expression");
                throw;
            }

            //The result has type int
            new_expression->type = type_make_int_bool_like();

            p_expression_node = new_expression;
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    return p_expression_node;
}

struct expression* _Owner _Opt assignment_expression(struct parser_ctx* ctx)
{
    /*
    assignment-expression:
       conditional-expression
       unary-expression assignment-operator assignment-expression
       */
       /*
          assignment-operator: one of
          = *= /= %= += -= <<= >>= &= ^= |=
       */
       // aqui eh duvidoso mas conditional faz a unary tb.
       // a diferenca q nao eh qualquer expressao
       // que pode ser de atribuicao
    struct expression* _Owner _Opt p_expression_node = NULL;
    try
    {
        p_expression_node = conditional_expression(ctx);
        if (p_expression_node == NULL)
            throw;

        assert(p_expression_node->expression_type != EXPRESSION_TYPE_INVALID);

        while (ctx->current != NULL &&
               (ctx->current->type == '=' ||
                   ctx->current->type == '*=' ||
                   ctx->current->type == '/=' ||
                   ctx->current->type == '%=' ||
                   ctx->current->type == '+=' ||
                   ctx->current->type == '-=' ||
                   ctx->current->type == '<<=' ||
                   ctx->current->type == '>>=' ||
                   ctx->current->type == '&=' ||
                   ctx->current->type == '^=' ||
                   ctx->current->type == '|='))
        {

            const struct token* const op_token = ctx->current;
            parser_match(ctx);
            if (ctx->current == NULL) throw;

            struct expression* _Owner _Opt new_expression = calloc(1, sizeof * new_expression);
            if (new_expression == NULL)
                throw;

            new_expression->first_token = ctx->current;
            new_expression->expression_type = ASSIGNMENT_EXPRESSION;
            new_expression->left = p_expression_node;
            p_expression_node = NULL; // MOVED

            const struct marker left_operand_marker = {
                      .p_token_begin = new_expression->left->first_token,
                      .p_token_end = new_expression->left->last_token,
            };

            if (type_is_function(&new_expression->left->type))
            {
                compiler_diagnostic_message(C_ERROR_ASSIGNMENT_OF_FUNCTION,
                    ctx,
                    NULL,
                    &left_operand_marker,
                    "assignment of function");
            }
            else if (type_is_array(&new_expression->left->type))
            {
                if (new_expression->left->type.storage_class_specifier_flags & STORAGE_SPECIFIER_PARAMETER)
                {
                    /*
                      assignment of array parameter
                    */
                    compiler_diagnostic_message(W_ASSIGNMENT_OF_ARRAY_PARAMETER,
                        ctx,
                        NULL,
                        &left_operand_marker,
                        "assignment to array parameter");
                }
                else
                {
                    compiler_diagnostic_message(C_ERROR_ASSIGNMENT_TO_EXPRESSION_WITH_ARRAY_TYPE,
                        ctx,
                        NULL,
                        &left_operand_marker,
                        "assignment to expression with array type");
                }
            }

            if (type_is_const(&new_expression->left->type))
            {
                compiler_diagnostic_message(C_ERROR_ASSIGNMENT_OF_READ_ONLY_OBJECT,
                    ctx,
                    NULL,
                    &left_operand_marker,
                    "assignment of read-only object");
            }


            if (!expression_is_lvalue(new_expression->left))
            {
                compiler_diagnostic_message(C_ERROR_OPERATOR_NEEDS_LVALUE,
                                            ctx,
                                            NULL,
                                            &left_operand_marker,
                                            "lvalue required as left operand of assignment");
            }

            new_expression->right = assignment_expression(ctx);
            if (new_expression->right == NULL)
            {
                expression_delete(new_expression);
                throw;
            }

            if (op_token->type == '=')
            {
                check_assigment(ctx, &new_expression->left->type, new_expression->right, ASSIGMENT_TYPE_OBJECTS);
            }

            new_expression->last_token = new_expression->right->last_token;

            new_expression->type = type_dup(&new_expression->left->type);

            new_expression->type.storage_class_specifier_flags &= ~STORAGE_SPECIFIER_FUNCTION_RETURN;
            new_expression->type.storage_class_specifier_flags &= ~STORAGE_SPECIFIER_FUNCTION_RETURN_NODISCARD;

            check_diferent_enuns(ctx,
                op_token,
                new_expression->left,
                new_expression->right,
                "assignment of different enums.");

            new_expression->left->is_assignment_expression = true;
            if (new_expression->left->left)
                new_expression->left->left->is_assignment_expression = true;
            p_expression_node = new_expression;
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    return p_expression_node;
}

void argument_expression_list_push(struct argument_expression_list* list, struct argument_expression* _Owner pitem)
{
    if (list->head == NULL)
    {
        list->head = pitem;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = pitem;
    }
    list->tail = pitem;
}

void argument_expression_list_destroy(struct argument_expression_list* _Obj_owner p)
{
    struct argument_expression* _Owner _Opt item = p->head;
    while (item)
    {
        struct argument_expression* _Owner _Opt next = item->next;
        item->next = NULL;
        argument_expression_delete(item);
        item = next;
    }
}

bool expression_is_malloc(const struct expression* p)
{
    if (p->expression_type == POSTFIX_FUNCTION_CALL &&
        p->left &&
        p->left->declarator &&
        p->left->declarator->name_opt)
    {
        if (strcmp(p->left->declarator->name_opt->lexeme, "malloc") == 0)
            return true;
    }
    return false;
}

bool expression_is_calloc(const struct expression* p)
{
    if (p->expression_type == POSTFIX_FUNCTION_CALL &&
        p->left &&
        p->left->declarator &&
        p->left->declarator->name_opt)
    {
        if (strcmp(p->left->declarator->name_opt->lexeme, "calloc") == 0)
            return true;
    }
    return false;
}

void expression_delete(struct expression* _Owner _Opt p)
{
    if (p)
    {
        expression_delete(p->condition_expr);
        compound_statement_delete(p->compound_statement);
        type_name_delete(p->type_name);

        expression_delete(p->right);
        expression_delete(p->left);
        braced_initializer_delete(p->braced_initializer);
        generic_selection_delete(p->generic_selection);
        type_destroy(&p->type);
        argument_expression_list_destroy(&p->argument_expression_list);
        free(p);
    }
}
struct expression* _Owner _Opt expression(struct parser_ctx* ctx)
{
    /*expression:
      assignment-expression
      expression, assignment-expression
    */
    struct expression* _Owner _Opt p_expression_node = NULL;
    try
    {
        if (ctx->current == NULL)
            throw;

        p_expression_node = assignment_expression(ctx);
        if (p_expression_node == NULL)
            throw;

        if (ctx->current == NULL)
            throw;

        if (ctx->current->type == ',')
        {
            while (ctx->current->type == ',')
            {
                parser_match(ctx);
                if (ctx->current == NULL) throw;

                struct expression* _Owner _Opt p_expression_node_new = calloc(1, sizeof * p_expression_node_new);
                if (p_expression_node_new == NULL)
                    throw;

                p_expression_node_new->first_token = ctx->current;
                p_expression_node_new->expression_type = ASSIGNMENT_EXPRESSION;
                p_expression_node_new->left = p_expression_node;
                p_expression_node = NULL; /*MOVED*/

                p_expression_node_new->right = expression(ctx);
                if (p_expression_node_new->right == NULL)
                {
                    expression_delete(p_expression_node_new);
                    throw;
                }
                p_expression_node_new->left->last_token = p_expression_node_new->right->last_token;

                p_expression_node = p_expression_node_new;

                if (ctx->current == NULL)
                {
                    //unexpected end of file
                    throw;
                }
            }

            /*same type of the last expression*/
            type_destroy(&p_expression_node->type);
            p_expression_node->type = type_dup(&p_expression_node->right->type);
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }
    return p_expression_node;
}

bool is_first_of_conditional_expression(struct parser_ctx* ctx)
{
    return is_first_of_unary_expression(ctx) ||
        is_first_of_primary_expression(ctx);
}

bool expression_is_one(const struct expression* expression)
{
    if (expression->expression_type == PRIMARY_EXPRESSION_NUMBER)
    {
        return (constant_value_is_valid(&expression->constant_value) &&
            constant_value_to_signed_int(&expression->constant_value) == 1);
    }
    return false;
}

bool expression_is_zero(const struct expression* expression)
{
    if (expression->expression_type == PRIMARY_EXPRESSION_NUMBER)
    {
        return (constant_value_is_valid(&expression->constant_value) &&
            constant_value_to_signed_int(&expression->constant_value) == 0);
    }
    return false;
}

bool expression_is_null_pointer_constant(const struct expression* expression)
{

    if (type_is_nullptr_t(&expression->type) ||
        (constant_value_is_valid(&expression->constant_value) &&
            constant_value_to_signed_int(&expression->constant_value) == 0))
    {
        return true;
    }

    return false;
}

struct expression* _Owner _Opt conditional_expression(struct parser_ctx* ctx)
{
    /*
      conditional-expression:
      logical-OR-expression
      logical-OR-expression ? expression : conditional-expression
    */
    struct expression* _Owner _Opt p_expression_node = NULL;
    struct type left_type = { 0 };
    struct type right_type = { 0 };
    try
    {
        p_expression_node = logical_or_expression(ctx);
        if (p_expression_node == NULL)
            throw;

        if (ctx->current && ctx->current->type == '?')
        {
            struct expression* _Owner _Opt p_conditional_expression = calloc(1, sizeof * p_conditional_expression);
            if (p_conditional_expression == NULL) throw;


            p_conditional_expression->first_token = ctx->current;
            p_conditional_expression->expression_type = CONDITIONAL_EXPRESSION;
            p_conditional_expression->condition_expr = p_expression_node;
            p_expression_node = NULL; /*MOVED*/

            parser_match(ctx); //?
            if (ctx->current == NULL)
            {
                expression_delete(p_conditional_expression);
                throw;
            }

            struct expression* _Owner _Opt p_left = expression(ctx);
            if (p_left == NULL)
            {
                expression_delete(p_conditional_expression);
                throw;
            }
            p_conditional_expression->left = p_left;

            parser_match(ctx); //:
            if (ctx->current == NULL)
            {
                expression_delete(p_conditional_expression);
                throw;
            }

            struct expression* _Owner _Opt p_right = conditional_expression(ctx);
            if (p_right == NULL)
            {
                expression_delete(p_conditional_expression);
                throw;
            }
            p_conditional_expression->right = p_right;

            if (constant_value_is_valid(&p_conditional_expression->condition_expr->constant_value))
            {
                if (constant_value_to_bool(&p_conditional_expression->condition_expr->constant_value))
                {
                    /*this is an extensions.. in constant expression we can mix types!*/
                    p_conditional_expression->type = type_dup(&p_conditional_expression->left->type);
                    p_conditional_expression->constant_value = p_conditional_expression->left->constant_value;
                }
                else
                {
                    /*this is an extensions.. in constant expression we can mix types!*/
                    p_conditional_expression->type = type_dup(&p_conditional_expression->right->type);
                    p_conditional_expression->constant_value = p_conditional_expression->right->constant_value;
                }
            }

            if (expression_is_subjected_to_lvalue_conversion(p_conditional_expression->left))
            {
                left_type = type_lvalue_conversion(&p_conditional_expression->left->type, ctx->options.null_checks_enabled);
            }
            else
            {
                left_type = type_dup(&p_conditional_expression->left->type);
            }

            if (expression_is_subjected_to_lvalue_conversion(p_conditional_expression->right))
            {
                right_type = type_lvalue_conversion(&p_conditional_expression->right->type, ctx->options.null_checks_enabled);
            }
            else
            {
                right_type = type_dup(&p_conditional_expression->right->type);
            }

            /*The first operand shall have scalar type*/
            if (!type_is_scalar(&p_conditional_expression->condition_expr->type))
            {
                compiler_diagnostic_message(C_ERROR_CONDITION_MUST_HAVE_SCALAR_TYPE, ctx, ctx->current, NULL, "condition must have scalar type");
            }
            else if (type_is_arithmetic(&left_type) &&
                     type_is_arithmetic(&right_type))
            {
                /*
                 *  both operands have arithmetic type;
                */
                type_destroy(&p_conditional_expression->type);
                p_conditional_expression->type = type_common(&left_type, &right_type);
            }
            else if (type_is_struct_or_union(&left_type) && type_is_struct_or_union(&right_type))
            {
                /*
                 *  both operands have compatible structure or union type;
                 */
                if (!type_is_same(&left_type, &right_type, true))
                {
                    compiler_diagnostic_message(C_ERROR_INCOMPATIBLE_TYPES, ctx, p_conditional_expression->condition_expr->first_token, NULL, "incompatible types");
                }
                type_swap(&p_conditional_expression->type, &right_type);
            }
            else if (type_is_void(&left_type) && type_is_void(&right_type))
            {
                /*
                 *  both operands have void type;
                 */
                type_swap(&p_conditional_expression->type, &right_type);
            }
            else if (type_is_nullptr_t(&left_type) && type_is_nullptr_t(&right_type))
            {
                /* both operands have nullptr_t type;*/
                type_swap(&p_conditional_expression->type, &right_type);
            }
            else if (type_is_pointer(&left_type))
            {
                /*
                — one operand is a pointer and the other is a null pointer constant or has type nullptr_t; or
                    — one operand is a pointer to an object type and the other is a pointer to a qualified or unqualified
                    version of void
            */
                if (expression_is_null_pointer_constant(p_conditional_expression->right) ||
                    type_is_nullptr_t(&right_type) ||
                    type_is_void_ptr(&right_type))
                {
                    type_swap(&p_conditional_expression->type, &left_type);
                }
                else if (type_is_pointer(&right_type))
                {
                    if (type_is_nullptr_t(&left_type) || type_is_void_ptr(&left_type))
                    {
                        type_swap(&p_conditional_expression->type, &left_type);
                    }
                    else if (!type_is_same(&left_type, &right_type, false))
                    {
                        // type_print(&left_type);
                        // type_print(&right_type);
                        compiler_diagnostic_message(C_ERROR_INCOMPATIBLE_TYPES, ctx, ctx->current, NULL, "incompatible types");
                    }
                    else
                    {
                        type_swap(&p_conditional_expression->type, &right_type);
                    }
                }
                else
                {
                    compiler_diagnostic_message(C_ERROR_INCOMPATIBLE_TYPES, ctx, p_conditional_expression->condition_expr->first_token, NULL, "incompatible types");
                }
            }
            else if (type_is_pointer(&right_type))
            {
                if (expression_is_null_pointer_constant(p_conditional_expression->left) ||
                    type_is_nullptr_t(&left_type) ||
                    type_is_void_ptr(&left_type))
                {
                    type_swap(&p_conditional_expression->type, &right_type);
                }
                else if (type_is_pointer(&left_type))
                {
                    if (type_is_nullptr_t(&left_type) || type_is_void_ptr(&left_type))
                    {
                        type_swap(&p_conditional_expression->type, &right_type);
                    }
                    else if (!type_is_same(&left_type, &right_type, false))
                    {
                        compiler_diagnostic_message(C_ERROR_INCOMPATIBLE_TYPES, ctx, p_conditional_expression->condition_expr->first_token, NULL, "incompatible types");
                    }
                    else
                    {
                        type_swap(&p_conditional_expression->type, &right_type);
                    }
                }
                else
                {
                    compiler_diagnostic_message(C_ERROR_INCOMPATIBLE_TYPES, ctx, p_conditional_expression->condition_expr->first_token, NULL, "incompatible types");
                }
            }
            else
            {
                compiler_diagnostic_message(C_ERROR_INCOMPATIBLE_TYPES, ctx, p_conditional_expression->condition_expr->first_token, NULL, "incompatible types??");
                assert(false);
            }
            p_expression_node = p_conditional_expression;
        }
    }
    catch
    {
        expression_delete(p_expression_node);
        p_expression_node = NULL;
    }

    type_destroy(&left_type);
    type_destroy(&right_type);

    return p_expression_node;
}

struct expression* _Owner _Opt constant_expression(struct parser_ctx* ctx, bool show_error_if_not_constant)
{
    struct expression* _Owner _Opt p_expression = conditional_expression(ctx);

    if (show_error_if_not_constant &&
        p_expression &&
        !constant_value_is_valid(&p_expression->constant_value))
    {
        compiler_diagnostic_message(C_ERROR_EXPECTED_CONSTANT_EXPRESSION, ctx, ctx->current, NULL, "expected constant expression");
    }

    return p_expression;
}

bool expression_is_lvalue(const struct expression* expr)
{
    // https://en.cppreference.com/w/c/language/value_category

    switch (expr->expression_type)
    {
    case PRIMARY_EXPRESSION_DECLARATOR:
    case PRIMARY_EXPRESSION__FUNC__:
    case PRIMARY_EXPRESSION_STRING_LITERAL:
    case POSTFIX_ARRAY:
    case POSTFIX_ARROW:
    case POSTFIX_EXPRESSION_COMPOUND_LITERAL:
    case UNARY_EXPRESSION_CONTENT:
        return true;
    default:
        break;
    }

    if (expr->expression_type == PRIMARY_EXPRESSION_PARENTESIS &&
        expr->right)
    {
        return expression_is_lvalue(expr->right);
    }
    else if (expr->expression_type == POSTFIX_DOT &&
             expr->left)
    {
        return expression_is_lvalue(expr->left);
    }

    return false;
}


/*
 * Returns true if the type of expression is subjected to type_lvalue_conversion
 */
bool expression_is_subjected_to_lvalue_conversion(const struct expression* expression)
{

    switch (expression->expression_type)
    {
    case UNARY_EXPRESSION_ADDRESSOF:
    case UNARY_EXPRESSION_INCREMENT:
    case UNARY_EXPRESSION_DECREMENT:
    case POSTFIX_INCREMENT:
    case POSTFIX_DECREMENT:
        return false;
    default:
        if (expression->type.storage_class_specifier_flags & STORAGE_SPECIFIER_PARAMETER)
            return true;
    }

    return true;
}

void check_comparison(struct parser_ctx* ctx,
    struct expression* p_a_expression,
    struct expression* p_b_expression,
    const struct token* op_token)
{
    //TODO more checks unsigned < 0

    struct type* p_a_type = &p_a_expression->type;
    struct type* p_b_type = &p_b_expression->type;

    if (type_is_pointer(p_a_type) && type_is_integer(p_b_type))
    {
        if (expression_is_zero(p_b_expression))
        {
            // p == 0
            //style warning
        }
        else
        {
            //array functions..
            compiler_diagnostic_message(W_ENUN_CONVERSION,
                                        ctx,
                                        op_token, NULL,
                                        "comparison between pointer and integer");
        }
    }

    check_diferent_enuns(ctx,
                         op_token,
                         p_a_expression,
                         p_b_expression,
                         "comparing different enums.");
}

void check_assigment(struct parser_ctx* ctx,
    const struct type* p_a_type, /*this is not expression because function parameters*/
    const struct expression* p_b_expression,
    enum assigment_type assignment_type /*ASSIGMENT_TYPE_RETURN, ASSIGMENT_TYPE_PARAMETER, ASSIGMENT_TYPE_OBJECTS*/)
{
    const struct type* const p_b_type = &p_b_expression->type;

    const bool is_null_pointer_constant = expression_is_null_pointer_constant(p_b_expression);

    if (type_is_pointer(p_a_type))
    {
        if (!type_is_nullptr_t(p_b_type) &&
            !type_is_pointer_or_array(p_b_type) &&
            !type_is_function(p_b_type))
        {
            if (is_null_pointer_constant)
            {
                if (p_b_expression->expression_type == PRIMARY_EXPRESSION_NUMBER)
                {
                    // This is the only exception.
                    // p = 0;
                    compiler_diagnostic_message(W_STYLE, ctx, p_b_expression->first_token, NULL, "use NULL instead of 0");
                }
                else
                {
                    //Everything else is unusual
                    // p = false;
                    // p = 1-1;
                    // p = '\0';
                    compiler_diagnostic_message(W_UNSUAL_NULL_POINTER_CONSTANT, ctx, p_b_expression->first_token, NULL, "unusual expression/type used as null pointer constant");
                }
            }
            else
            {
                compiler_diagnostic_message(C_ERROR_INT_TO_POINTER, ctx, p_b_expression->first_token, NULL, "non-pointer to pointer");
            }
        }
    }

    if (type_is_bool(p_a_type) && type_is_nullptr_t(p_b_type))
    {
        struct marker marker = {
        .p_token_begin = p_b_expression->first_token,
        .p_token_end = p_b_expression->first_token
        };

        compiler_diagnostic_message(W_NULL_CONVERTION,
        ctx,
        NULL,
        &marker,
        "implicit conversion of nullptr constant to 'bool'");
    }

    struct type lvalue_right_type = { 0 };
    struct type t2 = { 0 };

    if (expression_is_subjected_to_lvalue_conversion(p_b_expression))
    {
        lvalue_right_type = type_lvalue_conversion(p_b_type, ctx->options.null_checks_enabled);
    }
    else
    {
        lvalue_right_type = type_dup(p_b_type);
    }


    if (type_is_owner(p_a_type) && !type_is_owner(&p_b_expression->type))
    {
        if (!is_null_pointer_constant)
        {
            compiler_diagnostic_message(W_OWNERSHIP_NON_OWNER_TO_OWNER_ASSIGN, ctx, p_b_expression->first_token, NULL, "cannot assign a non-owner to owner");
            type_destroy(&lvalue_right_type);
            type_destroy(&t2);
            return;
        }
    }

    if (!type_is_owner(p_a_type) && type_is_any_owner(&p_b_expression->type))
    {
        if (p_b_expression->type.storage_class_specifier_flags & STORAGE_SPECIFIER_FUNCTION_RETURN)
        {
            compiler_diagnostic_message(W_OWNERSHIP_USING_TEMPORARY_OWNER,
                ctx,
                p_b_expression->first_token, NULL,
                "cannot assign a temporary owner to non-owner object.");
            type_destroy(&lvalue_right_type);
            type_destroy(&t2);
            return;
        }
    }

    if (assignment_type == ASSIGMENT_TYPE_RETURN)
    {
        if (!type_is_owner(p_a_type) && type_is_any_owner(&p_b_expression->type))
        {
            if (p_b_expression->type.storage_class_specifier_flags & STORAGE_SPECIFIER_AUTOMATIC_STORAGE)
            {
                compiler_diagnostic_message(C_ERROR_RETURN_LOCAL_OWNER_TO_NON_OWNER,
                    ctx,
                    p_b_expression->first_token, NULL,
                    "cannot return a automatic storage duration _Owner to non-owner");
                type_destroy(&lvalue_right_type);
                type_destroy(&t2);
                return;
            }
        }
    }

    if (type_is_obj_owner(p_a_type) && type_is_pointer(p_a_type))
    {
        if (type_is_owner(p_b_type))
        {
        }
        else if (!p_b_type->address_of)
        {
            compiler_diagnostic_message(W_MUST_USE_ADDRESSOF,
                       ctx,
                       p_b_expression->first_token, NULL,
                       "source expression of _Obj_owner must be addressof");
        }
    }


    if (type_is_pointer(p_a_type) &&
        !type_is_nullable(p_a_type, ctx->options.null_checks_enabled) &&
        is_null_pointer_constant)
    {

        compiler_diagnostic_message(W_FLOW_NULLABLE_TO_NON_NULLABLE,
            ctx,
            p_b_expression->first_token, NULL,
            "cannot convert a null pointer constant to non-nullable pointer");

        type_destroy(&lvalue_right_type);
        type_destroy(&t2);

        return;

    }



    /*
       less generic tests are first
    */
    if (type_is_enum(p_b_type) && type_is_enum(p_a_type))
    {
        if (!type_is_same(p_b_type, p_a_type, false))
        {
            compiler_diagnostic_message(W_INCOMPATIBLE_ENUN_TYPES, ctx,
                p_b_expression->first_token, NULL,
                " incompatible types ");
        }


        type_destroy(&lvalue_right_type);
        type_destroy(&t2);
        return;
    }

    if (type_is_arithmetic(p_b_type) && type_is_arithmetic(p_a_type))
    {

        type_destroy(&lvalue_right_type);
        type_destroy(&t2);
        return;
    }

    if (is_null_pointer_constant && type_is_pointer(p_a_type))
    {
        //TODO void F(int * [[_Opt]] p)
        // F(0) when passing null we will check if the parameter
        //have the anotation [[_Opt]]

        /*can be converted to any type*/

        type_destroy(&lvalue_right_type);
        type_destroy(&t2);
        return;
    }

    if (is_null_pointer_constant && type_is_array(p_a_type))
    {
        compiler_diagnostic_message(W_FLOW_NON_NULL,
            ctx,
            p_b_expression->first_token, NULL,
            " passing null as array");


        type_destroy(&lvalue_right_type);
        type_destroy(&t2);
        return;
    }

    /*
       We have two pointers or pointer/array combination
    */
    if (type_is_pointer_or_array(p_b_type) && type_is_pointer_or_array(p_a_type))
    {
        if (type_is_void_ptr(p_b_type))
        {
            /*void pointer can be converted to any type*/

            type_destroy(&lvalue_right_type);
            type_destroy(&t2);
            return;
        }

        if (type_is_void_ptr(p_a_type))
        {
            /*any pointer can be converted to void* */

            type_destroy(&lvalue_right_type);
            type_destroy(&t2);
            return;
        }


        //TODO  lvalue

        if (type_is_array(p_a_type))
        {
            int parameter_array_size = p_a_type->num_of_elements;
            if (type_is_array(p_b_type))
            {
                int argument_array_size = p_b_type->num_of_elements;
                if (parameter_array_size != 0 &&
                    argument_array_size < parameter_array_size)
                {
                    compiler_diagnostic_message(C_ERROR_ARGUMENT_SIZE_SMALLER_THAN_PARAMETER_SIZE, ctx,
                        p_b_expression->first_token, NULL,
                        " argument of size [%d] is smaller than parameter of size [%d]", argument_array_size, parameter_array_size);
                }
            }
            else if (is_null_pointer_constant || type_is_nullptr_t(p_b_type))
            {
                compiler_diagnostic_message(W_PASSING_NULL_AS_ARRAY, ctx,
                    p_b_expression->first_token, NULL,
                    " passing null as array");
            }
            t2 = type_lvalue_conversion(p_a_type, ctx->options.null_checks_enabled);
        }
        else
        {
            t2 = type_dup(p_a_type);
        }



        if (!type_is_same(&lvalue_right_type, &t2, false))
        {
            type_print(&lvalue_right_type);
            type_print(&t2);

            compiler_diagnostic_message(C_ERROR_INCOMPATIBLE_TYPES, ctx,
                p_b_expression->first_token, NULL,
                " incompatible types at argument ");
            //disabled for now util it works correctly
            //return false;
        }

        if (type_is_pointer(&lvalue_right_type) && type_is_pointer(&t2))
        {
            //parameter pointer do non const
            //argument const.
            struct type argument_pointer_to = type_remove_pointer(&lvalue_right_type);
            struct type parameter_pointer_to = type_remove_pointer(&t2);
            if (type_is_const(&argument_pointer_to) && !type_is_const(&parameter_pointer_to))
            {
                compiler_diagnostic_message(W_DISCARDED_QUALIFIERS, ctx,
                    p_b_expression->first_token, NULL,
                    " discarding const at argument ");
            }
            type_destroy(&argument_pointer_to);
            type_destroy(&parameter_pointer_to);
        }
        //return true;
    }

    if (!type_is_same(p_a_type, &lvalue_right_type, false))
    {
        //TODO more rules..but it is good to check worst case!
        //
        //  compiler_diagnostic_message(C1, ctx,
        //      right->first_token,
        //      " incompatible types ");
    }





    type_destroy(&lvalue_right_type);
    type_destroy(&t2);

}


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

#pragma safety enable

/*
  For performance reasons we will separate expression from preprocessor from compiler.
*/


#include <locale.h>

#ifdef _WIN32
#endif

#if defined _MSC_VER && !defined __POCC__
#endif

/*context expressions preprocessor*/
struct pre_expression_ctx
{
    /*all preprocessor expressions are calculated with long long*/
    long long value;
};

static void pre_postfix_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_cast_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_multiplicative_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_unary_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_additive_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_shift_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_relational_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_equality_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_and_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_exclusive_or_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_inclusive_or_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_logical_and_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_logical_or_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_conditional_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);
static void pre_conditional_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx);

//TODO share this with parser!
/*
 * preprocessor uses long long
 */
static int ppnumber_to_longlong(struct preprocessor_ctx* ctx, struct token* token, long long* result)
{
    /*copy removing the separators*/
    // um dos maiores buffer necessarios seria 128 bits binario...
    // 0xb1'1'1....
    int c = 0;
    char buffer[128 * 2 + 4] = { 0 };
    const char* s = token->lexeme;
    while (*s)
    {
        if (*s != '\'')
        {
            buffer[c] = *s;
            c++;
        }
        s++;
    }

    char errormsg[100];
    char suffix[4] = { 0 };
    const enum token_type type = parse_number(token->lexeme, suffix, errormsg);
    if (type == TK_NONE)
    {
        preprocessor_diagnostic_message(
            C_INVALID_TOKEN,
            ctx,
            token,
            "%s",
            errormsg);
        return 0;
    }
    struct constant_value  cv = { 0 };
    switch (type)
    {
    case TK_COMPILER_DECIMAL_CONSTANT:
    case TK_COMPILER_OCTAL_CONSTANT:
    case TK_COMPILER_HEXADECIMAL_CONSTANT:
    case TK_COMPILER_BINARY_CONSTANT:
    {
        unsigned long long value = 0;
        switch (type)
        {
        case TK_COMPILER_DECIMAL_CONSTANT:
            value = strtoull(buffer, NULL, 10);
            break;
        case TK_COMPILER_OCTAL_CONSTANT:
            value = strtoull(buffer + 1, NULL, 8);
            break;
        case TK_COMPILER_HEXADECIMAL_CONSTANT:
            value = strtoull(buffer + 2, NULL, 16);
            break;
        case TK_COMPILER_BINARY_CONSTANT:
            value = strtoull(buffer + 2, NULL, 2);
            break;
        default:
            break;
        }

        if (value == ULLONG_MAX && errno == ERANGE)
        {
            //compiler_diagnostic_message(
            //C_ERROR_LITERAL_OVERFLOW,
            //ctx,
            //token,
            //NULL,
            //"integer literal is too large to be represented in any integer type");
        }

        if (suffix[0] == 'U')
        {
            /*fixing the type that fits the size*/
            if (value <= UINT_MAX && suffix[1] != 'L')
            {
                cv = constant_value_make_unsigned_int((unsigned int)value);

            }
            else if (value <= ULONG_MAX && suffix[2] != 'L')
            {
                cv = constant_value_make_unsigned_long((unsigned long)value);
            }
            else //if (value <= ULLONG_MAX)
            {
                cv = constant_value_make_unsigned_long_long((unsigned long long)value);
            }
        }
        else
        {
            /*fixing the type that fits the size*/
            if (value <= INT_MAX && suffix[0] != 'L')
            {
                cv = constant_value_make_signed_int((int)value);
            }
            else if (value <= LONG_MAX && suffix[1] != 'L' /*!= LL*/)
            {
                cv = constant_value_make_signed_long((long)value);
            }
            else if (value <= LLONG_MAX)
            {
                cv = constant_value_make_signed_long_long((long long)value);
            }
            else
            {
                cv = constant_value_make_signed_long_long(value);
            }
        }

    }
    break;

    case TK_COMPILER_DECIMAL_FLOATING_CONSTANT:
    case TK_COMPILER_HEXADECIMAL_FLOATING_CONSTANT:
        //error
        break;

    default:
        assert(false);
    }

    *result = constant_value_to_signed_long_long(&cv);

    return 0;
}

/*
  ctx->current and pre_match are used only in preprocessor constant expressions
  (the preprocessor itself uses concept of removing from one list and adding
  into another so the head of the input list is the current.
  We could use the same concept here removing current.
*/
static struct token* _Opt pre_match(struct preprocessor_ctx* ctx)
{
    if (ctx->current == NULL)
        return NULL;

    ctx->current = ctx->current->next;

    while (ctx->current && token_is_blank(ctx->current))
    {
        ctx->current = ctx->current->next;
    }

    return ctx->current;
}

//TODO share this with parser
static struct constant_value char_constant_to_value(const char* s, char error_message[/*sz*/], int error_message_sz_bytes)
{
    error_message[0] = '\0';

    const unsigned char* _Opt p = (const unsigned char*)s;

    try
    {
        if (p[0] == 'u' && p[1] == '8')
        {
            p++;
            p++;
            p++;

            // A UTF-8 character constant has type char8_t.

            unsigned int c = 0;
            p = utf8_decode(p, &c);
            if (p == NULL)
            {
                throw;
            }

            if (c == '\\')
            {
                p = escape_sequences_decode_opt(p, &c);
                if (p == NULL)
                {
                    throw;
                }
            }

            if (*p != '\'')
            {
                snprintf(error_message, error_message_sz_bytes, "Unicode character literals may not contain multiple characters.");
            }

            if (c > 0x80)
            {
                snprintf(error_message, error_message_sz_bytes, "Character too large for enclosing character literal type.");
            }

            return constant_value_make_wchar_t((wchar_t)c);//, ctx->evaluation_is_disabled);
        }
        else if (p[0] == 'u')
        {
            p++;
            p++;

            // A UTF-16 character constant has type char16_t which is an unsigned integer types defined in the <uchar.h> header

            unsigned int c = 0;
            p = utf8_decode(p, &c);
            if (p == NULL)
            {
                throw;
            }

            if (c == '\\')
            {
                p = escape_sequences_decode_opt(p, &c);
                if (p == NULL)
                {
                    throw;
                }
            }

            if (*p != '\'')
            {
                snprintf(error_message, error_message_sz_bytes, "Unicode character literals may not contain multiple characters.");
            }

            if (c > USHRT_MAX)
            {
                snprintf(error_message, error_message_sz_bytes, "Character too large for enclosing character literal type.");
            }

            return constant_value_make_wchar_t((wchar_t)c);
        }
        else if (p[0] == 'U')
        {
            p++;
            p++;

            // A UTF-16 character constant has type char16_t which is an unsigned integer types defined in the <uchar.h> header

            unsigned int c = 0;
            p = utf8_decode(p, &c);
            if (p == NULL)
            {
                throw;
            }

            if (c == '\\')
            {
                p = escape_sequences_decode_opt(p, &c);

                if (p == NULL)
                {
                    throw;
                }
            }

            if (*p != '\'')
            {
                snprintf(error_message, error_message_sz_bytes, "Unicode character literals may not contain multiple characters.");
            }

            if (c > UINT_MAX)
            {
                snprintf(error_message, error_message_sz_bytes, "Character too large for enclosing character literal type.");
            }

            return constant_value_make_wchar_t((wchar_t)c);
        }
        else if (p[0] == 'L')
        {
            // A wchar_t character constant is prefixed by the letter L
            p++;
            p++;

            /*
             wchar_t character constant prefixed by the letter L has type wchar_t, an integer type defined in
             the <stddef.h> header. The value of a wchar_t character constant containing a single multibyte
             character that maps to a single member of the extended execution character set is the wide character
             corresponding to that multibyte character in the implementation-defined wide literal encoding
             (6.2.9). The value of a wchar_t character constant containing more than one multibyte character or a
             single multibyte character that maps to multiple members of the extended execution character set,
             or containing a multibyte character or escape sequence not represented in the extended execution
             character set, is implementation-defined.
            */
            long long value = 0;
            while (*p != '\'')
            {
                unsigned int c = 0;
                p = utf8_decode(p, &c);
                if (p == NULL)
                {
                    throw;
                }
                if (c == '\\')
                {
                    p = escape_sequences_decode_opt(p, &c);
                    if (p == NULL)
                        throw;
                }
       
                // TODO \u
                value = value * 256 + c;
#ifdef _WIN32
                if (value > USHRT_MAX)
                {
                    snprintf(error_message, error_message_sz_bytes, "character constant too long for its type");
                    break;
                }
#else
                if (value > UINT_MAX)
                {
                    snprintf(error_message, error_message_sz_bytes, "character constant too long for its type");
                    break;
                }
#endif
            }

            return constant_value_make_wchar_t((wchar_t)value);
        }
        else
        {
            p++;

            /*
              An integer character constant has type int. The value of an integer character constant containing
              a single character that maps to a single value in the literal encoding (6.2.9) is the numerical value
              of the representation of the mapped character in the literal encoding interpreted as an integer.
              The value of an integer character constant containing more than one character (e.g., ’ab’), or
              containing a character or escape sequence that does not map to a single value in the literal encoding,
              is implementation-defined. If an integer character constant contains a single character or escape
              sequence, its value is the one that results when an object with type char whose value is that of the
              single character or escape sequence is converted to type int.
            */
            long long value = 0;
            while (*p != '\'')
            {
                unsigned int c = 0;
                p = utf8_decode(p, &c);
                if (p == NULL)
                {
                    throw;
                }

                if (c == '\\')
                {
                    p = escape_sequences_decode_opt(p, &c);
                    if (p == NULL)
                        throw;
                }


                if (c < 0x80)
                {
                    value = value * 256 + c;
                }
                else
                {
                    value = c;
                }
                if (value > INT_MAX)
                {
                    snprintf(error_message, error_message_sz_bytes, "character constant too long for its type");
                    break;
                }
            }
            return constant_value_make_wchar_t((wchar_t)value);
        }
    }
    catch
    {
    }

    struct constant_value empty = { 0 };
    return empty;
}

static void pre_primary_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
     primary-expression:
      identifier
      constant
      string-literal
      ( expression )
      generic-selection
    */
    try
    {
        if (ctx->current == NULL)
        {
            throw;
        }

        if (ctx->current->type == TK_CHAR_CONSTANT)
        {
            const char* p = ctx->current->lexeme + 1;
            char errmsg[200] = { 0 };
            struct constant_value v = char_constant_to_value(p, errmsg, sizeof errmsg);
            if (errmsg[0] != '\0')
            {
                preprocessor_diagnostic_message(C_ERROR_UNEXPECTED, ctx, ctx->current, "%s", errmsg);
            }
            ectx->value = constant_value_to_signed_long_long(&v);
            pre_match(ctx);
        }
        else if (ctx->current->type == TK_PPNUMBER)
        {
            ppnumber_to_longlong(ctx, ctx->current, &ectx->value);
            pre_match(ctx);
        }
        else if (ctx->current->type == '(')
        {
            pre_match(ctx);
            pre_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;
            if (ctx->current && ctx->current->type != ')')
            {
                preprocessor_diagnostic_message(C_ERROR_UNEXPECTED, ctx, ctx->current, "expected )");
                throw;
            }
            pre_match(ctx);
        }
        else
        {
            preprocessor_diagnostic_message(C_ERROR_TOKEN_NOT_VALID_IN_PREPROCESSOR_EXPRESSIONS,
                                              ctx,
                                              ctx->current,
                                              "token '%s' is not valid in preprocessor expressions",
                                              ctx->current->lexeme);
            throw;
        }
    }
    catch
    {
    }
}

static void pre_postfix_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
      postfix-expression:
        primary-expression
        postfix-expression [ expression ]
        postfix-expression ( argument-expression-list_opt)
        postfix-expression . identifier
        postfix-expression -> identifier
        postfix-expression ++
        postfix-expression --
        ( type-name ) { initializer-ctx }
        ( type-name ) { initializer-ctx , }

        //My extension : if type-name is function then follow is compound-statement
        ( type-name ) compound-statement

        */
    try
    {
        pre_primary_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;
    }
    catch
    {
    }
}

static void pre_unary_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
    unary-expression:
      postfix-expression
      ++ unary-expression
      -- unary-expression

      one of (& * + - ~ !) cast-expression

      sizeof unary-expression
      sizeof ( type-name )
      _Alignof ( type-name )
      */
    try
    {
        if (ctx->current && (ctx->current->type == '++' || ctx->current->type == '--'))
        {
            preprocessor_diagnostic_message(C_ERROR_TOKEN_NOT_VALID_IN_PREPROCESSOR_EXPRESSIONS,
                                              ctx,
                                              ctx->current,
                                              "token '%s' is not valid in preprocessor expressions",
                                              ctx->current->lexeme);
            throw;
        }
        else if (ctx->current != NULL &&
                 (ctx->current->type == '&' || ctx->current->type == '*' || ctx->current->type == '+' || ctx->current->type == '-' || ctx->current->type == '~' || ctx->current->type == '!'))
        {
            const struct token* const p_old = ctx->current;
            enum token_type op = ctx->current->type;
            pre_match(ctx);
            pre_cast_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;

            if (op == '!')
                ectx->value = !ectx->value;
            else if (op == '~')
                ectx->value = ~ectx->value;
            else if (op == '-')
                ectx->value = -ectx->value;
            else if (op == '+')
                ectx->value = +ectx->value;
            else if (op == '*')
            {
                preprocessor_diagnostic_message(C_ERROR_TOKEN_NOT_VALID_IN_PREPROCESSOR_EXPRESSIONS, ctx, p_old, "token '%s' is not valid in preprocessor expressions", p_old->lexeme);
            }
            else if (op == '&')
            {
                preprocessor_diagnostic_message(C_ERROR_TOKEN_NOT_VALID_IN_PREPROCESSOR_EXPRESSIONS, ctx, p_old, "token '%s' is not valid in preprocessor expressions", p_old->lexeme);
            }
            else
            {
                preprocessor_diagnostic_message(C_ERROR_TOKEN_NOT_VALID_IN_PREPROCESSOR_EXPRESSIONS, ctx, p_old, "token '%s' is not valid in preprocessor expressions", p_old->lexeme);
            }
        }
        else
        {
            pre_postfix_expression(ctx, ectx);
        }
    }
    catch
    {
    }
}

static void pre_cast_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
     cast-expression:
      unary-expression
      ( type-name ) cast-expression
    */
    pre_unary_expression(ctx, ectx);
}

static void pre_multiplicative_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
     multiplicative-expression:
    cast-expression
    multiplicative-expression * cast-expression
    multiplicative-expression / cast-expression
    multiplicative-expression % cast-expression
    */
    try
    {
        pre_cast_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '*' ||
                   ctx->current->type == '/' ||
                   ctx->current->type == '%'))
        {
            struct token* op_token = ctx->current;
            enum token_type op = ctx->current->type;
            pre_match(ctx);
            long long left_value = ectx->value;
            pre_cast_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;

            if (op == '*')
            {
                ectx->value = (left_value * ectx->value);
            }
            else if (op == '/')
            {
                if (ectx->value == 0)
                {
                    preprocessor_diagnostic_message(C_PRE_DIVISION_BY_ZERO, ctx, op_token, "division by zero");
                    throw;
                }
                else
                {
                    ectx->value = (left_value / ectx->value);
                }
            }
            else if (op == '%')
            {
                ectx->value = (left_value % ectx->value);
            }
        }
    }
    catch
    {
    }
}

static void pre_additive_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
     additive-expression:
       multiplicative-expression
       additive-expression + multiplicative-expression
       additive-expression - multiplicative-expression
    */
    try
    {
        pre_multiplicative_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '+' ||
                   ctx->current->type == '-'))
        {
            const struct token* p_op_token = ctx->current;
            pre_match(ctx);
            if (ctx->current == NULL)
            {
                preprocessor_diagnostic_message(C_ERROR_UNEXPECTED_END_OF_FILE, ctx, p_op_token, "unexpected end of file");
                throw;
            }
            long long left_value = ectx->value;
            pre_multiplicative_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;

            if (p_op_token->type == '+')
            {
                ectx->value = left_value + ectx->value;
            }
            else if (p_op_token->type == '-')
            {
                ectx->value = left_value - ectx->value;
            }
            else
            {
                throw;
            }
        }
    }
    catch
    {
    }
}

static void pre_shift_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
     shift-expression:
       additive-expression
       shift-expression << additive-expression
       shift-expression >> additive-expression
    */
    try
    {
        pre_additive_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '>>' ||
                   ctx->current->type == '<<'))
        {
            enum token_type op = ctx->current->type;
            pre_match(ctx);
            long long left_value = ectx->value;
            pre_multiplicative_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;

            if (op == '>>')
            {
                ectx->value = left_value >> ectx->value;
            }
            else if (op == '<<')
            {
                ectx->value = left_value << ectx->value;
            }
        }
    }
    catch
    {
    }
}

static void pre_relational_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
    relational-expression:
      shift-expression
      relational-expression < shift-expression
      relational-expression > shift-expression
      relational-expression <= shift-expression
      relational-expression >= shift-expression
    */
    try
    {
        pre_shift_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '>' ||
                   ctx->current->type == '<' ||
                   ctx->current->type == '>=' ||
                   ctx->current->type == '<='))
        {
            enum token_type op = ctx->current->type;
            pre_match(ctx);
            long long left_value = ectx->value;
            pre_shift_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;

            if (op == '>')
            {
                ectx->value = left_value > ectx->value;
            }
            else if (op == '<')
            {
                ectx->value = left_value < ectx->value;
            }
            else if (op == '>=')
            {
                ectx->value = left_value >= ectx->value;
            }
            else if (op == '<=')
            {
                ectx->value = left_value <= ectx->value;
            }
        }
    }
    catch
    {
    }
}

static void pre_equality_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
      equality-expression:
        relational-expression
        equality-expression == relational-expression
        equality-expression != relational-expression
    */

    /*
    * Equality operators
    One of the following shall hold:
    — both operands have arithmetic type;
    — both operands are pointers to qualified or unqualified versions of compatible types;
    — one operand is a pointer to an object type and the other is a pointer to a qualified or unqualified
    version of void; or
    — one operand is a pointer and the other is a null pointer constant.
    */
    try
    {
        pre_relational_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '==' ||
                   ctx->current->type == '!='))
        {
            enum token_type op = ctx->current->type;
            pre_match(ctx);
            long long left_value = ectx->value;
            pre_multiplicative_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;

            if (op == '==')
            {
                ectx->value = left_value == ectx->value;
            }
            else if (op == '!=')
            {
                ectx->value = left_value != ectx->value;
            }
        }
    }
    catch
    {
    }
}

static void pre_and_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
     AND-expression:
      equality-expression
      AND-expression & equality-expression
    */
    try
    {
        pre_equality_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;
        while (ctx->current != NULL &&
               (ctx->current->type == '&'))
        {
            pre_match(ctx);
            long long left_value = ectx->value;
            pre_equality_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;
            ectx->value = left_value & ectx->value;
        }
    }
    catch
    {
    }
}

static void pre_exclusive_or_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
     exclusive-OR-expression:
      AND-expression
     exclusive-OR-expression ^ AND-expression
    */
    try
    {
        pre_and_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '^'))
        {
            pre_match(ctx);
            long long left_value = ectx->value;
            pre_and_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;
            ectx->value = left_value ^ ectx->value;
        }
    }
    catch
    {
    }
}

static void pre_inclusive_or_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
    inclusive-OR-expression:
    exclusive-OR-expression
    inclusive-OR-expression | exclusive-OR-expression
    */
    try
    {
        pre_exclusive_or_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '|'))
        {
            pre_match(ctx);
            long long left_value = ectx->value;
            pre_exclusive_or_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;

            ectx->value = left_value | ectx->value;
        }
    }
    catch
    {
    }
}

static void pre_logical_and_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
    logical-AND-expression:
     inclusive-OR-expression
     logical-AND-expression && inclusive-OR-expression
    */
    try
    {
        pre_inclusive_or_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '&&'))
        {
            pre_match(ctx);
            long long left_value = ectx->value;
            pre_inclusive_or_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;

            ectx->value = left_value && ectx->value;
        }
    }
    catch
    {
    }
}

static void pre_logical_or_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
      logical-OR-expression:
       logical-AND-expression
       logical-OR-expression || logical-AND-expression
    */
    try
    {
        pre_logical_and_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '||'))
        {
            pre_match(ctx);
            long long left_value = ectx->value;
            pre_logical_and_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;

            ectx->value = left_value || ectx->value;
        }
    }
    catch
    {
    }
}

static void pre_assignment_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
    assignment-expression:
       conditional-expression
       unary-expression assignment-operator assignment-expression
       */
       /*
          assignment-operator: one of
          = *= /= %= += -= <<= >>= &= ^= |=
       */
       // here it is doubtful but conditional does unary too. 
       // the difference is that it is not just any expression 
       // which can be an assignment
    try
    {
        pre_conditional_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;

        while (ctx->current != NULL &&
               (ctx->current->type == '=' ||
                   ctx->current->type == '*=' ||
                   ctx->current->type == '/=' ||
                   ctx->current->type == '+=' ||
                   ctx->current->type == '-=' ||
                   ctx->current->type == '<<=' ||
                   ctx->current->type == '>>=' ||
                   ctx->current->type == '&=' ||
                   ctx->current->type == '^=' ||
                   ctx->current->type == '|='))
        {
            preprocessor_diagnostic_message(C_ERROR_TOKEN_NOT_VALID_IN_PREPROCESSOR_EXPRESSIONS, ctx, ctx->current, "token '%s' is not valid in preprocessor expressions", ctx->current->lexeme);
            throw;
        }
    }
    catch
    {
    }
}

static void pre_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*expression:
      assignment-expression
      expression, assignment-expression
    */
    try
    {
        pre_assignment_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;

        while (ctx->current && ctx->current->type == ',')
        {
            pre_match(ctx);
            pre_expression(ctx, ectx);
            if (ctx->n_errors > 0)
                throw;
        }
    }
    catch
    {
    }
}

static void pre_conditional_expression(struct preprocessor_ctx* ctx, struct pre_expression_ctx* ectx)
{
    /*
      conditional-expression:
      logical-OR-expression
      logical-OR-expression ? expression : conditional-expression
    */
    try
    {
        pre_logical_or_expression(ctx, ectx);
        if (ctx->n_errors > 0)
            throw;

        if (ctx->current && ctx->current->type == '?')
        {
            pre_match(ctx);
            if (ectx->value)
            {
                pre_expression(ctx, ectx);
                if (ctx->n_errors > 0)
                    throw;

                pre_match(ctx); //:
                struct pre_expression_ctx temp = { 0 };
                pre_conditional_expression(ctx, &temp);
                if (ctx->n_errors > 0)
                    throw;
            }
            else
            {
                struct pre_expression_ctx temp = { 0 };
                pre_expression(ctx, &temp);
                if (ctx->n_errors > 0)
                    throw;

                pre_match(ctx); //:
                pre_conditional_expression(ctx, ectx);
                if (ctx->n_errors > 0)
                    throw;
            }
        }
    }
    catch
    {
    }
}

int pre_constant_expression(struct preprocessor_ctx* ctx, long long* pvalue)
{
    struct pre_expression_ctx ectx = { 0 };
    pre_conditional_expression(ctx, &ectx);
    *pvalue = ectx.value;
    return ctx->n_errors > 0;
}



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

#pragma safety enable



#include <stdint.h>


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

//#pragma once

/*
  To be able to do static analysis with goto jump, we
  need to see full function AST because this affects for 
  instance which scopes we are leaving.
  Because static analysis may change the state we also want
  to check static_assert here.. so better to move all checks to here.
  nullchecks and imaginary flags.
*/

struct label_state
{
    const char * label_name;
    int state_number;
};

struct flow_visit_ctx
{
    struct secondary_block* _Opt catch_secondary_block_opt;

    struct parser_ctx *ctx;
    _View struct ast ast;    
    struct flow_defer_scope* _Owner _Opt tail_block;
    struct type* _Opt p_return_type;
    int parameter_list;
    
    int state_number_generator;
    bool expression_is_not_evaluated; //true when is expression for sizeof, missing state_set, typeof
    bool inside_assert;

    int throw_join_state; /*state where throws are joined*/
    int break_join_state; /*state where breaks are joined*/
    int initial_state;    /*used to keep the original state*/

    struct objects arena;

    struct label_state labels[100]; //max 100 labels in a function (case not included)
    int labels_size;
};

struct flow_object* _Opt arena_new_object(struct flow_visit_ctx* ctx);

void flow_visit_ctx_destroy(struct flow_visit_ctx* _Obj_owner p);

void flow_start_visit_declaration(struct flow_visit_ctx* ctx, struct declaration* p_declaration);
void print_arena(struct flow_visit_ctx* ctx);



struct object_visitor
{
    int member_index;
    struct type* p_type;
    struct flow_object* p_object;
};

unsigned int s_visit_number = 1; //creates a unique number

bool flow_object_is_not_null(const struct flow_object* p)
{
    enum object_state e = p->current.state;
    return (
             !(e & OBJECT_STATE_NULL) &&
             ((e & OBJECT_STATE_NOT_NULL) || (e & OBJECT_STATE_MOVED))
           );

}

bool flow_object_can_be_not_null_or_moved(const struct flow_object* p)
{
    enum object_state e = p->current.state;
    return (e & OBJECT_STATE_NOT_NULL) ||
        (e & OBJECT_STATE_MOVED);
}

bool flow_object_is_null(const struct flow_object* p)
{
    enum object_state e = p->current.state;
    return ((e & OBJECT_STATE_NULL) &&
           !(e & OBJECT_STATE_NOT_NULL) &&
           !(e & OBJECT_STATE_MOVED));
}

bool flow_object_is_zero(const struct flow_object* p)
{
    enum object_state e = p->current.state;
    return ((e & OBJECT_STATE_ZERO) &&
            !(e & OBJECT_STATE_NOT_ZERO));
}

bool flow_object_is_not_zero(const struct flow_object* p)
{
    enum object_state e = p->current.state;
    return (!(e & OBJECT_STATE_ZERO) &&
           (e & OBJECT_STATE_NOT_ZERO));
}


bool flow_object_can_be_zero(const struct flow_object* p)
{
    enum object_state e = p->current.state;

    return (e & OBJECT_STATE_ZERO);
}

bool flow_object_can_be_moved(const struct flow_object* p)
{
    enum object_state e = p->current.state;

    return (e & OBJECT_STATE_MOVED);
}

bool flow_object_can_be_null(const struct flow_object* p)
{
    enum object_state e = p->current.state;

    return (e & OBJECT_STATE_NULL);
}

bool flow_object_is_uninitialized(const struct flow_object* p)
{
    enum object_state e = p->current.state;
    return e == OBJECT_STATE_UNINITIALIZED;
}

bool flow_object_can_be_uninitialized(const struct flow_object* p)
{
    enum object_state e = p->current.state;
    return (e & OBJECT_STATE_UNINITIALIZED);
}

bool flow_object_can_have_its_lifetime_ended(const struct flow_object* p)
{
    enum object_state e = p->current.state;
    return (e & OBJECT_STATE_LIFE_TIME_ENDED);
}


static void object_state_to_string_core(enum object_state e)
{
    bool first = true;

    printf("\"");
    if (e & OBJECT_STATE_UNINITIALIZED)
    {
        if (first)
            first = false;
        else
            printf(" | ");
        printf("uninitialized");
    }

    if (e & OBJECT_STATE_NOT_NULL)
    {
        if (first)
            first = false;
        else
            printf(" | ");
        printf("not-null");
    }

    if (e & OBJECT_STATE_NULL)
    {
        if (first)
            first = false;
        else
            printf(" | ");
        printf("null");
    }

    if (e & OBJECT_STATE_ZERO)
    {
        if (first)
            first = false;
        else
            printf(" | ");
        printf("zero");
    }

    if (e & OBJECT_STATE_NOT_ZERO)
    {
        if (first)
            first = false;
        else
            printf(" | ");
        printf("not-zero");
    }


    if (e & OBJECT_STATE_LIFE_TIME_ENDED)
    {
        if (first)
            first = false;
        else
            printf(" | ");
        printf("lifetime-ended");
    }

    if (e & OBJECT_STATE_MOVED)
    {
        if (first)
            first = false;
        else
            printf(" | ");
        printf("moved");
    }

    printf("\"");

}

void flow_object_state_delete(struct flow_object_state* _Owner _Opt p)
{
    if (p)
    {
        objects_view_destroy(&p->alternatives);
        assert(p->next == NULL);
        free(p);
    }
}
void flow_object_state_copy(struct flow_object_state* to, const struct flow_object_state* from)
{
    to->state = from->state;
    to->pointed = from->pointed;
    objects_view_copy(&to->alternatives, &from->alternatives);
}

void flow_object_print_state(struct flow_object* p)
{
    object_state_to_string_core(p->current.state);
}

void object_state_set_item_print(struct flow_object_state* item)
{
    object_state_to_string_core(item->state);
}

bool object_is_expansible(const struct flow_object* _Opt p_object)
{
    return (p_object &&
            p_object->current.state != OBJECT_STATE_NULL &&
                p_object->current.state != OBJECT_STATE_UNINITIALIZED &&
                p_object->current.pointed == 0);
}

void expand_pointer_object(struct flow_visit_ctx* ctx, struct type* p_type, struct flow_object* p_object)
{
    assert(type_is_pointer_or_array(p_type));

    if (object_is_expansible(p_object))
    {
        const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;

        struct type t2 = type_remove_pointer(p_type);
        if (!type_is_void(&t2))
        {
            struct flow_object* _Opt p_object2 = make_object(ctx, &t2, p_object->p_declarator_origin, p_object->p_expression_origin);
            if (p_object2)
            {
                const bool is_nullable = type_is_nullable(&t2, nullable_enabled);
                object_set_unknown(&t2, is_nullable, p_object2, nullable_enabled);
                object_set_pointer(p_object, p_object2);////obj.pointed2 = p_object;
                object_push_states_from(p_object, p_object2);
            }
            else
            {
                //ops
            }
        }
        type_destroy(&t2);
    }
}

void object_swap(struct flow_object* a, struct flow_object* b)
{
    struct flow_object temp = *a;
    *a = *b;
    *b = temp;
}

void object_delete(struct flow_object* _Owner _Opt p)
{
    if (p)
    {
        object_destroy(p);
        free(p);
    }
}
int objects_view_reserve(struct objects_view* p, int n);
void object_set_pointer(struct flow_object* p_object, struct flow_object* p_object2)
{
    p_object->current.pointed = p_object2;
}

void object_destroy(struct flow_object* _Obj_owner p)
{
    objects_view_destroy(&p->members);

    struct flow_object_state* _Owner _Opt p_flow_object_state = p->current.next;
    while (p_flow_object_state)
    {
        struct flow_object_state* _Owner _Opt temp = p_flow_object_state->next;
        p_flow_object_state->next = NULL;
        flow_object_state_delete(p_flow_object_state);
        p_flow_object_state = temp;
    }
    objects_view_destroy(&p->current.alternatives);
}

void flow_object_destroy(struct flow_object_state* _Obj_owner p)
{
    assert(p->next == NULL);
    objects_view_destroy(&p->alternatives);
}

void flow_object_update_current(struct flow_object* p)
{
    if (p->current.alternatives.size > 0)
    {
        p->current.state = 0;
        for (int i = 0; i < p->current.alternatives.size; i++)
        {
            //infinite recursion?
            flow_object_update_current(p->current.alternatives.data[i]);
            p->current.state |= p->current.alternatives.data[i]->current.state;
        }
    }
}

void flow_object_set_current_state_to_can_be_null(struct flow_object* p)
{
    p->current.state |= OBJECT_STATE_NULL;
}

void flow_object_set_current_state_to_is_null(struct flow_object* p)
{
    p->current.state = OBJECT_STATE_NULL;
    if (p->current.alternatives.size > 0)
    {
        for (int i = 0; i < p->current.alternatives.size; i++)
        {
            flow_object_set_current_state_to_can_be_null(p->current.alternatives.data[i]);
        }
    }
}

int flow_object_add_state(struct flow_object* p, struct flow_object_state* _Owner pnew)
{
    assert(pnew->next == NULL);
    pnew->next = p->current.next;
    p->current.next = pnew;
    return 0;
}





void objects_view_destroy(struct objects_view* _Obj_owner p)
{
    free(p->data);
}


int objects_view_reserve(struct objects_view* p, int n)
{
    if (n > p->capacity)
    {
        if ((size_t)n > (SIZE_MAX / (sizeof(p->data[0]))))
        {
            return EOVERFLOW;
        }

        void* _Owner _Opt pnew = realloc(p->data, n * sizeof(p->data[0]));
        if (pnew == NULL) return ENOMEM;

        static_set(p->data, "moved"); //p->data was moved to pnew

        p->data = pnew;
        p->capacity = n;
    }
    return 0;
}


int objects_view_push_back(struct objects_view* p, struct flow_object* p_object)
{
    if (p->size == INT_MAX)
    {
        return EOVERFLOW;
    }

    if (p->size + 1 > p->capacity)
    {
        int new_capacity = 0;
        if (p->capacity > (INT_MAX - p->capacity / 2))
        {
            /*overflow*/
            new_capacity = INT_MAX;
        }
        else
        {
            new_capacity = p->capacity + p->capacity / 2;
            if (new_capacity < p->size + 1)
            {
                new_capacity = p->size + 1;
            }
        }

        int error = objects_view_reserve(p, new_capacity);
        if (error != 0)
        {
            return error;
        }
    }

    p->data[p->size] = p_object;


    p->size++;

    return 0;
}

void objects_view_clear(struct objects_view* p)
{
    p->size = 0;
}

void objects_view_merge(struct objects_view* dest, const struct objects_view* source)
{
    for (int i = 0; i < source->size; i++)
    {
        if (!objects_view_find(dest, source->data[i]))
        {
            objects_view_push_back(dest, source->data[i]);
        }
    }
}

void objects_view_copy(struct objects_view* dest, const struct objects_view* source)
{
    objects_view_reserve(dest, source->size);
    for (int i = 0; i < source->size; i++)
    {
        dest->data[i] = source->data[i];
    }
    dest->size = source->size;
}

bool objects_view_find(const struct objects_view* p, const struct flow_object* p_object)
{
    for (int i = 0; i < p->size; i++)
    {
        if (p->data[i] == p_object)
            return true;
    }
    return false;
}
void objects_destroy(struct objects* _Obj_owner p)
{
    for (int i = 0; i < p->size; i++)
    {
        object_delete(p->data[i]);
    }
    free(p->data);
}

void objects_clear(struct objects* p)
{
    for (int i = 0; i < p->size; i++)
    {
        object_delete(p->data[i]);
    }
    p->size = 0;
}

int objects_reserve(struct objects* p, int n)
{
    if (n > p->capacity)
    {
        if ((size_t)n > (SIZE_MAX / (sizeof(p->data[0]))))
        {
            return EOVERFLOW;
        }

        void* _Owner _Opt pnew = realloc(p->data, n * sizeof(p->data[0]));
        if (pnew == NULL) return ENOMEM;

        static_set(p->data, "moved"); //p->data was moved to pnew

        p->data = pnew;
        p->capacity = n;
    }
    return 0;
}

const struct flow_object* _Opt objects_find(const struct objects* p_objects, const struct flow_object* object)
{
    for (int i = 0; i < p_objects->size; i++)
    {
        if (p_objects->data[i] == object)
            return object;
    }
    return NULL;
}

int objects_push_back(struct objects* p, struct flow_object* _Owner p_object)
{
    if (p->size == INT_MAX)
    {
        object_delete(p_object);
        return EOVERFLOW;
    }

    if (p->size + 1 > p->capacity)
    {
        int new_capacity = 0;
        if (p->capacity > (INT_MAX - p->capacity / 2))
        {
            /*overflow*/
            new_capacity = INT_MAX;
        }
        else
        {
            new_capacity = p->capacity + p->capacity / 2;
            if (new_capacity < p->size + 1)
            {
                new_capacity = p->size + 1;
            }
        }

        int error = objects_reserve(p, new_capacity);
        if (error != 0)
        {
            object_delete(p_object);
            return error;
        }
        assert(p->data != NULL);
    }

    p->data[p->size] = p_object; /*moved*/


    p->size++;

    return 0;
}
struct object_name_list
{
    const char* name;
    struct object_name_list* _Opt previous;
};

bool has_name(const char* name, struct object_name_list* list)
{
    struct object_name_list* _Opt p = list;

    while (p)
    {
        if (strcmp(p->name, name) == 0)
        {
            return true;
        }
        p = p->previous;
    }
    return false;
}

struct flow_object* _Opt make_object_core(struct flow_visit_ctx* ctx,
    struct type* p_type,
    struct object_name_list* list,
    const struct declarator* _Opt p_declarator_opt,
    const struct expression* _Opt p_expression_origin)
{
    //assert((p_declarator_opt == NULL) != (p_expression_origin == NULL));
    if (p_declarator_opt == NULL)
    {
        //assert(p_expression_origin != NULL);
    }
    if (p_expression_origin == NULL)
    {
        // assert(p_declarator_opt != NULL);
    }


    struct flow_object* _Opt p_object = arena_new_object(ctx);

    try
    {
        if (p_object == NULL) throw;

        p_object->p_expression_origin = p_expression_origin;
        p_object->p_declarator_origin = p_declarator_opt;

        if (p_type->struct_or_union_specifier)
        {
            struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
                get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);

            if (p_struct_or_union_specifier)
            {
                p_object->current.state = OBJECT_STATE_NOT_APPLICABLE;

                struct member_declaration* _Opt p_member_declaration =
                    p_struct_or_union_specifier->member_declaration_list.head;

                struct object_name_list l =
                {
                 .name = p_struct_or_union_specifier->tag_name,
                 .previous = list
                };

                //int member_index = 0;
                while (p_member_declaration)
                {
                    if (p_member_declaration->member_declarator_list_opt)
                    {
                        struct member_declarator* _Opt p_member_declarator =
                            p_member_declaration->member_declarator_list_opt->head;

                        while (p_member_declarator)
                        {
                            if (p_member_declarator->declarator)
                            {
                                char* _Opt tag = NULL;
                                if (p_member_declarator->declarator->type.struct_or_union_specifier)
                                {
                                    tag = p_member_declarator->declarator->type.struct_or_union_specifier->tag_name;
                                }
                                else if (p_member_declarator->declarator->type.next &&
                                    p_member_declarator->declarator->type.next->struct_or_union_specifier)
                                {
                                    tag = p_member_declarator->declarator->type.next->struct_or_union_specifier->tag_name;

                                }

                                if (tag && has_name(tag, &l))
                                {
                                    struct flow_object* _Opt member_obj = arena_new_object(ctx);
                                    if (member_obj == NULL)
                                    {
                                        throw;
                                    }

                                    member_obj->parent = p_object;

                                    member_obj->p_expression_origin = p_expression_origin;
                                    member_obj->p_declarator_origin = p_declarator_opt;
                                    member_obj->current.state = OBJECT_STATE_NOT_APPLICABLE;
                                    objects_view_push_back(&p_object->members, member_obj);
                                }
                                else
                                {
                                    struct flow_object* p_member_obj =
                                        make_object_core(ctx,
                                            &p_member_declarator->declarator->type,
                                            &l,
                                            p_declarator_opt,
                                            p_expression_origin);

                                    if (p_member_obj == NULL)
                                    {
                                        throw;
                                    }
                                    p_member_obj->parent = p_object;
                                    objects_view_push_back(&p_object->members, p_member_obj);
                                }

                                //member_index++;
                            }
                            p_member_declarator = p_member_declarator->next;
                        }
                    }
                    else
                    {
                        if (p_member_declaration->specifier_qualifier_list &&
                            p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                        {
                            struct type t = { 0 };
                            t.category = TYPE_CATEGORY_ITSELF;
                            t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                            t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                            struct flow_object* _Opt member_obj = make_object_core(ctx, &t, &l, p_declarator_opt, p_expression_origin);
                            if (member_obj == NULL)
                            {
                                type_destroy(&t);
                                throw;
                            }

                            for (int k = 0; k < member_obj->members.size; k++)
                            {
                                objects_view_push_back(&p_object->members, member_obj->members.data[k]);
                                member_obj->members.data[k] = NULL;
                            }

                            type_destroy(&t);
                        }
                    }
                    p_member_declaration = p_member_declaration->next;
                }
                return p_object;
            }
            return p_object;
        }


        else if (type_is_array(p_type))
        {
            //p_object->state = flags;
            //if (p_object->members_size > 0)
            //{
            //    //not sure if we instanticate all items of array
            //    p_object->members[0].state = flags;
            //}
            //TODO create object for fixed len arrays!
            return p_object;
        }


        p_object->current.state = OBJECT_STATE_UNINITIALIZED;
    }
    catch
    {        
        p_object = NULL;
    }
    return p_object;
}

struct flow_object* _Opt make_object(struct flow_visit_ctx* ctx,
    struct type* p_type,
                           const struct declarator* _Opt p_declarator_opt,
                           const struct expression* _Opt p_expression_origin)
{

    struct object_name_list list = { .name = "" };
    struct flow_object* _Opt p_object = make_object_core(ctx, p_type, &list, p_declarator_opt, p_expression_origin);

    return p_object;
}

struct token* _Opt object_get_token(const struct flow_object* object)
{
    if (object->p_declarator_origin)
    {
        return object->p_declarator_origin->name_opt;
    }
    if (object->p_expression_origin)
    {
        if (object->p_expression_origin->first_token)
            return object->p_expression_origin->first_token;

        if (object->p_expression_origin->last_token)
            return object->p_expression_origin->last_token;

    }
    return NULL;
}

void flow_object_add_new_state_as_a_copy_of_current_state(struct flow_object* object, const char* name, int state_number)
{
    struct flow_object_state* _Owner _Opt pnew = calloc(1, sizeof * pnew);
    if (pnew == NULL) return;//ENOMEM;

    pnew->dbg_name = name;
    pnew->state_number = state_number;


    pnew->next = object->current.next;
    object->current.next = pnew;

    flow_object_state_copy(pnew, &object->current);
    //TODO fix pnew is changed..
}

void object_remove_state(struct flow_object* object, int state_number)
{
    struct flow_object_state* previous = &object->current;
    struct flow_object_state* _Opt it = object->current.next;
    while (it)
    {
        if (it->state_number == state_number)
        {
            struct flow_object_state* _Owner _Opt p_it_next = it->next;
            it->next = NULL;
            flow_object_state_delete(previous->next);
            previous->next = p_it_next;
            break;
        }
        previous = it;
        it = it->next;
    }

}

void print_object_core(int ident,
    struct object_visitor* p_visitor,
    const char* previous_names,
    bool is_pointer,
    bool short_version,
    unsigned int visit_number)
{    
    if (p_visitor->p_object->visit_number == visit_number) return;
    p_visitor->p_object->visit_number = visit_number;

    if (p_visitor->p_type->struct_or_union_specifier)
    {
        assert(p_visitor->p_object->current.state == OBJECT_STATE_NOT_APPLICABLE);
        struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_visitor->p_type->struct_or_union_specifier);

        if (p_struct_or_union_specifier)
        {
            printf("%*c", ident + 1, ' ');
            printf("#%02d {\n", p_visitor->p_object->id);

            struct member_declaration* _Opt p_member_declaration =
                p_struct_or_union_specifier->member_declaration_list.head;


            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator* _Opt p_member_declarator =
                        p_member_declaration->member_declarator_list_opt->head;
                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            const char* name = p_member_declarator->declarator->name_opt ? p_member_declarator->declarator->name_opt->lexeme : "";

                            char buffer[200] = { 0 };
                            if (is_pointer)
                                snprintf(buffer, sizeof buffer, "%s->%s", previous_names, name);
                            else
                                snprintf(buffer, sizeof buffer, "%s.%s", previous_names, name);

                            struct object_visitor visitor = { 0 };
                            visitor.p_type = &p_member_declarator->declarator->type;
                            visitor.p_object = p_visitor->p_object->members.data[p_visitor->member_index];

                            print_object_core(ident + 2, &visitor, buffer,
                                type_is_pointer(&p_member_declarator->declarator->type), short_version,
                                visit_number);

                            p_visitor->member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else
                {
                    struct type t = { 0 };
                    t.category = TYPE_CATEGORY_ITSELF;
                    t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                    t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;


                    struct type* temp = p_visitor->p_type;
                    p_visitor->p_type = &t;

                    int visit_number0 = p_visitor->p_object->visit_number;
                    p_visitor->p_object->visit_number = 0;
                    print_object_core(ident + 1,
                        p_visitor,
                        previous_names,
                        false,
                        short_version,
                        visit_number);

                    p_visitor->p_type = temp; //restore
                    p_visitor->p_object->visit_number = visit_number0;
                    type_destroy(&t);
                }
                p_member_declaration = p_member_declaration->next;
            }

            printf("%*c", ident + 1, ' ');
            printf("}\n");
        }
    }
    else if (type_is_pointer(p_visitor->p_type))
    {
        struct type t2 = type_remove_pointer(p_visitor->p_type);
        printf("%*c", ident, ' ');

        if (short_version)
        {
            printf("#%02d %s == ", p_visitor->p_object->id, previous_names);
            flow_object_print_state(p_visitor->p_object);
            if (flow_object_is_null(p_visitor->p_object))
            {
            }
            else if (flow_object_can_be_uninitialized(p_visitor->p_object))
            {
            }
            else
            {
                printf(" -> ");

                if (p_visitor->p_object->current.pointed != NULL)
                {
                    printf(" #%02d", p_visitor->p_object->current.pointed->id);
                }
                else
                {
                    printf("{...}");
                }
            }
        }
        else
        {
            printf("%p:%s == ", p_visitor->p_object, previous_names);
            printf("{");

            struct flow_object_state* _Opt it = p_visitor->p_object->current.next;
            while (it)
            {
                printf(LIGHTCYAN);
                printf("(#%02d %s)", it->state_number, it->dbg_name);
                object_state_set_item_print(it);
                printf(RESET);
                printf(",");
                it = it->next;
            }
            //printf("*");
            printf(LIGHTMAGENTA);
            printf("(current)");
            flow_object_print_state(p_visitor->p_object);
            printf(RESET);
            printf("}");
        }
        printf("\n");

#if 0
        if (p_visitor->p_object->current.ref.size > 0)
        {
            char buffer[200] = { 0 };
            if (type_is_struct_or_union(&t2))
            {
                snprintf(buffer, sizeof buffer, "%s", previous_names);
            }
            else
            {
                snprintf(buffer, sizeof buffer, "*%s", previous_names);
            }

            for (int i = 0; i < p_visitor->p_object->current.ref.size; i++)
            {
                struct object_visitor visitor = { 0 };
                visitor.p_type = &t2;
                visitor.p_object = p_visitor->p_object->current.ref.data[i];
                print_object_core(ident + 1, &visitor, buffer, is_pointer, short_version, visit_number);
            }
        }
#endif
        type_destroy(&t2);
    }
    else
    {
        printf("%*c", ident, ' ');

        if (short_version)
        {
            printf("#%02d %s == ", p_visitor->p_object->id, previous_names);
            flow_object_print_state(p_visitor->p_object);
        }
        else
        {
            printf("%p:%s == ", p_visitor->p_object, previous_names);
            printf("{");

            struct flow_object_state* _Opt it = p_visitor->p_object->current.next;
            while (it)
            {
                printf("(#%02d %s)", it->state_number, it->dbg_name);
                object_state_set_item_print(it);
                printf(",");
                it = it->next;
            }


            flow_object_print_state(p_visitor->p_object);
            printf("}");
        }

        printf("\n");
    }


}


void object_merge_state(struct flow_object* pdest, struct flow_object* object1, struct flow_object* object2)
{
    pdest->current.state = object1->current.state | object2->current.state;

    if (pdest->members.size == object1->members.size &&
        object1->members.size == object2->members.size)
    {
        for (int i = 0; i < object1->members.size; i++)
        {
            struct flow_object* m1 = object1->members.data[i];
            struct flow_object* m2 = object2->members.data[i];
            object_merge_state(pdest->members.data[i], m1, m2);
        }
    }

#if 0
    for (int i = 0; i < object1->current.ref.size; i++)
    {
        struct flow_object* pointed = object1->current.ref.data[i];
        if (pointed)
        {
            objects_view_push_back(&pdest->current.ref, pointed);
        }
    }

    for (int i = 0; i < object2->current.ref.size; i++)
    {
        struct flow_object* pointed = object2->current.ref.data[i];
        if (pointed)
        {
            objects_view_push_back(&pdest->current.ref, pointed);
        }
    }

#endif


}


int object_restore_current_state_from_core(struct flow_object* object, int state_number, unsigned int visit_number)
{
    if (object->visit_number == visit_number) return 1;//already visited    
    object->visit_number = visit_number;


    struct flow_object_state* _Opt it = object->current.next;
    while (it)
    {
        if (it->state_number == state_number)
        {
            object->current.state = it->state;
#if 0
            objects_view_copy(&object->current.ref, &it->ref);
#endif
            break;
        }
        it = it->next;
    }

    for (int i = 0; i < object->members.size; i++)
    {
        object_restore_current_state_from_core(object->members.data[i], state_number, visit_number);
    }
#if 0
    for (int i = 0; i < object->current.ref.size; i++)
    {
        struct flow_object* pointed = object->current.ref.data[i];

        if (pointed)
        {
            object_restore_current_state_from_core(pointed, state_number, visit_number);
        }
    }
#endif
    return 1;
}

int object_restore_current_state_from(struct flow_object* object, int state_number)
{
    return object_restore_current_state_from_core(object, state_number, s_visit_number++);
}

int object_merge_current_state_with_state_number_core(struct flow_object* object, int state_number, unsigned int visit_number)
{
    if (object->visit_number == visit_number)
    {
        return 1;//already visited
    }
    object->visit_number = visit_number;

    struct flow_object_state* _Opt it = object->current.next;
    while (it)
    {
        if (it->state_number == state_number)
        {
            it->state |= object->current.state;
#if 0
            objects_view_merge(&it->ref, &object->current.ref);
#endif
            break;
        }
        it = it->next;
    }

    for (int i = 0; i < object->members.size; i++)
    {
        object_merge_current_state_with_state_number_core(object->members.data[i], state_number, visit_number);
    }
    if (object->current.state == OBJECT_STATE_NULL ||
        object->current.state == OBJECT_STATE_UNINITIALIZED) //moved
    {
        /*
        struct Y { int i; };
        struct X { struct Y y;  };

        struct X* _Opt _Owner create(struct Y* pY)
        {
            struct X* _Opt _Owner p  = malloc(sizeof * p);
            if (p)  {
                p->y = *pY;
            }
            else
            {
               //p is null, so the pointed object does not need to merge
            }
            return p;
        */
    }
    else
    {
#if 0
        for (int i = 0; i < object->current.ref.size; i++)
        {

            struct flow_object* pointed = object->current.ref.data[i];
            if (pointed)
            {
                object_merge_current_state_with_state_number_core(pointed, state_number, visit_number);
            }

        }
#endif
    }
    return 1;
}


void object_get_name(const struct type* p_type,
    const struct flow_object* p_object,
    char* outname,
    int out_size);


void print_object(struct type* p_type, struct flow_object* p_object, bool short_version)
{    
    char name[100] = { 0 };
    object_get_name(p_type, p_object, name, sizeof name);

    struct object_visitor visitor = { 0 };
    visitor.p_type = p_type;
    visitor.p_object = p_object;
    print_object_core(0, &visitor, name, type_is_pointer(p_type), short_version, s_visit_number++);
}


void object_set_uninitialized_core(struct object_visitor* p_visitor)
{
    if (p_visitor->p_object == NULL || p_visitor->p_type == NULL)
    {
        return;
    }

    if (p_visitor->p_type->struct_or_union_specifier)
    {
        struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_visitor->p_type->struct_or_union_specifier);

        if (p_struct_or_union_specifier)
        {
            struct member_declaration* _Opt p_member_declaration =
                p_struct_or_union_specifier->member_declaration_list.head;


            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator* _Opt p_member_declarator =
                        p_member_declaration->member_declarator_list_opt->head;

                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            if (p_visitor->member_index < p_visitor->p_object->members.size)
                            {
                                struct object_visitor visitor = { 0 };
                                visitor.p_type = &p_member_declarator->declarator->type;
                                visitor.p_object = p_visitor->p_object->members.data[p_visitor->member_index];
                                object_set_uninitialized_core(&visitor);
                            }
                            p_visitor->member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else
                {
                    if (p_member_declaration->specifier_qualifier_list &&
                       p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                    {
                        struct type t = { 0 };
                        t.category = TYPE_CATEGORY_ITSELF;
                        t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                        t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                        struct type* type_temp = p_visitor->p_type;
                        p_visitor->p_type = &t; //new type, same object

                        object_set_uninitialized_core(p_visitor);

                        p_visitor->p_type = type_temp; //restore                         

                        type_destroy(&t);
                    }

                }
                p_member_declaration = p_member_declaration->next;
            }
            return;
        }
    }

    if (type_is_pointer(p_visitor->p_type))
    {
        p_visitor->p_object->current.state = OBJECT_STATE_UNINITIALIZED;

#if 0
        if (p_visitor->p_object->current.ref.size)
        {
            struct type t2 = type_remove_pointer(p_visitor->p_type);
            for (int i = 0; i < p_visitor->p_object->current.ref.size; i++)
            {
                struct flow_object* pointed = p_visitor->p_object->current.ref.data[i];
                object_set_nothing(&t2, pointed);
            }
            type_destroy(&t2);
        }
#endif
    }
    else
    {
        p_visitor->p_object->current.state = OBJECT_STATE_UNINITIALIZED;
    }
}

void object_set_uninitialized(struct type* p_type, struct flow_object* p_object)
{
    struct object_visitor visitor = { 0 };
    visitor.p_type = p_type;
    visitor.p_object = p_object;
    object_set_uninitialized_core(&visitor);
}

static void checked_empty_core(struct flow_visit_ctx* ctx,
    struct type* p_type,
    struct flow_object* p_object,
    const char* previous_names,
    const struct marker* p_marker)
{
    if (p_object == NULL)
    {
        return;
    }


    if (p_type->struct_or_union_specifier && p_object->members.size > 0)
    {
        struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);

        struct member_declaration* _Opt p_member_declaration =
            p_struct_or_union_specifier ?
            p_struct_or_union_specifier->member_declaration_list.head :
            NULL;

        /*
        *  Some parts of the object needs to be moved..
        *  we need to print error one by one
        */
        int member_index = 0;
        while (p_member_declaration)
        {
            if (p_member_declaration->member_declarator_list_opt)
            {
                struct member_declarator* _Opt p_member_declarator =
                    p_member_declaration->member_declarator_list_opt->head;
                while (p_member_declarator)
                {

                    if (p_member_declarator->declarator)
                    {
                        const char* name = p_member_declarator->declarator->name_opt ? p_member_declarator->declarator->name_opt->lexeme : "";
                        char buffer[200] = { 0 };
                        if (type_is_pointer(p_type))
                            snprintf(buffer, sizeof buffer, "%s->%s", previous_names, name);
                        else
                            snprintf(buffer, sizeof buffer, "%s.%s", previous_names, name);


                        checked_empty_core(ctx, &p_member_declarator->declarator->type,
                            p_object->members.data[member_index],
                            name,
                            p_marker);

                        member_index++;
                    }
                    p_member_declarator = p_member_declarator->next;
                }
            }
            p_member_declaration = p_member_declaration->next;
        }
        return;
    }

    if (type_is_any_owner(p_type))
    {
        if (p_object->current.state == (OBJECT_STATE_UNINITIALIZED | OBJECT_STATE_NULL | OBJECT_STATE_MOVED) ||
            p_object->current.state == (OBJECT_STATE_NULL | OBJECT_STATE_MOVED) ||
            p_object->current.state == OBJECT_STATE_NULL ||
            p_object->current.state == OBJECT_STATE_MOVED ||
            p_object->current.state == OBJECT_STATE_UNINITIALIZED ||
            p_object->current.state == (OBJECT_STATE_UNINITIALIZED | OBJECT_STATE_NULL) ||
            p_object->current.state == (OBJECT_STATE_UNINITIALIZED | OBJECT_STATE_MOVED)
            )
        {
        }
        else
        {

            compiler_diagnostic_message(W_FLOW_MISSING_DTOR,
                ctx->ctx,
                NULL,
                p_marker,
                "object '%s' may not be empty",
                previous_names);
        }
    }
}

void checked_empty(struct flow_visit_ctx* ctx,
    struct type* p_type,
    struct flow_object* p_object,
    const struct marker* p_marker)
{
    char name[100] = { 0 };
    object_get_name(p_type, p_object, name, sizeof name);

    checked_empty_core(ctx,
    p_type,
    p_object,
    name,
    p_marker);
}

static void object_set_moved_core(struct object_visitor* p_visitor)
{
    if (p_visitor->p_object == NULL || p_visitor->p_type == NULL)
    {
        return;
    }

    if (p_visitor->p_type->struct_or_union_specifier)
    {
        struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_visitor->p_type->struct_or_union_specifier);

        if (p_struct_or_union_specifier)
        {
            struct member_declaration* _Opt p_member_declaration =
                p_struct_or_union_specifier->member_declaration_list.head;


            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator* _Opt p_member_declarator =
                        p_member_declaration->member_declarator_list_opt->head;

                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            if (p_visitor->member_index < p_visitor->p_object->members.size)
                            {
                                struct object_visitor visitor = { 0 };
                                visitor.p_type = &p_member_declarator->declarator->type;
                                visitor.p_object = p_visitor->p_object->members.data[p_visitor->member_index];
                                object_set_moved_core(&visitor);
                            }
                            p_visitor->member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else
                {
                    if (p_member_declaration->specifier_qualifier_list &&
                       p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                    {
                        struct type t = { 0 };
                        t.category = TYPE_CATEGORY_ITSELF;
                        t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                        t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                        struct type* type_temp = p_visitor->p_type;
                        p_visitor->p_type = &t; //new type, same object

                        object_set_moved_core(p_visitor);

                        p_visitor->p_type = type_temp; //restore                         

                        type_destroy(&t);
                    }

                }
                p_member_declaration = p_member_declaration->next;
            }
            return;
        }
    }

    if (type_is_pointer(p_visitor->p_type))
    {
        p_visitor->p_object->current.state = OBJECT_STATE_MOVED;
    }
    else
    {
        p_visitor->p_object->current.state = OBJECT_STATE_MOVED;
    }
}

void object_set_moved(struct type* p_type, struct flow_object* p_object)
{
    struct object_visitor visitor = { 0 };
    visitor.p_type = p_type;
    visitor.p_object = p_object;
    object_set_moved_core(&visitor);
}

static void object_set_unknown_core(struct object_visitor* p_visitor, bool t_is_nullable, unsigned int visit_number, bool nullable_enabled)
{
    if (p_visitor->p_object == NULL || p_visitor->p_type == NULL)
    {
        return;
    }

    if (p_visitor->p_object->visit_number == visit_number) return; //already visited
    p_visitor->p_object->visit_number = visit_number;


    if (p_visitor->p_type->struct_or_union_specifier)
    {
        struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_visitor->p_type->struct_or_union_specifier);

        if (p_struct_or_union_specifier)
        {
            struct member_declaration* _Opt p_member_declaration =
                p_struct_or_union_specifier->member_declaration_list.head;


            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator* _Opt p_member_declarator =
                        p_member_declaration->member_declarator_list_opt->head;

                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            if (p_visitor->member_index < p_visitor->p_object->members.size)
                            {
                                struct object_visitor visitor = { 0 };
                                visitor.p_type = &p_member_declarator->declarator->type;
                                visitor.p_object = p_visitor->p_object->members.data[p_visitor->member_index];

                                object_set_unknown_core(&visitor,
                                    t_is_nullable,
                                    visit_number,
                                    nullable_enabled);
                            }
                            else
                            {
                                //TODO BUG union?                                
                            }
                            p_visitor->member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else
                {
                    if (p_member_declaration->specifier_qualifier_list &&
                        p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                    {
                        struct type t = { 0 };
                        t.category = TYPE_CATEGORY_ITSELF;
                        t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                        t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                        struct type* temp = p_visitor->p_type;
                        p_visitor->p_type = &t;

                        int vn = p_visitor->p_object->visit_number;
                        p_visitor->p_object->visit_number = 0;
                        object_set_unknown_core(p_visitor, t_is_nullable, visit_number, nullable_enabled);



                        //restore
                        p_visitor->p_object->visit_number = vn;
                        p_visitor->p_type = temp;

                        type_destroy(&t);
                    }
                }
                p_member_declaration = p_member_declaration->next;
            }
            return;
        }
        return;
    }

    if (type_is_pointer(p_visitor->p_type))
    {
        if (t_is_nullable || type_is_nullable(p_visitor->p_type, nullable_enabled))
            p_visitor->p_object->current.state = OBJECT_STATE_NULL | OBJECT_STATE_NOT_NULL;
        else
            p_visitor->p_object->current.state = OBJECT_STATE_NOT_NULL;


        struct flow_object* _Opt pointed = p_visitor->p_object->current.pointed;
        if (pointed)
        {
            struct type t2 = type_remove_pointer(p_visitor->p_type);
            bool t2_is_nullable = type_is_nullable(&t2, nullable_enabled);
            struct object_visitor visitor = { 0 };
            visitor.p_type = &t2;
            visitor.p_object = pointed;

            object_set_unknown_core(&visitor, t2_is_nullable, visit_number, nullable_enabled);
            type_destroy(&t2);
        }

    }
    else
    {
        if (!type_is_struct_or_union(p_visitor->p_type))
            p_visitor->p_object->current.state = OBJECT_STATE_ZERO | OBJECT_STATE_NOT_ZERO;
    }
}

void object_set_unknown(struct type* p_type, bool t_is_nullable, struct flow_object* p_object, bool nullable_enabled)
{
    struct object_visitor visitor = { 0 };
    visitor.p_type = p_type;
    visitor.p_object = p_object;
    object_set_unknown_core(&visitor, t_is_nullable, s_visit_number++, nullable_enabled);
}


static void object_set_deleted_core(struct type* p_type, struct flow_object* p_object, unsigned int visit_number)
{
    if (p_object == NULL || p_type == NULL)
    {
        return;
    }

    if (p_object->visit_number == visit_number) return; //already visited
    p_object->visit_number = visit_number;


    if (p_type->struct_or_union_specifier && p_object->members.size > 0)
    {
        struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);

        if (p_struct_or_union_specifier)
        {
            struct member_declaration* _Opt p_member_declaration =
                p_struct_or_union_specifier->member_declaration_list.head;

            int member_index = 0;
            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator* _Opt p_member_declarator =
                        p_member_declaration->member_declarator_list_opt->head;

                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            if (member_index < p_object->members.size)
                            {
                                object_set_deleted_core(&p_member_declarator->declarator->type, p_object->members.data[member_index], visit_number);
                            }
                            else
                            {
                                //TODO BUG union?                                
                            }
                            member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                p_member_declaration = p_member_declaration->next;
            }
            return;
        }
        return;
    }

    if (type_is_pointer(p_type))
    {
        p_object->current.state = OBJECT_STATE_LIFE_TIME_ENDED;
#if 0
        for (int i = 0; i < p_object->current.ref.size; i++)
        {
            struct flow_object* pointed = p_object->current.ref.data[i];
            if (pointed)
            {
                struct type t2 = type_remove_pointer(p_type);
                object_set_deleted_core(&t2, pointed, visit_number);
                type_destroy(&t2);
            }
        }
#endif
    }
    else
    {
        if (!type_is_struct_or_union(p_type))
            p_object->current.state = OBJECT_STATE_LIFE_TIME_ENDED;
    }
}

void flow_object_set_can_be_uninitialized(struct flow_object* p_object)
{
    p_object->current.state |= OBJECT_STATE_UNINITIALIZED;
}
void flow_object_set_is_unitialized(struct flow_object* p_object)
{
    p_object->current.state = OBJECT_STATE_UNINITIALIZED;
    if (p_object->current.alternatives.size > 0)
    {
        for (int i = 0; i < p_object->current.alternatives.size; i++)
        {
            flow_object_set_can_be_uninitialized(p_object->current.alternatives.data[i]);
        }
    }
}

void flow_object_set_can_be_moved(struct flow_object* p_object)
{
    if (p_object->current.state & OBJECT_STATE_NOT_NULL)
    {
        p_object->current.state &= ~OBJECT_STATE_NOT_NULL;
        p_object->current.state |= OBJECT_STATE_MOVED;
        p_object->current.state |= OBJECT_STATE_MOVED;
    }
}
void flow_object_set_is_moved(struct flow_object* p_object)
{
    p_object->current.state = OBJECT_STATE_MOVED;

    if (p_object->current.alternatives.size > 0)
    {
        for (int i = 0; i < p_object->current.alternatives.size; i++)
        {
            flow_object_set_can_be_moved(p_object->current.alternatives.data[i]);
        }
    }
}


void object_set_deleted(struct type* p_type, struct flow_object* p_object)
{
    object_set_deleted_core(p_type, p_object, s_visit_number++);
}

void object_set_zero_core(struct object_visitor* p_visitor)
{
    if (p_visitor->p_object == NULL || p_visitor->p_type == NULL)
    {
        return;
    }

    if (p_visitor->p_type->struct_or_union_specifier)
    {
        struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_visitor->p_type->struct_or_union_specifier);

        if (p_struct_or_union_specifier)
        {
            struct member_declaration* p_member_declaration = p_struct_or_union_specifier->member_declaration_list.head;

            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator* _Opt p_member_declarator =
                        p_member_declaration->member_declarator_list_opt->head;

                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            if (p_visitor->member_index < p_visitor->p_object->members.size)
                            {
                                struct object_visitor visitor = { 0 };
                                visitor.p_type = &p_member_declarator->declarator->type;
                                visitor.p_object = p_visitor->p_object->members.data[p_visitor->member_index];
                                object_set_zero_core(&visitor);
                            }
                            p_visitor->member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else
                {
                    if (p_member_declaration->specifier_qualifier_list &&
                        p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                    {
                        struct type t = { 0 };
                        t.category = TYPE_CATEGORY_ITSELF;
                        t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                        t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                        struct type* temp = p_visitor->p_type;
                        p_visitor->p_type = &t;
                        object_set_zero_core(p_visitor);
                        p_visitor->p_type = temp; //restore
                        type_destroy(&t);
                    }
                }
                p_member_declaration = p_member_declaration->next;
            }
            return;
        }
        return;
    }

    if (type_is_pointer(p_visitor->p_type))
    {
        p_visitor->p_object->current.state = OBJECT_STATE_NULL;
    }
    else
    {
        p_visitor->p_object->current.state = OBJECT_STATE_ZERO;
    }
}

void object_set_zero(struct type* p_type, struct flow_object* p_object)
{
    struct object_visitor visitor = { 0 };
    visitor.p_type = p_type;
    visitor.p_object = p_object;
    object_set_zero_core(&visitor);
}

void object_set_end_of_lifetime_core(struct object_visitor* p_visitor)
{
    if (p_visitor->p_object == NULL || p_visitor->p_type == NULL)
    {
        return;
    }

    if (p_visitor->p_type->struct_or_union_specifier)
    {
        struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_visitor->p_type->struct_or_union_specifier);

        if (p_struct_or_union_specifier)
        {
            struct member_declaration* _Opt p_member_declaration = p_struct_or_union_specifier->member_declaration_list.head;

            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator* _Opt p_member_declarator =
                        p_member_declaration->member_declarator_list_opt->head;

                    while (p_member_declarator)
                    {
                        if (p_member_declarator->declarator)
                        {
                            if (p_visitor->member_index < p_visitor->p_object->members.size)
                            {
                                struct object_visitor visitor = { 0 };
                                visitor.p_type = &p_member_declarator->declarator->type;
                                visitor.p_object = p_visitor->p_object->members.data[p_visitor->member_index];
                                object_set_end_of_lifetime_core(&visitor);
                            }
                            p_visitor->member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else
                {
                    if (p_member_declaration->specifier_qualifier_list &&
                        p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                    {
                        struct type t = { 0 };
                        t.category = TYPE_CATEGORY_ITSELF;
                        t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                        t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                        struct type* temp = p_visitor->p_type;
                        p_visitor->p_type = &t;
                        object_set_end_of_lifetime_core(p_visitor);
                        p_visitor->p_type = temp; //restore
                        type_destroy(&t);
                    }
                }
                p_member_declaration = p_member_declaration->next;
            }
            return;
        }
        return;
    }

    p_visitor->p_object->current.state = OBJECT_STATE_LIFE_TIME_ENDED;
}

void object_set_end_of_lifetime(struct type* p_type, struct flow_object* p_object)
{
    struct object_visitor visitor = { 0 };
    visitor.p_type = p_type;
    visitor.p_object = p_object;
    object_set_end_of_lifetime_core(&visitor);
}
//returns true if all parts that need to be moved weren't moved.
bool object_check(struct type* p_type, struct flow_object* p_object)
{
    if (p_object == NULL)
    {
        return false;
    }
    if (p_type->type_qualifier_flags & TYPE_QUALIFIER_VIEW)
    {
        return false;
    }

    if (!type_is_any_owner(p_type))
    {
        return false;
    }

    if (p_type->struct_or_union_specifier && p_object->members.size > 0)
    {
        struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);

        struct member_declaration* _Opt p_member_declaration =
            p_struct_or_union_specifier->member_declaration_list.head;
        int possible_need_destroy_count = 0;
        int need_destroy_count = 0;
        int member_index = 0;
        while (p_member_declaration)
        {
            if (p_member_declaration->member_declarator_list_opt)
            {
                struct member_declarator* _Opt p_member_declarator =
                    p_member_declaration->member_declarator_list_opt->head;
                while (p_member_declarator)
                {

                    if (p_member_declarator->declarator)
                    {
                        if (type_is_owner(&p_member_declarator->declarator->type))
                        {
                            possible_need_destroy_count++;
                        }

                        if (object_check(&p_member_declarator->declarator->type,
                            p_object->members.data[member_index]))
                        {
                            need_destroy_count++;
                        }
                        member_index++;
                    }
                    p_member_declarator = p_member_declarator->next;
                }
            }
            p_member_declaration = p_member_declaration->next;
        }

        return need_destroy_count > 1 && (need_destroy_count == possible_need_destroy_count);
    }
    else
    {
        bool should_had_been_moved = false;
        if (type_is_pointer(p_type))
        {
            should_had_been_moved = (p_object->current.state & OBJECT_STATE_NOT_NULL);
        }
        else
        {
            if (p_object->current.state == OBJECT_STATE_UNINITIALIZED ||
                (p_object->current.state & OBJECT_STATE_MOVED) ||
                p_object->current.state == OBJECT_STATE_NOT_NULL ||
                p_object->current.state == (OBJECT_STATE_UNINITIALIZED))
            {
            }
            else
            {
                should_had_been_moved = true;
            }
        }

        return should_had_been_moved;
    }

    return false;
}

void object_get_name_core(
    const struct type* p_type,
    const struct flow_object* p_object,
    const struct flow_object* p_object_target,
    const char* previous_names,
    char* outname,
    int out_size,
    unsigned int visit_number)
{
    if (p_object == NULL)
    {
        return;
    }
    if (p_object->visit_number == visit_number) return;
    ((struct flow_object*)p_object)->visit_number = visit_number;

    if (p_object == p_object_target)
    {
        snprintf(outname, out_size, "%s", previous_names);
        return;
    }

    if (p_type->struct_or_union_specifier && p_object->members.size > 0)
    {
        struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);

        struct member_declaration* _Opt p_member_declaration =
            p_struct_or_union_specifier->member_declaration_list.head;

        int member_index = 0;
        while (p_member_declaration)
        {
            if (p_member_declaration->member_declarator_list_opt)
            {
                struct member_declarator* _Opt p_member_declarator =
                    p_member_declaration->member_declarator_list_opt->head;
                while (p_member_declarator)
                {

                    if (p_member_declarator->declarator)
                    {
                        const char* name = p_member_declarator->declarator->name_opt ? p_member_declarator->declarator->name_opt->lexeme : "";
                        char buffer[200] = { 0 };
                        if (type_is_pointer(p_type))
                            snprintf(buffer, sizeof buffer, "%s->%s", previous_names, name);
                        else
                            snprintf(buffer, sizeof buffer, "%s.%s", previous_names, name);

                        object_get_name_core(
                            &p_member_declarator->declarator->type,
                            p_object->members.data[member_index],
                            p_object_target,
                            buffer,
                            outname,
                            out_size, visit_number);

                        member_index++;
                    }
                    p_member_declarator = p_member_declarator->next;
                }
            }
            p_member_declaration = p_member_declaration->next;
        }

    }
    else
    {
        snprintf(outname, out_size, "%s", previous_names);
    }
}


void object_get_name(const struct type* p_type,
    const struct flow_object* p_object,
    char* outname,
    int out_size)
{
    outname[0] = '\0';

    if (p_object->p_declarator_origin)
    {

        const char* root_name = p_object->p_declarator_origin->name_opt ? p_object->p_declarator_origin->name_opt->lexeme : "?";
        //snprintf(outname, out_size, "%s",root_name);

        const struct flow_object* _Opt root = p_object->p_declarator_origin->p_object;

        object_get_name_core(&p_object->p_declarator_origin->type, root, p_object, root_name, outname, out_size, s_visit_number++);
    }
    else if (p_object->p_expression_origin)
    {
        int bytes_written = 0;
        struct token* p = p_object->p_expression_origin->first_token;
        for (int i = 0; i < 10; i++)
        {
            const char* ps = p->lexeme;
            while (*ps)
            {
                if (bytes_written < (out_size - 1))
                {
                    outname[bytes_written] = *ps;
                }
                bytes_written++;
                ps++;
            }

            if (p == p_object->p_expression_origin->last_token)
                break;

            p = p->next;
        }

        if (bytes_written < (out_size - 1))
            outname[bytes_written] = '\0';
        else
            outname[out_size - 1] = '\0';
    }
    else
    {
        outname[0] = '?';
        outname[1] = '\0';
    }
}

void checked_moved_core(struct flow_visit_ctx* ctx,
    struct type* p_type,
    struct flow_object* p_object,
    const struct token* position_token,
    unsigned int visit_number)
{
    if (p_object == NULL)
    {
        return;
    }

    if (p_object->visit_number == visit_number) return;//already visited    
    p_object->visit_number = visit_number;

    if (p_type->struct_or_union_specifier && p_object->members.size > 0)
    {
        struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);

        struct member_declaration* _Opt p_member_declaration =
            p_struct_or_union_specifier->member_declaration_list.head;

        /*
        *  Some parts of the object needs to be moved..
        *  we need to print error one by one
        */
        int member_index = 0;
        while (p_member_declaration)
        {
            if (p_member_declaration->member_declarator_list_opt)
            {
                struct member_declarator* _Opt p_member_declarator =
                    p_member_declaration->member_declarator_list_opt->head;
                while (p_member_declarator)
                {
                    if (p_member_declarator->declarator)
                    {
                        checked_moved_core(ctx, &p_member_declarator->declarator->type, p_object->members.data[member_index], position_token, visit_number);
                        member_index++;
                    }

                    p_member_declarator = p_member_declarator->next;
                }
            }
            p_member_declaration = p_member_declaration->next;
        }
        return;
    }
    else
    {
        if (type_is_pointer(p_type) && !type_is_any_owner(p_type))
        {
            if (p_object->current.state != OBJECT_STATE_UNINITIALIZED &&
                p_object->current.state != OBJECT_STATE_NULL)
            {
                struct type t2 = type_remove_pointer(p_type);
#if 0
                for (int i = 0; i < p_object->current.ref.size; i++)
                {
                    checked_moved_core(ctx,
                        &t2,
                        p_object->current.ref.data[i],
                        position_token,
                        visit_number);
                }
#endif
                type_destroy(&t2);
            }
        }

        if (p_object->current.state & OBJECT_STATE_MOVED)
        {
            struct token* name_pos = object_get_token(p_object);
            const char* parameter_name = name_pos ? name_pos->lexeme : "?";


            char name[200] = { 0 };
            object_get_name(p_type, p_object, name, sizeof name);
            if (compiler_diagnostic_message(W_FLOW_MISSING_DTOR,
                ctx->ctx,
                position_token, NULL,
                "parameter '%s' is leaving scoped with a moved object '%s'",
                parameter_name,
                name))
            {
                compiler_diagnostic_message(W_LOCATION, ctx->ctx, name_pos, NULL, "parameter", name);
            }
        }

        if (p_object->current.state & OBJECT_STATE_UNINITIALIZED)
        {
            struct token* name_pos = object_get_token(p_object);
            const char* parameter_name = name_pos ? name_pos->lexeme : "?";

            char name[200] = { 0 };
            object_get_name(p_type, p_object, name, sizeof name);
            if (compiler_diagnostic_message(W_FLOW_MISSING_DTOR,
                ctx->ctx,
                position_token, NULL,
                "parameter '%s' is leaving scoped with a uninitialized object '%s'",
                parameter_name,
                name))
            {
                compiler_diagnostic_message(W_LOCATION, ctx->ctx, name_pos, NULL, "parameter", name);
            }
        }
    }
}

void checked_moved(struct flow_visit_ctx* ctx,
    struct type* p_type,
    struct flow_object* p_object,
    const struct token* position_token)
{
    checked_moved_core(ctx,
    p_type,
    p_object,
    position_token,
    s_visit_number++);
}

void checked_read_object_core(struct flow_visit_ctx* ctx,
    struct object_visitor* p_visitor,
    bool is_nullable,
    const struct token* position_token,
    const struct marker* p_marker,
    bool check_pointed_object,
    const char* previous_names,
    unsigned int visit_number)
{
    assert(previous_names != NULL);
    if (p_visitor->p_object == NULL)
    {
        return;
    }

    if (p_visitor->p_object->visit_number == visit_number) return;
    p_visitor->p_object->visit_number = visit_number;


    if (p_visitor->p_type->struct_or_union_specifier && p_visitor->p_object->members.size > 0)
    {
        struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_visitor->p_type->struct_or_union_specifier);

        struct member_declaration* _Opt p_member_declaration =
            p_struct_or_union_specifier ?
            p_struct_or_union_specifier->member_declaration_list.head :
            NULL;

        /*
        *  Some parts of the object needs to be moved..
        *  we need to print error one by one
        */
        while (p_member_declaration)
        {
            if (p_member_declaration->member_declarator_list_opt)
            {
                struct member_declarator* _Opt p_member_declarator =
                    p_member_declaration->member_declarator_list_opt->head;
                while (p_member_declarator)
                {

                    if (p_member_declarator->declarator)
                    {
                        const char* name =
                            p_member_declarator->declarator->name_opt ? p_member_declarator->declarator->name_opt->lexeme : "?";

                        char buffer[200] = { 0 };
                        if (type_is_pointer(p_visitor->p_type))
                            snprintf(buffer, sizeof buffer, "%s->%s", previous_names, name);
                        else
                            snprintf(buffer, sizeof buffer, "%s.%s", previous_names, name);

                        struct object_visitor  visitor = { 0 };
                        visitor.p_type = &p_member_declarator->declarator->type;
                        visitor.p_object = p_visitor->p_object->members.data[p_visitor->member_index];


                        checked_read_object_core(ctx,
                            &visitor,
                            is_nullable,
                            position_token,
                            p_marker,
                            check_pointed_object,
                            buffer,
                            visit_number);

                        p_visitor->member_index++;
                    }
                    p_member_declarator = p_member_declarator->next;
                }
            }
            else
            {
                struct type t = { 0 };
                t.category = TYPE_CATEGORY_ITSELF;
                t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                char buffer[200] = { 0 };
                if (type_is_pointer(p_visitor->p_type))
                    snprintf(buffer, sizeof buffer, "%s->", previous_names);
                else
                    snprintf(buffer, sizeof buffer, "%s.", previous_names);

                struct type* temp = p_visitor->p_type;
                p_visitor->p_type = &t;

                int visit_number0 = p_visitor->p_object->visit_number;
                p_visitor->p_object->visit_number = 0;

                checked_read_object_core(ctx,
                        p_visitor,
                        is_nullable,
                        position_token,
                        p_marker,
                        check_pointed_object,
                        buffer,
                        visit_number);

                p_visitor->p_type = temp; //restore
                p_visitor->p_object->visit_number = visit_number0;
                type_destroy(&t);

            }
            p_member_declaration = p_member_declaration->next;
        }
        return;
    }
    else
    {

        if (type_is_pointer(p_visitor->p_type) &&
            !is_nullable &&
            !type_is_nullable(p_visitor->p_type, ctx->ctx->options.null_checks_enabled) &&
            flow_object_can_be_null(p_visitor->p_object))
        {
            compiler_diagnostic_message(W_FLOW_NULL_DEREFERENCE,
                ctx->ctx,
                NULL,
                p_marker,
                "non-nullable pointer '%s' may be null",
                previous_names);
        }

        if (type_is_pointer(p_visitor->p_type) &&
            check_pointed_object &&
            flow_object_can_be_not_null_or_moved(p_visitor->p_object))
        {
            struct type t2 = type_remove_pointer(p_visitor->p_type);

            if (p_visitor->p_object->current.pointed)
            {
                struct object_visitor  visitor = { 0 };
                visitor.p_type = &t2;
                visitor.p_object = p_visitor->p_object->current.pointed;

                checked_read_object_core(ctx,
                    &visitor,
                    is_nullable,
                    position_token,
                    p_marker,
                    true,
                    previous_names,
                    visit_number);
            }

            type_destroy(&t2);
        }


        if (p_visitor->p_object->current.state & OBJECT_STATE_UNINITIALIZED)
        {
            if (type_is_array(p_visitor->p_type))
            {
                //unitialized arrays are used as initialized pointers to uninitialized objects.
            }
            else
            {
                compiler_diagnostic_message(W_FLOW_UNINITIALIZED,
                    ctx->ctx,
                    position_token, NULL,
                    "uninitialized object '%s'",
                    previous_names);
            }
        }


        //TODO there is some problem with  OBJECT_STATE_LIFE_TIME_ENDED
        //state somewhere!
        if (p_visitor->p_object->current.state & OBJECT_STATE_LIFE_TIME_ENDED)
        {
            //compiler_diagnostic_message(W_FLOW_UNINITIALIZED,
            //    ctx->ctx,
            //    position_token,
            //    "lifetime ended '%s'",
            //    previous_names);
        }


    }
}

/*
  Check if all objects connect to this one
   - are initialized
*/
void checked_read_object(struct flow_visit_ctx* ctx,
    struct type* p_type,
    bool is_nullable,
    struct flow_object* p_object,
    const struct token* position_token,
    const struct marker* p_marker,
    bool check_pointed_object)
{
    const char* _Owner _Opt s = NULL;
    char name[200] = { 0 };

    object_get_name(p_type, p_object, name, sizeof name);

    struct object_visitor visitor = { 0 };
    visitor.p_object = p_object;
    visitor.p_type = p_type;

    checked_read_object_core(ctx,
    &visitor,
    is_nullable,
    position_token,
    p_marker,
    check_pointed_object,
    name,
    s_visit_number++);
    free((void* _Owner)s);
}

static void flow_end_of_block_visit_core(struct flow_visit_ctx* ctx,
    struct object_visitor* p_visitor,
    bool b_type_is_view,
    const struct token* position_token,
    const char* previous_names,
    unsigned int visit_number)
{
    if (p_visitor->p_object == NULL)
    {
        return;
    }

    if (p_visitor->p_object->visit_number == visit_number) return;
    p_visitor->p_object->visit_number = visit_number;


    if (p_visitor->p_type->struct_or_union_specifier && p_visitor->p_object->members.size > 0)
    {
        struct struct_or_union_specifier* _Opt p_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_visitor->p_type->struct_or_union_specifier);

        struct member_declaration* _Opt p_member_declaration =
            p_struct_or_union_specifier->member_declaration_list.head;

        if (object_check(p_visitor->p_type, p_visitor->p_object))
        {
            /*
            *  All parts of the object needs to be moved, so instead of
            *  describing each part we will just say that the object should
            *  have been moved.
            */
            const struct token* name = object_get_token(p_visitor->p_object);
            if (compiler_diagnostic_message(W_FLOW_MISSING_DTOR,
                ctx->ctx,
                name, NULL,
                "object '%s' was not moved/destroyed",
                previous_names))
            {

                if (p_visitor->p_object->p_declarator_origin)
                    compiler_diagnostic_message(W_LOCATION, ctx->ctx, position_token, NULL, "end of '%s' scope", previous_names);
            }
        }
        else
        {
            /*
            *  Some parts of the object needs to be moved..
            *  we need to print error one by one
            */


            while (p_member_declaration)
            {
                if (p_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator* _Opt p_member_declarator =
                        p_member_declaration->member_declarator_list_opt->head;
                    while (p_member_declarator)
                    {

                        if (p_member_declarator->declarator)
                        {
                            const char* name = p_member_declarator->declarator->name_opt ? p_member_declarator->declarator->name_opt->lexeme : "?";

                            char buffer[200] = { 0 };
                            if (type_is_pointer(p_visitor->p_type))
                                snprintf(buffer, sizeof buffer, "%s->%s", previous_names, name);
                            else
                                snprintf(buffer, sizeof buffer, "%s.%s", previous_names, name);

                            const bool member_is_view = type_is_view(&p_member_declarator->declarator->type);

                            struct object_visitor  visitor = { 0 };
                            visitor.p_type = &p_member_declarator->declarator->type;
                            visitor.p_object = p_visitor->p_object->members.data[p_visitor->member_index];

                            flow_end_of_block_visit_core(ctx,
                                &visitor,
                                b_type_is_view || member_is_view,
                                position_token,
                                buffer,
                                visit_number);
                            p_visitor->member_index++;
                        }
                        p_member_declarator = p_member_declarator->next;
                    }
                }
                else
                {
                    struct type t = { 0 };
                    t.category = TYPE_CATEGORY_ITSELF;
                    t.struct_or_union_specifier = p_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                    t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                    struct type* temp = p_visitor->p_type;
                    p_visitor->p_type = &t;

                    const bool member_is_view = type_is_view(&t);

                    int visit_number0 = p_visitor->p_object->visit_number;
                    p_visitor->p_object->visit_number = 0;
                    flow_end_of_block_visit_core(ctx,
                        p_visitor,
                        member_is_view,
                        position_token,
                        previous_names,
                        visit_number);

                    p_visitor->p_type = temp; //restore
                    p_visitor->p_object->visit_number = visit_number0;
                    type_destroy(&t);

                }
                p_member_declaration = p_member_declaration->next;
            }
        }


    }
    else
    {
        const char* name = previous_names;
        const struct token* _Opt position = NULL;
        if (p_visitor->p_object->p_declarator_origin)
            position = p_visitor->p_object->p_declarator_origin->name_opt ? p_visitor->p_object->p_declarator_origin->name_opt : p_visitor->p_object->p_declarator_origin->first_token_opt;
        else if (p_visitor->p_object->p_expression_origin)
            position = p_visitor->p_object->p_expression_origin->first_token;
        else
        {
            assert(false);
        }

        if (name[0] == '\0')
        {
            /*function arguments without name*/
            name = "?";
        }
        //bool should_had_been_moved = false;


        /*
           Despite the name OBJECT_STATE_NOT_NULL does not means null, it means
           the reference is not referring an object, the value could be -1 for instance.
        */
        if (type_is_pointer(p_visitor->p_type) &&
            !b_type_is_view &&
            type_is_owner(p_visitor->p_type) &&
            p_visitor->p_object->current.state & OBJECT_STATE_NOT_NULL)
        {
            if (compiler_diagnostic_message(W_FLOW_MISSING_DTOR,
                ctx->ctx,
                position, NULL,
                "ownership of '%s' not moved before the end of lifetime", previous_names))
            {
                compiler_diagnostic_message(W_LOCATION,
                ctx->ctx,
                position_token, NULL,
                "end of '%s' lifetime", previous_names);
            }
        }
        else if (!b_type_is_view && type_is_obj_owner(p_visitor->p_type) && type_is_pointer(p_visitor->p_type))
        {
            char buffer[100] = { 0 };
            snprintf(buffer, sizeof buffer, "%s", previous_names);
            struct type t2 = type_remove_pointer(p_visitor->p_type);

            if (p_visitor->p_object->current.pointed)
            {
                struct object_visitor visitor = { 0 };
                visitor.p_type = &t2;
                visitor.p_object = p_visitor->p_object->current.pointed;
                flow_end_of_block_visit_core(ctx, &visitor, b_type_is_view, position, buffer, visit_number);
            }


            type_destroy(&t2);
        }
        else if (type_is_owner(p_visitor->p_type) && !type_is_pointer(p_visitor->p_type))
        {
            //non-pointer _Owner
            if (p_visitor->p_object->current.state == OBJECT_STATE_UNINITIALIZED ||
                p_visitor->p_object->current.state == OBJECT_STATE_NULL ||
                p_visitor->p_object->current.state == OBJECT_STATE_MOVED)
            {
            }
            else
            {
                if (compiler_diagnostic_message(W_FLOW_MISSING_DTOR,
                    ctx->ctx,
                    position, NULL,
                    "ownership of '%s' not moved before the end of lifetime", previous_names))
                {
                    compiler_diagnostic_message(W_LOCATION,
                    ctx->ctx,
                    position_token, NULL,
                    "end of '%s' lifetime", previous_names);
                }
            }
        }
        else if (type_is_pointer(p_visitor->p_type))
        {
            if (p_visitor->p_type->storage_class_specifier_flags & STORAGE_SPECIFIER_PARAMETER)
            {
                //Visiting a pointer parameter. We check if we didn't mess a external object
                //TODO static objects
                struct type t2 = type_remove_pointer(p_visitor->p_type);

                if (p_visitor->p_object->current.pointed)
                {
                    struct token* name_token = p_visitor->p_object->p_declarator_origin->name_opt ?
                        p_visitor->p_object->p_declarator_origin->name_opt :
                        p_visitor->p_object->p_declarator_origin->first_token_opt;

                    checked_read_object(ctx,
                     &t2,
                     false,
                     p_visitor->p_object->current.pointed,
                     name_token,
                     NULL,
                     true);
                }
                type_destroy(&t2);
            }
        }
        else
        {
        }

    }
}

void flow_end_of_block_visit(struct flow_visit_ctx* ctx,
    struct type* p_type,
    bool type_is_view,
    struct flow_object* p_object,
    const struct token* position_token,
    const char* previous_names)
{
    struct object_visitor visitor = { 0 };
    visitor.p_type = p_type;
    visitor.p_object = p_object;
    flow_end_of_block_visit_core(ctx,
    &visitor,
    type_is_view,
    position_token,
    previous_names,
    s_visit_number++);
}

bool flow_object_is_zero_or_null(const struct flow_object* p_object)
{
    return (p_object->current.state == OBJECT_STATE_NULL) ||
        (p_object->current.state == OBJECT_STATE_ZERO);
}

/*
   This function must check and do the flow assignment of
   a = b
*/
static void flow_assignment_core(
    struct flow_visit_ctx* ctx,
    const struct token* error_position,
    const struct marker* p_a_marker,
    const struct marker* p_b_marker,
    enum assigment_type assigment_type,
    bool check_uninitialized_b,
    bool a_type_is_view,
    bool a_type_is_nullable,
    struct object_visitor* p_visitor_a,
    struct object_visitor* p_visitor_b,
    bool* _Opt  set_argument_to_unkown)
{
    if (p_visitor_a->p_object == NULL || p_visitor_b->p_object == NULL)
    {
        return;
    }
    //const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;

#ifdef _DEBUG
    while (error_position->line == 25)
    {
        break;
    }
#endif
    // printf("line  %d\n", error_position->line);
     //type_print(p_a_type);
     //printf(" = ");
     //type_print(p_b_type);
     //printf("\n");

     /*general check for copying uninitialized object*/


    if (check_uninitialized_b &&
        flow_object_can_be_uninitialized(p_visitor_b->p_object))
    {
        //a = b where b can be uninitialized

        if (type_is_array(p_visitor_b->p_type))
        {
            if (assigment_type == ASSIGMENT_TYPE_PARAMETER)
            {
                struct type item_type = { 0 };

                if (type_is_array(p_visitor_a->p_type))
                    item_type = get_array_item_type(p_visitor_a->p_type);
                else
                    item_type = type_remove_pointer(p_visitor_a->p_type);

                const bool cannot_be_uninitialized =
                    (ctx->ctx->options.ownership_enabled && !type_is_out(&item_type)) ||
                    type_is_const(&item_type);

                if (cannot_be_uninitialized)
                {
                    char b_object_name[100] = { 0 };
                    object_get_name(p_visitor_b->p_type, p_visitor_b->p_object, b_object_name, sizeof b_object_name);
                    compiler_diagnostic_message(W_FLOW_UNINITIALIZED,
                                ctx->ctx,
                                NULL,
                                p_b_marker,
                        "uninitialized object '%s' passed to non-optional parameter", b_object_name);
                }

                type_destroy(&item_type);
            }
        }
        else
        {
            char b_object_name[100] = { 0 };
            object_get_name(p_visitor_b->p_type, p_visitor_b->p_object, b_object_name, sizeof b_object_name);

            if (assigment_type == ASSIGMENT_TYPE_PARAMETER)
            {
                compiler_diagnostic_message(W_FLOW_UNINITIALIZED,
                            ctx->ctx,
                            NULL,
                            p_b_marker,
                    "passing an uninitialized argument '%s' object", b_object_name);
            }
            else if (assigment_type == ASSIGMENT_TYPE_RETURN)
            {
                compiler_diagnostic_message(W_FLOW_UNINITIALIZED,
                            ctx->ctx,
                            NULL,
                            p_b_marker,
                            "returning an uninitialized '%s' object", b_object_name);
            }
            else
            {
                compiler_diagnostic_message(W_FLOW_UNINITIALIZED,
                            ctx->ctx,
                            NULL,
                            p_b_marker,
                            "reading an uninitialized '%s' object", b_object_name);
            }
        }

        return;
    }

    if (check_uninitialized_b && flow_object_can_have_its_lifetime_ended(p_visitor_a->p_object))
    {
        //a = b where a was deleted
        char buffer[100] = { 0 };
        object_get_name(p_visitor_a->p_type, p_visitor_a->p_object, buffer, sizeof buffer);

        compiler_diagnostic_message(W_FLOW_LIFETIME_ENDED,
                    ctx->ctx,
                    NULL,
                    p_a_marker,
                    "The object '%s' may have been deleted or its lifetime have ended.", buffer);


        return;
    }

    /*general check passing possible null to non _Opt*/
    if (type_is_pointer(p_visitor_a->p_type) &&
        (!type_is_nullable(p_visitor_a->p_type, ctx->ctx->options.null_checks_enabled)) &&
        flow_object_can_be_null(p_visitor_b->p_object))
    {
        if (!a_type_is_nullable)
        {
            char buffer[100] = { 0 };
            object_get_name(p_visitor_b->p_type, p_visitor_b->p_object, buffer, sizeof buffer);

            if (assigment_type == ASSIGMENT_TYPE_PARAMETER)
            {
                compiler_diagnostic_message(W_FLOW_NULLABLE_TO_NON_NULLABLE,
                       ctx->ctx,
                       NULL,
                       p_b_marker,
                       "passing a possible null pointer '%s' to non-nullable pointer parameter", buffer);
            }
            else if (assigment_type == ASSIGMENT_TYPE_RETURN)
            {
                compiler_diagnostic_message(W_FLOW_NULLABLE_TO_NON_NULLABLE,
                       ctx->ctx,
                       NULL,
                       p_b_marker,
                       "returning a possible null pointer '%s' to non-nullable pointer", buffer);
            }
            else
            {
                compiler_diagnostic_message(W_FLOW_NULLABLE_TO_NON_NULLABLE,
                       ctx->ctx,
                       NULL,
                       p_b_marker,
                       "assignment of possible null pointer '%s' to non-nullable pointer", buffer);
            }
        }
    }

    if (type_is_pointer(p_visitor_a->p_type))
    {
        if (!a_type_is_view && type_is_owner(p_visitor_a->p_type))
        {
            checked_empty(ctx, p_visitor_a->p_type, p_visitor_a->p_object, p_a_marker);
        }

        if (flow_object_is_zero_or_null(p_visitor_b->p_object))
        {
            if (type_is_array(p_visitor_b->p_type))
            {
                p_visitor_a->p_object->current.state = OBJECT_STATE_NOT_NULL;
                return;
            }
            else if (type_is_nullptr_t(p_visitor_b->p_type) || type_is_integer(p_visitor_b->p_type))
            {
                flow_object_set_current_state_to_is_null(p_visitor_a->p_object);

                return;
            }
        }
    }

    if (!a_type_is_view && type_is_obj_owner(p_visitor_a->p_type) && type_is_pointer(p_visitor_a->p_type))
    {
        checked_empty(ctx, p_visitor_a->p_type, p_visitor_a->p_object, p_a_marker);

        if (flow_object_is_zero_or_null(p_visitor_b->p_object))
        {
            //0 to objec_owner??
            //a = nullpr
            //object_set_zero(p_a_type, p_a_object);
            return;
        }
    }

    /*copying to void * _Owner*/
    if (type_is_void_ptr(p_visitor_a->p_type) && type_is_pointer(p_visitor_b->p_type))
    {
        p_visitor_a->p_object->current.state = p_visitor_b->p_object->current.state;

        if (!a_type_is_view && type_is_owner(p_visitor_a->p_type))
        {
            //*b must be empty before copying to void* _Owner
            struct type t = type_remove_pointer(p_visitor_b->p_type);


            if (p_visitor_b->p_object->current.pointed == NULL)
            {
                // The question is..if we had this object expanded
                // could it possible have resources?
                //-> {...}
                if (object_is_expansible(p_visitor_b->p_object) &&
                    type_is_owner(&t))
                {
                    //if the anwser is yes then we need a warning
                    compiler_diagnostic_message(W_FLOW_MISSING_DTOR,
                                                ctx->ctx,
                                                NULL,
                                                p_a_marker,
                                                "pointed object may be not empty");
                }
            }
            else
            {
                checked_empty(ctx, &t, p_visitor_b->p_object->current.pointed, p_b_marker);
                object_set_deleted(&t, p_visitor_b->p_object->current.pointed);
            }

            type_destroy(&t);

            if (assigment_type == ASSIGMENT_TYPE_PARAMETER)
            {
                flow_object_set_is_unitialized(p_visitor_b->p_object);
                p_visitor_b->p_object->current.state = OBJECT_STATE_UNINITIALIZED;
            }
            else
            {
                flow_object_set_is_moved(p_visitor_b->p_object);
            }
        }
        return;
    }


    if (type_is_pointer(p_visitor_a->p_type) && type_is_pointer(p_visitor_b->p_type))
    {
        p_visitor_a->p_object->current.state = p_visitor_b->p_object->current.state;
        p_visitor_a->p_object->current.pointed = p_visitor_b->p_object->current.pointed;

        struct type t = type_remove_pointer(p_visitor_a->p_type);

        /*if the parameter points to _Out object, then we don´t need to check
          argument pointed object.
        */
        const bool checked_pointed_object_read =
            ctx->ctx->options.ownership_enabled && !type_is_out(&t);

        bool is_nullable = a_type_is_nullable || type_is_nullable(&t, ctx->ctx->options.null_checks_enabled);

        checked_read_object(ctx,
            p_visitor_b->p_type,
            is_nullable,
            p_visitor_b->p_object,
            error_position,
            p_b_marker,
            checked_pointed_object_read);


        //object_copy_state(p_a_type, p_a_object, p_b_type, p_b_object);
        type_destroy(&t);

        if (!a_type_is_view && type_is_owner(p_visitor_a->p_type))
        {
            /*
               T * _Owner pA = pB;
            */

            if (flow_object_can_be_moved(p_visitor_b->p_object))
            {
                //TODO we need 2 positions, source, dest
                compiler_diagnostic_message(W_FLOW_MOVED,
                   ctx->ctx,
                   error_position, NULL,
                   "source object has already been moved");
            }


            if (assigment_type == ASSIGMENT_TYPE_PARAMETER)
            {
                p_visitor_b->p_object->current.state = OBJECT_STATE_UNINITIALIZED;
                if (p_visitor_b->p_object->current.pointed)
                {
                    struct flow_object* pointed = p_visitor_b->p_object->current.pointed;

                    struct type t2 = type_remove_pointer(p_visitor_b->p_type);
                    object_set_deleted(&t2, pointed);
                    type_destroy(&t2);
                }
            }
            else
            {

                //TODO
                p_visitor_a->p_object->current.state = p_visitor_a->p_object->current.state & ~OBJECT_STATE_MOVED;
                if (p_visitor_b->p_object->current.state & OBJECT_STATE_NOT_NULL)
                {
                    //null not-null -> null moved
                    p_visitor_b->p_object->current.state &= ~OBJECT_STATE_NOT_NULL;
                    p_visitor_b->p_object->current.state |= OBJECT_STATE_MOVED;
                }
            }
        }
        else if (!a_type_is_view && type_is_obj_owner(p_visitor_a->p_type))
        {
            if (type_is_any_owner(p_visitor_b->p_type))
            {
                if (assigment_type == ASSIGMENT_TYPE_PARAMETER)
                {
                    if (p_visitor_b->p_object->current.pointed)
                    {
                        struct flow_object* pointed = p_visitor_b->p_object->current.pointed;

                        struct type t2 = type_remove_pointer(p_visitor_b->p_type);
                        object_set_uninitialized(&t2, pointed);
                        type_destroy(&t2);
                    }

                }
                else
                    object_set_moved(p_visitor_b->p_type, p_visitor_b->p_object);
            }
            else
            {
                if (p_visitor_b->p_type->address_of)
                {
                    //must be address of.
                    if (assigment_type == ASSIGMENT_TYPE_PARAMETER)
                    {
                        p_visitor_b->p_object->current.state = OBJECT_STATE_UNINITIALIZED;

                        if (p_visitor_b->p_object->current.pointed)
                        {
                            struct flow_object* pointed = p_visitor_b->p_object->current.pointed;

                            struct type t2 = type_remove_pointer(p_visitor_b->p_type);
                            object_set_uninitialized(&t2, pointed);
                            type_destroy(&t2);
                        }
                    }
                    else
                        object_set_moved(p_visitor_b->p_type, p_visitor_b->p_object);
                }
                else
                {
                    //avoid error on top of error
                    //address error already emitted
                    //at this point
                }
            }

        }
        else
        {
            if (a_type_is_view || !type_is_owner(p_visitor_a->p_type))
            {
                p_visitor_a->p_object->current.state = p_visitor_b->p_object->current.state;
            }


            if (assigment_type == ASSIGMENT_TYPE_PARAMETER)
            {
                struct type t3 = type_remove_pointer(p_visitor_a->p_type);
                if (!type_is_const(&t3))
                {
                    if (p_visitor_b->p_object->current.pointed)
                    {
                        if (set_argument_to_unkown)
                        {
                            //Tells the caller it must make argument unknown
                            *set_argument_to_unkown = true;
                        }
                        //   object_set_unknown(&t3, t3_is_nullable, pointed, nullable_enabled);
                    }
                }
                type_destroy(&t3);
            }
        }

        return;
    }

    if (p_visitor_a->p_type->struct_or_union_specifier && p_visitor_a->p_object->members.size > 0)
    {
        struct struct_or_union_specifier* _Opt p_a_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_visitor_a->p_type->struct_or_union_specifier);

        struct struct_or_union_specifier* _Opt p_b_struct_or_union_specifier =
            get_complete_struct_or_union_specifier(p_visitor_b->p_type->struct_or_union_specifier);

        if (p_a_struct_or_union_specifier && p_b_struct_or_union_specifier)
        {
            struct member_declaration* _Opt p_a_member_declaration =
                p_a_struct_or_union_specifier->member_declaration_list.head;

            struct member_declaration* _Opt p_b_member_declaration =
                p_b_struct_or_union_specifier->member_declaration_list.head;


            while (p_a_member_declaration && p_b_member_declaration)
            {
                if (p_a_member_declaration->member_declarator_list_opt)
                {
                    struct member_declarator* _Opt p_a_member_declarator =
                        p_a_member_declaration->member_declarator_list_opt->head;

                    struct member_declarator* _Opt p_b_member_declarator =
                        p_b_member_declaration->member_declarator_list_opt->head;

                    while (p_a_member_declarator && p_b_member_declarator)
                    {
                        if (p_a_member_declarator->declarator &&
                            p_b_member_declarator->declarator)
                        {
                            if (p_visitor_a->member_index < p_visitor_a->p_object->members.size &&
                                p_visitor_b->member_index < p_visitor_b->p_object->members.size)
                            {
                                struct object_visitor visitor_a = { 0 };
                                visitor_a.p_type = &p_a_member_declarator->declarator->type;
                                visitor_a.p_object = p_visitor_a->p_object->members.data[p_visitor_a->member_index];


                                struct object_visitor visitor_b = { 0 };
                                visitor_b.p_type = &p_b_member_declarator->declarator->type;
                                visitor_b.p_object = p_visitor_b->p_object->members.data[p_visitor_b->member_index];


                                flow_assignment_core(ctx,
                                    error_position,
                                    p_a_marker,
                                    p_b_marker,
                                    assigment_type,
                                    check_uninitialized_b,
                                    a_type_is_view,
                                    a_type_is_nullable,
                                    &visitor_a,
                                    &visitor_b,
                                    set_argument_to_unkown);
                            }
                            else
                            {
                                //TODO BUG union?                                
                            }
                            p_visitor_a->member_index++;
                            p_visitor_b->member_index++;

                        }
                        p_a_member_declarator = p_a_member_declarator->next;
                        p_b_member_declarator = p_b_member_declarator->next;
                    }
                }
                else
                {
                    if (p_a_member_declaration->specifier_qualifier_list &&
                       p_a_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
                    {
                        struct type t = { 0 };
                        t.category = TYPE_CATEGORY_ITSELF;
                        t.struct_or_union_specifier = p_a_member_declaration->specifier_qualifier_list->struct_or_union_specifier;
                        t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                        struct type* temp1 = p_visitor_a->p_type;
                        struct type* temp2 = p_visitor_b->p_type;
                        p_visitor_a->p_type = &t;
                        p_visitor_b->p_type = &t;

                        flow_assignment_core(
                                            ctx,
                                            error_position,
                                            p_a_marker,
                                            p_b_marker,
                                            assigment_type,
                                            check_uninitialized_b,
                                            a_type_is_view,
                                            a_type_is_nullable,
                                            p_visitor_a,
                                            p_visitor_b,
                                            set_argument_to_unkown);

                        //restore
                        p_visitor_a->p_type = temp1;
                        p_visitor_b->p_type = temp2;

                        type_destroy(&t);
                    }
                }
                p_a_member_declaration = p_a_member_declaration->next;
                p_b_member_declaration = p_b_member_declaration->next;
            }
            return;
        }
    }

    p_visitor_a->p_object->current.state = p_visitor_b->p_object->current.state;
    if (!a_type_is_view && type_is_owner(p_visitor_a->p_type))
    {
        if (assigment_type == ASSIGMENT_TYPE_PARAMETER)
            object_set_uninitialized(p_visitor_b->p_type, p_visitor_b->p_object);
        else
            object_set_moved(p_visitor_b->p_type, p_visitor_b->p_object);
    }
}


struct flow_object* _Opt  expression_get_object(struct flow_visit_ctx* ctx, struct expression* p_expression, bool nullable_enabled)
{
    if (p_expression == NULL)
        return NULL;
    if (p_expression->expression_type == PRIMARY_EXPRESSION_DECLARATOR)
    {
        if (p_expression->declarator->declaration_specifiers &&
            p_expression->declarator->declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_EXTERN)
        {
            //External objects are added to the arena on-demand
            if (objects_find(&ctx->arena, p_expression->declarator->p_object) == NULL)
            {
                p_expression->declarator->p_object = make_object(ctx, &p_expression->declarator->type, p_expression->declarator, NULL);

                object_set_unknown(&p_expression->declarator->type,
                                   type_is_nullable(&p_expression->declarator->type, ctx->ctx->options.null_checks_enabled),
                                   p_expression->declarator->p_object,
                                   ctx->ctx->options.null_checks_enabled);
            }
        }
        return p_expression->declarator->p_object;
    }

    else if (p_expression->expression_type == UNARY_EXPRESSION_ADDRESSOF)
    {
        struct flow_object* _Opt p_object = make_object(ctx, &p_expression->type, NULL, p_expression);
        object_set_pointer(p_object, expression_get_object(ctx, p_expression->right, nullable_enabled));
        p_object->current.state = OBJECT_STATE_NOT_NULL;
        p_object->is_temporary = true;
        return p_object;
    }
    else if (p_expression->expression_type == PRIMARY_EXPRESSION_PARENTESIS)
    {
        return expression_get_object(ctx, p_expression->right, nullable_enabled);
    }
    else if (p_expression->expression_type == CAST_EXPRESSION)
    {

        struct flow_object* _Opt p = expression_get_object(ctx, p_expression->left, nullable_enabled);
        if (p)
        {
            if (type_is_pointer(&p_expression->type_name->type))
            {
                //casting from 0 to pointer we need to change the zero to null
                //#define NULL ((void*)0)
                if (p->current.state & OBJECT_STATE_ZERO)
                {
                    p->current.state &= ~OBJECT_STATE_ZERO;
                    p->current.state |= OBJECT_STATE_NULL;
                }
                if (p->current.state & OBJECT_STATE_NOT_ZERO)
                {
                    p->current.state &= ~OBJECT_STATE_NOT_ZERO;
                    p->current.state |= OBJECT_STATE_NOT_NULL;
                }
            }
        }
        return p;
    }
    else if (p_expression->expression_type == POSTFIX_DOT)
    {
        struct flow_object* p_obj = expression_get_object(ctx, p_expression->left, nullable_enabled);
        if (p_obj)
        {
            if (p_expression->member_index < p_obj->members.size)
                return p_obj->members.data[p_expression->member_index];
            else
            {
                // assert(false);
                return NULL;
            }
        }
    }
    else if (p_expression->expression_type == POSTFIX_ARRAY)
    {
        //All arrays items point to the same object.
        struct flow_object* _Opt p_obj = expression_get_object(ctx, p_expression->left, nullable_enabled);
        if (p_obj)
        {

            if (p_obj->current.pointed == NULL)
            {
                expand_pointer_object(ctx, &p_expression->left->type, p_obj);
            }

            if (p_obj->current.pointed)
            {
                struct flow_object* pointed = p_obj->current.pointed;
                return pointed;
            }
#if 0
            if (p_obj->current.ref.size == 1)
            {
                struct flow_object* pointed = p_obj->current.ref.data[0];
                return pointed;
            }
            else
            {
                struct flow_object* p_object = make_object(ctx, &p_expression->type, NULL, p_expression);
                object_set_nothing(&p_expression->type, p_object);
                for (int i = 0; i < p_obj->current.ref.size; i++)
                {
                    struct flow_object* pointed = p_obj->current.ref.data[i];
                    if (pointed != NULL)
                    {
                        if (p_expression->member_index < pointed->members.size)
                        {
                            p_object->current.state |=
                                pointed->members.data[p_expression->member_index]->current.state;
                            objects_view_merge(&p_object->current.ref, &pointed->members.data[p_expression->member_index]->current.ref);
                            //return pointed->members.data[p_expression->member_index];
                        }
                        else
                        {
                            //return NULL;
                        }
                    }
                }
                return p_object;
            }
#endif
        }
        return NULL;
    }
    else if (p_expression->expression_type == POSTFIX_ARROW)
    {
        struct flow_object* _Opt p_obj = expression_get_object(ctx, p_expression->left, nullable_enabled);
        if (p_obj)
        {
            if (p_obj->current.pointed == 0)
            {
                expand_pointer_object(ctx, &p_expression->left->type, p_obj);
            }

            struct flow_object* pointed = p_obj->current.pointed;

            if (pointed == NULL ||
                p_expression->member_index >= pointed->members.size)
            {
                //ops!
                return NULL;
            }

            struct flow_object* _Opt p_obj2 = pointed->members.data[p_expression->member_index];

            p_obj2->p_declarator_origin = NULL;
            p_obj2->p_expression_origin = p_expression;
            return p_obj2;
        }
        return NULL;
    }
    else if (p_expression->expression_type == UNARY_EXPRESSION_CONTENT)
    {
        struct flow_object* _Opt p_obj = expression_get_object(ctx, p_expression->right, nullable_enabled);
        if (p_obj)
        {
            if (p_obj->current.pointed == NULL)
            {
                expand_pointer_object(ctx, &p_expression->right->type, p_obj);
            }

            if (p_obj->current.pointed != NULL)
            {
                return p_obj->current.pointed;
            }
        }
        return p_obj;
    }
    else if (p_expression->expression_type == POSTFIX_FUNCTION_CALL)
    {
        struct flow_object* p_object = make_object(ctx, &p_expression->type, NULL, p_expression);

        const bool is_nullable = type_is_nullable(&p_expression->type, nullable_enabled);
        object_set_unknown(&p_expression->type, is_nullable, p_object, nullable_enabled);
        p_object->is_temporary = true;

        if (type_is_pointer(&p_expression->type) && object_is_expansible(p_object))
        {
            expand_pointer_object(ctx, &p_expression->type, p_object);
        }


        return p_object;
    }
    else if (p_expression->expression_type == POSTFIX_EXPRESSION_COMPOUND_LITERAL)
    {
        return p_expression->type_name->abstract_declarator->p_object;
    }
    else if (p_expression->expression_type == PRIMARY_EXPRESSION_STRING_LITERAL)
    {
        struct flow_object* _Opt p_object = make_object(ctx, &p_expression->type, NULL, p_expression);
        p_object->current.state = OBJECT_STATE_NOT_NULL;
        return p_object;
    }
    else if (p_expression->expression_type == PRIMARY_EXPRESSION_PREDEFINED_CONSTANT)
    {
        struct flow_object* _Opt p_object = make_object(ctx, &p_expression->type, NULL, p_expression);
        if (p_expression->type.type_specifier_flags == TYPE_SPECIFIER_NULLPTR_T)
        {
            p_object->current.state = OBJECT_STATE_NULL;
        }
        else
        {
            if (constant_value_is_valid(&p_expression->constant_value))
            {
                bool not_zero = constant_value_to_bool(&p_expression->constant_value);
                p_object->current.state = not_zero ? OBJECT_STATE_NOT_ZERO : OBJECT_STATE_ZERO;
            }
        }

        return p_object;
    }
    else if (p_expression->expression_type == ASSIGNMENT_EXPRESSION)
    {
        struct flow_object* p_obj = expression_get_object(ctx, p_expression->left, nullable_enabled);

        //
        //
        return p_obj;
    }
    else if (p_expression->expression_type == CONDITIONAL_EXPRESSION)
    {
        struct flow_object* _Opt p_object = make_object(ctx, &p_expression->type, NULL, p_expression);


        struct flow_object* _Opt p_obj1 = expression_get_object(ctx, p_expression->left, nullable_enabled);


        struct flow_object* _Opt p_obj2 = expression_get_object(ctx, p_expression->right, nullable_enabled);


        object_merge_state(p_object, p_obj1, p_obj2);



        //object_destroy(&obj1);
        //object_destroy(&obj2);

        return p_object;
    }
    else if (p_expression->expression_type == EQUALITY_EXPRESSION_EQUAL ||
             p_expression->expression_type == EQUALITY_EXPRESSION_NOT_EQUAL)
    {

        struct flow_object* _Opt p_object = make_object(ctx, &p_expression->type, NULL, p_expression);
        if (constant_value_is_valid(&p_expression->constant_value))
        {
            bool not_zero = constant_value_to_bool(&p_expression->constant_value);
            p_object->current.state = not_zero ? OBJECT_STATE_NOT_ZERO : OBJECT_STATE_ZERO;
        }
        else
        {
            p_object->current.state = OBJECT_STATE_NOT_ZERO | OBJECT_STATE_ZERO;
        }
        return p_object;
    }
    else if (p_expression->expression_type == ADDITIVE_EXPRESSION_PLUS)
    {
        struct flow_object* _Opt p_object = make_object(ctx, &p_expression->type, NULL, p_expression);
        if (type_is_pointer(&p_expression->type))
        {
            //p + 1
            //never null
            p_object->current.state = OBJECT_STATE_NOT_NULL;
        }
        else
        {
            if (constant_value_is_valid(&p_expression->constant_value))
            {
                bool not_zero = constant_value_to_bool(&p_expression->constant_value);
                p_object->current.state = not_zero ? OBJECT_STATE_NOT_NULL : OBJECT_STATE_NULL;
            }
            else
            {
                p_object->current.state = OBJECT_STATE_NOT_NULL | OBJECT_STATE_NULL;
            }
        }
        return p_object;
    }
    else if (p_expression->expression_type == UNARY_EXPRESSION_NEG ||
             p_expression->expression_type == UNARY_EXPRESSION_PLUS)
    {
        struct flow_object* _Opt p_obj_right = expression_get_object(ctx, p_expression->right, nullable_enabled);
        struct flow_object* _Opt p_object = make_object(ctx, &p_expression->type, NULL, p_expression);
        if (p_object && p_obj_right)
        {
            p_object->current.state = p_obj_right->current.state;
        }

        return p_object;
    }
    //
    else
    {

        struct flow_object* _Opt p_object = make_object(ctx, &p_expression->type, NULL, p_expression);

        if (type_is_pointer(&p_expression->type))
        {
            if (constant_value_is_valid(&p_expression->constant_value))
            {
                bool not_zero = constant_value_to_bool(&p_expression->constant_value);
                p_object->current.state = not_zero ? OBJECT_STATE_NOT_NULL : OBJECT_STATE_NULL;
            }
            else
            {
                p_object->current.state = OBJECT_STATE_NOT_NULL | OBJECT_STATE_NULL;
            }
        }
        else
        {
            if (constant_value_is_valid(&p_expression->constant_value))
            {
                bool not_zero = constant_value_to_bool(&p_expression->constant_value);
                p_object->current.state = not_zero ? OBJECT_STATE_NOT_ZERO : OBJECT_STATE_ZERO;
            }
            else
            {
                p_object->current.state = OBJECT_STATE_NOT_ZERO | OBJECT_STATE_ZERO;
            }
        }


        return p_object;
    }

    //printf("null object");
    //assert(false);
    return NULL;
}

void flow_check_assignment(
    struct flow_visit_ctx* ctx,
    const struct token* error_position,
    const struct marker* p_a_marker,
    const struct marker* p_b_marker,
    enum assigment_type assigment_type,
    bool check_uninitialized_b,
    bool a_type_is_view,
    bool a_type_is_nullable,
    struct type* p_a_type, struct flow_object* p_a_object,
    struct type* p_b_type, struct flow_object* p_b_object,
    bool* _Opt set_argument_to_unkown)
{
    if (type_is_pointer(p_b_type) && object_is_expansible(p_b_object))
    {
        //number of warning goes up!
        //expand_pointer_object(ctx, p_b_type, p_b_object);
    }

    struct object_visitor visitor_a = {
    .p_object = p_a_object,
    .p_type = p_a_type
    };

    struct object_visitor visitor_b = {
     .p_object = p_b_object,
     .p_type = p_b_type
    };


    flow_assignment_core(
     ctx,
    error_position,
    p_a_marker,
    p_b_marker,
    assigment_type,
    check_uninitialized_b,
    a_type_is_view,
    a_type_is_nullable,
    &visitor_a,
    &visitor_b,
    set_argument_to_unkown);
}


void print_object_state_to_str(enum object_state e, char str[], int sz)
{
    bool first = true;
    struct osstream ss = { 0 };

    if (e == OBJECT_STATE_NOT_APPLICABLE)
        ss_fprintf(&ss, "--");

    if (e & OBJECT_STATE_UNINITIALIZED)
    {
        if (first)
            first = false;
        else
            ss_fprintf(&ss, ",");
        ss_fprintf(&ss, "unset");
    }

    if (e & OBJECT_STATE_NOT_NULL)
    {
        if (first)
            first = false;
        else
            ss_fprintf(&ss, ",");
        ss_fprintf(&ss, "not-null");
    }

    if (e & OBJECT_STATE_NULL)
    {
        if (first)
            first = false;
        else
            ss_fprintf(&ss, ",");
        ss_fprintf(&ss, "null");
    }

    if (e & OBJECT_STATE_ZERO)
    {
        if (first)
            first = false;
        else
            ss_fprintf(&ss, ",");
        ss_fprintf(&ss, "zero");
    }

    if (e & OBJECT_STATE_NOT_ZERO)
    {
        if (first)
            first = false;
        else
            ss_fprintf(&ss, ",");
        ss_fprintf(&ss, "not-zero");
    }


    if (e & OBJECT_STATE_LIFE_TIME_ENDED)
    {
        if (first)
            first = false;
        else
            ss_fprintf(&ss, ",");
        ss_fprintf(&ss, "lifetime-ended");
    }

    if (e & OBJECT_STATE_MOVED)
    {
        if (first)
            first = false;
        else
            ss_fprintf(&ss, ",");
        ss_fprintf(&ss, "moved");
    }
    snprintf(str, sz, "%s", ss.c_str);
    ss_close(&ss);
}

void flow_object_state_print(struct flow_object_state* p_state)
{
    struct osstream ss = { 0 };

    char temp[200] = { 0 };
    print_object_state_to_str(p_state->state, temp, sizeof temp);
    ss_fprintf(&ss, "%d %s", p_state->state_number, temp);


    if (p_state->pointed)
    {
        ss_fprintf(&ss, " ->%d", p_state->pointed->id);
    }

    if (p_state->alternatives.size > 0)
        ss_fprintf(&ss, " ");
    for (int i = 0; i < p_state->alternatives.size; i++)
    {
        if (i != 0)
            ss_fprintf(&ss, ",");

        ss_fprintf(&ss, "%d", p_state->alternatives.data[i]->id);
    }
    printf("%-25s│", ss.c_str);
    ss_close(&ss);
}

void print_object_line(struct flow_object* p_object, int extra_cols)
{
    struct osstream ss = { 0 };

    if (p_object->parent)
    {
        ss_fprintf(&ss, "↑%d", p_object->parent->id);

        //if (p_object->current.alternatives.size > 0)
         //ss_fprintf(&ss, " &");

        printf("│%-2d│", p_object->id);
        printf("%-20s│", ss.c_str); //here we need compesate the unicode byte len of ↑
    }
    else
    {
        int line = 0, col = 0;
        if (p_object->p_declarator_origin)
        {
            if (p_object->p_declarator_origin->name_opt)
            {
                line = p_object->p_declarator_origin->name_opt->line;
                col = p_object->p_declarator_origin->name_opt->col;
                ss_fprintf(&ss, "%2d:%2d ", line, col);
                ss_fprintf(&ss, "%s", p_object->p_declarator_origin->name_opt->lexeme);
            }
            else
            {
                ss_fprintf(&ss, "%2d:%2d ", line, col);
                ss_fprintf(&ss, "%s", "?");
            }
        }
        else if (p_object->p_expression_origin)
        {
            line = p_object->p_expression_origin->first_token->line;
            col = p_object->p_expression_origin->first_token->col;
            ss_fprintf(&ss, "%2d:%2d ", line, col);

            ss_fprintf(&ss, "%s", p_object->p_expression_origin->first_token->lexeme);
        }
        else
        {
            ss_fprintf(&ss, "&");
        }
        printf("│%-2d│", p_object->id);
        printf("%-18s│", ss.c_str);
    }

    ss_close(&ss);





    int cols = 0;
    struct flow_object_state* _Opt p_state = &p_object->current;
    while (p_state)
    {
        cols++;
        flow_object_state_print(p_state);
        p_state = p_state->next;
    }

    for (int i = 0; i <= extra_cols - cols; i++)
    {
        printf("%-25s│", " ");
    }
    printf("\n");

}


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

#pragma safety enable




/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

//#pragma once

struct format_visit_ctx
{
    _View struct ast ast;
    int indentation;
};

void format_visit(struct format_visit_ctx* ctx);

#ifdef _WIN32
#endif


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

//#pragma once

#define CAKE_VERSION "0.9.25"



#if defined _MSC_VER && !defined __POCC__
#endif



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

//#pragma once

struct defer_scope
{
    struct defer_statement* _Opt defer_statement; // defer 
    struct try_statement* _Opt p_try_statement; //try
    struct selection_statement* _Opt p_selection_statement; //if swith
    struct iteration_statement* _Opt p_iteration_statement; //for do while
    struct statement* _Opt p_statement; //
    struct compound_statement* _Opt p_function_body;
    
    struct defer_scope* _Owner _Opt lastchild;
    struct defer_scope* _Owner _Opt previous;
};
void defer_scope_delete(struct defer_scope * _Owner _Opt p);
struct visit_ctx
{
    /*
    * It is necessary two passes to generate lambdas expressions
    * because some types maybe needs to be "globalized"
    * is_second_pass is true if the compiler is at second pass
    */
    bool is_second_pass;
   
    bool has_lambda;

    bool is_inside_lambda;
    bool hide_non_used_declarations;

    /*these indexes are used to generate unique names at file scope*/
    int capture_index;    
    int lambdas_index;
    
    struct token_list insert_before_declaration;
    struct token_list insert_before_block_item;
    _View struct ast ast;
    enum language_version target;
    struct defer_scope* _Owner _Opt tail_block;
};

void visit(struct visit_ctx* ctx);
void visit_ctx_destroy( struct visit_ctx* _Obj_owner ctx);


#ifdef PATH_MAX
#define MYMAX_PATH PATH_MAX // Linux uses it in realpath
#else
#define MYMAX_PATH MAX_PATH
#endif


struct defer_statement* _Owner _Opt defer_statement(struct parser_ctx* ctx);

void defer_statement_delete(struct defer_statement* _Owner _Opt p)
{
    if (p)
    {
        secondary_block_delete(p->secondary_block);
        free(p);
    }
}

static int s_anonymous_struct_count = 0;

///////////////////////////////////////////////////////////////////////////////
void naming_convention_struct_tag(struct parser_ctx* ctx, struct token* token);
void naming_convention_enum_tag(struct parser_ctx* ctx, struct token* token);
void naming_convention_function(struct parser_ctx* ctx, struct token* token);
void naming_convention_enumerator(struct parser_ctx* ctx, struct token* token);
void naming_convention_struct_member(struct parser_ctx* ctx, struct token* token, struct type* type);
void naming_convention_parameter(struct parser_ctx* ctx, struct token* token, struct type* type);
void naming_convention_global_var(struct parser_ctx* ctx, struct token* token, struct type* type, enum storage_class_specifier_flags storage);
void naming_convention_local_var(struct parser_ctx* ctx, struct token* token, struct type* type);

///////////////////////////////////////////////////////////////////////////////

static bool parser_is_diagnostic_enabled(const struct parser_ctx* ctx, enum diagnostic_id w)
{
    if (w > W_NOTE)
        return true;

    return ((ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors & w) != 0) ||
        ((ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings & w) != 0) ||
        ((ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes & w) != 0);
}

static void check_open_brace_style(struct parser_ctx* ctx, struct token* token)
{
    // token points to {

    if (token->level == 0 &&
        !(token->flags & TK_FLAG_MACRO_EXPANDED) &&
        token->type == '{' &&
        token->prev &&
        parser_is_diagnostic_enabled(ctx, W_STYLE))
    {
        if (ctx->options.style == STYLE_CAKE)
        {
            if (token->prev->type == TK_BLANKS &&
                token->prev->prev &&
                token->prev->prev->type == TK_NEWLINE)
            {
            }
            else
            {
                compiler_diagnostic_message(W_STYLE, ctx, token, NULL, "not following correct brace style {");
            }
        }
    }
}

static void check_close_brace_style(struct parser_ctx* ctx, struct token* token)
{
    // token points to {

    if (token->level == 0 &&
        !(token->flags & TK_FLAG_MACRO_EXPANDED) &&
        token->type == '}' &&
        token->prev &&
        token->prev->prev &&
        parser_is_diagnostic_enabled(ctx, W_STYLE))
    {
        if (ctx->options.style == STYLE_CAKE)
        {
            if (token->prev->type == TK_BLANKS &&
                token->prev->prev->type == TK_NEWLINE)
            {
            }
            else
            {
                compiler_diagnostic_message(W_STYLE, ctx, token, NULL, "not following correct close brace style }");
            }
        }
    }
}

static void check_func_open_brace_style(struct parser_ctx* ctx, struct token* token)
{
    // token points to {

    if (token->level == 0 &&
        !(token->flags & TK_FLAG_MACRO_EXPANDED) &&
        token->type == '{' &&
        token->prev &&
        parser_is_diagnostic_enabled(ctx, W_STYLE))
    {
        if (ctx->options.style == STYLE_CAKE)
        {
            if (token->prev->type == TK_NEWLINE)
            {
            }
            else
            {
                compiler_diagnostic_message(W_STYLE, ctx, token, NULL, "not following correct brace style {");
            }
        }
    }
}
/*
static void check_func_close_brace_style(struct parser_ctx* ctx, struct token* token)
{
    //token points to {

    if (token->level == 0 &&
        !(token->flags & TK_FLAG_MACRO_EXPANDED) &&
        token->type == '}' &&
        parser_is_warning_enabled(ctx, W_STYLE))
    {
        if (ctx->options.style == STYLE_CAKE)
        {
            if (token->prev->prev->type == TK_NEWLINE)
            {
            }
            else
            {
                compiler_diagnostic_message(W_STYLE, ctx, token, "not following correct close brace style }");
            }
        }
    }
}
*/


void scope_destroy(struct scope* _Obj_owner p)
{
    hashmap_destroy(&p->tags);
    hashmap_destroy(&p->variables);
}

void scope_list_push(struct scope_list* list, struct scope* pnew)
{
    if (list->tail)
        pnew->scope_level = list->tail->scope_level + 1;

    if (list->head == NULL)
    {
        list->head = pnew;
        list->tail = pnew;
        // pnew->prev = list->tail;
    }
    else
    {
        assert(list->tail != NULL);
        pnew->previous = list->tail;
        list->tail->next = pnew;
        list->tail = pnew;
    }
}

void scope_list_pop(struct scope_list* list)
{

    if (list->head == NULL)
        return;
    assert(list->tail != NULL);
    struct scope* p = list->tail;
    if (list->head == list->tail)
    {
        list->head = NULL;
        list->tail = NULL;
    }
    else
    {
        list->tail = list->tail->previous;
        if (list->tail == list->head)
        {
            assert(list->tail != NULL);
            list->tail->next = NULL;
            list->tail->previous = NULL;
        }
    }
    p->next = NULL;
    p->previous = NULL;
}

void switch_value_destroy(struct switch_value_list* _Obj_owner p)
{
    struct switch_value* _Owner _Opt item = p->head;
    while (item)
    {
        struct switch_value* _Owner _Opt next = item->next;
        item->next = NULL;
        free(item);
        item = next;
    }

    if (p->p_default)
    {
        assert(p->p_default->next == NULL);
        free(p->p_default);
    }
}

void switch_value_list_push(struct switch_value_list* list, struct switch_value* _Owner pnew)
{
    if (list->head == NULL)
    {
        list->head = pnew;
        list->tail = pnew;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = pnew;
        list->tail = pnew;
    }
}

struct switch_value* _Opt switch_value_list_find(struct switch_value_list* list, long long value)
{
    struct switch_value* _Opt p = list->head;
    while (p)
    {
        if (p->value == value)
        {
            return p;
        }
        p = p->next;
    }
    return NULL;
}

void parser_ctx_destroy(struct parser_ctx* _Obj_owner ctx)
{
    if (ctx->sarif_file)
    {
        fclose(ctx->sarif_file);
    }
}

static void stringfy(const char* input, char* json_str_message, int output_size)
{
    json_str_message[0] = '\0'; //out

    int k = 0;
    while (*input != '\0')
    {
        if (*input == '\"')
        {
            if (k < output_size)
                json_str_message[k] = '\\';
            k++;
            if (k < output_size)
                json_str_message[k] = '"';
            k++;
            input++;
        }
        else if (*input == '\n')
        {
            if (k < output_size)
                json_str_message[k] = '\\';
            k++;
            if (k < output_size)
                json_str_message[k] = 'n';
            k++;
            input++;
        }
        else
        {
            if (k < output_size)
                json_str_message[k] = *input;
            k++;
            input++;
        }
    }
    if (k < output_size)
        json_str_message[k] = '\0';
    else
        json_str_message[output_size - 1] = '\0';
}

_Bool compiler_diagnostic_message(enum diagnostic_id w,
    const struct parser_ctx* ctx,
    const struct token* _Opt p_token_opt,
    const struct marker* _Opt p_marker_temp,
    const char* fmt, ...)
{
    bool included_file_location = false;
    struct marker marker = { 0 };
    if (p_marker_temp == NULL)
    {
        if (p_token_opt == NULL) return false;

        marker.file = p_token_opt->token_origin->lexeme;
        marker.line = p_token_opt->line;
        marker.start_col = p_token_opt->col;
        marker.end_col = p_token_opt->col;
        marker.p_token_caret = p_token_opt;
        included_file_location = p_token_opt->level > 0;
    }
    else
    {
        assert(p_token_opt == NULL);
        marker = *p_marker_temp;
        if (marker.p_token_caret)
            p_token_opt = marker.p_token_caret;
        else if (marker.p_token_begin)
            p_token_opt = marker.p_token_begin;

        if (p_token_opt == NULL) return false;
        marker.file = p_token_opt->token_origin->lexeme;
        included_file_location = p_token_opt->level > 0;

        marker.line = p_token_opt->line;
        marker.start_col = p_token_opt->col;
        marker.end_col = p_token_opt->col;
    }

    bool is_error = false;
    bool is_warning = false;
    bool is_note = false;

    if (w > W_NOTE)
    {
        is_error = true;
    }
    else if (w == W_LOCATION)
    {
        is_note = true;
    }
    else
    {
        is_error =
            (ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors & (1ULL << w)) != 0;

        is_warning =
            (ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings & (1ULL << w)) != 0;

        is_note =
            ((ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes & (1ULL << w)) != 0);
    }

    if (is_error)
    {
        ctx->p_report->error_count++;
    }
    else if (is_warning)
    {
        /*warnings inside headers are ignored*/
        if (included_file_location)
        {
            return false;
        }

        ctx->p_report->warnings_count++;
    }
    else if (is_note)
    {
        /*notes inside headers are ignored*/
        if (included_file_location)
        {
            return false;
        }

        if (w != W_LOCATION)
            ctx->p_report->info_count++;
    }
    else
    {
        return false;
    }

    if (w != W_LOCATION)
    {
        //index 0 is the most recent
        ctx->p_report->last_diagnostics_ids[1] = ctx->p_report->last_diagnostics_ids[0];
        ctx->p_report->last_diagnostics_ids[0] = w;
    }

    const char* func_name = "module";
    if (ctx->p_current_function_opt)
    {
        assert(ctx->p_current_function_opt->init_declarator_list.head != NULL);
        assert(ctx->p_current_function_opt->init_declarator_list.head->p_declarator != NULL);
        assert(ctx->p_current_function_opt->init_declarator_list.head->p_declarator->name_opt != NULL);
        func_name = ctx->p_current_function_opt->init_declarator_list.head->p_declarator->name_opt->lexeme;
    }

    char buffer[200] = { 0 };

    char diagnostic_name[100] = { 0 };
    get_warning_name(w, sizeof diagnostic_name, diagnostic_name);




    print_position(marker.file, marker.line, marker.start_col, ctx->options.visual_studio_ouput_format);

#pragma CAKE diagnostic push
#pragma CAKE diagnostic ignored "-Wnullable-to-non-nullable"
#pragma CAKE diagnostic ignored "-Wanalyzer-null-dereference"

    va_list args = { 0 };
    va_start(args, fmt);
    /*int n =*/vsnprintf(buffer, sizeof(buffer), fmt, args);
    va_end(args);

#pragma CAKE diagnostic pop

    //bool show_warning_name = w < W_NOTE && w != W_LOCATION;


    if (ctx->options.visual_studio_ouput_format)
    {
        if (is_error)
            printf("error: ");
        else if (is_warning)
            printf("warning: ");
        else if (is_note)
            printf("note: ");

        printf("%s", buffer);

        printf(" [%s]\n", diagnostic_name);
    }
    else
    {
        if (is_error)
        {
            printf(LIGHTRED "error: " WHITE "%s [" LIGHTRED "%s" WHITE "]\n" RESET, buffer, diagnostic_name);
        }
        else if (is_warning)
        {
            printf(LIGHTMAGENTA "warning: " WHITE "%s [" LIGHTMAGENTA "%s" WHITE "]\n" RESET, buffer, diagnostic_name);
        }
        else if (is_note)
        {
            if (w == W_LOCATION)
                printf(LIGHTCYAN "note: " WHITE "%s\n" RESET, buffer);
            else
                printf(LIGHTCYAN "note: " WHITE "%s [" LIGHTCYAN "%s" WHITE "]\n" RESET, buffer, diagnostic_name);
        }
    }

    print_line_and_token(&marker, ctx->options.visual_studio_ouput_format);


    if (ctx->sarif_file)
    {

        char json_str_message[200] = { 0 };
        stringfy(buffer, json_str_message, sizeof json_str_message);

        if (ctx->sarif_entries > 0)
        {
            fprintf(ctx->sarif_file, "   ,\n");
        }

        ((struct parser_ctx*)ctx)->sarif_entries++;

        fprintf(ctx->sarif_file, "   {\n");
        fprintf(ctx->sarif_file, "     \"ruleId\":\"%s\",\n", diagnostic_name);

        if (is_error)
            fprintf(ctx->sarif_file, "     \"level\":\"error\",\n");
        else if (is_warning)
            fprintf(ctx->sarif_file, "     \"level\":\"warning\",\n");
        else if (is_note)
            fprintf(ctx->sarif_file, "     \"level\":\"note\",\n");

        fprintf(ctx->sarif_file, "     \"message\": {\n");
        fprintf(ctx->sarif_file, "            \"text\": \"%s\"\n", json_str_message);
        fprintf(ctx->sarif_file, "      },\n");
        fprintf(ctx->sarif_file, "      \"locations\": [\n");
        fprintf(ctx->sarif_file, "       {\n");

        fprintf(ctx->sarif_file, "       \"physicalLocation\": {\n");

        fprintf(ctx->sarif_file, "             \"artifactLocation\": {\n");
        fprintf(ctx->sarif_file, "                 \"uri\": \"file:///%s\"\n", marker.file);
        fprintf(ctx->sarif_file, "              },\n");

        fprintf(ctx->sarif_file, "              \"region\": {\n");
        fprintf(ctx->sarif_file, "                  \"startLine\": %d,\n", marker.line);
        fprintf(ctx->sarif_file, "                  \"startColumn\": %d,\n", marker.start_col);
        fprintf(ctx->sarif_file, "                  \"endLine\": %d,\n", marker.line);
        fprintf(ctx->sarif_file, "                  \"endColumn\": %d\n", marker.end_col);
        fprintf(ctx->sarif_file, "               }\n");
        fprintf(ctx->sarif_file, "         },\n");

        fprintf(ctx->sarif_file, "         \"logicalLocations\": [\n");
        fprintf(ctx->sarif_file, "          {\n");

        fprintf(ctx->sarif_file, "              \"fullyQualifiedName\": \"%s\",\n", func_name);
        fprintf(ctx->sarif_file, "              \"decoratedName\": \"%s\",\n", func_name);

        fprintf(ctx->sarif_file, "              \"kind\": \"%s\"\n", "function");
        fprintf(ctx->sarif_file, "          }\n");

        fprintf(ctx->sarif_file, "         ]\n");

        fprintf(ctx->sarif_file, "       }\n");
        fprintf(ctx->sarif_file, "     ]\n");

        fprintf(ctx->sarif_file, "   }\n");
    }

    return 1;
}

void print_scope(struct scope_list* e)
{
    printf("--- begin of scope---\n");
    struct scope* _Opt p = e->head;
    int level = 0;
    while (p)
    {
        if (p->variables.table)
        {
            for (int i = 0; i < p->variables.capacity; i++)
            {
                if (p->variables.table[i])
                {
                    for (int k = 0; k < level; k++)
                        printf(" ");
                    printf("%s\n", p->variables.table[i]->key);
                }
            }

            for (int i = 0; i < p->tags.capacity; i++)
            {
                if (p->tags.table[i])
                {
                    for (int k = 0; k < level; k++)
                        printf(" ");
                    printf("tag %s\n", p->tags.table[i]->key);
                }
            }
        }

        level++;
        p = p->next;
    }
    printf("--- end of scope---\n");
}


bool first_of_function_specifier(const struct parser_ctx* ctx)
{
    struct token* _Opt token = ctx->current;

    if (token == NULL)
        return false;

    return token->type == TK_KEYWORD_INLINE ||
        token->type == TK_KEYWORD__NORETURN;
}

bool first_of_enum_specifier_token(const struct token* token)
{
    return token->type == TK_KEYWORD_ENUM;
}

bool first_of_enum_specifier(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return first_of_enum_specifier_token(ctx->current);
}


bool first_of_alignment_specifier(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;
    return ctx->current->type == TK_KEYWORD__ALIGNAS;
}

bool first_of_atomic_type_specifier(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    /*
      If the _Atomic keyword is immediately followed by a left parenthesis, it is interpreted
      as a type specifier (with a type name), not as a type qualifier.
    */

    if (ctx->current->type == TK_KEYWORD__ATOMIC)
    {
        struct token* _Opt ahead = parser_look_ahead(ctx);
        if (ahead != NULL)
        {
            return ahead->type == '(';
        }
    }
    return false;
}

bool first_of_storage_class_specifier(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return ctx->current->type == TK_KEYWORD_TYPEDEF ||
        ctx->current->type == TK_KEYWORD_CONSTEXPR ||
        ctx->current->type == TK_KEYWORD_EXTERN ||
        ctx->current->type == TK_KEYWORD_STATIC ||
        ctx->current->type == TK_KEYWORD__THREAD_LOCAL ||
        ctx->current->type == TK_KEYWORD_AUTO ||
        ctx->current->type == TK_KEYWORD_REGISTER;
}

bool first_of_struct_or_union_token(const struct token* token)
{
    return token->type == TK_KEYWORD_STRUCT || token->type == TK_KEYWORD_UNION;
}

bool first_of_struct_or_union(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return first_of_struct_or_union_token(ctx->current);
}

bool first_of_type_qualifier_token(const struct token* p_token)
{

    return p_token->type == TK_KEYWORD_CONST ||
        p_token->type == TK_KEYWORD_RESTRICT ||
        p_token->type == TK_KEYWORD_VOLATILE ||
        p_token->type == TK_KEYWORD__ATOMIC ||

        /*extensions*/
        p_token->type == TK_KEYWORD__OUT ||
        p_token->type == TK_KEYWORD__OWNER ||
        p_token->type == TK_KEYWORD__OBJ_OWNER ||
        p_token->type == TK_KEYWORD__VIEW ||
        p_token->type == TK_KEYWORD__OPT;

    //__fastcall
    //__stdcall
}

bool first_of_type_qualifier(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return first_of_type_qualifier_token(ctx->current);
}

struct map_entry* _Opt find_tag(struct parser_ctx* ctx, const char* lexeme)
{
    struct scope* _Opt scope = ctx->scopes.tail;
    while (scope)
    {
        struct map_entry* _Opt p_entry = hashmap_find(&scope->tags, lexeme);
        if (p_entry)
        {
            return p_entry;
        }
        scope = scope->previous;
    }
    return NULL;
}

struct map_entry* _Opt find_variables(const struct parser_ctx* ctx, const char* lexeme, struct scope* _Opt* _Opt ppscope_opt)
{
    if (ppscope_opt != NULL)
        *ppscope_opt = NULL; // out

    struct scope* _Opt scope = ctx->scopes.tail;
    while (scope)
    {
        struct map_entry* _Opt p_entry = hashmap_find(&scope->variables, lexeme);
        if (p_entry)
        {
            if (ppscope_opt)
                *ppscope_opt = scope;
            return p_entry;
        }
        scope = scope->previous;
    }
    return NULL;
}

struct enum_specifier* _Opt find_enum_specifier(struct parser_ctx* ctx, const char* lexeme)
{
    struct enum_specifier* _Opt best = NULL;
    struct scope* _Opt scope = ctx->scopes.tail;
    while (scope)
    {
        struct map_entry* _Opt p_entry = hashmap_find(&scope->tags, lexeme);
        if (p_entry &&
            p_entry->type == TAG_TYPE_ENUN_SPECIFIER)
        {
            best = p_entry->p;
            if (best->enumerator_list.head != NULL)
                return best; // OK bem completo
            else
            {
                // it's not complete let's keep going up
            }
        }
        scope = scope->previous;
    }
    return best; // mesmo que nao seja tao completo vamos retornar.
}

struct struct_or_union_specifier* _Opt find_struct_or_union_specifier(struct parser_ctx* ctx, const char* lexeme)
{
    struct struct_or_union_specifier* _Opt p = NULL;
    struct scope* _Opt scope = ctx->scopes.tail;
    while (scope)
    {
        struct map_entry* _Opt p_entry = hashmap_find(&scope->tags, lexeme);
        if (p_entry &&
            p_entry->type == TAG_TYPE_STRUCT_OR_UNION_SPECIFIER)
        {
            p = p_entry->p;
            break;
        }
        scope = scope->previous;
    }
    return p;
}

struct declarator* _Opt find_declarator(const struct parser_ctx* ctx, const char* lexeme, struct scope** _Opt ppscope_opt)
{
    struct map_entry* _Opt p_entry = find_variables(ctx, lexeme, ppscope_opt);

    if (p_entry)
    {
        if (p_entry->type == TAG_TYPE_INIT_DECLARATOR)
        {
            struct init_declarator* p_init_declarator = p_entry->p;
            return (struct declarator*)p_init_declarator->p_declarator;
        }
        else if (p_entry->type == TAG_TYPE_ONLY_DECLARATOR)
        {
            return p_entry->p;
        }
    }

    return NULL;
}

struct enumerator* _Opt find_enumerator(const struct parser_ctx* ctx, const char* lexeme, struct scope** _Opt ppscope_opt)
{
    struct map_entry* _Opt p_entry = find_variables(ctx, lexeme, ppscope_opt);

    if (p_entry && p_entry->type == TAG_TYPE_ENUMERATOR)
        return p_entry->p;

    return NULL;
}

bool first_of_typedef_name(const struct parser_ctx* ctx, struct token* p_token)
{

    if (p_token->type != TK_IDENTIFIER)
    {
        // no need to check
        return false;
    }
    if (p_token->flags & TK_FLAG_IDENTIFIER_IS_TYPEDEF)
    {
        // it has already been verified that it is a typedef
        return true;
    }
    if (p_token->flags & TK_FLAG_IDENTIFIER_IS_NOT_TYPEDEF)
    {
        // it has already been verified that it is NOT a typedef
        return false;
    }

    struct declarator* _Opt p_declarator = find_declarator(ctx, p_token->lexeme, NULL);

    if (p_declarator &&
        p_declarator->declaration_specifiers &&
        (p_declarator->declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_TYPEDEF))
    {
        p_declarator->num_uses++;
        p_token->flags |= TK_FLAG_IDENTIFIER_IS_TYPEDEF;
        return true;
    }
    else
    {
        p_token->flags |= TK_FLAG_IDENTIFIER_IS_NOT_TYPEDEF;
    }
    return false;
}

bool first_of_type_specifier(const struct parser_ctx* ctx);
bool first_of_type_specifier_token(const struct parser_ctx* ctx, struct token* token);

bool first_of_type_name_ahead(const struct parser_ctx* ctx)
{

    if (ctx->current == NULL)
        return false;

    if (ctx->current->type != '(')
        return false;

    struct token* _Opt token_ahead = parser_look_ahead(ctx);

    if (token_ahead == NULL)
        return false;

    return first_of_type_specifier_token(ctx, token_ahead) ||
        first_of_type_qualifier_token(token_ahead);
}

bool first_of_type_name(const struct parser_ctx* ctx)
{
    return first_of_type_specifier(ctx) || first_of_type_qualifier(ctx);
}

bool first_of_type_specifier_token(const struct parser_ctx* ctx, struct token* p_token)
{
    return p_token->type == TK_KEYWORD_VOID ||
        p_token->type == TK_KEYWORD_CHAR ||
        p_token->type == TK_KEYWORD_SHORT ||
        p_token->type == TK_KEYWORD_INT ||
        p_token->type == TK_KEYWORD_LONG ||

        // microsoft extension
        p_token->type == TK_KEYWORD__INT8 ||
        p_token->type == TK_KEYWORD__INT16 ||
        p_token->type == TK_KEYWORD__INT32 ||
        p_token->type == TK_KEYWORD__INT64 ||

        // end microsoft

        p_token->type == TK_KEYWORD_FLOAT ||
        p_token->type == TK_KEYWORD_DOUBLE ||
        p_token->type == TK_KEYWORD_SIGNED ||
        p_token->type == TK_KEYWORD_UNSIGNED ||
        p_token->type == TK_KEYWORD__BITINT ||
        p_token->type == TK_KEYWORD__BOOL ||
        p_token->type == TK_KEYWORD__COMPLEX ||
        p_token->type == TK_KEYWORD__DECIMAL32 ||
        p_token->type == TK_KEYWORD__DECIMAL64 ||
        p_token->type == TK_KEYWORD__DECIMAL128 ||
        p_token->type == TK_KEYWORD_TYPEOF ||        // C23
        p_token->type == TK_KEYWORD_TYPEOF_UNQUAL || // C23
        first_of_atomic_type_specifier(ctx) ||
        first_of_struct_or_union_token(p_token) ||
        first_of_enum_specifier_token(p_token) ||
        first_of_typedef_name(ctx, p_token);
}

bool first_of_type_specifier(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;
    return first_of_type_specifier_token(ctx, ctx->current);
}

bool first_of_type_specifier_qualifier(const struct parser_ctx* ctx)
{
    return first_of_type_specifier(ctx) ||
        first_of_type_qualifier(ctx) ||
        first_of_alignment_specifier(ctx);
}

bool first_of_compound_statement(const struct parser_ctx* ctx)
{
    return ctx->current != NULL && ctx->current->type == '{';
}

bool first_of_jump_statement(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return ctx->current->type == TK_KEYWORD_GOTO ||
        ctx->current->type == TK_KEYWORD_CONTINUE ||
        ctx->current->type == TK_KEYWORD_BREAK ||
        ctx->current->type == TK_KEYWORD_RETURN ||
        ctx->current->type == TK_KEYWORD_THROW /*extension*/;
}

bool first_of_selection_statement(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return ctx->current->type == TK_KEYWORD_IF ||
        ctx->current->type == TK_KEYWORD_SWITCH;
}

bool first_of_iteration_statement(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return ctx->current->type == TK_KEYWORD_WHILE ||
        ctx->current->type == TK_KEYWORD_DO ||
        ctx->current->type == TK_KEYWORD_FOR;
}

bool first_of_label(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    if (ctx->current->type == TK_IDENTIFIER)
    {
        struct token* _Opt next = parser_look_ahead(ctx);
        return next && next->type == ':';
    }
    else if (ctx->current->type == TK_KEYWORD_CASE)
    {
        return true;
    }
    else if (ctx->current->type == TK_KEYWORD_DEFAULT)
    {
        return true;
    }

    return false;
}

bool first_of_declaration_specifier(const struct parser_ctx* ctx)
{
    /*
    declaration-specifier:
    storage-class-specifier
    type-specifier-qualifier
    function-specifier
    */
    return first_of_storage_class_specifier(ctx) ||
        first_of_function_specifier(ctx) ||
        first_of_type_specifier_qualifier(ctx);
}

bool first_of_pragma_declaration(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return ctx->current->type == TK_PRAGMA;
}

bool first_of_static_assert_declaration(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return ctx->current->type == TK_KEYWORD__STATIC_ASSERT ||
        ctx->current->type == TK_KEYWORD_STATIC_DEBUG ||
        ctx->current->type == TK_KEYWORD_STATIC_DEBUG_EX ||
        ctx->current->type == TK_KEYWORD_STATIC_STATE ||
        ctx->current->type == TK_KEYWORD_STATIC_SET;
}

bool first_of_attribute_specifier(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    if (ctx->current->type != '[')
    {
        return false;
    }
    struct token* _Opt p_token = parser_look_ahead(ctx);
    return p_token != NULL && p_token->type == '[';
}

bool first_of_labeled_statement(const struct parser_ctx* ctx)
{
    return first_of_label(ctx);
}

bool first_of_designator(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return ctx->current->type == '[' || ctx->current->type == '.';
}

struct token* _Opt previous_parser_token(const struct token* token)
{
    if (token->prev == NULL)
    {
        return NULL;
    }

    struct token* _Opt prev = token->prev;
    while (prev && !(prev->flags & TK_FLAG_FINAL))
    {
        prev = prev->prev;
    }

    return prev;
}

enum token_type is_keyword(const char* text)
{
    enum token_type result = 0;
    switch (text[0])
    {
    case 'a':
        if (strcmp("alignof", text) == 0)
            result = TK_KEYWORD__ALIGNOF;
        else if (strcmp("auto", text) == 0)
            result = TK_KEYWORD_AUTO;
        else if (strcmp("alignas", text) == 0)
            result = TK_KEYWORD__ALIGNAS; /*C23 alternate spelling _Alignas*/
        else if (strcmp("alignof", text) == 0)
            result = TK_KEYWORD__ALIGNAS; /*C23 alternate spelling _Alignof*/
        else if (strcmp("assert", text) == 0)
            result = TK_KEYWORD_ASSERT; /*extension*/
        break;
    case 'b':
        if (strcmp("break", text) == 0)
            result = TK_KEYWORD_BREAK;
        else if (strcmp("bool", text) == 0)
            result = TK_KEYWORD__BOOL; /*C23 alternate spelling _Bool*/

        break;
    case 'c':
        if (strcmp("case", text) == 0)
            result = TK_KEYWORD_CASE;
        else if (strcmp("char", text) == 0)
            result = TK_KEYWORD_CHAR;
        else if (strcmp("const", text) == 0)
            result = TK_KEYWORD_CONST;
        else if (strcmp("constexpr", text) == 0)
            result = TK_KEYWORD_CONSTEXPR;
        else if (strcmp("continue", text) == 0)
            result = TK_KEYWORD_CONTINUE;
        else if (strcmp("catch", text) == 0)
            result = TK_KEYWORD_CATCH;
        break;
    case 'd':
        if (strcmp("default", text) == 0)
            result = TK_KEYWORD_DEFAULT;
        else if (strcmp("do", text) == 0)
            result = TK_KEYWORD_DO;
        else if (strcmp("defer", text) == 0)
            result = TK_KEYWORD_DEFER;
        else if (strcmp("double", text) == 0)
            result = TK_KEYWORD_DOUBLE;
        break;
    case 'e':
        if (strcmp("else", text) == 0)
            result = TK_KEYWORD_ELSE;
        else if (strcmp("enum", text) == 0)
            result = TK_KEYWORD_ENUM;
        else if (strcmp("extern", text) == 0)
            result = TK_KEYWORD_EXTERN;
        break;
    case 'f':
        if (strcmp("float", text) == 0)
            result = TK_KEYWORD_FLOAT;
        else if (strcmp("for", text) == 0)
            result = TK_KEYWORD_FOR;
        else if (strcmp("false", text) == 0)
            result = TK_KEYWORD_FALSE;
        break;
    case 'g':
        if (strcmp("goto", text) == 0)
            result = TK_KEYWORD_GOTO;
        break;
    case 'i':
        if (strcmp("if", text) == 0)
            result = TK_KEYWORD_IF;
        else if (strcmp("inline", text) == 0)
            result = TK_KEYWORD_INLINE;
        else if (strcmp("int", text) == 0)
            result = TK_KEYWORD_INT;
        break;
    case 'n':
        if (strcmp("nullptr", text) == 0)
            result = TK_KEYWORD_NULLPTR;
        else if (strcmp("nelementsof", text) == 0)
            result = TK_KEYWORD_NELEMENTSOF;
        break;

    case 'l':
        if (strcmp("long", text) == 0)
            result = TK_KEYWORD_LONG;
        break;
    case 'r':
        if (strcmp("register", text) == 0)
            result = TK_KEYWORD_REGISTER;
        else if (strcmp("restrict", text) == 0)
            result = TK_KEYWORD_RESTRICT;
        else if (strcmp("return", text) == 0)
            result = TK_KEYWORD_RETURN;

        break;
    case 's':
        if (strcmp("short", text) == 0)
            result = TK_KEYWORD_SHORT;
        else if (strcmp("signed", text) == 0)
            result = TK_KEYWORD_SIGNED;
        else if (strcmp("sizeof", text) == 0)
            result = TK_KEYWORD_SIZEOF;
        else if (strcmp("static", text) == 0)
            result = TK_KEYWORD_STATIC;
        else if (strcmp("struct", text) == 0)
            result = TK_KEYWORD_STRUCT;
        else if (strcmp("switch", text) == 0)
            result = TK_KEYWORD_SWITCH;
        else if (strcmp("static_assert", text) == 0)
            result = TK_KEYWORD__STATIC_ASSERT; /*C23 alternate spelling _Static_assert*/
        else if (strcmp("static_debug", text) == 0)
            result = TK_KEYWORD_STATIC_DEBUG;
        else if (strcmp("static_debug_ex", text) == 0)
            result = TK_KEYWORD_STATIC_DEBUG_EX;
        else if (strcmp("static_state", text) == 0)
            result = TK_KEYWORD_STATIC_STATE;
        else if (strcmp("static_set", text) == 0)
            result = TK_KEYWORD_STATIC_SET;

        break;
    case 't':
        if (strcmp("typedef", text) == 0)
            result = TK_KEYWORD_TYPEDEF;
        else if (strcmp("typeof", text) == 0)
            result = TK_KEYWORD_TYPEOF; /*C23*/
        else if (strcmp("typeof_unqual", text) == 0)
            result = TK_KEYWORD_TYPEOF_UNQUAL; /*C23*/
        else if (strcmp("true", text) == 0)
            result = TK_KEYWORD_TRUE; /*C23*/
        else if (strcmp("thread_local", text) == 0)
            result = TK_KEYWORD__THREAD_LOCAL; /*C23 alternate spelling _Thread_local*/
        else if (strcmp("try", text) == 0)
            result = TK_KEYWORD_TRY;
        else if (strcmp("throw", text) == 0)
            result = TK_KEYWORD_THROW;
        break;
    case 'u':
        if (strcmp("union", text) == 0)
            result = TK_KEYWORD_UNION;
        else if (strcmp("unsigned", text) == 0)
            result = TK_KEYWORD_UNSIGNED;
        break;
    case 'v':
        if (strcmp("void", text) == 0)
            result = TK_KEYWORD_VOID;
        else if (strcmp("volatile", text) == 0)
            result = TK_KEYWORD_VOLATILE;

        break;
    case 'w':
        if (strcmp("while", text) == 0)
            result = TK_KEYWORD_WHILE;
        break;
    case '_':


        //
        // end microsoft

        /*ownership*/
        if (strcmp("_Out", text) == 0)
            result = TK_KEYWORD__OUT; /*extension*/
        else if (strcmp("_Owner", text) == 0)
            result = TK_KEYWORD__OWNER; /*extension*/
        else if (strcmp("_Obj_owner", text) == 0)
            result = TK_KEYWORD__OBJ_OWNER; /*extension*/
        else if (strcmp("_Opt", text) == 0)
            result = TK_KEYWORD__OPT; /*extension*/

        else if (strcmp("_View", text) == 0)
            result = TK_KEYWORD__VIEW; /*extension*/


        /*TRAITS EXTENSION*/
        else if (strcmp("_is_lvalue", text) == 0)
            result = TK_KEYWORD_IS_LVALUE;
        else if (strcmp("_is_const", text) == 0)
            result = TK_KEYWORD_IS_CONST;
        else if (strcmp("_is_owner", text) == 0)
            result = TK_KEYWORD_IS_OWNER;
        else if (strcmp("_is_pointer", text) == 0)
            result = TK_KEYWORD_IS_POINTER;
        else if (strcmp("_is_array", text) == 0)
            result = TK_KEYWORD_IS_ARRAY;
        else if (strcmp("_is_function", text) == 0)
            result = TK_KEYWORD_IS_FUNCTION;
        else if (strcmp("_is_arithmetic", text) == 0)
            result = TK_KEYWORD_IS_ARITHMETIC;
        else if (strcmp("_is_floating_point", text) == 0)
            result = TK_KEYWORD_IS_FLOATING_POINT;
        else if (strcmp("_is_integral", text) == 0)
            result = TK_KEYWORD_IS_INTEGRAL;
        else if (strcmp("_is_scalar", text) == 0)
            result = TK_KEYWORD_IS_SCALAR;
        /*TRAITS EXTENSION*/

        else if (strcmp("_Alignof", text) == 0)
            result = TK_KEYWORD__ALIGNOF;
        else if (strcmp("_Alignas", text) == 0)
            result = TK_KEYWORD__ALIGNAS;
        else if (strcmp("_Atomic", text) == 0)
            result = TK_KEYWORD__ATOMIC;
        else if (strcmp("_Bool", text) == 0)
            result = TK_KEYWORD__BOOL;
        else if (strcmp("_Complex", text) == 0)
            result = TK_KEYWORD__COMPLEX;
        else if (strcmp("_Decimal32", text) == 0)
            result = TK_KEYWORD__DECIMAL32;
        else if (strcmp("_Decimal64", text) == 0)
            result = TK_KEYWORD__DECIMAL64;
        else if (strcmp("_Decimal128", text) == 0)
            result = TK_KEYWORD__DECIMAL128;
        else if (strcmp("_Generic", text) == 0)
            result = TK_KEYWORD__GENERIC;
        else if (strcmp("_Imaginary", text) == 0)
            result = TK_KEYWORD__IMAGINARY;
        else if (strcmp("_Noreturn", text) == 0)
            result = TK_KEYWORD__NORETURN; /*_Noreturn deprecated C23*/
        else if (strcmp("_Static_assert", text) == 0)
            result = TK_KEYWORD__STATIC_ASSERT;
        else if (strcmp("_Thread_local", text) == 0)
            result = TK_KEYWORD__THREAD_LOCAL;
        else if (strcmp("_BitInt", text) == 0)
            result = TK_KEYWORD__BITINT; /*(C23)*/
        else if (strcmp("__typeof__", text) == 0)
            result = TK_KEYWORD_TYPEOF; /*(C23)*/
#ifdef  _MSC_VER
        // begin microsoft
        else if (strcmp("__int8", text) == 0)
            result = TK_KEYWORD__INT8;
        else if (strcmp("__int16", text) == 0)
            result = TK_KEYWORD__INT16;
        else if (strcmp("__int32", text) == 0)
            result = TK_KEYWORD__INT32;
        else if (strcmp("__int64", text) == 0)
            result = TK_KEYWORD__INT64;
        else if (strcmp("__forceinline", text) == 0)
            result = TK_KEYWORD_INLINE;
        else if (strcmp("__inline", text) == 0)
            result = TK_KEYWORD_INLINE;
        else if (strcmp("_asm", text) == 0 || strcmp("__asm", text) == 0)
            result = TK_KEYWORD__ASM;
        else if (strcmp("__alignof", text) == 0)
            result = TK_KEYWORD__ALIGNOF;
        else if (strcmp("__restrict", text) == 0)
            result = TK_KEYWORD_RESTRICT;
#endif
        break;
    default:
        break;
    }
    return result;
}


static void token_promote(const struct parser_ctx* ctx, struct token* token)
{
    if (token->type == TK_IDENTIFIER_RECURSIVE_MACRO)
    {
        // talvez desse para remover antesisso..
        // assim que sai do tetris
        // virou passado
        token->type = TK_IDENTIFIER; /*nao precisamos mais disso*/
    }

    if (token->type == TK_IDENTIFIER)
    {
        enum token_type t = is_keyword(token->lexeme);
        if (t != TK_NONE)
            token->type = t;
    }
    else if (token->type == TK_PPNUMBER)
    {
        char errormsg[100] = { 0 };
        char suffix[4] = { 0 };
        token->type = parse_number(token->lexeme, suffix, errormsg);
        if (token->type == TK_NONE)
        {
            compiler_diagnostic_message(C_INVALID_TOKEN, ctx, token, NULL, errormsg);
        }
    }
}

struct token* _Opt parser_look_ahead(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return NULL;

    struct token* _Opt p = ctx->current->next;
    while (p && !(p->flags & TK_FLAG_FINAL))
    {
        p = p->next;
    }

    if (p)
    {
        token_promote(ctx, p);
    }

    return p;
}


static struct token* _Opt pragma_match(struct token* p_current)
{
    struct token* _Opt p_token = p_current->next;
    while (p_token && p_token->type == TK_BLANKS)
    {
        p_token = p_token->next;
    }
    return p_token;
}

static void pragma_skip_blanks(struct parser_ctx* ctx)
{
    while (ctx->current && ctx->current->type == TK_BLANKS)
    {
        ctx->current = ctx->current->next;
    }
}

/*
 * Some pragmas needs to be handled by the compiler
 */
static void parse_pragma(struct parser_ctx* ctx, struct token* token)
{
    try
    {
        if (ctx->current == NULL)
            throw;

        if (ctx->current->type == TK_PRAGMA)
        {
            ctx->current = ctx->current->next;
            pragma_skip_blanks(ctx);

            if (ctx->current &&
                (strcmp(ctx->current->lexeme, "CAKE") == 0 ||
                    strcmp(ctx->current->lexeme, "cake") == 0))
            {
                ctx->current = ctx->current->next;
                pragma_skip_blanks(ctx);
            }

            if (ctx->current && strcmp(ctx->current->lexeme, "nullchecks") == 0)
            {
                ctx->current = ctx->current->next;
                pragma_skip_blanks(ctx);

                // Isso nao esta funcionando pois esta informao precisa estar na AST.
                // pois eh usada em um segundo passo.
                bool onoff = false;
                if (ctx->current && strcmp(ctx->current->lexeme, "ON") == 0)
                {
                    onoff = true;
                }
                else if (ctx->current && strcmp(ctx->current->lexeme, "OFF") == 0)
                {
                    onoff = false;
                }
                else
                {
                    compiler_diagnostic_message(C_ERROR_PRAGMA_ERROR, ctx, ctx->current, NULL, "nullchecks pragma needs to use ON OFF");
                }
                ctx->options.null_checks_enabled = onoff;
            }

            if (ctx->current && strcmp(ctx->current->lexeme, "diagnostic") == 0)
            {
                ctx->current = ctx->current->next;
                pragma_skip_blanks(ctx);

                if (ctx->current && strcmp(ctx->current->lexeme, "push") == 0)
                {
                    // #pragma GCC diagnostic push
                    if (ctx->options.diagnostic_stack.top_index <
                        sizeof(ctx->options.diagnostic_stack) / sizeof(ctx->options.diagnostic_stack.stack[0]))
                    {
                        ctx->options.diagnostic_stack.top_index++;
                        ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index] =
                            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index - 1];
                    }
                    ctx->current = ctx->current->next;
                    pragma_skip_blanks(ctx);
                }
                else if (ctx->current && strcmp(ctx->current->lexeme, "pop") == 0)
                {
                    // #pragma CAKE diagnostic pop
                    if (ctx->options.diagnostic_stack.top_index > 0)
                    {
                        ctx->options.diagnostic_stack.top_index--;
                    }
                    ctx->current = ctx->current->next;
                    pragma_skip_blanks(ctx);
                }
                else if (ctx->current &&
                    (strcmp(ctx->current->lexeme, "error") == 0 ||
                        strcmp(ctx->current->lexeme, "warning") == 0 ||
                        strcmp(ctx->current->lexeme, "note") == 0 ||
                        strcmp(ctx->current->lexeme, "ignored") == 0))
                {
                    const bool is_error = strcmp(ctx->current->lexeme, "error") == 0;
                    const bool is_warning = strcmp(ctx->current->lexeme, "warning") == 0;
                    const bool is_note = strcmp(ctx->current->lexeme, "note") == 0;

                    ctx->current = ctx->current->next;
                    pragma_skip_blanks(ctx);

                    if (ctx->current && ctx->current->type == TK_STRING_LITERAL)
                    {
                        unsigned long long w = get_warning_bit_mask(ctx->current->lexeme + 1 /*+ 2*/);

                        ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors &= ~w;
                        ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes &= ~w;
                        ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings &= ~w;

                        if (is_error)
                            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors |= w;
                        else if (is_warning)
                            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings |= w;
                        else if (is_note)
                            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes |= w;
                    }
                }
                else if (ctx->current &&
                    (strcmp(ctx->current->lexeme, "check") == 0))
                {
                    // TODO better name .  Ack. : means ‘alarm acknowledged’ ?
                    ctx->current = ctx->current->next;
                    pragma_skip_blanks(ctx);

                    if (ctx->current && ctx->current->type == TK_STRING_LITERAL)
                    {
                        enum diagnostic_id id = get_warning(ctx->current->lexeme + 1 + 2);
                        bool found = false;
                        for (int i = 0;
                             i < (int)(sizeof(ctx->p_report->last_diagnostics_ids) / sizeof(ctx->p_report->last_diagnostics_ids[0]));
                             i++)
                        {
                            if (ctx->p_report->last_diagnostics_ids[i] == 0) break;

                            if (ctx->p_report->last_diagnostics_ids[i] == id)
                            {
                                found = true;
                                // lets remove this error/warning/info from the final report.

                                int t =
                                    get_diagnostic_type(&ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index],
                                        id);
                                if (t == 3)
                                    ctx->p_report->error_count--;
                                else if (t == 2)
                                    ctx->p_report->warnings_count--;
                                else if (t == 1)
                                    ctx->p_report->info_count--;

                                break;
                            }
                        }

                        if (!found)
                        {
                            compiler_diagnostic_message(C_ERROR_UNEXPECTED, ctx, ctx->current, NULL, "pragma check failed");
                        }
                    }
                }
                else
                {
                    compiler_diagnostic_message(C_ERROR_UNEXPECTED, ctx, ctx->current, NULL, "unknown pragma");
                }
            }
        }
    }
    catch
    {
    }
}

static void parser_skip_blanks(struct parser_ctx* ctx)
{
    while (ctx->current && !(ctx->current->flags & TK_FLAG_FINAL))
    {

        if (ctx->current->type == TK_PRAGMA)
        {
            /*only active block have TK_PRAGMA*/
            parse_pragma(ctx, ctx->current);
        }

        if (ctx->current)
            ctx->current = ctx->current->next;
    }

    if (ctx->current)
    {
        token_promote(ctx, ctx->current); // transform to parser token
    }
}

void parser_match(struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return;

    ctx->previous = ctx->current;
    ctx->current = ctx->current->next;
    parser_skip_blanks(ctx);
}

NODISCARD
int parser_match_tk(struct parser_ctx* ctx, enum token_type type)
{
    int error = 0;
    if (ctx->current != NULL)
    {
        if (ctx->current->type != type)
        {
            compiler_diagnostic_message(C_ERROR_UNEXPECTED_TOKEN, ctx, ctx->current, NULL, "expected %s", get_token_name(type));
            error = 1;
        }

        ctx->previous = ctx->current;
        ctx->current = ctx->current->next;
        parser_skip_blanks(ctx);
    }
    else
    {
        compiler_diagnostic_message(C_ERROR_UNEXPECTED_TOKEN, ctx, ctx->input_list.tail, NULL, "unexpected end of file after");
        error = 1;
    }

    return error;
}

void print_declaration_specifiers(struct osstream* ss, struct declaration_specifiers* p_declaration_specifiers)
{
    bool first = true;
    print_type_qualifier_flags(ss, &first, p_declaration_specifiers->type_qualifier_flags);

    if (p_declaration_specifiers->enum_specifier)
    {

        if (p_declaration_specifiers->enum_specifier->tag_token)
        {
            ss_fprintf(ss, "enum %s", p_declaration_specifiers->enum_specifier->tag_token->lexeme);
        }
        else
        {
            assert(false);
        }
    }
    else if (p_declaration_specifiers->struct_or_union_specifier)
    {
        ss_fprintf(ss, "struct %s", p_declaration_specifiers->struct_or_union_specifier->tag_name);
    }
    else if (p_declaration_specifiers->typedef_declarator)
    {
        if (p_declaration_specifiers->typedef_declarator->name_opt)
            print_item(ss, &first, p_declaration_specifiers->typedef_declarator->name_opt->lexeme);
    }
    else
    {
        print_type_specifier_flags(ss, &first, p_declaration_specifiers->type_specifier_flags);
    }
}

bool type_specifier_is_integer(enum type_specifier_flags flags)
{
    if ((flags & TYPE_SPECIFIER_CHAR) ||
        (flags & TYPE_SPECIFIER_SHORT) ||
        (flags & TYPE_SPECIFIER_INT) ||
        (flags & TYPE_SPECIFIER_LONG) ||
        (flags & TYPE_SPECIFIER_INT) ||
        (flags & TYPE_SPECIFIER_INT8) ||
        (flags & TYPE_SPECIFIER_INT16) ||
        (flags & TYPE_SPECIFIER_INT32) ||
        (flags & TYPE_SPECIFIER_INT64) ||
        (flags & TYPE_SPECIFIER_LONG_LONG))
    {
        return true;
    }
    return false;
}

int final_specifier(struct parser_ctx* ctx, enum type_specifier_flags* flags)
{
    if (((*flags) & TYPE_SPECIFIER_UNSIGNED) ||
        ((*flags) & TYPE_SPECIFIER_SIGNED))
    {
        if (!type_specifier_is_integer(*flags))
        {
            // se nao especificou nada vira integer
            (*flags) |= TYPE_SPECIFIER_INT;
        }
    }

    return 0;
}

int add_specifier(struct parser_ctx* ctx,
    enum type_specifier_flags* flags,
    enum type_specifier_flags new_flag)
{
    /*
        transform the sequence of two longs
        in
        TYPE_SPECIFIER_LONG_LONG
    */
    if (new_flag & TYPE_SPECIFIER_LONG) // adding a long
    {
        if ((*flags) & TYPE_SPECIFIER_LONG_LONG) // ja tinha long long
        {
            compiler_diagnostic_message(C_ERROR_CANNOT_COMBINE_WITH_PREVIOUS_LONG_LONG, ctx, ctx->current, NULL, "cannot combine with previous 'long long' declaration specifier");
            return 1;
        }
        else if ((*flags) & TYPE_SPECIFIER_LONG) // ja tinha um long
        {
            (*flags) = (*flags) & ~TYPE_SPECIFIER_LONG;
            (*flags) |= TYPE_SPECIFIER_LONG_LONG;
        }
        else // nao tinha nenhum long
        {
            (*flags) = (*flags) & ~TYPE_SPECIFIER_INT;
            (*flags) |= TYPE_SPECIFIER_LONG;
        }
    }
    else
    {
        (*flags) |= new_flag;
    }

    //Following 6.7.2 we check possible combinations
    switch ((unsigned int)*flags)
    {
    case TYPE_SPECIFIER_VOID:  //void
    case TYPE_SPECIFIER_CHAR:  //char
    case TYPE_SPECIFIER_SIGNED | TYPE_SPECIFIER_CHAR:  //signed char
    case TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_CHAR:  //unsigned char
    case TYPE_SPECIFIER_SHORT:  //short
    case TYPE_SPECIFIER_SIGNED | TYPE_SPECIFIER_SHORT:  //signed short
    case TYPE_SPECIFIER_SHORT | TYPE_SPECIFIER_INT:  //short int
    case TYPE_SPECIFIER_SIGNED | TYPE_SPECIFIER_SHORT | TYPE_SPECIFIER_INT:  //signed short int
    case TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_SHORT:  //unsigned short 
    case TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_SHORT | TYPE_SPECIFIER_INT:  //unsigned short int
    case TYPE_SPECIFIER_INT:  //int
    case TYPE_SPECIFIER_SIGNED:  //signed
    case TYPE_SPECIFIER_INT | TYPE_SPECIFIER_SIGNED:  //int signed
    case TYPE_SPECIFIER_UNSIGNED:  //signed
    case TYPE_SPECIFIER_INT | TYPE_SPECIFIER_UNSIGNED:  //int unsigned
    case TYPE_SPECIFIER_LONG:  //long
    case TYPE_SPECIFIER_SIGNED | TYPE_SPECIFIER_LONG:  //signed long
    case TYPE_SPECIFIER_LONG | TYPE_SPECIFIER_INT:  //long int
    case TYPE_SPECIFIER_SIGNED | TYPE_SPECIFIER_LONG | TYPE_SPECIFIER_INT:  //signed long int
    case TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_LONG:  //unsigned long
    case TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_LONG | TYPE_SPECIFIER_INT:  //unsigned long int
    case TYPE_SPECIFIER_LONG_LONG:  //long long
    case TYPE_SPECIFIER_SIGNED | TYPE_SPECIFIER_LONG_LONG:  //signed long long
    case TYPE_SPECIFIER_LONG_LONG | TYPE_SPECIFIER_INT:  //long long int
    case TYPE_SPECIFIER_SIGNED | TYPE_SPECIFIER_LONG_LONG | TYPE_SPECIFIER_INT:  //signed long long
    case TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_LONG_LONG:  //unsigned long long
    case TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_LONG_LONG | TYPE_SPECIFIER_INT:  //unsigned long long int
        // _BitInt constant-expression, or signed _BitInt constant-expression        
        // unsigned _BitInt constant-expression
    case TYPE_SPECIFIER_FLOAT:  //float
    case TYPE_SPECIFIER_DOUBLE:  //double
    case TYPE_SPECIFIER_LONG | TYPE_SPECIFIER_DOUBLE:  //long double
    case TYPE_SPECIFIER_DECIMAL32:  //_Decimal32
    case TYPE_SPECIFIER_DECIMAL64:  //_Decimal64
    case TYPE_SPECIFIER_DECIMAL128:  //_Decimal128
    case TYPE_SPECIFIER_BOOL:  //bool
    case TYPE_SPECIFIER_COMPLEX | TYPE_SPECIFIER_FLOAT:  //complex float
    case TYPE_SPECIFIER_COMPLEX | TYPE_SPECIFIER_DOUBLE:  //complex double
    case TYPE_SPECIFIER_LONG | TYPE_SPECIFIER_COMPLEX | TYPE_SPECIFIER_DOUBLE:  //complex long double        
    case TYPE_SPECIFIER_ATOMIC:  //complex long double
    case TYPE_SPECIFIER_STRUCT_OR_UNION:  //complex long double
    case TYPE_SPECIFIER_ENUM:  //complex long double
    case TYPE_SPECIFIER_TYPEOF:  //typeof        
    case TYPE_SPECIFIER_TYPEDEF:

    case TYPE_SPECIFIER_INT8:
    case TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT8:

    case TYPE_SPECIFIER_INT16:
    case TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT16:
    case TYPE_SPECIFIER_SIGNED | TYPE_SPECIFIER_INT16:
    case TYPE_SPECIFIER_INT32:
    case TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT32:
    case TYPE_SPECIFIER_SIGNED | TYPE_SPECIFIER_INT32:
    case TYPE_SPECIFIER_INT64:
    case TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT64:
    case TYPE_SPECIFIER_SIGNED | TYPE_SPECIFIER_INT64:
        //VALID
        break;
    default:
        compiler_diagnostic_message(C_ERROR_TWO_OR_MORE_SPECIFIERS, ctx, ctx->current, NULL, "incompatible specifiers");
        return 1;
    }

    return 0;
}

void declaration_specifiers_delete(struct declaration_specifiers* _Owner _Opt p)
{
    if (p)
    {
        attribute_specifier_sequence_delete(p->p_attribute_specifier_sequence_opt);

        struct declaration_specifier* _Owner _Opt item = p->head;
        while (item)
        {
            struct declaration_specifier* _Owner _Opt next = item->next;
            item->next = NULL;
            declaration_specifier_delete(item);
            item = next;
        }
        free(p);
    }
}

void declaration_specifiers_add(struct declaration_specifiers* list, struct declaration_specifier* _Owner p_item)
{

    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

struct declaration_specifiers* _Owner _Opt declaration_specifiers(struct parser_ctx* ctx,
    enum storage_class_specifier_flags default_storage_flag)
{
    /*
        declaration-specifiers:
          declaration-specifier attribute-specifier-sequence_opt
          declaration-specifier declaration-specifiers
    */

    /*
     Ao fazer parser do segundo o X ja existe mas ele nao deve ser usado
     typedef char X;
     typedef char X;
    */

    if (ctx->current == NULL)
        return NULL;

    struct declaration_specifiers* _Owner _Opt p_declaration_specifiers = calloc(1, sizeof(struct declaration_specifiers));

    try
    {
        if (p_declaration_specifiers == NULL)
            throw;

        p_declaration_specifiers->first_token = ctx->current;

        while (first_of_declaration_specifier(ctx))
        {
            if (ctx->current == NULL)
                throw;

            if (ctx->current->flags & TK_FLAG_IDENTIFIER_IS_TYPEDEF)
            {
                if (p_declaration_specifiers->type_specifier_flags != TYPE_SPECIFIER_NONE)
                {
                    // typedef tem que aparecer sozinho
                    // exemplo Socket eh nome e nao typdef
                    // typedef int Socket;
                    // struct X {int Socket;};
                    break;
                }
            }

            struct declaration_specifier* _Owner _Opt p_declaration_specifier = declaration_specifier(ctx);
            if (p_declaration_specifier == NULL) throw;

            if (p_declaration_specifier->type_specifier_qualifier)
            {
                if (p_declaration_specifier->type_specifier_qualifier->type_specifier)
                {
                    if (add_specifier(ctx,
                        &p_declaration_specifiers->type_specifier_flags,
                        p_declaration_specifier->type_specifier_qualifier->type_specifier->flags) != 0)
                    {
                        //not fatal error
                    }

                    if (p_declaration_specifier->type_specifier_qualifier->type_specifier->struct_or_union_specifier)
                    {
                        p_declaration_specifiers->struct_or_union_specifier = p_declaration_specifier->type_specifier_qualifier->type_specifier->struct_or_union_specifier;
                    }
                    else if (p_declaration_specifier->type_specifier_qualifier->type_specifier->enum_specifier)
                    {
                        p_declaration_specifiers->enum_specifier = p_declaration_specifier->type_specifier_qualifier->type_specifier->enum_specifier;
                    }
                    else if (p_declaration_specifier->type_specifier_qualifier->type_specifier->typeof_specifier)
                    {
                        p_declaration_specifiers->typeof_specifier = p_declaration_specifier->type_specifier_qualifier->type_specifier->typeof_specifier;
                    }
                    else if (p_declaration_specifier->type_specifier_qualifier->type_specifier->token->type == TK_IDENTIFIER)
                    {
                        p_declaration_specifiers->typedef_declarator =
                            find_declarator(ctx,
                                p_declaration_specifier->type_specifier_qualifier->type_specifier->token->lexeme,
                                NULL);

                        // p_declaration_specifiers->typedef_declarator = p_declaration_specifier->type_specifier_qualifier->pType_specifier->token->lexeme;
                    }
                }
                else if (p_declaration_specifier->type_specifier_qualifier->type_qualifier)
                {
                    p_declaration_specifiers->type_qualifier_flags |= p_declaration_specifier->type_specifier_qualifier->type_qualifier->flags;
                }
            }
            else if (p_declaration_specifier->storage_class_specifier)
            {
                p_declaration_specifiers->storage_class_specifier_flags |= p_declaration_specifier->storage_class_specifier->flags;
            }

            declaration_specifiers_add(p_declaration_specifiers, p_declaration_specifier);

            assert(p_declaration_specifiers->p_attribute_specifier_sequence_opt == NULL);
            p_declaration_specifiers->p_attribute_specifier_sequence_opt = attribute_specifier_sequence_opt(ctx);

            if (ctx->current == NULL) throw;

            if (ctx->current->type == TK_IDENTIFIER &&
                p_declaration_specifiers->type_specifier_flags != TYPE_SPECIFIER_NONE)
            {
                // typedef nao pode aparecer com outro especifier
                // entao ja tem tem algo e vier identifier signfica que acabou
                // exemplo
                /*
                 typedef char X;
                 typedef char X;
                */
                break;
            }
        }

        struct token* _Opt prev = previous_parser_token(ctx->current);
        if (prev == NULL)
            throw;

        p_declaration_specifiers->last_token = prev;

        // int main() { static int i; } // i is not automatic
        final_specifier(ctx, &p_declaration_specifiers->type_specifier_flags);

        p_declaration_specifiers->storage_class_specifier_flags |= default_storage_flag;

        if (p_declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_STATIC)
        {
            //
            p_declaration_specifiers->storage_class_specifier_flags &= ~STORAGE_SPECIFIER_AUTOMATIC_STORAGE;
        }
    }
    catch
    {
        declaration_specifiers_delete(p_declaration_specifiers);
        p_declaration_specifiers = NULL;
    }
    return p_declaration_specifiers;
}

struct declaration* _Owner _Opt declaration_core(struct parser_ctx* ctx,
    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt /*SINK*/,
    bool can_be_function_definition,
    bool* is_function_definition,
    enum storage_class_specifier_flags default_storage_class_specifier_flags,
    bool without_semicolon)
{
    /*
                                  declaration-specifiers init-declarator-list_opt ;
     attribute-specifier-sequence declaration-specifiers init-declarator-list ;
     static_assert-declaration
     attribute-declaration
  */

    struct declaration* _Owner _Opt p_declaration = NULL;

    try
    {
        if (ctx->current == NULL)
        {
            throw;
        }

        p_declaration = calloc(1, sizeof(struct declaration));
        if (p_declaration == NULL)
        {
            throw;
        }

        p_declaration->p_attribute_specifier_sequence_opt = p_attribute_specifier_sequence_opt;
        p_attribute_specifier_sequence_opt = NULL; /*MOVED*/

        p_declaration->first_token = ctx->current;

        if (ctx->current->type == ';')
        {
            parser_match(ctx);
            // empty declaration
            return p_declaration;
        }

        if (first_of_static_assert_declaration(ctx))
        {
            p_declaration->static_assert_declaration = static_assert_declaration(ctx);
        }
        else if (first_of_pragma_declaration(ctx))
        {
            p_declaration->pragma_declaration = pragma_declaration(ctx);
        }
        else
        {

            if (first_of_declaration_specifier(ctx))
            {
                p_declaration->declaration_specifiers = declaration_specifiers(ctx, default_storage_class_specifier_flags);
                if (p_declaration->declaration_specifiers == NULL) throw;

                if (p_declaration->p_attribute_specifier_sequence_opt)
                {
                    p_declaration->declaration_specifiers->attributes_flags =
                        p_declaration->p_attribute_specifier_sequence_opt->attributes_flags;
                }

                if (ctx->current == NULL)
                {
                    throw;
                }

                if (ctx->current->type != ';')
                {
                    p_declaration->init_declarator_list = init_declarator_list(ctx,
                        p_declaration->declaration_specifiers);
                }

                if (ctx->current == NULL)
                {
                    throw;
                }

                p_declaration->last_token = ctx->current;

                if (ctx->current->type == '{')
                {
                    if (can_be_function_definition)
                        *is_function_definition = true;
                }
                else
                {
                    if (!without_semicolon && parser_match_tk(ctx, ';') != 0)
                        throw;
                }
            }
            else
            {
                if (ctx->current->type == TK_IDENTIFIER)
                {
                    compiler_diagnostic_message(C_ERROR_INVALID_TYPE, ctx, ctx->current, NULL, "invalid type '%s'", ctx->current->lexeme);
                }
                else
                {
                    compiler_diagnostic_message(C_ERROR_EXPECTED_DECLARATION, ctx, ctx->current, NULL, "expected declaration not '%s'", ctx->current->lexeme);
                }
                parser_match(ctx); // we need to go ahead
            }
        }
    }
    catch
    {
        declaration_delete(p_declaration);
        p_declaration = NULL;
    }

    attribute_specifier_sequence_delete(p_attribute_specifier_sequence_opt);

    return p_declaration;
}

struct declaration* _Owner _Opt function_definition_or_declaration(struct parser_ctx* ctx)
{
    /*
     function-definition:
        attribute-specifier-sequence _Opt declaration-specifiers declarator function-body
    */

    /*
      declaration:
        declaration-specifiers                              init-declarator-list _Opt ;
        attribute-specifier-sequence declaration-specifiers init-declarator-list ;
        static_assert-declaration
        attribute-declaration
    */


    struct declaration* _Owner _Opt p_declaration = NULL;
    try
    {
        if (ctx->current == NULL)
            throw;

        struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt =
            attribute_specifier_sequence_opt(ctx);

        bool is_function_definition = false;

        p_declaration = declaration_core(ctx, p_attribute_specifier_sequence_opt, true, &is_function_definition, STORAGE_SPECIFIER_EXTERN, false);
        if (p_declaration == NULL)
            throw;

        if (is_function_definition)
        {

            if (p_declaration->init_declarator_list.head == NULL ||
                p_declaration->init_declarator_list.head->p_declarator->direct_declarator == NULL ||
                p_declaration->init_declarator_list.head->p_declarator->direct_declarator->function_declarator == NULL)
            {
                throw; //unexpected
            }

            ctx->p_current_function_opt = p_declaration;

            /*
                scope of parameters is the inner declarator

                void (*f(int i))(void) {
                    i = 1;
                    return 0;
                }
            */

            struct declarator* inner = p_declaration->init_declarator_list.head->p_declarator;
            for (;;)
            {
                if (inner->direct_declarator &&
                    inner->direct_declarator->function_declarator &&
                    inner->direct_declarator->function_declarator->direct_declarator &&
                    inner->direct_declarator->function_declarator->direct_declarator->declarator)
                {
                    inner = inner->direct_declarator->function_declarator->direct_declarator->declarator;
                }
                else
                    break;
            }

            struct scope* parameters_scope = &inner->direct_declarator->function_declarator->parameters_scope;
            scope_list_push(&ctx->scopes, parameters_scope);

            if (ctx->current == NULL)
            {
                throw;
            }
            check_func_open_brace_style(ctx, ctx->current);

            struct diagnostic before_function_diagnostics = ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index];

            struct compound_statement* _Owner _Opt p_function_body = function_body(ctx);
            if (p_function_body == NULL)
                throw;

            assert(p_declaration->function_body == NULL);
            p_declaration->function_body = p_function_body;

            p_declaration->init_declarator_list.head->p_declarator->function_body = p_declaration->function_body;

            if (ctx->options.flow_analysis)
            {
                /*
                 Now we have the full function AST let´s visit to Analise
                 jumps
                */

                /*we are going to visit the function again.. lets put the same diagnostic state*/
                ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index] = before_function_diagnostics;

                struct flow_visit_ctx ctx2 = { 0 };
                ctx2.ctx = ctx;
                flow_start_visit_declaration(&ctx2, p_declaration);
                flow_visit_ctx_destroy(&ctx2);
            }

            struct parameter_declaration* _Opt parameter = NULL;

            if (p_declaration->init_declarator_list.head->p_declarator->direct_declarator->function_declarator &&
                p_declaration->init_declarator_list.head->p_declarator->direct_declarator->function_declarator->parameter_type_list_opt &&
                p_declaration->init_declarator_list.head->p_declarator->direct_declarator->function_declarator->parameter_type_list_opt->parameter_list)
            {
                parameter = p_declaration->init_declarator_list.head->p_declarator->direct_declarator->function_declarator->parameter_type_list_opt->parameter_list->head;
            }

            /*parametros nao usados*/
            while (parameter)
            {
                if (!type_is_maybe_unused(&parameter->declarator->type) &&
                    parameter->declarator &&
                    parameter->declarator->num_uses == 0)
                {
                    if (parameter->declarator->name_opt &&
                        parameter->declarator->name_opt->level == 0 /*direct source*/
                        )
                    {
                        compiler_diagnostic_message(W_UNUSED_PARAMETER,
                            ctx,
                            parameter->declarator->name_opt, NULL,
                            "'%s': unreferenced formal parameter",
                            parameter->declarator->name_opt->lexeme);
                    }
                }
                parameter = parameter->next;
            }

            scope_list_pop(&ctx->scopes);
            ctx->p_current_function_opt = NULL;
        }
        else
        {
            if (ctx->options.flow_analysis)
            {
                /*
                 *  The objetive of this visit is to initialize global objects.
                 *  It also executes static_debug
                 */
                struct flow_visit_ctx ctx2 = { 0 };
                ctx2.ctx = ctx;
                flow_start_visit_declaration(&ctx2, p_declaration);
                flow_visit_ctx_destroy(&ctx2);
            }
        }
    }
    catch
    {
        declaration_delete(p_declaration);
        p_declaration = NULL;
    }

    return p_declaration;
}

struct simple_declaration* _Owner _Opt simple_declaration(struct parser_ctx* ctx,
    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt,
    bool ignore_semicolon)
{

    if (ctx->current == NULL)
    {
        attribute_specifier_sequence_delete(p_attribute_specifier_sequence_opt);
        return NULL;
    }

    enum storage_class_specifier_flags storage_specifier_flags = STORAGE_SPECIFIER_AUTOMATIC_STORAGE;
    /*
      simple-declaration:
      declaration-specifiers init-declarator-list _Opt ;
      attribute-specifier-sequence declaration-specifiers init-declarator-list ;
    */

    struct simple_declaration* _Owner _Opt p_simple_declaration = calloc(1, sizeof(struct simple_declaration));

    try
    {
        if (p_simple_declaration == NULL)
            throw;

        p_simple_declaration->first_token = ctx->current;

        p_simple_declaration->p_attribute_specifier_sequence_opt = p_attribute_specifier_sequence_opt;
        p_attribute_specifier_sequence_opt = NULL; /*MOVED*/

        struct declaration_specifiers* _Owner _Opt ptemp = declaration_specifiers(ctx, storage_specifier_flags);
        if (ptemp == NULL) throw;

        p_simple_declaration->p_declaration_specifiers = ptemp;

        if (p_simple_declaration->p_attribute_specifier_sequence_opt)
        {
            p_simple_declaration->p_declaration_specifiers->attributes_flags =
                p_simple_declaration->p_attribute_specifier_sequence_opt->attributes_flags;
        }

        p_simple_declaration->init_declarator_list = init_declarator_list(ctx, p_simple_declaration->p_declaration_specifiers);

        if (ctx->current == NULL) throw;

        struct token* _Opt prev = previous_parser_token(ctx->current);
        if (prev == NULL) throw;

        p_simple_declaration->last_token = prev;

        if (!ignore_semicolon && parser_match_tk(ctx, ';') != 0) throw;
    }
    catch
    {
        simple_declaration_delete(p_simple_declaration);
        p_simple_declaration = NULL;
    }

    attribute_specifier_sequence_delete(p_attribute_specifier_sequence_opt);

    return p_simple_declaration;
}

struct declaration* _Owner _Opt declaration(struct parser_ctx* ctx,
    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt,
    enum storage_class_specifier_flags storage_specifier_flags)
{
    bool is_function_definition = false;
    return declaration_core(ctx, p_attribute_specifier_sequence_opt, false, &is_function_definition, storage_specifier_flags, false);
}

//(6.7) declaration-specifiers:
// declaration-specifier attribute-specifier-sequenceopt
// declaration-specifier declaration-specifiers

void declaration_specifier_delete(struct declaration_specifier* _Owner _Opt p)
{
    if (p)
    {
        free(p->function_specifier);
        type_specifier_qualifier_delete(p->type_specifier_qualifier);
        free(p->storage_class_specifier);
        assert(p->next == NULL);
        free(p);
    }
}

struct declaration_specifier* _Owner _Opt declaration_specifier(struct parser_ctx* ctx)
{
    //    storage-class-specifier
    //    type-specifier-qualifier
    //    function-specifier

    struct declaration_specifier* _Owner _Opt p_declaration_specifier = NULL;
    try
    {
        p_declaration_specifier = calloc(1, sizeof * p_declaration_specifier);
        if (p_declaration_specifier == NULL)
            throw;

        if (first_of_storage_class_specifier(ctx))
        {
            p_declaration_specifier->storage_class_specifier = storage_class_specifier(ctx);
            if (p_declaration_specifier->storage_class_specifier == NULL) throw;
        }
        else if (first_of_type_specifier_qualifier(ctx))
        {
            p_declaration_specifier->type_specifier_qualifier = type_specifier_qualifier(ctx);
            if (p_declaration_specifier->type_specifier_qualifier == NULL) throw;
        }
        else if (first_of_function_specifier(ctx))
        {
            p_declaration_specifier->function_specifier = function_specifier(ctx);
            if (p_declaration_specifier->function_specifier == NULL) throw;
        }
        else
        {
            compiler_diagnostic_message(C_ERROR_UNEXPECTED, ctx, ctx->current, NULL, "unexpected");
        }
    }
    catch
    {
        declaration_specifier_delete(p_declaration_specifier);
        p_declaration_specifier = NULL;
    }

    return p_declaration_specifier;
}

void init_declarator_delete(struct init_declarator* _Owner _Opt p)
{
    if (p)
    {
        initializer_delete(p->initializer);
        declarator_delete(p->p_declarator);
        assert(p->next == NULL);
        free(p);
    }
}
struct init_declarator* _Owner _Opt init_declarator(struct parser_ctx* ctx,
    struct declaration_specifiers* p_declaration_specifiers)
{
    /*
     init-declarator:
       declarator
       declarator = initializer
    */
    struct init_declarator* _Owner _Opt p_init_declarator = NULL;
    try
    {
        p_init_declarator = calloc(1, sizeof(struct init_declarator));
        if (p_init_declarator == NULL)
            throw;

        struct token* _Opt tkname = NULL;

        struct declarator* _Owner _Opt p_temp_declarator = declarator(ctx,
            NULL,
            p_declaration_specifiers,
            false,
            &tkname);

        if (p_temp_declarator == NULL) throw;

        p_init_declarator->p_declarator = p_temp_declarator;
        p_init_declarator->p_declarator->name_opt = tkname;

        if (tkname == NULL)
        {
            compiler_diagnostic_message(C_ERROR_UNEXPECTED, ctx, ctx->current, NULL, "empty declarator name?? unexpected");
            return p_init_declarator;
        }

        p_init_declarator->p_declarator->declaration_specifiers = p_declaration_specifiers;
        p_init_declarator->p_declarator->name_opt = tkname;

        if (p_init_declarator->p_declarator->declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_AUTO)
        {
            /*
              auto requires we find the type after initializer
            */
        }
        else
        {
#pragma cake diagnostic push
#pragma cake diagnostic ignored "-Wmissing-destructor"
            assert(p_init_declarator->p_declarator->type.type_specifier_flags == 0);
            p_init_declarator->p_declarator->type = make_type_using_declarator(ctx, p_init_declarator->p_declarator);
#pragma cake diagnostic pop

        }

        const char* name = p_init_declarator->p_declarator->name_opt->lexeme;
        if (name)
        {
            assert(p_init_declarator->p_declarator->declaration_specifiers != NULL);

            /*
              Checking naming conventions
            */
            if (ctx->scopes.tail->scope_level == 0)
            {
                if (type_is_function(&p_init_declarator->p_declarator->type))
                {
                    naming_convention_global_var(ctx,
                        tkname,
                        &p_init_declarator->p_declarator->type,
                        p_init_declarator->p_declarator->declaration_specifiers->storage_class_specifier_flags);
                }
                else
                {
                    naming_convention_global_var(ctx,
                        tkname,
                        &p_init_declarator->p_declarator->type,
                        p_init_declarator->p_declarator->declaration_specifiers->storage_class_specifier_flags);
                }
            }

            struct scope* _Opt out_scope = NULL;
            struct declarator* _Opt previous = find_declarator(ctx, name, &out_scope);
            if (previous)
            {
                assert(out_scope != NULL);

                if (out_scope->scope_level == ctx->scopes.tail->scope_level)
                {
                    if (out_scope->scope_level == 0)
                    {
                        /*file scope*/
                        if (!type_is_same(&previous->type, &p_init_declarator->p_declarator->type, true))
                        {
                            // TODO failing on windows headers
                            // parser_seterror_with_token(ctx, p_init_declarator->declarator->name, "redeclaration of  '%s' with diferent types", previous->name->lexeme);
                            // parser_set_info_with_token(ctx, previous->name, "previous declaration");
                        }
                    }
                    else
                    {
                        compiler_diagnostic_message(C_ERROR_REDECLARATION, ctx, ctx->current, NULL, "redeclaration");
                        compiler_diagnostic_message(W_NOTE, ctx, previous->name_opt, NULL, "previous declaration");
                    }
                }
                else
                {
                    hashmap_set(&ctx->scopes.tail->variables, name, p_init_declarator, TAG_TYPE_INIT_DECLARATOR);

                    /*global scope no warning...*/
                    if (out_scope->scope_level != 0)
                    {
                        /*but redeclaration at function scope we show warning*/
                        if (compiler_diagnostic_message(W_DECLARATOR_HIDE, ctx, p_init_declarator->p_declarator->first_token_opt, NULL, "declaration of '%s' hides previous declaration", name))
                        {
                            compiler_diagnostic_message(W_NOTE, ctx, previous->first_token_opt, NULL, "previous declaration is here");
                        }
                    }
                }
            }
            else
            {
                /*first time we see this declarator*/
                hashmap_set(&ctx->scopes.tail->variables, name, p_init_declarator, TAG_TYPE_INIT_DECLARATOR);
            }
        }
        else
        {
            assert(false);
        }

        if (ctx->current == NULL) throw;

        if (ctx->current->type == '=')
        {
            parser_match(ctx);
            p_init_declarator->initializer = initializer(ctx);

            if (p_init_declarator->initializer == NULL)
            {
                throw;
            }

            if (p_init_declarator->initializer->braced_initializer)
            {
                if (type_is_array(&p_init_declarator->p_declarator->type))
                {
                    const int sz = p_init_declarator->p_declarator->type.num_of_elements;
                    if (sz == 0)
                    {
                        /*int a[] = {1, 2, 3}*/
                        int braced_initializer_size = 0;

                        if (p_init_declarator->initializer->braced_initializer->initializer_list)
                        {
                            braced_initializer_size = p_init_declarator->initializer->braced_initializer->initializer_list->size;
                        }
                        else
                        {
                            /*
                               char s[] = {};
                               warning: zero size arrays are an extension [-Wzero-length-array]
                            */
                        }

                        p_init_declarator->p_declarator->type.num_of_elements = braced_initializer_size;
                    }
                    else
                    {
                        if (p_init_declarator->initializer->braced_initializer->initializer_list &&
                            p_init_declarator->initializer->braced_initializer->initializer_list->size > sz)
                        {
                            if (p_init_declarator->p_declarator->first_token_opt)
                            {
                                compiler_diagnostic_message(W_ARRAY_SIZE, ctx, p_init_declarator->p_declarator->first_token_opt, NULL, "initializer for array is too long");
                            }
                        }
                    }
                }

                /*
                  Fixing the type of auto declarator
                  ??
                */
            }
            else if (p_init_declarator->initializer->assignment_expression)
            {
                if (type_is_array(&p_init_declarator->p_declarator->type))
                {
                    const int array_size_elements = p_init_declarator->p_declarator->type.num_of_elements;
                    if (array_size_elements == 0)
                    {
                        p_init_declarator->p_declarator->type.num_of_elements =
                            p_init_declarator->initializer->assignment_expression->type.num_of_elements;
                    }
                    else
                    {
                        if (p_init_declarator->initializer->assignment_expression->type.num_of_elements > array_size_elements)
                        {
                            if (p_init_declarator->p_declarator->first_token_opt)
                            {
                                compiler_diagnostic_message(W_ARRAY_SIZE, ctx, p_init_declarator->p_declarator->first_token_opt, NULL, "initializer for array is too long");
                            }
                        }
                    }
                }

                /*
                  Fixing the type of auto declarator
                */
                assert(p_init_declarator->p_declarator->declaration_specifiers != NULL);

                if (p_init_declarator->p_declarator->declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_AUTO)
                {

                    if (p_init_declarator->p_declarator->direct_declarator &&
                        p_init_declarator->p_declarator->direct_declarator->array_declarator != NULL ||
                        p_init_declarator->p_declarator->direct_declarator->function_declarator != NULL)
                    {
                        compiler_diagnostic_message(C_ERROR_AUTO_NEEDS_SINGLE_DECLARATOR, ctx, p_init_declarator->p_declarator->first_token_opt, NULL, "'auto' requires a plain identifier");
                        throw;
                    }
                    if (p_init_declarator->p_declarator->pointer != NULL)
                    {
                        compiler_diagnostic_message(C_ERROR_AUTO_NEEDS_SINGLE_DECLARATOR, ctx, p_init_declarator->p_declarator->first_token_opt, NULL, "'auto' requires a plain identifier");
                        throw;
                    }

                    struct type t = { 0 };

                    if (p_init_declarator->initializer->assignment_expression->expression_type == UNARY_EXPRESSION_ADDRESSOF)
                    {
                        t = type_dup(&p_init_declarator->initializer->assignment_expression->type);
                    }
                    else
                    {
                        struct type t2 = type_lvalue_conversion(&p_init_declarator->initializer->assignment_expression->type, ctx->options.null_checks_enabled);
                        type_swap(&t2, &t);
                        type_destroy(&t2);
                    }

                    type_remove_names(&t);
                    assert(t.name_opt == NULL);
                    t.name_opt = strdup(p_init_declarator->p_declarator->name_opt->lexeme);

                    type_set_qualifiers_using_declarator(&t, p_init_declarator->p_declarator);

                    type_visit_to_mark_anonymous(&t);
                    type_swap(&p_init_declarator->p_declarator->type, &t);
                    type_destroy(&t);
                }

                check_assigment(ctx, &p_init_declarator->p_declarator->type, p_init_declarator->initializer->assignment_expression, ASSIGMENT_TYPE_OBJECTS);
            }
        }
        else
        {
            if (type_is_const(&p_init_declarator->p_declarator->type))
            {
                if (p_declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_TYPEDEF)
                {
                    //no warning on typedefs
                }
                else
                {
                    compiler_diagnostic_message(W_CONST_NOT_INITIALIZED,
                        ctx,
                        p_init_declarator->p_declarator->first_token_opt, NULL,
                        "const object should be initialized");
                }
            }
        }

        /*
           checking usage of [static ] other than in function arguments
        */
        if (p_init_declarator->p_declarator)
        {
            if (type_is_array(&p_init_declarator->p_declarator->type))
                if (p_init_declarator->p_declarator->type.type_qualifier_flags != 0 ||
                    p_init_declarator->p_declarator->type.static_array)
                {
                    if (p_init_declarator->p_declarator->first_token_opt)
                    {
                        compiler_diagnostic_message(C_ERROR_STATIC_OR_TYPE_QUALIFIERS_NOT_ALLOWED_IN_NON_PARAMETER,
                            ctx,
                            p_init_declarator->p_declarator->first_token_opt, NULL,
                            "static or type qualifiers are not allowed in non-parameter array declarator");
                    }
                    else
                    {
                        compiler_diagnostic_message(C_ERROR_STATIC_OR_TYPE_QUALIFIERS_NOT_ALLOWED_IN_NON_PARAMETER,
                        ctx,
                        p_init_declarator->initializer->first_token, NULL,
                        "static or type qualifiers are not allowed in non-parameter array declarator");
                    }
                }

            if (!type_is_pointer(&p_init_declarator->p_declarator->type) &&
                p_init_declarator->p_declarator->type.type_qualifier_flags & TYPE_QUALIFIER_OBJ_OWNER)
            {
                if (p_init_declarator->p_declarator->first_token_opt)
                {
                    compiler_diagnostic_message(C_ERROR_OBJ_OWNER_CAN_BE_USED_ONLY_IN_POINTER,
                        ctx,
                        p_init_declarator->p_declarator->first_token_opt, NULL,
                        "_Obj_owner qualifier can only be used with pointers");
                }
                else
                {
                    compiler_diagnostic_message(C_ERROR_OBJ_OWNER_CAN_BE_USED_ONLY_IN_POINTER,
                    ctx,
                    p_init_declarator->initializer->first_token, NULL,
                    "_Obj_owner qualifier can only be used with pointers");
                }
            }
        }

        if (
            !(p_init_declarator->p_declarator->type.storage_class_specifier_flags & STORAGE_SPECIFIER_TYPEDEF) &&
            !type_is_function(&p_init_declarator->p_declarator->type))
        {

            if (type_is_vla(&p_init_declarator->p_declarator->type))
            {
            }
            else
            {
                int sz = type_get_sizeof(&p_init_declarator->p_declarator->type);

                if (sz == -3)
                {
                    /*type_get_sizeof returns -3 for VLAs*/
                }
                else if (sz < 0)
                {
                    // clang warning: array 'c' assumed to have one element
                    // gcc "error: storage size of '%s' isn't known"
                    compiler_diagnostic_message(C_ERROR_STORAGE_SIZE,
                        ctx,
                        p_init_declarator->p_declarator->name_opt, NULL,
                        "storage size of '%s' isn't known",
                        p_init_declarator->p_declarator->name_opt->lexeme);
                }
                else
                {
                    // ok
                }
            }
        }
    }
    catch
    {
        init_declarator_delete(p_init_declarator);
        p_init_declarator = NULL;
    }

    return p_init_declarator;
}

void init_declarator_list_add(struct init_declarator_list* list, struct init_declarator* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void init_declarator_list_destroy(struct init_declarator_list* _Obj_owner p)
{
    struct init_declarator* _Owner _Opt item = p->head;
    while (item)
    {
        struct init_declarator* _Owner _Opt next = item->next;
        item->next = NULL;
        init_declarator_delete(item);
        item = next;
    }
}

struct init_declarator_list init_declarator_list(struct parser_ctx* ctx,
    struct declaration_specifiers* p_declaration_specifiers)
{
    /*
    init-declarator-list:
      init-declarator
      init-declarator-list , init-declarator
    */
    struct init_declarator_list init_declarator_list = { 0 };
    struct init_declarator* _Owner _Opt p_init_declarator = NULL;

    try
    {
        p_init_declarator = init_declarator(ctx, p_declaration_specifiers);

        if (p_init_declarator == NULL)
            throw;

        init_declarator_list_add(&init_declarator_list, p_init_declarator);
        p_init_declarator = NULL; /*MOVED*/

        while (ctx->current != NULL && ctx->current->type == ',')
        {
            parser_match(ctx);
            p_init_declarator = init_declarator(ctx, p_declaration_specifiers);
            if (p_init_declarator == NULL)
                throw;

            init_declarator_list_add(&init_declarator_list, p_init_declarator);
            p_init_declarator = NULL; /*MOVED*/
        }
    }
    catch
    {
    }

    return init_declarator_list;
}

void storage_class_specifier_delete(struct storage_class_specifier* _Owner _Opt p)
{
    if (p)
    {
        free(p);
    }
}

struct storage_class_specifier* _Owner _Opt storage_class_specifier(struct parser_ctx* ctx)
{
    struct storage_class_specifier* _Owner _Opt p_storage_class_specifier = NULL;
    try
    {
        if (ctx->current == NULL)
            throw;

        p_storage_class_specifier = calloc(1, sizeof(struct storage_class_specifier));
        if (p_storage_class_specifier == NULL)
            throw;

        p_storage_class_specifier->token = ctx->current;
        switch (ctx->current->type)
        {
        case TK_KEYWORD_TYPEDEF:
            p_storage_class_specifier->flags = STORAGE_SPECIFIER_TYPEDEF;
            break;
        case TK_KEYWORD_EXTERN:
            p_storage_class_specifier->flags = STORAGE_SPECIFIER_EXTERN;
            break;
        case TK_KEYWORD_CONSTEXPR:

            p_storage_class_specifier->flags = STORAGE_SPECIFIER_CONSTEXPR;
            if (ctx->scopes.tail->scope_level == 0)
                p_storage_class_specifier->flags |= STORAGE_SPECIFIER_CONSTEXPR_STATIC;
            break;
        case TK_KEYWORD_STATIC:
            p_storage_class_specifier->flags = STORAGE_SPECIFIER_STATIC;
            break;
        case TK_KEYWORD__THREAD_LOCAL:
            p_storage_class_specifier->flags = STORAGE_SPECIFIER_THREAD_LOCAL;
            break;
        case TK_KEYWORD_AUTO:
            p_storage_class_specifier->flags = STORAGE_SPECIFIER_AUTO;
            break;
        case TK_KEYWORD_REGISTER:
            p_storage_class_specifier->flags = STORAGE_SPECIFIER_REGISTER;
            break;
        default:
            assert(false);
        }

        /*
         TODO
         thread_local may appear with static or extern,
         auto may appear with all the others except typedef138), and
         constexpr may appear with auto, register, or static.
        */

        parser_match(ctx);
    }
    catch
    {
        storage_class_specifier_delete(p_storage_class_specifier);
        p_storage_class_specifier = NULL;
    }

    return p_storage_class_specifier;
}

struct typeof_specifier_argument* _Owner _Opt typeof_specifier_argument(struct parser_ctx* ctx)
{
    struct typeof_specifier_argument* _Owner _Opt new_typeof_specifier_argument = NULL;
    try
    {
        new_typeof_specifier_argument = calloc(1, sizeof(struct typeof_specifier_argument));
        if (new_typeof_specifier_argument == NULL)
            throw;

        if (first_of_type_name(ctx))
        {
            new_typeof_specifier_argument->type_name = type_name(ctx);
        }
        else
        {
            const bool disable_evaluation_copy = ctx->evaluation_is_disabled;
            ctx->evaluation_is_disabled = true;
            new_typeof_specifier_argument->expression = expression(ctx);
            /*restore*/
            ctx->evaluation_is_disabled = disable_evaluation_copy;

            if (new_typeof_specifier_argument->expression == NULL)
                throw;

            // declarator_type_clear_name(new_typeof_specifier_argument->expression->type.declarator_type);
        }
    }
    catch
    {
        typeof_specifier_argument_delete(new_typeof_specifier_argument);
        new_typeof_specifier_argument = NULL;
    }

    return new_typeof_specifier_argument;
}

bool first_of_typeof_specifier(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    return ctx->current->type == TK_KEYWORD_TYPEOF ||
        ctx->current->type == TK_KEYWORD_TYPEOF_UNQUAL;
}

struct typeof_specifier* _Owner _Opt  typeof_specifier(struct parser_ctx* ctx)
{
    struct typeof_specifier* _Owner _Opt p_typeof_specifier = NULL;
    try
    {
        if (ctx->current == NULL)
            throw;

        p_typeof_specifier = calloc(1, sizeof(struct typeof_specifier));
        if (p_typeof_specifier == NULL)
            throw;

        p_typeof_specifier->first_token = ctx->current;

        const bool is_typeof_unqual = ctx->current->type == TK_KEYWORD_TYPEOF_UNQUAL;
        parser_match(ctx);
        if (parser_match_tk(ctx, '(') != 0)
            throw;

        p_typeof_specifier->typeof_specifier_argument = typeof_specifier_argument(ctx);
        if (p_typeof_specifier->typeof_specifier_argument == NULL)
            throw;

        if (p_typeof_specifier->typeof_specifier_argument->expression)
        {
            p_typeof_specifier->type = type_dup(&p_typeof_specifier->typeof_specifier_argument->expression->type);
        }
        else if (p_typeof_specifier->typeof_specifier_argument->type_name)
        {
            p_typeof_specifier->type = type_dup(&p_typeof_specifier->typeof_specifier_argument->type_name->abstract_declarator->type);
        }

        if (p_typeof_specifier->type.storage_class_specifier_flags & STORAGE_SPECIFIER_PARAMETER)
        {
            compiler_diagnostic_message(W_TYPEOF_ARRAY_PARAMETER, ctx, ctx->current, NULL, "typeof used in array arguments");

            if (type_is_array(&p_typeof_specifier->type))
            {
                struct type t = type_param_array_to_pointer(&p_typeof_specifier->type, ctx->options.null_checks_enabled);
                type_swap(&t, &p_typeof_specifier->type);
                type_destroy(&t);
            }
        }

        if (is_typeof_unqual)
        {
            type_remove_qualifiers(&p_typeof_specifier->type);
        }

        type_visit_to_mark_anonymous(&p_typeof_specifier->type);

        free((void* _Owner)p_typeof_specifier->type.name_opt);
        p_typeof_specifier->type.name_opt = NULL;

        if (ctx->current == NULL)
            throw;

        p_typeof_specifier->last_token = ctx->current;
        if (parser_match_tk(ctx, ')') != 0) throw;
    }
    catch
    {
        typeof_specifier_delete(p_typeof_specifier);
        p_typeof_specifier = NULL;
    }

    return p_typeof_specifier;
}

void typeof_specifier_argument_delete(struct typeof_specifier_argument* _Owner _Opt p)
{
    if (p)
    {
        expression_delete(p->expression);
        type_name_delete(p->type_name);
        free(p);
    }
}

void typeof_specifier_delete(struct typeof_specifier* _Owner _Opt p)
{
    if (p)
    {
        typeof_specifier_argument_delete(p->typeof_specifier_argument);
        type_destroy(&p->type);
        free(p);
    }
}

void type_specifier_delete(struct type_specifier* _Owner _Opt p)
{
    if (p)
    {
        struct_or_union_specifier_delete(p->struct_or_union_specifier);
        typeof_specifier_delete(p->typeof_specifier);
        enum_specifier_delete(p->enum_specifier);
        atomic_type_specifier_delete(p->atomic_type_specifier);
        free(p);
    }
}
struct type_specifier* _Owner _Opt type_specifier(struct parser_ctx* ctx)
{
    /*
     type-specifier:
       void
       char
       short
       int
       long
       float
       double
       signed
       unsigned
       _BitInt ( constant-expression )
       bool                                  C23
       _Complex
       _Decimal32
       _Decimal64
       _Decimal128
       atomic-type-specifier
       struct-or-union-specifier
       enum-specifier
       typedef-name
       typeof-specifier                      C23
    */

    struct type_specifier* _Owner _Opt p_type_specifier = NULL;

    try
    {
        if (ctx->current == NULL)
            throw;

        p_type_specifier = calloc(1, sizeof * p_type_specifier);
        if (p_type_specifier == NULL)
            throw;

        switch (ctx->current->type)
        {
        case TK_KEYWORD_VOID:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_VOID;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD_CHAR:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_CHAR;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD_SHORT:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_SHORT;
            p_type_specifier->token = ctx->current;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD_INT:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_INT;
            p_type_specifier->token = ctx->current;
            parser_match(ctx);
            return p_type_specifier;

            // microsoft
        case TK_KEYWORD__INT8:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_INT8;
            p_type_specifier->token = ctx->current;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD__INT16:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_INT16;
            p_type_specifier->token = ctx->current;
            parser_match(ctx);
            return p_type_specifier;
        case TK_KEYWORD__INT32:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_INT32;
            p_type_specifier->token = ctx->current;
            parser_match(ctx);
            return p_type_specifier;
        case TK_KEYWORD__INT64:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_INT64;
            p_type_specifier->token = ctx->current;
            parser_match(ctx);
            return p_type_specifier;
            // end microsoft

        case TK_KEYWORD_LONG:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_LONG;
            p_type_specifier->token = ctx->current;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD_FLOAT:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_FLOAT;
            p_type_specifier->token = ctx->current;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD_DOUBLE:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_DOUBLE;
            p_type_specifier->token = ctx->current;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD_SIGNED:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_SIGNED;
            p_type_specifier->token = ctx->current;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD_UNSIGNED:

            p_type_specifier->flags = TYPE_SPECIFIER_UNSIGNED;
            p_type_specifier->token = ctx->current;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD__BOOL:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_BOOL;
            p_type_specifier->token = ctx->current;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD__COMPLEX:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_COMPLEX;
            p_type_specifier->token = ctx->current;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD__DECIMAL32:
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_DECIMAL32;
            p_type_specifier->token = ctx->current;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD__DECIMAL64:

            p_type_specifier->flags = TYPE_SPECIFIER_DECIMAL64;
            p_type_specifier->token = ctx->current;
            parser_match(ctx);
            return p_type_specifier;

        case TK_KEYWORD__DECIMAL128:
            p_type_specifier->flags = TYPE_SPECIFIER_DECIMAL128;
            p_type_specifier->token = ctx->current;
            parser_match(ctx);
            return p_type_specifier;

        default:
            // Do nothing
            break;
        }

        if (first_of_typeof_specifier(ctx))
        {
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_TYPEOF;
            p_type_specifier->typeof_specifier = typeof_specifier(ctx);
            if (p_type_specifier->typeof_specifier == NULL)
            {
                type_specifier_delete(p_type_specifier);
                return NULL;
            }

        }
        else if (first_of_atomic_type_specifier(ctx))
        {
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_ATOMIC;
            p_type_specifier->atomic_type_specifier = atomic_type_specifier(ctx);
            if (p_type_specifier->atomic_type_specifier == NULL)
            {
                type_specifier_delete(p_type_specifier);
                return NULL;
            }
        }
        else if (first_of_struct_or_union(ctx))
        {
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_STRUCT_OR_UNION;
            p_type_specifier->struct_or_union_specifier = struct_or_union_specifier(ctx);
            if (p_type_specifier->struct_or_union_specifier == NULL)
            {
                type_specifier_delete(p_type_specifier);
                return NULL;
            }
        }
        else if (first_of_enum_specifier(ctx))
        {
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_ENUM;
            p_type_specifier->enum_specifier = enum_specifier(ctx);
            if (p_type_specifier->enum_specifier == NULL)
            {
                type_specifier_delete(p_type_specifier);
                return NULL;
            }
        }
        else if (ctx->current->type == TK_KEYWORD__BITINT)
        {
            //TODO
            type_specifier_delete(p_type_specifier);
            return NULL;
        }
        else if (ctx->current->type == TK_IDENTIFIER)
        {
            p_type_specifier->token = ctx->current;
            p_type_specifier->flags = TYPE_SPECIFIER_TYPEDEF;

            p_type_specifier->typedef_declarator =
                find_declarator(ctx, ctx->current->lexeme, NULL);

            // Ser chegou aqui já tem que exitir (reaprovecitar?)
            assert(p_type_specifier->typedef_declarator != NULL);

            parser_match(ctx);
        }

    }
    catch
    {
        type_specifier_delete(p_type_specifier);
        p_type_specifier = NULL;
    }
    return p_type_specifier;
}

const struct enum_specifier* _Opt get_complete_enum_specifier(const struct enum_specifier* p_enum_specifier)
{
    /*
      The way cake find the complete struct is using one pass.. for this task is uses double indirection.
      Then the result will be there at end of first pass.
      This crazy code finds the complete definition of the struct if exists.
    */
    if (p_enum_specifier->enumerator_list.head)
    {
        /*p_struct_or_union_specifier is complete*/
        return p_enum_specifier;
    }
    else if (p_enum_specifier->complete_enum_specifier2 &&
        p_enum_specifier->complete_enum_specifier2->enumerator_list.head)
    {
        /*p_struct_or_union_specifier is the first seem tag tag points directly to complete*/
        return p_enum_specifier->complete_enum_specifier2;
    }
    else if (p_enum_specifier->complete_enum_specifier2 &&
        p_enum_specifier->complete_enum_specifier2->complete_enum_specifier2 &&
        p_enum_specifier->complete_enum_specifier2->complete_enum_specifier2->enumerator_list.head)
    {
        /* all others points to the first seem that points to the complete*/
        return p_enum_specifier->complete_enum_specifier2->complete_enum_specifier2;
    }

    return NULL;
}

struct struct_or_union_specifier* _Opt get_complete_struct_or_union_specifier(struct struct_or_union_specifier* p_struct_or_union_specifier)
{
    /*
      The way cake find the complete struct is using one pass.. for this task is uses double indirection.
      Then the result will be there at end of first pass.
      This crazy code finds the complete definition of the struct if exists.
    */


    if (p_struct_or_union_specifier->member_declaration_list.head)
    {
        /*p_struct_or_union_specifier is complete*/
        return p_struct_or_union_specifier;
    }
    else if (p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection &&
        p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection->member_declaration_list.head)
    {
        /*p_struct_or_union_specifier is the first seem tag tag points directly to complete*/
        return p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection;
    }
    else if (p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection &&
        p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection->complete_struct_or_union_specifier_indirection &&
        p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection->complete_struct_or_union_specifier_indirection->member_declaration_list.head)
    {
        /* all others points to the first seem that points to the complete*/
        return p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection->complete_struct_or_union_specifier_indirection;
    }

    return NULL;
}

bool struct_or_union_specifier_is_complete(struct struct_or_union_specifier* p_struct_or_union_specifier)
{
    return get_complete_struct_or_union_specifier(p_struct_or_union_specifier) != NULL;
}

void struct_or_union_specifier_delete(struct struct_or_union_specifier* _Owner _Opt p)
{
    if (p)
    {
        member_declaration_list_destroy(&p->member_declaration_list);
        attribute_specifier_sequence_delete(p->attribute_specifier_sequence_opt);
        free(p);
    }
}

struct struct_or_union_specifier* _Owner _Opt struct_or_union_specifier(struct parser_ctx* ctx)
{
    struct struct_or_union_specifier* _Owner _Opt p_struct_or_union_specifier = NULL;
    try
    {
        if (ctx->current == NULL)
            throw;

        p_struct_or_union_specifier = calloc(1, sizeof * p_struct_or_union_specifier);
        if (p_struct_or_union_specifier == NULL)
            throw;

        if (ctx->current->type == TK_KEYWORD_STRUCT ||
            ctx->current->type == TK_KEYWORD_UNION)
        {
            p_struct_or_union_specifier->first_token = ctx->current;
            parser_match(ctx);
        }
        else
        {
            throw;
        }

        p_struct_or_union_specifier->attribute_specifier_sequence_opt = attribute_specifier_sequence_opt(ctx);

        struct struct_or_union_specifier* p_first_tag_in_this_scope = NULL;

        if (ctx->current == NULL)
        {
            throw;
        }

        if (ctx->current->type == TK_IDENTIFIER)
        {
            p_struct_or_union_specifier->tagtoken = ctx->current;
            /*
             Structure, union, and enumeration tags have scope that begins just after the
             appearance of the tag in a type specifier that declares the tag.
            */

            snprintf(p_struct_or_union_specifier->tag_name, sizeof p_struct_or_union_specifier->tag_name, "%s", ctx->current->lexeme);

            struct map_entry* _Opt p_entry = hashmap_find(&ctx->scopes.tail->tags, ctx->current->lexeme);
            if (p_entry)
            {
                /*this tag already exist in this scope*/
                if (p_entry->type == TAG_TYPE_STRUCT_OR_UNION_SPECIFIER)
                {
                    p_first_tag_in_this_scope = p_entry->p;
                    p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection = p_first_tag_in_this_scope;
                }
                else
                {
                    compiler_diagnostic_message(C_ERROR_TAG_TYPE_DOES_NOT_MATCH_PREVIOUS_DECLARATION,
                        ctx,
                        ctx->current, NULL,
                        "use of '%s' with tag type that does not match previous declaration.",
                        ctx->current->lexeme);
                }
            }
            else
            {
                /*tag does not exist in the current scope, let search on upper scopes*/
                struct struct_or_union_specifier* _Opt p_first_tag_previous_scopes = find_struct_or_union_specifier(ctx, ctx->current->lexeme);
                if (p_first_tag_previous_scopes == NULL)
                {
                    /*tag not found, so it is the first appearence*/
                    p_struct_or_union_specifier->scope_level = ctx->scopes.tail->scope_level;
                    hashmap_set(&ctx->scopes.tail->tags, ctx->current->lexeme, p_struct_or_union_specifier, TAG_TYPE_STRUCT_OR_UNION_SPECIFIER);
                }
                else
                {
                    /*tag already exists in some scope*/
                    p_struct_or_union_specifier->complete_struct_or_union_specifier_indirection = p_first_tag_previous_scopes;
                }
            }

            parser_match(ctx);
        }
        else
        {
            /*struct without a tag, in this case we make one*/
            snprintf(p_struct_or_union_specifier->tag_name, sizeof p_struct_or_union_specifier->tag_name, "_anonymous_struct_%d", s_anonymous_struct_count);
            s_anonymous_struct_count++;
            p_struct_or_union_specifier->has_anonymous_tag = true;
            p_struct_or_union_specifier->scope_level = ctx->scopes.tail->scope_level;
            hashmap_set(&ctx->scopes.tail->tags, p_struct_or_union_specifier->tag_name, p_struct_or_union_specifier, TAG_TYPE_STRUCT_OR_UNION_SPECIFIER);
        }

        if (ctx->current->type == '{')
        {
            /*
            this is the complete struct
            */

            struct struct_or_union_specifier* _Opt first = find_struct_or_union_specifier(ctx, p_struct_or_union_specifier->tag_name);

            if (first)
            {
                /*
                   The first tag (will the one at symbol table) will point to the complete struct
                */
                first->complete_struct_or_union_specifier_indirection = p_struct_or_union_specifier;
            }

            if (p_struct_or_union_specifier->tagtoken)
                naming_convention_struct_tag(ctx, p_struct_or_union_specifier->tagtoken);

            struct token* firsttoken = ctx->current;
            parser_match(ctx);
            if (ctx->current->type != '}') /*not official extensions yet..missing sizeof etc*/
            {
#pragma cake diagnostic push
#pragma cake diagnostic ignored "-Wmissing-destructor"
                p_struct_or_union_specifier->member_declaration_list = member_declaration_list(ctx, p_struct_or_union_specifier);
#pragma cake diagnostic pop

                //we cannot have an empty struct
                if (p_struct_or_union_specifier->member_declaration_list.head == NULL) throw;
            }
            p_struct_or_union_specifier->member_declaration_list.first_token = firsttoken;
            p_struct_or_union_specifier->last_token = ctx->current;
            p_struct_or_union_specifier->member_declaration_list.last_token = ctx->current;
            if (parser_match_tk(ctx, '}') != 0)
                throw;
        }
        else
        {
            p_struct_or_union_specifier->last_token = ctx->current;
        }

        struct struct_or_union_specifier* _Opt p_complete =
            get_complete_struct_or_union_specifier(p_struct_or_union_specifier);

        /*check if complete struct is deprecated*/
        if (p_complete)
        {
            if (p_complete->attribute_specifier_sequence_opt &&
                p_complete->attribute_specifier_sequence_opt->attributes_flags & STD_ATTRIBUTE_DEPRECATED)
            {
                if (p_struct_or_union_specifier->tagtoken)
                {
                    // TODO add deprecated message
                    compiler_diagnostic_message(W_DEPRECATED, ctx, p_struct_or_union_specifier->first_token, NULL, "'%s' is deprecated", p_struct_or_union_specifier->tagtoken->lexeme);
                }
                else
                {
                    compiler_diagnostic_message(W_DEPRECATED, ctx, p_struct_or_union_specifier->first_token, NULL, "deprecated");
                }
            }
        }
    }
    catch
    {
        struct_or_union_specifier_delete(p_struct_or_union_specifier);
        p_struct_or_union_specifier = NULL;
    }
    return p_struct_or_union_specifier;
}

struct member_declarator* _Owner _Opt member_declarator(
    struct parser_ctx* ctx,
    struct struct_or_union_specifier* p_struct_or_union_specifier, /*not const*/
    const struct specifier_qualifier_list* p_specifier_qualifier_list)
{
    /*
    member-declarator:
     declarator
     declaratoropt : constant-expression
    */
    struct member_declarator* _Owner _Opt p_member_declarator = NULL;
    try
    {
        p_member_declarator = calloc(1, sizeof(struct member_declarator));
        if (p_member_declarator == NULL) throw;

        struct token* _Opt p_token_name = NULL;

        p_member_declarator->declarator = declarator(ctx, p_specifier_qualifier_list, /*declaration_specifiers*/ NULL, false, &p_token_name);
        if (p_member_declarator->declarator == NULL) throw;

        p_member_declarator->declarator->name_opt = p_token_name;
        p_member_declarator->declarator->specifier_qualifier_list = p_specifier_qualifier_list;

#pragma cake diagnostic push
#pragma cake diagnostic ignored "-Wmissing-destructor"    
        p_member_declarator->declarator->type = make_type_using_declarator(ctx, p_member_declarator->declarator);
#pragma cake diagnostic pop

        /*extension*/
        if (type_is_owner(&p_member_declarator->declarator->type))
        {
            /*having at least 1 _Owner member, the struct type is _Owner by default*/
            p_struct_or_union_specifier->is_owner = true;
        }

        if (p_member_declarator->declarator->name_opt)
            naming_convention_struct_member(ctx, p_member_declarator->declarator->name_opt, &p_member_declarator->declarator->type);

        if (ctx->current == NULL)
        {
            throw;
        }

        if (ctx->current->type == ':')
        {
            parser_match(ctx);
            p_member_declarator->constant_expression = constant_expression(ctx, true);
        }
    }
    catch
    {
        member_declarator_delete(p_member_declarator);
        p_member_declarator = NULL;
    }
    return p_member_declarator;
}

void member_declarator_delete(struct member_declarator* _Owner _Opt p)
{
    if (p)
    {
        expression_delete(p->constant_expression);
        assert(p->next == NULL);
        declarator_delete(p->declarator);
        free(p);
    }
}

void member_declarator_list_add(struct member_declarator_list* list, struct member_declarator* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void member_declarator_list_delete(struct member_declarator_list* _Owner _Opt p)
{
    if (p)
    {
        struct member_declarator* _Owner _Opt item = p->head;
        while (item)
        {
            struct member_declarator* _Owner _Opt next = item->next;
            item->next = NULL;
            member_declarator_delete(item);
            item = next;
        }
        free(p);
    }
}
struct member_declarator_list* _Owner _Opt member_declarator_list(
    struct parser_ctx* ctx,
    struct struct_or_union_specifier* p_struct_or_union_specifier,
    const struct specifier_qualifier_list* p_specifier_qualifier_list)
{
    struct member_declarator_list* _Owner _Opt p_member_declarator_list = calloc(1, sizeof(struct member_declarator_list));
    try
    {
        if (p_member_declarator_list == NULL) throw;

        struct member_declarator* _Opt _Owner p_member_declarator = member_declarator(ctx, p_struct_or_union_specifier, p_specifier_qualifier_list);
        if (p_member_declarator == NULL) throw;

        member_declarator_list_add(p_member_declarator_list, p_member_declarator);

        if (ctx->current == NULL)
        {
            throw;
        }

        while (ctx->current->type == ',')
        {
            parser_match(ctx);

            if (ctx->current == NULL)
            {
                throw;
            }

            struct member_declarator* _Opt _Owner p_member_declarator2 = member_declarator(ctx, p_struct_or_union_specifier, p_specifier_qualifier_list);
            if (p_member_declarator2 == NULL) throw;

            member_declarator_list_add(p_member_declarator_list, p_member_declarator2);
        }
    }
    catch
    {
        member_declarator_list_delete(p_member_declarator_list);
        p_member_declarator_list = NULL;
    }

    return p_member_declarator_list;
}

void member_declaration_list_add(struct member_declaration_list* list, struct member_declaration* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void member_declaration_list_destroy(struct member_declaration_list* _Obj_owner p)
{
    struct member_declaration* _Owner _Opt item = p->head;
    while (item)
    {
        struct member_declaration* _Owner _Opt next = item->next;
        item->next = NULL;
        member_declaration_delete(item);
        item = next;
    }
}

struct member_declaration_list member_declaration_list(struct parser_ctx* ctx, struct struct_or_union_specifier* p_struct_or_union_specifier)
{
    struct member_declaration_list list = { 0 };
    // member_declaration
    // member_declaration_list member_declaration

    struct member_declaration* _Owner _Opt p_member_declaration = NULL;

    try
    {
        p_member_declaration = member_declaration(ctx, p_struct_or_union_specifier);

        if (p_member_declaration == NULL)
            throw;

        member_declaration_list_add(&list, p_member_declaration);
        p_member_declaration = NULL; /*MOVED*/

        while (ctx->current && ctx->current->type != '}')
        {
            p_member_declaration = member_declaration(ctx, p_struct_or_union_specifier);
            if (p_member_declaration == NULL)
                throw;
            member_declaration_list_add(&list, p_member_declaration);
            p_member_declaration = NULL; /*MOVED*/
        }
    }
    catch
    {
        member_declaration_list_destroy(&list);
        list = (struct member_declaration_list){ 0 };
    }

    return list;
}

void member_declaration_delete(struct member_declaration* _Owner _Opt p)
{
    if (p)
    {
        assert(p->next == NULL);
        specifier_qualifier_list_delete(p->specifier_qualifier_list);
        member_declarator_list_delete(p->member_declarator_list_opt);
        attribute_specifier_sequence_delete(p->p_attribute_specifier_sequence_opt);
        static_assert_declaration_delete(p->static_assert_declaration);
        pragma_declaration_delete(p->pragma_declaration);
        free(p);
    }
}

struct member_declaration* _Owner _Opt member_declaration(struct parser_ctx* ctx,
    struct struct_or_union_specifier* p_struct_or_union_specifier)
{
    struct member_declaration* _Owner _Opt p_member_declaration = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            throw;
        }

        p_member_declaration = calloc(1, sizeof(struct member_declaration));
        if (p_member_declaration == NULL)
            throw;

        // attribute_specifier_sequence_opt specifier_qualifier_list member_declarator_list_opt ';'
        // static_assert_declaration
        if (ctx->current->type == TK_KEYWORD__STATIC_ASSERT)
        {
            p_member_declaration->static_assert_declaration = static_assert_declaration(ctx);
        }
        else if (ctx->current->type == TK_PRAGMA)
        {
            p_member_declaration->pragma_declaration = pragma_declaration(ctx);
        }
        else
        {
            p_member_declaration->p_attribute_specifier_sequence_opt = attribute_specifier_sequence_opt(ctx);

            p_member_declaration->specifier_qualifier_list = specifier_qualifier_list(ctx);

            if (ctx->current == NULL)
            {
                throw;
            }

            if (ctx->current->type != ';')
            {
                p_member_declaration->member_declarator_list_opt = member_declarator_list(ctx,
                    p_struct_or_union_specifier,
                    p_member_declaration->specifier_qualifier_list);
                if (p_member_declaration->member_declarator_list_opt == NULL) throw;
            }

            if (parser_match_tk(ctx, ';') != 0)
                throw;
        }
    }
    catch
    {
        member_declaration_delete(p_member_declaration);
        p_member_declaration = NULL;
    }
    return p_member_declaration;
}

struct member_declarator* _Opt find_member_declarator(struct member_declaration_list* list, const char* name, int* p_member_index)
{
    if (list->head == NULL)
        return NULL;

    struct member_declaration* _Opt p_member_declaration = list->head;
    while (p_member_declaration)
    {
        struct member_declarator* _Opt p_member_declarator = NULL;

        if (p_member_declaration->member_declarator_list_opt)
        {
            p_member_declarator = p_member_declaration->member_declarator_list_opt->head;

            while (p_member_declarator)
            {
                if (p_member_declarator->declarator->name_opt && strcmp(p_member_declarator->declarator->name_opt->lexeme, name) == 0)
                {
                    return p_member_declarator;
                }

                (*p_member_index)++;
                p_member_declarator = p_member_declarator->next;
            }
        }
        else
        {
            if (p_member_declaration->specifier_qualifier_list &&
                p_member_declaration->specifier_qualifier_list->struct_or_union_specifier)
            {
                struct member_declaration_list* p_member_declaration_list =
                    &p_member_declaration->specifier_qualifier_list->struct_or_union_specifier->member_declaration_list;

                p_member_declarator = find_member_declarator(p_member_declaration_list, name, p_member_index);
                if (p_member_declarator)
                    return p_member_declarator;
            }
        }

        p_member_declaration = p_member_declaration->next;
    }
    return NULL;
}

void print_specifier_qualifier_list(struct osstream* ss, bool* first, struct specifier_qualifier_list* p_specifier_qualifier_list)
{

    print_type_qualifier_flags(ss, first, p_specifier_qualifier_list->type_qualifier_flags);

    if (p_specifier_qualifier_list->enum_specifier)
    {

        // TODO
        assert(false);
    }
    else if (p_specifier_qualifier_list->struct_or_union_specifier)
    {
        ss_fprintf(ss, "struct %s", p_specifier_qualifier_list->struct_or_union_specifier->tag_name);
    }
    else if (p_specifier_qualifier_list->typedef_declarator)
    {
        print_item(ss, first, p_specifier_qualifier_list->typedef_declarator->name_opt->lexeme);
    }
    else
    {
        print_type_specifier_flags(ss, first, p_specifier_qualifier_list->type_specifier_flags);
    }
}


void specifier_qualifier_list_add(struct specifier_qualifier_list* list, struct type_specifier_qualifier* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void specifier_qualifier_list_delete(struct specifier_qualifier_list* _Owner _Opt p)
{
    if (p)
    {
        struct type_specifier_qualifier* _Owner _Opt item = p->head;
        while (item)
        {
            struct type_specifier_qualifier* _Owner _Opt next = item->next;
            item->next = NULL;
            type_specifier_qualifier_delete(item);
            item = next;
        }

        attribute_specifier_sequence_delete(p->p_attribute_specifier_sequence);

        free(p);
    }
}

struct specifier_qualifier_list* _Owner _Opt specifier_qualifier_list(struct parser_ctx* ctx)
{
    struct specifier_qualifier_list* _Owner _Opt p_specifier_qualifier_list = NULL;
    try
    {
        if (!first_of_type_specifier(ctx) && !first_of_type_qualifier(ctx))
        {
            compiler_diagnostic_message(C_ERROR_MISSING_ENUM_TAG_NAME, ctx, ctx->current, NULL, "type specifier or qualifier expected");
            throw;
        }

        if (ctx->current == NULL)
            throw;

        p_specifier_qualifier_list = calloc(1, sizeof(struct specifier_qualifier_list));
        if (p_specifier_qualifier_list == NULL)
            throw;

        /*
          type_specifier_qualifier attribute_specifier_sequence_opt
          type_specifier_qualifier specifier_qualifier_list
        */

        p_specifier_qualifier_list->first_token = ctx->current;

        while (ctx->current != NULL &&
            (first_of_type_specifier(ctx) ||
                first_of_type_qualifier(ctx)))
        {

            if (ctx->current->flags & TK_FLAG_IDENTIFIER_IS_TYPEDEF)
            {
                if (p_specifier_qualifier_list->type_specifier_flags != TYPE_SPECIFIER_NONE)
                {
                    // typedef tem que aparecer sozinho
                    // exemplo Socket eh nome e nao typdef
                    // typedef int Socket;
                    // struct X {int Socket;};
                    break;
                }
            }

            struct type_specifier_qualifier* _Owner _Opt p_type_specifier_qualifier = type_specifier_qualifier(ctx);
            if (p_type_specifier_qualifier == NULL)
            {
                throw;
            }

            if (p_type_specifier_qualifier->type_specifier)
            {
                if (add_specifier(ctx,
                    &p_specifier_qualifier_list->type_specifier_flags,
                    p_type_specifier_qualifier->type_specifier->flags) != 0)
                {
                    type_specifier_qualifier_delete(p_type_specifier_qualifier);
                    throw;
                }

                if (p_type_specifier_qualifier->type_specifier->struct_or_union_specifier)
                {
                    p_specifier_qualifier_list->struct_or_union_specifier = p_type_specifier_qualifier->type_specifier->struct_or_union_specifier;
                }
                else if (p_type_specifier_qualifier->type_specifier->enum_specifier)
                {
                    p_specifier_qualifier_list->enum_specifier = p_type_specifier_qualifier->type_specifier->enum_specifier;
                }
                else if (p_type_specifier_qualifier->type_specifier->typeof_specifier)
                {
                    p_specifier_qualifier_list->typeof_specifier = p_type_specifier_qualifier->type_specifier->typeof_specifier;
                }
                else if (p_type_specifier_qualifier->type_specifier->token->type == TK_IDENTIFIER)
                {
                    p_specifier_qualifier_list->typedef_declarator =
                        find_declarator(ctx,
                            p_type_specifier_qualifier->type_specifier->token->lexeme,
                            NULL);
                }
            }
            else if (p_type_specifier_qualifier->type_qualifier)
            {
                p_specifier_qualifier_list->type_qualifier_flags |= p_type_specifier_qualifier->type_qualifier->flags;
            }

            assert(p_specifier_qualifier_list->p_attribute_specifier_sequence == NULL);
            p_specifier_qualifier_list->p_attribute_specifier_sequence = attribute_specifier_sequence_opt(ctx);

            specifier_qualifier_list_add(p_specifier_qualifier_list, p_type_specifier_qualifier);
        }

        final_specifier(ctx, &p_specifier_qualifier_list->type_specifier_flags);
        struct token* _Opt p_previous_parser_token = previous_parser_token(ctx->current);
        if (p_previous_parser_token == NULL) throw;

        p_specifier_qualifier_list->last_token = p_previous_parser_token;
    }
    catch
    {
        specifier_qualifier_list_delete(p_specifier_qualifier_list);
        p_specifier_qualifier_list = NULL;
    }

    return p_specifier_qualifier_list;
}

void type_qualifier_delete(struct type_qualifier* _Owner _Opt p)
{
    if (p)
    {
        assert(p->next == NULL);
        free(p);
    }
}

void type_specifier_qualifier_delete(struct type_specifier_qualifier* _Owner _Opt p)
{
    if (p)
    {
        assert(p->next == NULL);
        if (p->type_qualifier)
        {
            assert(p->type_qualifier->next == NULL);
            free(p->type_qualifier);
        }
        alignment_specifier_delete(p->alignment_specifier);

        type_specifier_delete(p->type_specifier);

        //ATENTION LIST?? SEE ABOVE TODO
        //type_qualifier_delete(p->type_qualifier);

        free(p);
    }
}
struct type_specifier_qualifier* _Owner _Opt type_specifier_qualifier(struct parser_ctx* ctx)
{
    struct type_specifier_qualifier* _Owner _Opt type_specifier_qualifier = NULL;
    try
    {
        type_specifier_qualifier = calloc(1, sizeof * type_specifier_qualifier);
        if (type_specifier_qualifier == NULL) throw;

        // type_specifier
        // type_qualifier
        // alignment_specifier
        if (first_of_type_specifier(ctx))
        {
            type_specifier_qualifier->type_specifier = type_specifier(ctx);
            if (type_specifier_qualifier->type_specifier == NULL) throw;
        }
        else if (first_of_type_qualifier(ctx))
        {
            type_specifier_qualifier->type_qualifier = type_qualifier(ctx);
            if (type_specifier_qualifier->type_qualifier == NULL) throw;
        }
        else if (first_of_alignment_specifier(ctx))
        {
            type_specifier_qualifier->alignment_specifier = alignment_specifier(ctx);
            if (type_specifier_qualifier->alignment_specifier == NULL) throw;
        }
        else
        {
            assert(false);
        }
    }
    catch
    {
        type_specifier_qualifier_delete(type_specifier_qualifier);
        type_specifier_qualifier = NULL;
    }
    return type_specifier_qualifier;
}

const struct enumerator* _Opt find_enumerator_by_value(const struct enum_specifier* p_enum_specifier, long long value)
{
    if (p_enum_specifier->enumerator_list.head == NULL)
    {
        return NULL;
    }

    struct enumerator* _Opt p = p_enum_specifier->enumerator_list.head;
    while (p)
    {
        if (constant_value_to_signed_long_long(&p->value) == value)
            return p;
        p = p->next;
    }
    return NULL;
}

void enum_specifier_delete(struct enum_specifier* _Owner _Opt p)
{
    if (p)
    {
        specifier_qualifier_list_delete(p->specifier_qualifier_list);
        attribute_specifier_sequence_delete(p->attribute_specifier_sequence_opt);
        enumerator_list_destroy(&p->enumerator_list);
        free(p);
    }
}

struct enum_specifier* _Owner _Opt enum_specifier(struct parser_ctx* ctx)
{
    /*
     enum-type-specifier:
     : specifier-qualifier-list
    */

    /*
        enum-specifier:

        "enum" attribute-specifier-sequence _Opt identifier _Opt enum-type-specifier _Opt
        { enumerator-list }

        "enum" attribute-specifier-sequence _Opt identifier _Opt enum-type-specifier _Opt
        { enumerator-list , }
        enum identifier enum-type-specifier _Opt
    */
    struct enum_specifier* _Owner _Opt p_enum_specifier = NULL;
    try
    {
        if (ctx->current == NULL)
            throw;

        p_enum_specifier = calloc(1, sizeof * p_enum_specifier);
        if (p_enum_specifier == NULL)
            throw;

        p_enum_specifier->first_token = ctx->current;
        if (parser_match_tk(ctx, TK_KEYWORD_ENUM) != 0)
            throw;

        p_enum_specifier->attribute_specifier_sequence_opt =
            attribute_specifier_sequence_opt(ctx);


        if (ctx->current->type == TK_IDENTIFIER)
        {
            snprintf(p_enum_specifier->tag_name, sizeof p_enum_specifier->tag_name, "%s", ctx->current->lexeme);


            p_enum_specifier->tag_token = ctx->current;
            parser_match(ctx);
        }
        else
        {
            snprintf(p_enum_specifier->tag_name, sizeof p_enum_specifier->tag_name, "_anonymous_struct_%d", s_anonymous_struct_count);
            s_anonymous_struct_count++;
        }

        if (ctx->current == NULL)
        {
            throw;
        }

        if (ctx->current->type == ':')
        {
            if (!ctx->inside_generic_association)
            {
                /*C23*/
                parser_match(ctx);
                p_enum_specifier->specifier_qualifier_list = specifier_qualifier_list(ctx);
            }
            else
            {
                //TODO
            }
        }

        if (ctx->current == NULL)
        {
            throw;
        }

        if (ctx->current->type == '{')
        {
            if (p_enum_specifier->tag_token)
                naming_convention_enum_tag(ctx, p_enum_specifier->tag_token);

            /*points to itself*/
            p_enum_specifier->complete_enum_specifier2 = p_enum_specifier;

            if (parser_match_tk(ctx, '{') != 0)
                throw;

            p_enum_specifier->enumerator_list = enumerator_list(ctx, p_enum_specifier);

            if (p_enum_specifier->enumerator_list.head == NULL)
                throw;

            if (ctx->current == NULL)
            {
                throw;
            }

            if (ctx->current->type == ',')
            {
                parser_match(ctx);
            }

            if (parser_match_tk(ctx, '}') != 0)
                throw;

            hashmap_set(&ctx->scopes.tail->tags, p_enum_specifier->tag_name, p_enum_specifier, TAG_TYPE_ENUN_SPECIFIER);
            p_enum_specifier->complete_enum_specifier2 = p_enum_specifier;
        }
        else
        {
            struct enum_specifier* _Opt p_existing_enum_specifier = find_enum_specifier(ctx, p_enum_specifier->tag_token->lexeme);
            if (p_existing_enum_specifier)
            {
                //p_existing_enum_specifier->complete_enum_specifier2 = p_enum_specifier;
                //ja existe
                //verificar o caso de ser outro tag no memso escopo
                p_enum_specifier->complete_enum_specifier2 = p_existing_enum_specifier;
            }
            else
            {
                //nao existe lugar nenhum vamos adicionar
                hashmap_set(&ctx->scopes.tail->tags, p_enum_specifier->tag_name, p_enum_specifier, TAG_TYPE_ENUN_SPECIFIER);
                p_enum_specifier->complete_enum_specifier2 = p_enum_specifier;
            }

            //if (!has_identifier)
            //{
              //  compiler_diagnostic_message(C_ERROR_MISSING_ENUM_TAG_NAME, ctx, ctx->current, "missing enum tag name");
                //throw;
            //}
        }


    }
    catch
    {
        enum_specifier_delete(p_enum_specifier);
        p_enum_specifier = NULL;
    }

    return p_enum_specifier;
}

void enumerator_list_add(struct enumerator_list* list, struct enumerator* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void enumerator_list_destroy(struct enumerator_list* _Obj_owner p)
{
    struct enumerator* _Owner _Opt item = p->head;
    while (item)
    {
        struct enumerator* _Owner _Opt next = item->next;
        item->next = NULL;
        enumerator_delete(item);
        item = next;
    }
}

struct enumerator_list enumerator_list(struct parser_ctx* ctx, const struct enum_specifier* p_enum_specifier)
{

    /*
       enumerator
        enumerator_list ',' enumerator
     */
    long long next_enumerator_value = 0;

    struct enumerator_list enumeratorlist = { 0 };
    struct enumerator* _Owner _Opt p_enumerator = NULL;
    try
    {
        p_enumerator = enumerator(ctx, p_enum_specifier, &next_enumerator_value);
        if (p_enumerator == NULL)
            throw;

        enumerator_list_add(&enumeratorlist, p_enumerator);

        while (ctx->current != NULL && ctx->current->type == ',')
        {
            parser_match(ctx); /*pode ter uma , vazia no fim*/

            if (ctx->current && ctx->current->type != '}')
            {
                p_enumerator = enumerator(ctx, p_enum_specifier, &next_enumerator_value);
                if (p_enumerator == NULL)
                    throw;
                enumerator_list_add(&enumeratorlist, p_enumerator);
            }
        }
    }
    catch
    {
        enumerator_list_destroy(&enumeratorlist);
        enumeratorlist.head = NULL;
        enumeratorlist.tail = NULL;
    }

    return enumeratorlist;
}

void enumerator_delete(struct enumerator* _Owner _Opt p)
{
    if (p)
    {
        assert(p->next == NULL);
        attribute_specifier_sequence_delete(p->attribute_specifier_sequence_opt);
        expression_delete(p->constant_expression_opt);

        free(p);
    }
}

struct enumerator* _Owner _Opt enumerator(struct parser_ctx* ctx,
    const struct enum_specifier* p_enum_specifier,
    long long* p_next_enumerator_value)
{
    // TODO VALUE
    struct enumerator* _Owner _Opt p_enumerator = NULL;
    try
    {
        if (ctx->current == NULL)
            throw;

        p_enumerator = calloc(1, sizeof(struct enumerator));
        if (p_enumerator == NULL)
            throw;

        p_enumerator->enum_specifier = p_enum_specifier;
        struct token* name = ctx->current;

        naming_convention_enumerator(ctx, name);

        if (parser_match_tk(ctx, TK_IDENTIFIER) != 0)
            throw;

        p_enumerator->attribute_specifier_sequence_opt = attribute_specifier_sequence_opt(ctx);

        p_enumerator->token = name;
        hashmap_set(&ctx->scopes.tail->variables, p_enumerator->token->lexeme, p_enumerator, TAG_TYPE_ENUMERATOR);

        if (ctx->current == NULL)
        {
            throw;
        }

        if (ctx->current->type == '=')
        {
            parser_match(ctx);
            p_enumerator->constant_expression_opt = constant_expression(ctx, true);
            if (p_enumerator->constant_expression_opt == NULL) throw;

            p_enumerator->value = p_enumerator->constant_expression_opt->constant_value;
            *p_next_enumerator_value = constant_value_to_signed_long_long(&p_enumerator->value);
            (*p_next_enumerator_value)++; // TODO overflow  and size check
        }
        else
        {
            p_enumerator->value = constant_value_make_signed_long_long(*p_next_enumerator_value);
            (*p_next_enumerator_value)++; // TODO overflow  and size check
        }
    }
    catch
    {
        enumerator_delete(p_enumerator);
        p_enumerator = NULL;
    }
    return p_enumerator;
}

void alignment_specifier_delete(struct alignment_specifier* _Owner _Opt p)
{
    if (p)
    {
        expression_delete(p->constant_expression);
        type_name_delete(p->type_name);
        free(p);
    }
}

struct alignment_specifier* _Owner _Opt alignment_specifier(struct parser_ctx* ctx)
{
    struct alignment_specifier* _Owner _Opt alignment_specifier = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            throw;
        }

        alignment_specifier = calloc(1, sizeof * alignment_specifier);

        if (alignment_specifier == NULL)
            throw;

        alignment_specifier->token = ctx->current;
        if (parser_match_tk(ctx, TK_KEYWORD__ALIGNAS) != 0)
            throw;
        if (parser_match_tk(ctx, '(') != 0)
            throw;
        if (first_of_type_name(ctx))
        {
            alignment_specifier->type_name = type_name(ctx);
            if (alignment_specifier->type_name == NULL)
                throw;
        }
        else
        {
            alignment_specifier->constant_expression = constant_expression(ctx, true);
            if (alignment_specifier->constant_expression == NULL)
                throw;
        }
        if (parser_match_tk(ctx, ')') != 0)
            throw;
    }
    catch
    {
    }
    return alignment_specifier;
}

void atomic_type_specifier_delete(struct atomic_type_specifier* _Owner _Opt p)
{
    if (p)
    {
        type_name_delete(p->type_name);
        free(p);
    }
}
struct atomic_type_specifier* _Owner _Opt atomic_type_specifier(struct parser_ctx* ctx)
{
    //'_Atomic' '(' type_name ')'
    struct atomic_type_specifier* _Owner _Opt p_atomic_type_specifier = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            throw;
        }

        p_atomic_type_specifier = calloc(1, sizeof * p_atomic_type_specifier);
        if (p_atomic_type_specifier == NULL)
            throw;

        p_atomic_type_specifier->token = ctx->current;
        if (parser_match_tk(ctx, TK_KEYWORD__ATOMIC) != 0)
            throw;
        if (parser_match_tk(ctx, '(') != 0)
            throw;

        struct type_name* _Owner _Opt ptemp = type_name(ctx);
        if (ptemp == NULL)
        {
            throw;
        }

        p_atomic_type_specifier->type_name = ptemp;
        if (parser_match_tk(ctx, ')') != 0)
            throw;
    }
    catch
    {
        atomic_type_specifier_delete(p_atomic_type_specifier);
        p_atomic_type_specifier = NULL;
    }
    return p_atomic_type_specifier;
}


struct type_qualifier* _Owner _Opt type_qualifier(struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return NULL;

    struct type_qualifier* _Owner _Opt p_type_qualifier = calloc(1, sizeof * p_type_qualifier);

    if (p_type_qualifier == NULL)
        return NULL;

    switch (ctx->current->type)
    {
    case TK_KEYWORD_CONST:
        p_type_qualifier->flags = TYPE_QUALIFIER_CONST;
        break;
    case TK_KEYWORD_RESTRICT:
        p_type_qualifier->flags = TYPE_QUALIFIER_RESTRICT;
        break;
    case TK_KEYWORD_VOLATILE:
        p_type_qualifier->flags = TYPE_QUALIFIER_VOLATILE;
        break;
    case TK_KEYWORD__ATOMIC:
        p_type_qualifier->flags = TYPE_QUALIFIER__ATOMIC;
        break;

    default:
        // do nothing
        break;
    }

    if (ctx->options.ownership_enabled)
    {
        switch (ctx->current->type)
        {
        case TK_KEYWORD__OUT:
            p_type_qualifier->flags = TYPE_QUALIFIER_OUT;
            break;

        case TK_KEYWORD__OWNER:
            p_type_qualifier->flags = TYPE_QUALIFIER_OWNER;
            break;

        case TK_KEYWORD__OBJ_OWNER:
            p_type_qualifier->flags = TYPE_QUALIFIER_OBJ_OWNER;
            break;
        case TK_KEYWORD__VIEW:
            p_type_qualifier->flags = TYPE_QUALIFIER_VIEW;
            break;
        default:
            // do nothing
            break;
        }
    }

    if (ctx->options.null_checks_enabled)
    {
        switch (ctx->current->type)
        {
        case TK_KEYWORD__OPT:
            p_type_qualifier->flags = TYPE_QUALIFIER_NULLABLE;
            break;

        default:
            // do nothing
            break;
        }
    }

    p_type_qualifier->token = ctx->current;

    //'const'
    //'restrict'
    //'volatile'
    //'_Atomic'
    parser_match(ctx);
    return p_type_qualifier;
}
//

struct type_qualifier* _Owner _Opt type_qualifier_opt(struct parser_ctx* ctx)
{
    if (first_of_type_qualifier(ctx))
    {
        return type_qualifier(ctx);
    }
    return NULL;
}

void function_specifier_delete(struct function_specifier* _Owner _Opt p)
{
    if (p)
    {
        free(p);
    }
}

struct function_specifier* _Owner _Opt function_specifier(struct parser_ctx* ctx)
{
    struct function_specifier* _Owner _Opt p_function_specifier = NULL;
    try
    {
        if (ctx->current == NULL)
            throw;

        if (ctx->current->type == TK_KEYWORD__NORETURN)
        {
            compiler_diagnostic_message(W_STYLE, ctx, ctx->current, NULL, "_Noreturn is deprecated use attributes");
        }

        p_function_specifier = calloc(1, sizeof * p_function_specifier);
        if (p_function_specifier == NULL)
            throw;

        p_function_specifier->token = ctx->current;
        parser_match(ctx);
    }
    catch
    {
        function_specifier_delete(p_function_specifier);
        p_function_specifier = NULL;
    }

    return p_function_specifier;
}

void declarator_delete(struct declarator* _Owner _Opt p)
{
    if (p)
    {
        type_destroy(&p->type);
        direct_declarator_delete(p->direct_declarator);
        pointer_delete(p->pointer);
        free(p);
    }
}

struct declarator* _Owner _Opt declarator(struct parser_ctx* ctx,
    const struct specifier_qualifier_list* _Opt p_specifier_qualifier_list_opt,
    struct declaration_specifiers* _Opt p_declaration_specifiers_opt,
    bool abstract_acceptable,
    struct token** pp_token_name)
{
    /*
      declarator:
      pointer_opt direct-declarator
    */


    struct declarator* _Owner _Opt p_declarator = NULL;
    try
    {
        if (ctx->current == NULL)
            throw;

        p_declarator = calloc(1, sizeof(struct declarator));
        if (p_declarator == NULL) throw;

        p_declarator->first_token_opt = ctx->current;
        p_declarator->pointer = pointer_opt(ctx);
        p_declarator->direct_declarator = direct_declarator(ctx, p_specifier_qualifier_list_opt, p_declaration_specifiers_opt, abstract_acceptable, pp_token_name);
        if (p_declarator->direct_declarator == NULL) throw;

        if (ctx->current == NULL)
            throw;

        if (ctx->current != p_declarator->first_token_opt)
        {
            p_declarator->last_token_opt = previous_parser_token(ctx->current);
        }
        else
        {
            /*empty declarator*/

            p_declarator->last_token_opt = p_declarator->first_token_opt;
            p_declarator->first_token_opt = NULL; /*this is the way we can know...first is null*/
        }
    }
    catch
    {
        declarator_delete(p_declarator);
        p_declarator = NULL;
    }

    return p_declarator;
}

const char* _Opt declarator_get_name(struct declarator* p_declarator)
{
    if (p_declarator->direct_declarator)
    {
        if (p_declarator->direct_declarator->name_opt)
            return p_declarator->direct_declarator->name_opt->lexeme;
    }

    return NULL;
}

bool declarator_is_function(struct declarator* p_declarator)
{
    return (p_declarator->direct_declarator &&
        p_declarator->direct_declarator->function_declarator != NULL);
}

struct array_declarator* _Owner _Opt array_declarator(struct direct_declarator* _Owner p_direct_declarator, struct parser_ctx* ctx);
struct function_declarator* _Owner _Opt function_declarator(struct direct_declarator* _Owner p_direct_declarator, struct parser_ctx* ctx);

void function_declarator_delete(struct function_declarator* _Owner _Opt p)
{
    if (p)
    {
        direct_declarator_delete(p->direct_declarator);
        scope_destroy(&p->parameters_scope);
        parameter_type_list_delete(p->parameter_type_list_opt);
        free(p);
    }
}
void direct_declarator_delete(struct direct_declarator* _Owner _Opt p)
{
    if (p)
    {
        declarator_delete(p->declarator);
        attribute_specifier_sequence_delete(p->p_attribute_specifier_sequence_opt);
        array_declarator_delete(p->array_declarator);
        function_declarator_delete(p->function_declarator);

        free(p);
    }
}
struct direct_declarator* _Owner _Opt direct_declarator(struct parser_ctx* ctx,
    const struct specifier_qualifier_list* _Opt p_specifier_qualifier_list,
    struct declaration_specifiers* _Opt p_declaration_specifiers,
    bool abstract_acceptable,
    struct token** pptoken_name)
{
    /*
    direct-declarator:
     identifier attribute-specifier-sequenceopt
     ( declarator )

     array-declarator attribute-specifier-sequenceopt
     function-declarator attribute-specifier-sequenceopt
    */


    struct direct_declarator* _Owner _Opt p_direct_declarator = NULL;
    try
    {
        if (ctx->current == NULL)
            throw;

        p_direct_declarator = calloc(1, sizeof(struct direct_declarator));
        if (p_direct_declarator == NULL) throw;

        struct token* _Opt p_token_ahead = parser_look_ahead(ctx);
        if (p_token_ahead == NULL)
            throw;

        if (ctx->current->type == TK_IDENTIFIER)
        {
            p_direct_declarator->name_opt = ctx->current;
            if (pptoken_name != NULL)
            {
                *pptoken_name = ctx->current;
            }

            parser_match(ctx);
            p_direct_declarator->p_attribute_specifier_sequence_opt = attribute_specifier_sequence_opt(ctx);
        }
        else if (ctx->current->type == '(')
        {
            struct token* _Opt ahead = parser_look_ahead(ctx);
            if (ahead == NULL)
                throw;

            if (!first_of_type_specifier_token(ctx, p_token_ahead) &&
                !first_of_type_qualifier_token(p_token_ahead) &&
                ahead->type != ')' &&
                ahead->type != '...')
            {
                // look ahead para nao confundir (declarator) com parametros funcao ex void (int)
                // or function int ()

                parser_match(ctx);

                struct declarator* _Owner _Opt p_declarator_temp =
                    declarator(ctx,
                        p_specifier_qualifier_list,
                        p_declaration_specifiers,
                        abstract_acceptable,
                        pptoken_name);

                if (p_declarator_temp == NULL)
                    throw;

                p_direct_declarator->declarator = p_declarator_temp;
                parser_match(ctx); //)
            }
        }

        while (ctx->current != NULL &&
            (ctx->current->type == '[' || ctx->current->type == '('))
        {
            struct direct_declarator* _Owner _Opt p_direct_declarator2 = calloc(1, sizeof(struct direct_declarator));
            if (p_direct_declarator2 == NULL) throw;

            if (ctx->current->type == '[')
            {
                p_direct_declarator2->array_declarator = array_declarator(p_direct_declarator, ctx);
                p_direct_declarator = NULL; //MOVED
                if (p_direct_declarator2->array_declarator == NULL)
                {
                    direct_declarator_delete(p_direct_declarator2);
                    throw;
                }
            }
            else
            {
                p_direct_declarator2->function_declarator = function_declarator(p_direct_declarator, ctx);
            }
            p_direct_declarator = p_direct_declarator2;
        }
    }
    catch
    {
        direct_declarator_delete(p_direct_declarator);
        p_direct_declarator = NULL;
    }

    return p_direct_declarator;
}

void array_declarator_delete(struct array_declarator* _Owner _Opt p)
{
    if (p)
    {
        expression_delete(p->assignment_expression);
        direct_declarator_delete(p->direct_declarator);
        expression_delete(p->expression);
        type_qualifier_list_delete(p->type_qualifier_list_opt);

        free(p);
    }
}

unsigned long long array_declarator_get_size(const struct array_declarator* p_array_declarator)
{
    if (p_array_declarator->assignment_expression)
    {
        if (constant_value_is_valid(&p_array_declarator->assignment_expression->constant_value))
        {
            return constant_value_to_unsigned_long_long(&p_array_declarator->assignment_expression->constant_value);
        }
    }
    return 0;
}

struct array_declarator* _Owner _Opt array_declarator(struct direct_declarator* _Owner p_direct_declarator, struct parser_ctx* ctx)
{
    // direct_declarator '['          type_qualifier_list_opt           assignment_expression_opt ']'
    // direct_declarator '[' 'static' type_qualifier_list_opt           assignment_expression     ']'
    // direct_declarator '['          type_qualifier_list      'static' assignment_expression     ']'
    // direct_declarator '['          type_qualifier_list_opt  '*'           ']'

    struct array_declarator* _Owner _Opt p_array_declarator = NULL;
    try
    {
        p_array_declarator = calloc(1, sizeof * p_array_declarator);
        if (p_array_declarator == NULL)
        {
            throw;
        }

        p_array_declarator->direct_declarator = p_direct_declarator;
        p_direct_declarator = NULL; /*MOVED*/

        if (parser_match_tk(ctx, '[') != 0)
            throw;

        if (ctx->current == NULL)
        {
            throw;
        }

        bool has_static = false;
        if (ctx->current->type == TK_KEYWORD_STATIC)
        {
            p_array_declarator->static_token_opt = ctx->current;
            parser_match(ctx);
            has_static = true;
        }

        if (first_of_type_qualifier(ctx))
        {
            p_array_declarator->type_qualifier_list_opt = type_qualifier_list(ctx);
        }

        if (ctx->current == NULL)
        {
            throw;
        }

        if (!has_static)
        {
            if (ctx->current->type == TK_KEYWORD_STATIC)
            {
                parser_match(ctx);
                has_static = true;
            }
        }

        if (has_static)
        {
            // tem que ter..

            const bool evaluation_is_disabled = ctx->evaluation_is_disabled;
            ctx->evaluation_is_disabled = false;
            p_array_declarator->assignment_expression = assignment_expression(ctx);
            /*restore*/
            ctx->evaluation_is_disabled = evaluation_is_disabled;

            if (p_array_declarator->assignment_expression == NULL)
                throw;
        }
        else
        {
            if (ctx->current == NULL)
            {
                throw;
            }

            // opcional
            if (ctx->current->type == '*')
            {
                parser_match(ctx);
            }
            else if (ctx->current->type != ']')
            {
                const bool evaluation_is_disabled = ctx->evaluation_is_disabled;
                ctx->evaluation_is_disabled = false;
                p_array_declarator->assignment_expression = assignment_expression(ctx);

                /*restore*/
                ctx->evaluation_is_disabled = evaluation_is_disabled;

                if (p_array_declarator->assignment_expression == NULL)
                    throw;
            }
            else
            {
            }
        }

        if (parser_match_tk(ctx, ']') != 0)
            throw;
    }
    catch
    {
        array_declarator_delete(p_array_declarator);
        p_array_declarator = NULL;

    }

    direct_declarator_delete(p_direct_declarator);

    return p_array_declarator;
}

struct function_declarator* _Owner _Opt function_declarator(struct direct_declarator* _Owner p_direct_declarator, struct parser_ctx* ctx)
{
    struct function_declarator* _Owner _Opt p_function_declarator = calloc(1, sizeof(struct function_declarator));
    try
    {
        if (p_function_declarator == NULL)
        {
            throw;
        }

        // faz um push da funcion_scope_declarator_list que esta vivendo mais em cima
        // eh feito o pop mais em cima tb.. aqui dentro do decide usar.
        // ctx->funcion_scope_declarator_list->outer_scope = ctx->current_scope;
        // ctx->current_scope = ctx->funcion_scope_declarator_list;
        // direct_declarator '(' parameter_type_list_opt ')'

        p_function_declarator->direct_declarator = p_direct_declarator;
        p_direct_declarator = NULL; /*MOVED*/
        p_function_declarator->parameters_scope.scope_level = ctx->scopes.tail->scope_level + 1;
        p_function_declarator->parameters_scope.variables.capacity = 5;
        p_function_declarator->parameters_scope.tags.capacity = 1;

        if (parser_match_tk(ctx, '(') != 0)
            throw;

        if (ctx->current == NULL)
            throw;

        if (ctx->current->type != ')')
        {
            scope_list_push(&ctx->scopes, &p_function_declarator->parameters_scope);
            p_function_declarator->parameter_type_list_opt = parameter_type_list(ctx);
            scope_list_pop(&ctx->scopes);
        }
        if (parser_match_tk(ctx, ')') != 0)
            throw;

    }
    catch
    {
        function_declarator_delete(p_function_declarator);
        p_function_declarator = NULL;
    }

    direct_declarator_delete(p_direct_declarator);
    return p_function_declarator;
}

void pointer_delete(struct pointer* _Owner _Opt p)
{
    if (p)
    {
        attribute_specifier_sequence_delete(p->attribute_specifier_sequence_opt);
        type_qualifier_list_delete(p->type_qualifier_list_opt);

        struct pointer* _Owner _Opt item = p->pointer;
        while (item)
        {
            struct pointer* _Owner _Opt next = item->pointer;
            attribute_specifier_sequence_delete(item->attribute_specifier_sequence_opt);
            type_qualifier_list_delete(item->type_qualifier_list_opt);
            free(item);
            item = next;
        }

        free(p);
    }
}
struct pointer* _Owner _Opt pointer_opt(struct parser_ctx* ctx)
{
    struct pointer* _Owner _Opt p = NULL;
    struct pointer* _Owner _Opt p_pointer = NULL;
    try
    {
        while (ctx->current != NULL && ctx->current->type == '*')
        {
            p_pointer = calloc(1, sizeof(struct pointer));
            if (p_pointer == NULL)
                throw;

            p = p_pointer;
            parser_match(ctx);

            p_pointer->attribute_specifier_sequence_opt =
                attribute_specifier_sequence_opt(ctx);

            if (first_of_type_qualifier(ctx))
            {
                assert(ctx->current != NULL);

                if (ctx->current->type == TK_KEYWORD__VIEW)
                {
                    compiler_diagnostic_message(C_ERROR_INVALID_QUALIFIER_FOR_POINTER,
                                ctx,
                                ctx->current,
                                NULL,
                                "invalid qualifier for pointer");
                }
                else
                {
                    p_pointer->type_qualifier_list_opt = type_qualifier_list(ctx);
                }
            }

            while (ctx->current != NULL && ctx->current->type == '*')
            {
                p_pointer->pointer = pointer_opt(ctx);
                if (p_pointer->pointer == NULL)
                    throw;
            }
        }
    }
    catch
    {
    }

    //'*' attribute_specifier_sequence_opt type_qualifier_list_opt
    //'*' attribute_specifier_sequence_opt type_qualifier_list_opt pointer
    return p;
}

void type_qualifier_list_add(struct type_qualifier_list* list, struct type_qualifier* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void type_qualifier_list_delete(struct type_qualifier_list* _Owner _Opt p)
{
    if (p)
    {
        struct type_qualifier* _Owner _Opt item = p->head;
        while (item)
        {
            struct type_qualifier* _Owner _Opt next = item->next;
            item->next = NULL;
            free(item);
            item = next;
        }
        free(p);
    }
}

struct type_qualifier_list* _Owner _Opt type_qualifier_list(struct parser_ctx* ctx)
{
    // type_qualifier
    // type_qualifier_list type_qualifier

    struct type_qualifier_list* _Owner _Opt p_type_qualifier_list = NULL;
    struct type_qualifier* _Owner _Opt p_type_qualifier = NULL;

    try
    {
        p_type_qualifier_list = calloc(1, sizeof(struct type_qualifier_list));
        if (p_type_qualifier_list == NULL)
            throw;

        p_type_qualifier = type_qualifier(ctx);
        if (p_type_qualifier == NULL)
            throw;

        p_type_qualifier_list->flags |= p_type_qualifier->flags;
        type_qualifier_list_add(p_type_qualifier_list, p_type_qualifier);
        p_type_qualifier = NULL; /*MOVED*/

        while (ctx->current != NULL && first_of_type_qualifier(ctx))
        {
            p_type_qualifier = type_qualifier(ctx);
            if (p_type_qualifier == NULL)
                throw;

            p_type_qualifier_list->flags |= p_type_qualifier->flags;
            type_qualifier_list_add(p_type_qualifier_list, p_type_qualifier);
            p_type_qualifier = NULL; /*MOVED*/
        }
    }
    catch
    {
    }

    return p_type_qualifier_list;
}

void parameter_type_list_delete(struct parameter_type_list* _Owner _Opt p)
{
    if (p)
    {
        parameter_list_delete(p->parameter_list);
        free(p);
    }
}

struct parameter_type_list* _Owner _Opt parameter_type_list(struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return NULL;

    struct parameter_type_list* _Owner _Opt p_parameter_type_list = calloc(1, sizeof(struct parameter_type_list));

    try
    {
        if (p_parameter_type_list == NULL)
            throw;

        // parameter_list
        // parameter_list ',' '...'
        p_parameter_type_list->parameter_list = parameter_list(ctx);

        if (p_parameter_type_list->parameter_list &&
            p_parameter_type_list->parameter_list->head ==
            p_parameter_type_list->parameter_list->tail)
        {
            if (type_is_void(&p_parameter_type_list->parameter_list->head->declarator->type))
            {
                p_parameter_type_list->is_void = true;
            }
        }

        if (ctx->current == NULL) throw;

        /*ja esta saindo com a virgula consumida do parameter_list para evitar ahead*/
        if (ctx->current->type == '...')
        {
            parser_match(ctx);
            // parser_match_tk(ctx, '...');
            p_parameter_type_list->is_var_args = true;
        }
    }
    catch
    {
    }

    return p_parameter_type_list;
}

void parameter_list_add(struct parameter_list* list, struct parameter_declaration* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void parameter_list_delete(struct parameter_list* _Owner p)
{
    if (p)
    {
        struct parameter_declaration* _Owner _Opt item = p->head;
        while (item)
        {
            struct parameter_declaration* _Owner _Opt next = item->next;
            item->next = NULL;
            parameter_declaration_delete(item);
            item = next;
        }
        free(p);
    }
}
struct parameter_list* _Owner _Opt parameter_list(struct parser_ctx* ctx)
{
    /*
      parameter_list
      parameter_declaration
      parameter_list ',' parameter_declaration
    */
    struct parameter_list* _Owner _Opt p_parameter_list = NULL;
    struct parameter_declaration* _Owner _Opt p_parameter_declaration = NULL;
    try
    {
        p_parameter_list = calloc(1, sizeof(struct parameter_list));
        if (p_parameter_list == NULL)
            throw;

        p_parameter_declaration = parameter_declaration(ctx);
        if (p_parameter_declaration == NULL)
            throw;

        parameter_list_add(p_parameter_list, p_parameter_declaration);
        p_parameter_declaration = NULL; /*MOVED*/

        while (ctx->current != NULL && ctx->current->type == ',')
        {
            parser_match(ctx);

            if (ctx->current == NULL)
            {
                throw;
            }

            if (ctx->current->type == '...')
            {
                // follow
                break;
            }

            p_parameter_declaration = parameter_declaration(ctx);
            if (p_parameter_declaration == NULL)
                throw;

            parameter_list_add(p_parameter_list, p_parameter_declaration);
            p_parameter_declaration = NULL; /*MOVED*/
        }
    }
    catch
    {
    }
    return p_parameter_list;
}

void parameter_declaration_delete(struct parameter_declaration* _Owner _Opt p)
{
    if (p)
    {
        attribute_specifier_sequence_delete(p->attribute_specifier_sequence_opt);
        declaration_specifiers_delete(p->declaration_specifiers);
        declarator_delete(p->declarator);

        assert(p->next == NULL);
        free(p);
    }
}

struct parameter_declaration* _Owner _Opt parameter_declaration(struct parser_ctx* ctx)
{
    struct parameter_declaration* _Owner _Opt p_parameter_declaration = calloc(1, sizeof(struct parameter_declaration));
    try
    {
        if (p_parameter_declaration == NULL)
            throw;

        p_parameter_declaration->attribute_specifier_sequence_opt = attribute_specifier_sequence_opt(ctx);

        struct declaration_specifiers* _Owner _Opt p_declaration_specifiers =
            declaration_specifiers(ctx, STORAGE_SPECIFIER_PARAMETER);

        if (p_declaration_specifiers == NULL)
        {
            throw;
        }

        p_parameter_declaration->declaration_specifiers = p_declaration_specifiers;


        struct token* p_token_name = NULL;

        p_parameter_declaration->declarator = declarator(ctx,
            /*specifier_qualifier_list*/ NULL,
            p_parameter_declaration->declaration_specifiers,
            true /*can be abstract*/,
            &p_token_name);

        if (p_parameter_declaration->declarator == NULL) throw;

        p_parameter_declaration->declarator->name_opt = p_token_name;
        p_parameter_declaration->declarator->declaration_specifiers = p_parameter_declaration->declaration_specifiers;

#pragma cake diagnostic push
#pragma cake diagnostic ignored "-Wmissing-destructor"        
        p_parameter_declaration->declarator->type = make_type_using_declarator(ctx, p_parameter_declaration->declarator);
#pragma cake diagnostic pop

        if (p_parameter_declaration->attribute_specifier_sequence_opt)
        {
            p_parameter_declaration->declarator->type.attributes_flags |=
                p_parameter_declaration->attribute_specifier_sequence_opt->attributes_flags;
        }

        p_parameter_declaration->declarator->type.storage_class_specifier_flags |= STORAGE_SPECIFIER_PARAMETER;

        if (p_parameter_declaration->declarator->name_opt)
            naming_convention_parameter(ctx, p_parameter_declaration->declarator->name_opt, &p_parameter_declaration->declarator->type);

        // coloca o pametro no escpo atual que deve apontar para escopo paramtros
        //  da funcao .
        //
        // assert ctx->current_scope->variables parametrosd
        if (p_parameter_declaration->declarator->name_opt)
        {
            // parametro void nao te name
            hashmap_set(&ctx->scopes.tail->variables,
                p_parameter_declaration->declarator->name_opt->lexeme,
                p_parameter_declaration->declarator,
                TAG_TYPE_ONLY_DECLARATOR);
            // print_scope(ctx->current_scope);
        }
    }
    catch
    {
        parameter_declaration_delete(p_parameter_declaration);
        p_parameter_declaration = NULL;
    }

    return p_parameter_declaration;
}

struct specifier_qualifier_list* _Owner _Opt copy(struct declaration_specifiers* p_declaration_specifiers)
{
    struct specifier_qualifier_list* _Owner _Opt p_specifier_qualifier_list = calloc(1, sizeof(struct specifier_qualifier_list));

    try
    {
        if (p_specifier_qualifier_list == NULL)
            throw;

        p_specifier_qualifier_list->type_qualifier_flags = p_declaration_specifiers->type_qualifier_flags;
        p_specifier_qualifier_list->type_specifier_flags = p_declaration_specifiers->type_specifier_flags;

        struct declaration_specifier* _Opt p_declaration_specifier = p_declaration_specifiers->head;

        while (p_declaration_specifier)
        {
            if (p_declaration_specifier->type_specifier_qualifier)
            {
                struct type_specifier_qualifier* _Owner _Opt p_specifier_qualifier = calloc(1, sizeof(struct type_specifier_qualifier));

                if (p_specifier_qualifier == NULL)
                {
                    throw;
                }

                if (p_declaration_specifier->type_specifier_qualifier->type_qualifier)
                {
                    struct type_qualifier* _Owner _Opt p_type_qualifier = calloc(1, sizeof(struct type_qualifier));
                    if (p_type_qualifier == NULL)
                    {
                        type_specifier_qualifier_delete(p_specifier_qualifier);
                        throw;
                    }

                    p_type_qualifier->flags = p_declaration_specifier->type_specifier_qualifier->type_qualifier->flags;

                    p_type_qualifier->token = p_declaration_specifier->type_specifier_qualifier->type_qualifier->token;
                    p_specifier_qualifier->type_qualifier = p_type_qualifier;
                }
                else if (p_declaration_specifier->type_specifier_qualifier->type_specifier)
                {
                    struct type_specifier* _Owner _Opt p_type_specifier = calloc(1, sizeof(struct type_specifier));
                    if (p_type_specifier == NULL)
                    {
                        type_specifier_qualifier_delete(p_specifier_qualifier);
                        throw;
                    }

                    p_type_specifier->flags = p_declaration_specifier->type_specifier_qualifier->type_specifier->flags;

                    // todo
                    assert(p_declaration_specifier->type_specifier_qualifier->type_specifier->struct_or_union_specifier == NULL);

                    p_type_specifier->token = p_declaration_specifier->type_specifier_qualifier->type_specifier->token;
                    p_specifier_qualifier->type_specifier = p_type_specifier;
                }

                specifier_qualifier_list_add(p_specifier_qualifier_list, p_specifier_qualifier);
            }
            p_declaration_specifier = p_declaration_specifier->next;
        }
    }
    catch
    {
        specifier_qualifier_list_delete(p_specifier_qualifier_list);
        p_specifier_qualifier_list = NULL;
    }

    return p_specifier_qualifier_list;
}

void print_declarator(struct osstream* ss, struct declarator* p_declarator, bool is_abstract);

void print_direct_declarator(struct osstream* ss, struct direct_declarator* p_direct_declarator, bool is_abstract)
{
    if (p_direct_declarator->declarator)
    {
        ss_fprintf(ss, "(");
        print_declarator(ss, p_direct_declarator->declarator, is_abstract);
        ss_fprintf(ss, ")");
    }

    if (p_direct_declarator->name_opt && !is_abstract)
    {
        // Se is_abstract for true é pedido para nao imprimir o nome do indentificador
        ss_fprintf(ss, "%s", p_direct_declarator->name_opt->lexeme);
    }

    if (p_direct_declarator->function_declarator)
    {
        assert(p_direct_declarator->function_declarator->direct_declarator != NULL);

        print_direct_declarator(ss, p_direct_declarator->function_declarator->direct_declarator, is_abstract);

        ss_fprintf(ss, "(");
        struct parameter_declaration* _Opt p_parameter_declaration =
            p_direct_declarator->function_declarator->parameter_type_list_opt ? p_direct_declarator->function_declarator->parameter_type_list_opt->parameter_list->head : NULL;

        while (p_parameter_declaration)
        {
            if (p_parameter_declaration != p_direct_declarator->function_declarator->parameter_type_list_opt->parameter_list->head)
                ss_fprintf(ss, ",");

            print_declaration_specifiers(ss, p_parameter_declaration->declaration_specifiers);
            ss_fprintf(ss, " ");
            print_declarator(ss, p_parameter_declaration->declarator, is_abstract);

            p_parameter_declaration = p_parameter_declaration->next;
        }
        //... TODO
        ss_fprintf(ss, ")");
    }
    if (p_direct_declarator->array_declarator)
    {
        // TODO
        ss_fprintf(ss, "[]");
    }
}

enum type_specifier_flags declarator_get_type_specifier_flags(const struct declarator* p)
{
    if (p->declaration_specifiers)
        return p->declaration_specifiers->type_specifier_flags;
    if (p->specifier_qualifier_list)
        return p->specifier_qualifier_list->type_specifier_flags;
    return 0;
}

void print_declarator(struct osstream* ss, struct declarator* p_declarator, bool is_abstract)
{
    bool first = true;
    if (p_declarator->pointer)
    {
        struct pointer* _Opt p = p_declarator->pointer;
        while (p)
        {
            if (p->type_qualifier_list_opt)
            {
                print_type_qualifier_flags(ss, &first, p->type_qualifier_list_opt->flags);
            }
            ss_fprintf(ss, "*");
            p = p->pointer;
        }
    }
    if (p_declarator->direct_declarator)
        print_direct_declarator(ss, p_declarator->direct_declarator, is_abstract);
}

void print_type_name(struct osstream* ss, struct type_name* p)
{
    bool first = true;
    print_specifier_qualifier_list(ss, &first, p->specifier_qualifier_list);
    print_declarator(ss, p->abstract_declarator, true);
}

void type_name_delete(struct type_name* _Owner _Opt p)
{
    if (p)
    {
        specifier_qualifier_list_delete(p->specifier_qualifier_list);
        type_destroy(&p->type);
        declarator_delete(p->abstract_declarator);
        free(p);
    }
}
struct type_name* _Owner _Opt type_name(struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return NULL;

    struct type_name* _Owner _Opt p_type_name = calloc(1, sizeof(struct type_name));
    try
    {
        if (p_type_name == NULL) throw;

        p_type_name->first_token = ctx->current;

        struct specifier_qualifier_list* _Owner _Opt p_specifier_qualifier_list =
            specifier_qualifier_list(ctx);

        if (p_specifier_qualifier_list == NULL)
        {
            throw;
        }

        p_type_name->specifier_qualifier_list = p_specifier_qualifier_list;

        struct declarator* _Owner _Opt p_declarator = declarator(ctx,
            p_type_name->specifier_qualifier_list, //??
            /*declaration_specifiers*/ NULL,
            true /*DEVE SER TODO*/,
            NULL);

        if (p_declarator == NULL)
            throw;

        p_type_name->abstract_declarator = p_declarator;

        p_type_name->abstract_declarator->specifier_qualifier_list = p_type_name->specifier_qualifier_list;

#pragma cake diagnostic push
#pragma cake diagnostic ignored "-Wmissing-destructor"    
        p_type_name->abstract_declarator->type = make_type_using_declarator(ctx, p_type_name->abstract_declarator);
#pragma cake diagnostic pop

        if (ctx->current == NULL)
        {
            throw;
        }

        if (ctx->current->prev == NULL)
            throw;

        p_type_name->last_token = ctx->current->prev;
        p_type_name->type = type_dup(&p_type_name->abstract_declarator->type);

    }
    catch
    {
        type_name_delete(p_type_name);
        p_type_name = NULL;
    }

    return p_type_name;
}

void braced_initializer_delete(struct braced_initializer* _Owner _Opt p)
{
    if (p)
    {
        initializer_list_delete(p->initializer_list);
        free(p);
    }
}
struct braced_initializer* _Owner _Opt braced_initializer(struct parser_ctx* ctx)
{
    /*
     { }
     { initializer-list }
     { initializer-list , }
    */

    struct braced_initializer* _Owner _Opt p_bracket_initializer_list = NULL;
    try
    {
        if (ctx->current == NULL)
            throw;

        p_bracket_initializer_list = calloc(1, sizeof(struct braced_initializer));

        if (p_bracket_initializer_list == NULL)
            throw;

        p_bracket_initializer_list->first_token = ctx->current;
        if (parser_match_tk(ctx, '{') != 0)
            throw;

        if (ctx->current == NULL)
            throw;

        if (ctx->current->type != '}')
        {
            p_bracket_initializer_list->initializer_list = initializer_list(ctx);
        }
        if (parser_match_tk(ctx, '}') != 0)
            throw;
    }
    catch
    {
        braced_initializer_delete(p_bracket_initializer_list);
        p_bracket_initializer_list = NULL;
    }
    return p_bracket_initializer_list;
}

void initializer_delete(struct initializer* _Owner _Opt p)
{
    if (p)
    {
        assert(p->next == NULL);
        expression_delete(p->assignment_expression);
        braced_initializer_delete(p->braced_initializer);
        designation_delete(p->designation);
        free(p);
    }
}

struct initializer* _Owner _Opt initializer(struct parser_ctx* ctx)
{
    /*
    initializer:
      assignment-expression
      braced-initializer
    */

    struct initializer* _Owner _Opt p_initializer = NULL;

    try
    {
        if (ctx->current == NULL)
            throw;

        p_initializer = calloc(1, sizeof(struct initializer));
        if (p_initializer == NULL)
            throw;

        p_initializer->first_token = ctx->current;

        if (ctx->current->type == '{')
        {
            p_initializer->braced_initializer = braced_initializer(ctx);
        }
        else
        {
            p_initializer->assignment_expression = assignment_expression(ctx);
        }
    }
    catch
    {
        initializer_delete(p_initializer);
        p_initializer = NULL;
    }
    return p_initializer;
}

void initializer_list_add(struct initializer_list* list, struct initializer* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void initializer_list_delete(struct initializer_list* _Owner _Opt p)
{
    if (p)
    {
        struct initializer* _Owner _Opt item = p->head;
        while (item)
        {
            struct initializer* _Owner _Opt next = item->next;
            item->next = NULL;
            initializer_delete(item);
            item = next;
        }
        free(p);
    }
}
struct initializer_list* _Owner _Opt initializer_list(struct parser_ctx* ctx)
{
    /*
    initializer-list:
       designation _Opt initializer
       initializer-list , designation _Opt initializer
    */

    struct initializer_list* _Owner _Opt p_initializer_list = NULL;

    try
    {
        if (ctx->current == NULL)
            return NULL;

        p_initializer_list = calloc(1, sizeof(struct initializer_list));
        if (p_initializer_list == NULL)
            throw;

        p_initializer_list->first_token = ctx->current;

        struct designation* _Owner _Opt p_designation = NULL;
        if (first_of_designator(ctx))
        {
            p_designation = designation(ctx);
            if (p_designation == NULL)
                throw;
        }

        struct initializer* _Owner _Opt p_initializer = initializer(ctx);

        if (p_initializer == NULL)
        {
            designation_delete(p_designation);
            throw;
        }

        assert(p_initializer->designation == NULL);
        p_initializer->designation = p_designation;

        initializer_list_add(p_initializer_list, p_initializer);
        p_initializer_list->size++;

        while (ctx->current != NULL && ctx->current->type == ',')
        {
            parser_match(ctx);

            if (ctx->current == NULL)
                throw;

            if (ctx->current->type == '}')
                break; // follow

            struct designation* _Owner _Opt p_designation2 = NULL;
            if (first_of_designator(ctx))
            {
                p_designation2 = designation(ctx);
                if (p_designation2 == NULL)
                    throw;
            }

            struct initializer* _Owner _Opt p_initializer2 = initializer(ctx);
            if (p_initializer2 == NULL)
            {
                designation_delete(p_designation2);
                throw;
            }

            assert(p_initializer2->designation == NULL);
            p_initializer2->designation = p_designation2;

            initializer_list_add(p_initializer_list, p_initializer2);
            p_initializer_list->size++;
        }
    }
    catch
    {
        initializer_list_delete(p_initializer_list);
        p_initializer_list = NULL;
    }
    return p_initializer_list;
}

void designation_delete(struct designation* _Owner _Opt p)
{
    if (p)
    {
        designator_list_delete(p->designator_list);
        free(p);
    }
}
struct designation* _Owner _Opt designation(struct parser_ctx* ctx)
{
    // designator_list '='
    struct designation* _Owner _Opt p_designation = NULL;
    try
    {
        p_designation = calloc(1, sizeof(struct designation));
        if (p_designation == NULL)
            throw;

        struct designator_list* _Owner _Opt p_designator_list = designator_list(ctx);

        if (p_designator_list == NULL)
            throw;

        p_designation->designator_list = p_designator_list;

        if (parser_match_tk(ctx, '=') != 0)
            throw;
    }
    catch
    {
        designation_delete(p_designation);
        p_designation = NULL;
    }
    return p_designation;
}


void designator_list_add(struct designator_list* list, struct designator* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void designator_list_delete(struct designator_list* _Owner _Opt p)
{
    if (p)
    {
        struct designator* _Owner _Opt  item = p->head;
        while (item)
        {
            struct designator* _Owner _Opt next = item->next;
            item->next = NULL;
            designator_delete(item);
            item = next;
        }
        free(p);
    }
}
struct designator_list* _Owner _Opt designator_list(struct parser_ctx* ctx)
{
    // designator
    // designator_list designator
    struct designator_list* _Owner _Opt p_designator_list = NULL;
    struct designator* _Owner _Opt p_designator = NULL;
    try
    {
        p_designator_list = calloc(1, sizeof(struct designator_list));
        if (p_designator_list == NULL)
            throw;

        p_designator = designator(ctx);
        if (p_designator == NULL)
            throw;
        designator_list_add(p_designator_list, p_designator);
        p_designator = NULL; /*MOVED*/

        while (ctx->current != NULL && first_of_designator(ctx))
        {
            p_designator = designator(ctx);
            if (p_designator == NULL)
                throw;
            designator_list_add(p_designator_list, p_designator);
            p_designator = NULL; /*MOVED*/
        }
    }
    catch
    {
        designator_list_delete(p_designator_list);
        p_designator_list = NULL;
    }

    return p_designator_list;
}

void designator_delete(struct designator* _Owner _Opt p)
{
    if (p)
    {
        assert(p->next == NULL);
        expression_delete(p->constant_expression_opt);
        free(p);
    }
}

struct designator* _Owner _Opt designator(struct parser_ctx* ctx)
{
    //'[' constant_expression ']'
    //'.' identifier
    struct designator* _Owner _Opt p_designator = NULL;

    try
    {
        if (ctx->current == NULL)
            throw;

        p_designator = calloc(1, sizeof(struct designator));
        if (p_designator == NULL)
            throw;

        if (ctx->current->type == '[')
        {
            if (parser_match_tk(ctx, '[') != 0)
                throw;
            p_designator->constant_expression_opt = constant_expression(ctx, true);
            if (parser_match_tk(ctx, ']') != 0)
                throw;
        }
        else if (ctx->current->type == '.')
        {
            parser_match(ctx);
            if (parser_match_tk(ctx, TK_IDENTIFIER) != 0)
                throw;
        }
    }
    catch
    {
        designator_delete(p_designator);
        p_designator = NULL;
    }
    return p_designator;
}

void static_assert_declaration_delete(struct static_assert_declaration* _Owner _Opt p)
{
    if (p)
    {
        expression_delete(p->constant_expression);
        free(p);
    }
}

void pragma_declaration_delete(struct pragma_declaration* _Owner _Opt p)
{
    if (p)
    {
        free(p);
    }
}

void execute_pragma(struct parser_ctx* ctx, struct pragma_declaration* p_pragma, bool on_flow_analysis)
{
    struct token* _Opt p_pragma_token = p_pragma->first_token;

    if (p_pragma_token->type != TK_PRAGMA)
    {
        assert(false);
        return;
    }

    p_pragma_token = pragma_match(p_pragma_token);

    if (p_pragma_token &&
        (strcmp(p_pragma_token->lexeme, "CAKE") == 0 ||
            strcmp(p_pragma_token->lexeme, "cake") == 0))
    {
        p_pragma_token = pragma_match(p_pragma_token);
    }

    if (p_pragma_token && strcmp(p_pragma_token->lexeme, "diagnostic") == 0)
    {
        p_pragma_token = pragma_match(p_pragma_token);

        if (p_pragma_token && strcmp(p_pragma_token->lexeme, "push") == 0)
        {
            // #pragma GCC diagnostic push
            if (ctx->options.diagnostic_stack.top_index <
                sizeof(ctx->options.diagnostic_stack) / sizeof(ctx->options.diagnostic_stack.stack[0]))
            {
                ctx->options.diagnostic_stack.top_index++;
                ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index] =
                    ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index - 1];
            }
            p_pragma_token = p_pragma_token->next;
        }
        else if (p_pragma_token && strcmp(p_pragma_token->lexeme, "pop") == 0)
        {
            // #pragma CAKE diagnostic pop
            if (ctx->options.diagnostic_stack.top_index > 0)
            {
                ctx->options.diagnostic_stack.top_index--;
            }
            p_pragma_token = pragma_match(p_pragma_token);
        }
        else if (p_pragma_token &&
            (strcmp(p_pragma_token->lexeme, "error") == 0 ||
                strcmp(p_pragma_token->lexeme, "warning") == 0 ||
                strcmp(p_pragma_token->lexeme, "note") == 0 ||
                strcmp(p_pragma_token->lexeme, "ignored") == 0))
        {
            const bool is_error = strcmp(p_pragma_token->lexeme, "error") == 0;
            const bool is_warning = strcmp(p_pragma_token->lexeme, "warning") == 0;
            const bool is_note = strcmp(p_pragma_token->lexeme, "note") == 0;

            p_pragma_token = pragma_match(p_pragma_token);

            if (p_pragma_token && p_pragma_token->type == TK_STRING_LITERAL)
            {

                unsigned long long w = get_warning_bit_mask(p_pragma_token->lexeme + 1 /*+ 2*/);

                ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors &= ~w;
                ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes &= ~w;
                ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings &= ~w;

                if (is_error)
                    ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors |= w;
                else if (is_warning)
                    ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings |= w;
                else if (is_note)
                    ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes |= w;
            }
        }
        else if (p_pragma_token &&
            (strcmp(p_pragma_token->lexeme, "check") == 0))
        {
            p_pragma_token = pragma_match(p_pragma_token);

            if (p_pragma_token && p_pragma_token->type == TK_STRING_LITERAL)
            {
                enum diagnostic_id id = get_warning(p_pragma_token->lexeme + 1);
                //warnings errors are removed on demand..

                if ((!on_flow_analysis && get_diagnostic_phase(id) != 2) ||
                    (on_flow_analysis && get_diagnostic_phase(id) == 2))
                {
                    bool found = false;
                    for (int i = 0;
                         i < (int)(sizeof(ctx->p_report->last_diagnostics_ids) / sizeof(ctx->p_report->last_diagnostics_ids[0]));
                         i++)
                    {
                        if (ctx->p_report->last_diagnostics_ids[i] == 0) break;

                        if (ctx->p_report->last_diagnostics_ids[i] == id)
                        {
                            // lets remove this error/warning/info from the final report.
                            found = true;
                            int t =
                                get_diagnostic_type(&ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index],
                                    id);
                            if (t == 3)
                                ctx->p_report->error_count--;
                            else if (t == 2)
                                ctx->p_report->warnings_count--;
                            else if (t == 1)
                                ctx->p_report->info_count--;

                            break;
                        }
                    }

                    if (!found)
                    {
                        //is fatal error?
                        //fatal errors are kept here and checked at end
                        ctx->p_report->fatal_error_expected = atoi(p_pragma_token->lexeme + 3);

                        compiler_diagnostic_message(C_ERROR_UNEXPECTED, ctx, p_pragma_token, NULL, "pragma check failed");
                    }
                }
            }
        }
        else
        {
            compiler_diagnostic_message(C_ERROR_UNEXPECTED, ctx, p_pragma_token, NULL, "unknown pragma");
        }
    }
    else if (p_pragma_token && strcmp(p_pragma_token->lexeme, "nullable") == 0)
    {
        //see
        //https://learn.microsoft.com/en-us/dotnet/csharp/nullable-references
        p_pragma_token = pragma_match(p_pragma_token);

        if (p_pragma_token && strcmp(p_pragma_token->lexeme, "enable") == 0)
        {
            unsigned long long w = NULLABLE_DISABLE_REMOVED_WARNINGS;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors &= ~w;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes &= ~w;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings &= ~w;

            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings |= w;
            ctx->options.null_checks_enabled = true;
            ctx->options.flow_analysis = true; //also enable flow analysis
        }
        if (p_pragma_token && strcmp(p_pragma_token->lexeme, "disable") == 0)
        {
            unsigned long long w = NULLABLE_DISABLE_REMOVED_WARNINGS;

            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors &= ~w;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes &= ~w;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings &= ~w;


            // Dereference warnings : Disabled
            // Assignment warnings : Disabled
            // Pointer types : All are nullable
            ctx->options.null_checks_enabled = false;
        }
    }
    else if (p_pragma_token && strcmp(p_pragma_token->lexeme, "ownership") == 0)
    {
        //see
        //https://learn.microsoft.com/en-us/dotnet/csharp/nullable-references
        p_pragma_token = pragma_match(p_pragma_token);

        if (p_pragma_token && strcmp(p_pragma_token->lexeme, "enable") == 0)
        {
            unsigned long long w = OWNERSHIP_DISABLE_REMOVED_WARNINGS;

            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors &= ~w;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes &= ~w;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings &= ~w;

            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings |= w;

            ctx->options.ownership_enabled = true;
            ctx->options.flow_analysis = true; //also enable flow analysis

        }
        if (p_pragma_token && strcmp(p_pragma_token->lexeme, "disable") == 0)
        {
            unsigned long long w = OWNERSHIP_DISABLE_REMOVED_WARNINGS;

            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors &= ~w;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes &= ~w;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings &= ~w;

            ctx->options.ownership_enabled = false;
        }
    }
    else if (p_pragma_token && strcmp(p_pragma_token->lexeme, "flow") == 0)
    {
        p_pragma_token = pragma_match(p_pragma_token);

        if (p_pragma_token && strcmp(p_pragma_token->lexeme, "enable") == 0)
        {
            ctx->options.flow_analysis = true;
        }
        if (p_pragma_token && strcmp(p_pragma_token->lexeme, "disable") == 0)
        {
            ctx->options.flow_analysis = false;
        }
    }
    else if (p_pragma_token && strcmp(p_pragma_token->lexeme, "safety") == 0)
    {
        p_pragma_token = pragma_match(p_pragma_token);

        if (p_pragma_token && strcmp(p_pragma_token->lexeme, "enable") == 0)
        {
            unsigned long long w = NULLABLE_DISABLE_REMOVED_WARNINGS | OWNERSHIP_DISABLE_REMOVED_WARNINGS;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors &= ~w;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes &= ~w;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings &= ~w;

            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings |= w;
            ctx->options.null_checks_enabled = true;
            ctx->options.flow_analysis = true; //also enable flow analysis

            ctx->options.ownership_enabled = true;
        }
        if (p_pragma_token && strcmp(p_pragma_token->lexeme, "disable") == 0)
        {
            unsigned long long w = NULLABLE_DISABLE_REMOVED_WARNINGS | OWNERSHIP_DISABLE_REMOVED_WARNINGS;

            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].errors &= ~w;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].notes &= ~w;
            ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index].warnings &= ~w;

            ctx->options.null_checks_enabled = false;
            ctx->options.ownership_enabled = false;
            ctx->options.flow_analysis = false;
        }
    }

}

struct pragma_declaration* _Owner _Opt pragma_declaration(struct parser_ctx* ctx)
{
    assert(ctx->current->type == TK_PRAGMA);
    struct pragma_declaration* _Owner _Opt p_pragma_declaration = NULL;
    try
    {
        if (ctx->current == NULL)
            throw;

        p_pragma_declaration = calloc(1, sizeof(struct pragma_declaration));
        if (p_pragma_declaration == NULL)
            throw;

        p_pragma_declaration->first_token = ctx->current;
        parser_match(ctx);
        while (ctx->current && ctx->current->type != TK_PRAGMA_END)
        {
            ctx->current = ctx->current->next;
        }

        if (ctx->current == NULL)
            throw;

        p_pragma_declaration->last_token = ctx->current;
        parser_match(ctx);
    }
    catch
    {
    }
    if (p_pragma_declaration)
        execute_pragma(ctx, p_pragma_declaration, false);

    return p_pragma_declaration;
}

struct static_assert_declaration* _Owner _Opt static_assert_declaration(struct parser_ctx* ctx)
{

    /*
     static_assert-declaration:
      "static_assert" ( constant-expression , string-literal ) ;
      "static_assert" ( constant-expression ) ;
    */

    struct static_assert_declaration* _Owner _Opt p_static_assert_declaration = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            throw;
        }

        p_static_assert_declaration = calloc(1, sizeof(struct static_assert_declaration));
        if (p_static_assert_declaration == NULL)
            throw;

        p_static_assert_declaration->first_token = ctx->current;
        struct token* position = ctx->current;

        parser_match(ctx);

        if (parser_match_tk(ctx, '(') != 0)
            throw;

        /*
         When flow analysis is enabled static assert is evaluated there
        */
        bool show_error_if_not_constant = false;
        if (p_static_assert_declaration->first_token->type == TK_KEYWORD__STATIC_ASSERT)
        {
            show_error_if_not_constant = true;
        }

        struct expression* _Owner _Opt p_constant_expression = constant_expression(ctx, show_error_if_not_constant);
        if (p_constant_expression == NULL)
            throw;

        p_static_assert_declaration->constant_expression = p_constant_expression;

        if (ctx->current == NULL)
            throw;

        if (ctx->current->type == ',')
        {
            parser_match(ctx);
            p_static_assert_declaration->string_literal_opt = ctx->current;
            if (parser_match_tk(ctx, TK_STRING_LITERAL) != 0)
                throw;
        }

        if (parser_match_tk(ctx, ')') != 0)
            throw;

        if (ctx->current == NULL)
            throw;

        p_static_assert_declaration->last_token = ctx->current;
        if (parser_match_tk(ctx, ';') != 0)
            throw;

        if (position->type == TK_KEYWORD__STATIC_ASSERT)
        {
            if (!constant_value_to_bool(&p_static_assert_declaration->constant_expression->constant_value))
            {
                if (p_static_assert_declaration->string_literal_opt)
                {
                    compiler_diagnostic_message(C_ERROR_STATIC_ASSERT_FAILED, ctx, position, NULL, "_Static_assert failed %s\n",
                        p_static_assert_declaration->string_literal_opt->lexeme);
                }
                else
                {
                    compiler_diagnostic_message(C_ERROR_STATIC_ASSERT_FAILED, ctx, position, NULL, "_Static_assert failed");
                }
            }
        }
    }
    catch
    {
    }

    return p_static_assert_declaration;
}

void attribute_specifier_sequence_add(struct attribute_specifier_sequence* list, struct attribute_specifier* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void attribute_specifier_sequence_delete(struct attribute_specifier_sequence* _Owner _Opt p)
{
    if (p)
    {
        struct attribute_specifier* _Owner _Opt item = p->head;
        while (item)
        {
            struct attribute_specifier* _Owner _Opt next = item->next;
            item->next = NULL;
            attribute_specifier_delete(item);
            item = next;
        }
        free(p);
    }
}

struct attribute_specifier_sequence* _Owner _Opt attribute_specifier_sequence_opt(struct parser_ctx* ctx)
{
    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence = NULL;
    try
    {
        if (ctx->current == NULL)
            throw;

        if (first_of_attribute_specifier(ctx))
        {
            p_attribute_specifier_sequence = calloc(1, sizeof(struct attribute_specifier_sequence));
            if (p_attribute_specifier_sequence == NULL)
                throw;

            p_attribute_specifier_sequence->first_token = ctx->current;

            while (ctx->current != NULL &&
                first_of_attribute_specifier(ctx))
            {
                struct attribute_specifier* _Owner _Opt p_attribute_specifier = attribute_specifier(ctx);
                if (p_attribute_specifier == NULL)
                    throw;

                p_attribute_specifier_sequence->attributes_flags |=
                    p_attribute_specifier->attribute_list->attributes_flags;

                attribute_specifier_sequence_add(p_attribute_specifier_sequence, p_attribute_specifier);
            }

            if (ctx->previous == NULL)
                throw;

            p_attribute_specifier_sequence->last_token = ctx->previous;
        }
    }
    catch
    {
        attribute_specifier_sequence_delete(p_attribute_specifier_sequence);
        p_attribute_specifier_sequence = NULL;
    }

    return p_attribute_specifier_sequence;
}

struct attribute_specifier_sequence* _Owner _Opt attribute_specifier_sequence(struct parser_ctx* ctx)
{
    // attribute_specifier_sequence_opt attribute_specifier
    struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence = NULL;
    try
    {
        p_attribute_specifier_sequence = calloc(1, sizeof(struct attribute_specifier_sequence));
        if (p_attribute_specifier_sequence == NULL)
            throw;

        while (first_of_attribute_specifier(ctx))
        {
            struct attribute_specifier* _Owner _Opt p_attribute_specifier = attribute_specifier(ctx);
            if (p_attribute_specifier == NULL) throw;

            attribute_specifier_sequence_add(p_attribute_specifier_sequence, p_attribute_specifier);
        }
    }
    catch
    {
        attribute_specifier_sequence_delete(p_attribute_specifier_sequence);
        p_attribute_specifier_sequence = NULL;
    }

    return p_attribute_specifier_sequence;
}

void attribute_specifier_delete(struct attribute_specifier* _Owner _Opt p)
{
    if (p)
    {
        attribute_list_delete(p->attribute_list);
        assert(p->next == NULL);
        free(p);
    }
}
struct attribute_specifier* _Owner _Opt attribute_specifier(struct parser_ctx* ctx)
{
    struct attribute_specifier* _Owner _Opt p_attribute_specifier = NULL;
    try
    {
        if (ctx->current == NULL)
            throw;

        p_attribute_specifier = calloc(1, sizeof(struct attribute_specifier));
        if (p_attribute_specifier == NULL)
            throw;

        p_attribute_specifier->first_token = ctx->current;

        //'[' '[' attribute_list ']' ']'
        if (parser_match_tk(ctx, '[') != 0)
            throw;
        if (parser_match_tk(ctx, '[') != 0)
            throw;

        struct attribute_list* _Owner _Opt p_attribute_list = attribute_list(ctx);

        if (p_attribute_list == NULL)
            throw;

        p_attribute_specifier->attribute_list = p_attribute_list;
        if (parser_match_tk(ctx, ']') != 0)
            throw;

        if (ctx->current == NULL)
            throw;

        p_attribute_specifier->last_token = ctx->current;
        if (parser_match_tk(ctx, ']') != 0)
            throw;
    }
    catch
    {
        attribute_specifier_delete(p_attribute_specifier);
        p_attribute_specifier = NULL;
    }
    return p_attribute_specifier;
}

void attribute_delete(struct attribute* _Owner _Opt p)
{
    if (p)
    {
        attribute_token_delete(p->attribute_token);
        attribute_argument_clause_delete(p->attribute_argument_clause);
        assert(p->next == NULL);
        free(p);
    }
}

void attribute_list_add(struct attribute_list* list, struct attribute* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void attribute_list_destroy(struct attribute_list* _Obj_owner p)
{
    struct attribute* _Owner _Opt item = p->head;
    while (item)
    {
        struct attribute* _Owner _Opt next = item->next;
        item->next = NULL;
        attribute_delete(item);
        item = next;
    }
}
void attribute_list_delete(struct attribute_list* _Owner p)
{
    if (p)
    {
        attribute_list_destroy(p);
        free(p);
    }
}

struct attribute_list* _Owner _Opt attribute_list(struct parser_ctx* ctx)
{
    struct attribute_list* _Owner _Opt p_attribute_list = NULL;
    try
    {
        p_attribute_list = calloc(1, sizeof(struct attribute_list));
        if (p_attribute_list == NULL)
            throw;

        //
        // attribute_list ',' attribute_opt
        while (ctx->current != NULL && (first_of_attribute(ctx) ||
            ctx->current->type == ','))
        {
            if (first_of_attribute(ctx))
            {
                struct attribute* _Owner _Opt p_attribute = attribute(ctx);
                if (p_attribute == NULL) throw;

                p_attribute_list->attributes_flags |= p_attribute->attributes_flags;
                attribute_list_add(p_attribute_list, p_attribute);
            }

            if (ctx->current == NULL)
                throw;

            if (ctx->current->type == ',')
            {
                parser_match(ctx);
            }
        }
    }
    catch
    {
        attribute_list_delete(p_attribute_list);
        p_attribute_list = NULL;
    }

    return p_attribute_list;
}

bool first_of_attribute(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;
    return ctx->current->type == TK_IDENTIFIER;
}

struct attribute* _Owner _Opt attribute(struct parser_ctx* ctx)
{
    struct attribute* _Owner _Opt p_attribute = NULL;
    try
    {
        p_attribute = calloc(1, sizeof(struct attribute));
        if (p_attribute == NULL)
            throw;

        struct attribute_token* _Owner _Opt p_attribute_token = attribute_token(ctx);

        if (p_attribute_token == NULL)
            throw;

        // attribute_token attribute_argument_clause_opt
        p_attribute->attribute_token = p_attribute_token;
        if (ctx->current == NULL)
            throw;

        p_attribute->attributes_flags = p_attribute->attribute_token->attributes_flags;
        if (ctx->current->type == '(') // first
        {
            struct attribute_argument_clause* _Owner _Opt  p_attribute_argument_clause =
                attribute_argument_clause(ctx);
            if (p_attribute_argument_clause == NULL)
                throw;
            p_attribute->attribute_argument_clause = p_attribute_argument_clause;
        }
    }
    catch
    {
        attribute_delete(p_attribute);
        p_attribute = NULL;
    }
    return p_attribute;
}

void attribute_token_delete(struct attribute_token* _Owner _Opt p)
{
    if (p)
    {
        free(p);
    }
}

struct attribute_token* _Owner _Opt attribute_token(struct parser_ctx* ctx)
{
    struct attribute_token* _Owner _Opt p_attribute_token = NULL;
    try
    {
        if (ctx->current == NULL)
            throw;

        p_attribute_token = calloc(1, sizeof(struct attribute_token));
        if (p_attribute_token == NULL)
            throw;

        struct token* attr_token = ctx->current;

        bool is_standard_attribute = false;
        if (strcmp(attr_token->lexeme, "deprecated") == 0)
        {
            is_standard_attribute = true;
            p_attribute_token->attributes_flags = STD_ATTRIBUTE_DEPRECATED;
        }
        else if (strcmp(attr_token->lexeme, "fallthrough") == 0)
        {
            is_standard_attribute = true;
        }
        else if (strcmp(attr_token->lexeme, "maybe_unused") == 0)
        {
            is_standard_attribute = true;
            p_attribute_token->attributes_flags = STD_ATTRIBUTE_MAYBE_UNUSED;
        }
        else if (strcmp(attr_token->lexeme, "noreturn") == 0)
        {
            is_standard_attribute = true;
            p_attribute_token->attributes_flags = STD_ATTRIBUTE_NORETURN;
        }
        else if (strcmp(attr_token->lexeme, "reproducible") == 0)
        {
            is_standard_attribute = true;
            p_attribute_token->attributes_flags = STD_ATTRIBUTE_REPRODUCIBLE;
        }
        else if (strcmp(attr_token->lexeme, "unsequenced") == 0)
        {
            is_standard_attribute = true;
            p_attribute_token->attributes_flags = STD_ATTRIBUTE_UNSEQUENCED;
        }
        else if (strcmp(attr_token->lexeme, "nodiscard") == 0)
        {
            is_standard_attribute = true;
            p_attribute_token->attributes_flags = STD_ATTRIBUTE_NODISCARD;
        }

        const bool is_cake_attr = strcmp(attr_token->lexeme, "cake") == 0;

        if (token_is_identifier_or_keyword(ctx->current->type))
        {
            parser_match(ctx);
        }
        else
        {
            compiler_diagnostic_message(C_ERROR_UNEXPECTED_TOKEN, ctx, attr_token, NULL, "expected identifier");
        }

        if (ctx->current == NULL) throw;

        if (ctx->current->type == '::')
        {
            parser_match(ctx);
            if (is_cake_attr)
            {
                compiler_diagnostic_message(W_ATTRIBUTES, ctx, attr_token, NULL, "warning '%s' is not an cake attribute", ctx->current->lexeme);
            }

            if (ctx->current == NULL)
                throw;

            if (token_is_identifier_or_keyword(ctx->current->type))
            {
                parser_match(ctx);
            }
            else
            {
                compiler_diagnostic_message(C_ERROR_UNEXPECTED_TOKEN, ctx, attr_token, NULL, "expected identifier");
            }
        }
        else
        {
            /*
             * Each implementation should choose a distinctive name for the attribute prefix in an attribute
             * prefixed token. Implementations should not define attributes without an attribute prefix unless it is
             * a standard attribute as specified in this document.
             */
            if (!is_standard_attribute)
            {
                compiler_diagnostic_message(W_ATTRIBUTES, ctx, attr_token, NULL, "warning '%s' is not an standard attribute", attr_token->lexeme);
            }
        }
    }
    catch
    {
        attribute_token_delete(p_attribute_token);
        p_attribute_token = NULL;
    }

    return p_attribute_token;
}

void attribute_argument_clause_delete(struct attribute_argument_clause* _Owner _Opt p)
{
    if (p)
    {
        balanced_token_sequence_delete(p->p_balanced_token_sequence);
        free(p);
    }
}
struct attribute_argument_clause* _Owner _Opt  attribute_argument_clause(struct parser_ctx* ctx)
{
    struct attribute_argument_clause* _Owner _Opt p_attribute_argument_clause = calloc(1, sizeof(struct attribute_argument_clause));
    try
    {
        if (p_attribute_argument_clause == NULL)
            throw;

        //'(' balanced_token_sequence_opt ')'
        if (parser_match_tk(ctx, '(') != 0)
            throw;
        p_attribute_argument_clause->p_balanced_token_sequence = balanced_token_sequence_opt(ctx);
        if (parser_match_tk(ctx, ')') != 0)
            throw;
    }
    catch
    {
        attribute_argument_clause_delete(p_attribute_argument_clause);
        p_attribute_argument_clause = NULL;
    }
    return p_attribute_argument_clause;
}

void balanced_token_sequence_delete(struct balanced_token_sequence* _Owner _Opt p)
{
    if (p)
    {
        struct balanced_token* _Owner _Opt item = p->head;
        while (item)
        {
            struct balanced_token* _Owner _Opt  next = item->next;
            free(item);
            item = next;
        }
        free(p);
    }
}
struct balanced_token_sequence* _Owner _Opt balanced_token_sequence_opt(struct parser_ctx* ctx)
{
    struct balanced_token_sequence* _Owner _Opt p_balanced_token_sequence = calloc(1, sizeof(struct balanced_token_sequence));
    try
    {
        if (p_balanced_token_sequence == NULL)
            throw;

        // balanced_token
        // balanced_token_sequence balanced_token
        int count1 = 0;
        int count2 = 0;
        int count3 = 0;
        for (; ctx->current;)
        {
            if (ctx->current->type == '(')
                count1++;
            else if (ctx->current->type == '[')
                count2++;
            else if (ctx->current->type == '{')
                count3++;
            else if (ctx->current->type == ')')
            {
                if (count1 == 0)
                {
                    // parser_match(ctx);
                    break;
                }
                count1--;
            }
            else if (ctx->current->type == '[')
                count2--;
            else if (ctx->current->type == '{')
                count3--;
            parser_match(ctx);
        }
        if (count2 != 0)
        {
            compiler_diagnostic_message(C_ERROR_ATTR_UNBALANCED, ctx, ctx->current, NULL, "expected ']' before ')'");
        }
        if (count3 != 0)
        {
            compiler_diagnostic_message(C_ERROR_ATTR_UNBALANCED, ctx, ctx->current, NULL, "expected '}' before ')'");
        }
    }
    catch
    {
        balanced_token_sequence_delete(p_balanced_token_sequence);
        p_balanced_token_sequence = NULL;
    }
    return p_balanced_token_sequence;
}

void statement_delete(struct statement* _Owner _Opt p)
{
    if (p)
    {
        labeled_statement_delete(p->labeled_statement);
        unlabeled_statement_delete(p->unlabeled_statement);
        free(p);
    }
}
struct statement* _Owner _Opt statement(struct parser_ctx* ctx)
{
    struct statement* _Owner _Opt p_statement = calloc(1, sizeof(struct statement));
    try
    {
        if (p_statement == NULL)
            throw;

        if (first_of_labeled_statement(ctx))
        {
            p_statement->labeled_statement = labeled_statement(ctx);
            if (p_statement->labeled_statement == NULL)
                throw;
        }
        else
        {
            p_statement->unlabeled_statement = unlabeled_statement(ctx);
            if (p_statement->unlabeled_statement == NULL)
                throw;
        }
    }
    catch
    {
        statement_delete(p_statement);
        p_statement = NULL;
    }
    return p_statement;
}

struct primary_block* _Owner _Opt primary_block(struct parser_ctx* ctx)
{
    assert(ctx->current != NULL);
    struct primary_block* _Owner _Opt p_primary_block = calloc(1, sizeof(struct primary_block));
    try
    {
        if (p_primary_block == NULL)
            throw;

        if (first_of_compound_statement(ctx))
        {
            p_primary_block->compound_statement = compound_statement(ctx);
            if (p_primary_block->compound_statement == NULL)
                throw;
        }
        else if (first_of_selection_statement(ctx))
        {
            p_primary_block->selection_statement = selection_statement(ctx);
            if (p_primary_block->selection_statement == NULL)
                throw;
        }
        else if (first_of_iteration_statement(ctx))
        {
            p_primary_block->iteration_statement = iteration_statement(ctx);
            if (p_primary_block->iteration_statement == NULL)
                throw;
        }
        else if (ctx->current->type == TK_KEYWORD_DEFER)
        {
            p_primary_block->defer_statement = defer_statement(ctx);
            if (p_primary_block->defer_statement == NULL)
                throw;
        }
        else if (ctx->current->type == TK_KEYWORD_TRY)
        {
            p_primary_block->try_statement = try_statement(ctx);
            if (p_primary_block->try_statement == NULL)
                throw;
        }
        else
        {
            compiler_diagnostic_message(C_ERROR_UNEXPECTED_TOKEN, ctx, ctx->current, NULL, "unexpected token");
        }
    }
    catch
    {
        primary_block_delete(p_primary_block);
        p_primary_block = NULL;
    }
    return p_primary_block;
}

struct secondary_block* _Owner _Opt secondary_block(struct parser_ctx* ctx)
{
    struct secondary_block* _Owner _Opt p_secondary_block = NULL;
    try
    {
        if (ctx->current == NULL) throw;

        check_open_brace_style(ctx, ctx->current);

        p_secondary_block = calloc(1, sizeof(struct secondary_block));
        if (p_secondary_block == NULL)
            throw;

        if (ctx->current == NULL)
            throw;

        p_secondary_block->first_token = ctx->current;

        struct statement* _Owner _Opt p_statement = statement(ctx);
        if (p_statement == NULL)
            throw;

        p_secondary_block->statement = p_statement;

        if (ctx->previous == NULL)
            throw;

        p_secondary_block->last_token = ctx->previous;

        check_close_brace_style(ctx, p_secondary_block->last_token);
    }
    catch
    {
        secondary_block_delete(p_secondary_block);
        p_secondary_block = NULL;
    }
    return p_secondary_block;
}

bool unlabeled_statement_ends_with_jump(struct unlabeled_statement* p_unlabeled_statement)
{
    struct expression* _Opt p_expression = NULL;

    if (p_unlabeled_statement->expression_statement)
    {
        p_expression = p_unlabeled_statement->expression_statement->expression_opt;
    }
    else if (p_unlabeled_statement->jump_statement)
    {
        return true;
    }
    else if (p_unlabeled_statement->primary_block &&
        p_unlabeled_statement->primary_block->compound_statement &&
        p_unlabeled_statement->primary_block->compound_statement->block_item_list.tail &&
        p_unlabeled_statement->primary_block->compound_statement->block_item_list.tail->unlabeled_statement &&
        p_unlabeled_statement->primary_block->compound_statement->block_item_list.tail->unlabeled_statement->expression_statement)
    {
        p_expression =
            p_unlabeled_statement->primary_block->compound_statement->block_item_list.tail->unlabeled_statement->expression_statement->expression_opt;
    }

    if (p_expression)
    {
        return p_expression->type.attributes_flags & STD_ATTRIBUTE_NORETURN;
    }

    if (p_unlabeled_statement->primary_block &&
        p_unlabeled_statement->primary_block->compound_statement &&
        p_unlabeled_statement->primary_block->compound_statement->block_item_list.tail &&
        p_unlabeled_statement->primary_block->compound_statement->block_item_list.tail->unlabeled_statement)
    {
        return
            p_unlabeled_statement->primary_block->compound_statement->block_item_list.tail->unlabeled_statement->jump_statement != NULL;
    }

    return false;
}

bool secondary_block_ends_with_jump(struct secondary_block* _Opt p_secondary_block)
{
    if (p_secondary_block &&
        p_secondary_block->statement->unlabeled_statement)
    {
        return unlabeled_statement_ends_with_jump(p_secondary_block->statement->unlabeled_statement);
    }
    return false;
}

void secondary_block_delete(struct secondary_block* _Owner _Opt p)
{
    if (p)
    {
        statement_delete(p->statement);
        free(p);
    }
}
void primary_block_delete(struct primary_block* _Owner _Opt p)
{
    if (p)
    {
        compound_statement_delete(p->compound_statement);
        defer_statement_delete(p->defer_statement);
        iteration_statement_delete(p->iteration_statement);
        selection_statement_delete(p->selection_statement);
        try_statement_delete(p->try_statement);
        free(p);
    }
}

bool first_of_primary_block(const struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return false;

    if (first_of_compound_statement(ctx) ||
        first_of_selection_statement(ctx) ||
        first_of_iteration_statement(ctx) ||
        ctx->current->type == TK_KEYWORD_DEFER /*extension*/ ||
        ctx->current->type == TK_KEYWORD_TRY /*extension*/
        )
    {
        return true;
    }
    return false;
}

void unlabeled_statement_delete(struct unlabeled_statement* _Owner _Opt p)
{
    if (p)
    {
        expression_statement_delete(p->expression_statement);
        jump_statement_delete(p->jump_statement);
        primary_block_delete(p->primary_block);
        free(p);
    }
}

struct unlabeled_statement* _Owner _Opt unlabeled_statement(struct parser_ctx* ctx)
{
    /*
     unlabeled-statement:
       expression-statement
       attribute-specifier-sequence _Opt primary-block
       attribute-specifier-sequence _Opt jump-statement
    */
    struct unlabeled_statement* _Owner _Opt p_unlabeled_statement = calloc(1, sizeof(struct unlabeled_statement));
    try
    {
        if (p_unlabeled_statement == NULL)
            throw;

        if (first_of_primary_block(ctx))
        {
            p_unlabeled_statement->primary_block = primary_block(ctx);
            if (p_unlabeled_statement->primary_block == NULL)
                throw;
        }
        else if (first_of_jump_statement(ctx))
        {
            p_unlabeled_statement->jump_statement = jump_statement(ctx);
            if (p_unlabeled_statement->jump_statement == NULL)
                throw;
        }
        else
        {
            p_unlabeled_statement->expression_statement = expression_statement(ctx, false);
            if (p_unlabeled_statement->expression_statement == NULL)
                throw;

            if (p_unlabeled_statement->expression_statement->expression_opt)
            {
                if (!type_is_void(&p_unlabeled_statement->expression_statement->expression_opt->type) &&
                    type_is_nodiscard(&p_unlabeled_statement->expression_statement->expression_opt->type) &&
                    p_unlabeled_statement->expression_statement->expression_opt->type.storage_class_specifier_flags & STORAGE_SPECIFIER_FUNCTION_RETURN)
                {

                    if (p_unlabeled_statement->expression_statement->expression_opt->first_token->level == 0)
                    {
                        compiler_diagnostic_message(W_ATTRIBUTES, ctx,
                            p_unlabeled_statement->expression_statement->expression_opt->first_token, NULL,
                            "ignoring return value of function declared with 'nodiscard' attribute");
                    }
                }
                if (type_is_owner(&p_unlabeled_statement->expression_statement->expression_opt->type) &&
                    p_unlabeled_statement->expression_statement->expression_opt->type.storage_class_specifier_flags & STORAGE_SPECIFIER_FUNCTION_RETURN)
                {

                    if (p_unlabeled_statement->expression_statement->expression_opt->first_token->level == 0)
                    {
                        compiler_diagnostic_message(W_ATTRIBUTES, ctx,
                            p_unlabeled_statement->expression_statement->expression_opt->first_token, NULL,
                            "ignoring the result of _Owner type ");
                    }
                }
            }
            if (p_unlabeled_statement->expression_statement->expression_opt &&
                p_unlabeled_statement->expression_statement->expression_opt->expression_type == POSTFIX_FUNCTION_CALL)
            {
            }
            else
            {
                /*
                 *  The objective here is to detect expression with not effect
                 *  a == b; etc
                 */
                if (p_unlabeled_statement != NULL &&
                    p_unlabeled_statement->jump_statement == NULL &&
                    p_unlabeled_statement->expression_statement != NULL &&
                    p_unlabeled_statement->expression_statement->expression_opt &&
                    !type_is_void(&p_unlabeled_statement->expression_statement->expression_opt->type) &&
                    p_unlabeled_statement->expression_statement->expression_opt->expression_type != ASSIGNMENT_EXPRESSION &&
                    p_unlabeled_statement->expression_statement->expression_opt->expression_type != POSTFIX_FUNCTION_CALL &&
                    p_unlabeled_statement->expression_statement->expression_opt->expression_type != POSTFIX_INCREMENT &&
                    p_unlabeled_statement->expression_statement->expression_opt->expression_type != POSTFIX_DECREMENT &&
                    p_unlabeled_statement->expression_statement->expression_opt->expression_type != UNARY_EXPRESSION_INCREMENT &&
                    p_unlabeled_statement->expression_statement->expression_opt->expression_type != UNARY_EXPRESSION_DECREMENT &&
                    p_unlabeled_statement->expression_statement->expression_opt->expression_type != UNARY_DECLARATOR_ATTRIBUTE_EXPR &&
                    p_unlabeled_statement->expression_statement->expression_opt->expression_type != UNARY_EXPRESSION_ASSERT)
                {
                    if (ctx->current &&
                        ctx->current->level == 0)
                    {
#if 0
                        //too many false..alerts.
                        //make list of for sure ...
                        compiler_diagnostic_message(W_UNUSED_VALUE,
                            ctx,
                            p_unlabeled_statement->expression_statement->expression_opt->first_token,
                            "expression not used");
#endif
                    }
                }
            }
        }
    }
    catch
    {
        unlabeled_statement_delete(p_unlabeled_statement);
        p_unlabeled_statement = NULL;
    }

    return p_unlabeled_statement;
}

void label_delete(struct label* _Owner _Opt p)
{
    if (p)
    {
        expression_delete(p->constant_expression);
        free(p);
    }
}

struct label* _Owner _Opt label(struct parser_ctx* ctx)
{
    if (ctx->current == NULL)
        return NULL;

    struct label* _Owner _Opt p_label = calloc(1, sizeof(struct label));
    try
    {
        if (p_label == NULL)
            throw;

        if (ctx->current->type == TK_IDENTIFIER)
        {
            p_label->p_identifier_opt = ctx->current;
            parser_match(ctx);
            if (parser_match_tk(ctx, ':') != 0)
                throw;
        }
        else if (ctx->current->type == TK_KEYWORD_CASE)
        {
            if (ctx->p_current_selection_statement == NULL ||
                ctx->p_current_selection_statement->condition == NULL)
            {
                //unexpected because we are in case
                throw;
            }

            parser_match(ctx);
            p_label->constant_expression = constant_expression(ctx, true);
            if (p_label->constant_expression == NULL)
                throw;

            if (parser_match_tk(ctx, ':') != 0)
                throw;

            const long long case_value = constant_value_to_signed_long_long(&p_label->constant_expression->constant_value);

            if (ctx->p_switch_value_list == NULL)
            {
                //unexpected because we are in case
                throw;
            }

            struct switch_value* _Opt p_switch_value = switch_value_list_find(ctx->p_switch_value_list, case_value);

            if (p_switch_value)
            {
                compiler_diagnostic_message(W_SWITCH,
                        ctx,
                        p_label->constant_expression->first_token, NULL,
                        "duplicate case value '%lld'", case_value);

                compiler_diagnostic_message(W_LOCATION,
                    ctx,
                    p_switch_value->p_label->constant_expression->first_token, NULL, "previous declaration");
            }

            struct  switch_value* _Owner _Opt newvalue = calloc(1, sizeof * newvalue);
            if (newvalue == NULL)
                throw;

            newvalue->p_label = p_label;
            newvalue->value = case_value;
            switch_value_list_push(ctx->p_switch_value_list, newvalue);

            if (p_label->constant_expression &&
            ctx->p_current_selection_statement &&
            ctx->p_current_selection_statement->condition &&
            ctx->p_current_selection_statement->condition->expression)
            {
                if (type_is_enum(&ctx->p_current_selection_statement->condition->expression->type))
                {
                    if (type_is_enum(&p_label->constant_expression->type))
                    {
                        check_diferent_enuns(ctx,
                                    p_label->constant_expression->first_token,
                                    p_label->constant_expression,
                                    ctx->p_current_selection_statement->condition->expression,
                                    "mismatch in enumeration types");
                    }
                    else
                    {
                        //enum and something else...
                    }
                }

                const struct enum_specifier* _Opt p_enum_specifier = NULL;

                if (ctx->p_current_selection_statement->condition->expression->type.enum_specifier)
                {
                    p_enum_specifier = get_complete_enum_specifier(ctx->p_current_selection_statement->condition->expression->type.enum_specifier);
                }

                if (p_enum_specifier)
                {
                    const struct enumerator* _Opt p_enumerator = find_enumerator_by_value(p_enum_specifier, case_value);
                    if (p_enumerator == NULL)
                    {
                        compiler_diagnostic_message(W_ENUN_CONVERSION,
                                        ctx,
                                        p_label->constant_expression->first_token, NULL,
                                        "case value '%lld' not in enumerated type 'enum %s'",
                                        case_value,
                                        p_enum_specifier->tag_name);
                    }
                    else
                    {

                    }
                }
            }

        }
        else if (ctx->current->type == TK_KEYWORD_DEFAULT)
        {
            if (ctx->p_switch_value_list->p_default)
            {
                //two defaults?
                throw;
            }

            struct  switch_value* _Owner _Opt p_default = calloc(1, sizeof * p_default);
            if (p_default == NULL)
            {
                throw;
            }

            p_default->p_label = p_label;
            ctx->p_switch_value_list->p_default = p_default;

            parser_match(ctx);
            if (parser_match_tk(ctx, ':') != 0)
                throw;
        }
        // attribute_specifier_sequence_opt identifier ':'
        // attribute_specifier_sequence_opt 'case' constant_expression ':'
        // attribute_specifier_sequence_opt 'default' ':'
    }
    catch
    {
        label_delete(p_label);
        p_label = NULL;
    }
    return p_label;
}

void labeled_statement_delete(struct labeled_statement* _Owner _Opt p)
{
    if (p)
    {
        label_delete(p->label);
        statement_delete(p->statement);
        free(p);
    }
}

struct labeled_statement* _Owner _Opt labeled_statement(struct parser_ctx* ctx)
{
    struct labeled_statement* _Owner _Opt p_labeled_statement = calloc(1, sizeof(struct labeled_statement));
    try
    {
        if (p_labeled_statement == NULL)
            throw;

        // label statement
        struct label* _Owner _Opt p_label = label(ctx);

        if (p_label == NULL)
            throw;

        p_labeled_statement->label = p_label;

        struct statement* _Owner _Opt p_statement = statement(ctx);
        if (p_statement == NULL)
            throw;

        p_labeled_statement->statement = p_statement;
    }
    catch
    {
        labeled_statement_delete(p_labeled_statement);
        p_labeled_statement = NULL;
    }
    return p_labeled_statement;
}

void compound_statement_delete(struct compound_statement* _Owner _Opt p)
{
    if (p)
    {
        block_item_list_destroy(&p->block_item_list);
        free(p);
    }
}

struct compound_statement* _Owner _Opt compound_statement(struct parser_ctx* ctx)
{

    struct scope block_scope = { .variables.capacity = 10 };

    //'{' block_item_list_opt '}'
    struct compound_statement* _Owner _Opt p_compound_statement = NULL;

    try
    {
        if (ctx->current == NULL)
            throw;

        p_compound_statement = calloc(1, sizeof(struct compound_statement));

        if (p_compound_statement == NULL)
            throw;

        p_compound_statement->diagnostic_flags = ctx->options.diagnostic_stack.stack[ctx->options.diagnostic_stack.top_index];

        scope_list_push(&ctx->scopes, &block_scope);

        p_compound_statement->first_token = ctx->current;
        if (parser_match_tk(ctx, '{') != 0)
            throw;

        if (ctx->current == NULL)
            throw;

        if (ctx->current->type != '}')
        {
            bool berror = false;
            p_compound_statement->block_item_list = block_item_list(ctx, &berror);
            if (berror)
                throw;
        }

        if (ctx->current == NULL)
            throw;

        p_compound_statement->last_token = ctx->current;
        if (parser_match_tk(ctx, '}') != 0)
            throw;

        // TODO ver quem nao foi usado.

        for (int i = 0; i < block_scope.variables.capacity; i++)
        {
            if (block_scope.variables.table == NULL)
                continue;
            struct map_entry* _Opt entry = block_scope.variables.table[i];
            while (entry)
            {

                if (entry->type != TAG_TYPE_ONLY_DECLARATOR &&
                    entry->type != TAG_TYPE_INIT_DECLARATOR)
                {
                    entry = entry->next;
                    continue;
                }

                struct declarator* _Opt p_declarator = NULL;
                struct init_declarator* _Opt p_init_declarator = NULL;
                if (entry->type == TAG_TYPE_INIT_DECLARATOR)
                {
                    p_init_declarator = entry->p;
                    p_declarator = p_init_declarator->p_declarator;
                }
                else
                {
                    p_declarator = entry->p;
                }

                if (p_declarator)
                {

                    if (!type_is_maybe_unused(&p_declarator->type) &&
                        p_declarator->num_uses == 0)
                    {
                        if (p_declarator->name_opt->token_origin->level == 0)
                        {
                            compiler_diagnostic_message(W_UNUSED_VARIABLE,
                                ctx,
                                p_declarator->name_opt, NULL,
                                "'%s': unreferenced declarator",
                                p_declarator->name_opt->lexeme);
                        }
                    }
                }

                entry = entry->next;
            }
        }
    }
    catch
    {
        compound_statement_delete(p_compound_statement);
        p_compound_statement = NULL;
    }
    scope_list_pop(&ctx->scopes);

    scope_destroy(&block_scope);

    return p_compound_statement;
}

void block_item_list_add(struct block_item_list* list, struct block_item* _Owner p_item)
{

    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;

}

void block_item_list_destroy(struct block_item_list* _Obj_owner list)
{
    struct block_item* _Owner _Opt item = list->head;
    while (item)
    {
        struct block_item* _Owner _Opt next = item->next;
        item->next = NULL;
        block_item_delete(item);
        item = next;
    }
}

struct block_item_list block_item_list(struct parser_ctx* ctx, bool* error)
{
    /*
      block_item_list:
      block_item
      block_item_list block_item
    */
    *error = false;
    struct block_item_list block_item_list = { 0 };
    struct block_item* _Owner _Opt p_block_item = NULL;
    try
    {
        p_block_item = block_item(ctx);
        if (p_block_item == NULL)
            throw;

        block_item_list_add(&block_item_list, p_block_item);

        p_block_item = NULL; /*MOVED*/

        while (ctx->current != NULL && ctx->current->type != '}') // follow
        {
            p_block_item = block_item(ctx);
            if (p_block_item == NULL)
                throw;
            block_item_list_add(&block_item_list, p_block_item);
            p_block_item = NULL; /*MOVED*/
        }
    }
    catch
    {
        *error = true;
    }

    return block_item_list;
}

void block_item_delete(struct block_item* _Owner _Opt p)
{
    if (p)
    {
        declaration_delete(p->declaration);
        label_delete(p->label);
        unlabeled_statement_delete(p->unlabeled_statement);
        assert(p->next == NULL);
        free(p);
    }
}

struct block_item* _Owner _Opt block_item(struct parser_ctx* ctx)
{
    //   declaration
    //     unlabeled_statement
    //   label


    struct block_item* _Owner _Opt p_block_item = NULL;

    try
    {
        if (ctx->current == NULL)
            throw;

        p_block_item = calloc(1, sizeof(struct block_item));
        if (p_block_item == NULL)
            throw;

        /*
         * Attributes can be first of declaration, labels etc..
         * so it is better to parse it in advance.
         */
        struct attribute_specifier_sequence* _Owner _Opt p_attribute_specifier_sequence_opt =
            attribute_specifier_sequence_opt(ctx);

        if (ctx->current == NULL)
        {
            attribute_specifier_sequence_delete(p_attribute_specifier_sequence_opt);
            throw;
        }

        p_block_item->first_token = ctx->current;

        if (ctx->current->type == TK_KEYWORD__ASM)
        { /*
       asm-block:
       __asm assembly-instruction ;_Opt
       __asm { assembly-instruction-list } ;_Opt

   assembly-instruction-list:
       assembly-instruction ;_Opt
       assembly-instruction ; assembly-instruction-list ;_Opt
       */

            parser_match(ctx);

            if (ctx->current == NULL)
                throw;

            if (ctx->current->type == '{')
            {
                parser_match(ctx);

                while (ctx->current && ctx->current->type != '}')
                {
                    parser_match(ctx);
                }

                parser_match(ctx);
            }
            else
            {

                while (ctx->current && ctx->current->type != TK_NEWLINE)
                {
                    ctx->current = ctx->current->next;
                }

                parser_match(ctx);
            }

            if (ctx->current == NULL)
                throw;

            if (ctx->current->type == ';')
                parser_match(ctx);
        }
        else if (first_of_declaration_specifier(ctx) ||
            first_of_static_assert_declaration(ctx) ||
            first_of_pragma_declaration(ctx))
        {
            p_block_item->declaration = declaration(ctx, p_attribute_specifier_sequence_opt, STORAGE_SPECIFIER_AUTOMATIC_STORAGE);
            if (p_block_item->declaration == NULL)
                throw;
            p_attribute_specifier_sequence_opt = NULL; /*MOVED*/

            struct init_declarator* _Opt p = p_block_item->declaration->init_declarator_list.head;
            while (p)
            {
                if (p->p_declarator && p->p_declarator->name_opt)
                {
                    naming_convention_local_var(ctx, p->p_declarator->name_opt, &p->p_declarator->type);
                }
                p = p->next;
            }
        }
        else if (first_of_label(ctx))
        {
            // so identifier confunde com expression
            p_block_item->label = label(ctx);
            if (p_block_item->label == NULL)
            {
                attribute_specifier_sequence_delete(p_attribute_specifier_sequence_opt);
                throw;
            }
        }
        else
        {
            p_block_item->unlabeled_statement = unlabeled_statement(ctx);
            if (p_block_item->unlabeled_statement == NULL)
            {
                attribute_specifier_sequence_delete(p_attribute_specifier_sequence_opt);
                throw;
            }
        }
        /*
                                               declaration-specifiers init-declarator-list_opt;
                  attribute-specifier-sequence declaration-specifiers init-declarator-list;
                  static_assert-declaration attribute_declaration
        */
        /*
        unlabeled-statement:
         expression-statement
         attribute-specifier-sequenceopt compound-statement
         attribute-specifier-sequenceopt selection-statement
         attribute-specifier-sequenceopt iteration-statement
         attribute-specifier-sequenceopt jump-statement

        label:
        attribute-specifier-sequenceopt identifier :
        attribute-specifier-sequenceopt case constant-expression :
        attribute-specifier-sequenceopt default :
        */

        attribute_specifier_sequence_delete(p_attribute_specifier_sequence_opt);
    }
    catch
    {
        block_item_delete(p_block_item);
        p_block_item = NULL;
    }
    return p_block_item;
}

void try_statement_delete(struct try_statement* _Owner _Opt p)
{
    if (p)
    {
        secondary_block_delete(p->catch_secondary_block_opt);
        secondary_block_delete(p->secondary_block);
        free(p);
    }
}

struct try_statement* _Owner _Opt try_statement(struct parser_ctx* ctx)
{
    struct try_statement* _Owner _Opt p_try_statement = NULL;
    try
    {
        if (ctx->current == NULL)
            throw;

        p_try_statement = calloc(1, sizeof(struct try_statement));

        if (p_try_statement == NULL)
            throw;

        p_try_statement->first_token = ctx->current;

        assert(ctx->current->type == TK_KEYWORD_TRY);
        const struct try_statement* _Opt try_statement_copy_opt = ctx->p_current_try_statement_opt;
        ctx->p_current_try_statement_opt = p_try_statement;
        ctx->try_catch_block_index++;
        p_try_statement->try_catch_block_index = ctx->try_catch_block_index;


        if (parser_match_tk(ctx, TK_KEYWORD_TRY) != 0)
            throw;

#pragma cake diagnostic push
#pragma cake diagnostic ignored "-Wmissing-destructor"    

        struct secondary_block* _Owner _Opt p_secondary_block = secondary_block(ctx);
        if (p_secondary_block == NULL) throw;

        p_try_statement->secondary_block = p_secondary_block;
#pragma cake diagnostic pop

        /*restores the previous one*/
        ctx->p_current_try_statement_opt = try_statement_copy_opt;

        if (ctx->current == NULL)
            throw;

        if (ctx->current->type == TK_KEYWORD_CATCH)
        {
            p_try_statement->catch_token_opt = ctx->current;
            parser_match(ctx);

            assert(p_try_statement->catch_secondary_block_opt == NULL);


            p_try_statement->catch_secondary_block_opt = secondary_block(ctx);
            if (p_try_statement->catch_secondary_block_opt == NULL) throw;

        }
        if (ctx->previous == NULL)
            throw;

        p_try_statement->last_token = ctx->previous;
    }
    catch
    {
        try_statement_delete(p_try_statement);
        p_try_statement = NULL;
    }
    return p_try_statement;
}

void selection_statement_delete(struct selection_statement* _Owner _Opt p)
{
    if (p)
    {
        secondary_block_delete(p->secondary_block);
        secondary_block_delete(p->else_secondary_block_opt);

        condition_delete(p->condition);
        init_statement_delete(p->p_init_statement);
        free(p);
    }
}

struct selection_statement* _Owner _Opt selection_statement(struct parser_ctx* ctx)
{
    /*
    selection-statement: //C23
        "if" ( expression ) secondary-block
        "if" ( expression ) secondary-block else secondary-block
        "switch" ( expression ) secondary-block
    */

    /* Extension

    selection-statement: C2Y?
       "if" ( init-statement _Opt condition ) secondary-block
       "if" ( init-statement _Opt condition ) secondary-block "else" secondary-block
       switch ( init-statement _Opt condition ) secondary-block
    */

    struct scope if_scope = { 0 };
    scope_list_push(&ctx->scopes, &if_scope);

    struct selection_statement* _Owner _Opt p_selection_statement = NULL;
    try
    {
        if (ctx->current == NULL)
        {
            throw;
        }

        p_selection_statement = calloc(1, sizeof(struct selection_statement));

        if (p_selection_statement == NULL)
        {
            throw;
        }

        p_selection_statement->first_token = ctx->current;

        const bool is_if = (ctx->current->type == TK_KEYWORD_IF);
        if (ctx->current->type == TK_KEYWORD_IF ||
            ctx->current->type == TK_KEYWORD_SWITCH)
        {
            parser_match(ctx);
        }
        else
        {
            throw;
        }

        if (ctx->current == NULL)
        {
            throw;
        }

        if (!(ctx->current->flags & TK_FLAG_MACRO_EXPANDED) && !style_has_one_space(ctx->current))
        {
            compiler_diagnostic_message(W_STYLE, ctx, ctx->current, NULL, "one space");
        }

        p_selection_statement->open_parentesis_token = ctx->current;


        if (parser_match_tk(ctx, '(') != 0)
            throw;

        /*
           init-statement and condition are  almost the same.
           the diference is that init-statement has ;
        */
        p_selection_statement->p_init_statement = init_statement(ctx, true);

        if (p_selection_statement->p_init_statement == NULL)
            throw;

        if (ctx->current == NULL)
        {
            throw;
        }

        if (ctx->current->type == ';')
        {
            /*
              We only know if we are at init-statement if we find ;
            */

            //  fixing the last_token            
            if (p_selection_statement->p_init_statement->p_simple_declaration)
                p_selection_statement->p_init_statement->p_simple_declaration->last_token = ctx->current;
            else if (p_selection_statement->p_init_statement->p_expression_statement)
                p_selection_statement->p_init_statement->p_simple_declaration->last_token = ctx->current;

            parser_match(ctx);
            p_selection_statement->condition = condition(ctx);
        }
        else if (ctx->current->type == ')')
        {
            /*
              We only know if we are at init-statement if we find ;
              In this case it is NOT.
              So we copy parts of init-statement to condition
            */

            /*ignore that init_statement*/
            p_selection_statement->condition = calloc(1, sizeof * p_selection_statement->condition);
            if (p_selection_statement->condition == NULL)
                throw;

            //steal expression
            if (p_selection_statement->p_init_statement->p_expression_statement)
            {
                p_selection_statement->condition->first_token = p_selection_statement->p_init_statement->p_expression_statement->expression_opt->first_token;
                p_selection_statement->condition->last_token = p_selection_statement->p_init_statement->p_expression_statement->expression_opt->last_token;

                p_selection_statement->condition->expression =
                    p_selection_statement->p_init_statement->p_expression_statement->expression_opt;
                p_selection_statement->p_init_statement->p_expression_statement->expression_opt = NULL;
            }

            if (p_selection_statement->p_init_statement->p_simple_declaration)
            {
                p_selection_statement->condition->first_token = p_selection_statement->p_init_statement->p_simple_declaration->first_token;
                p_selection_statement->condition->last_token = p_selection_statement->p_init_statement->p_simple_declaration->last_token;

                if (p_selection_statement->p_init_statement->p_simple_declaration->init_declarator_list.head !=
                    p_selection_statement->p_init_statement->p_simple_declaration->init_declarator_list.tail)
                {
                    //tODO only 1
                    assert(false);
                    throw;
                }
                p_selection_statement->condition->p_init_declarator =
                    p_selection_statement->p_init_statement->p_simple_declaration->init_declarator_list.head;

                p_selection_statement->p_init_statement->p_simple_declaration->init_declarator_list.head = NULL;
                p_selection_statement->p_init_statement->p_simple_declaration->init_declarator_list.tail = NULL;

                p_selection_statement->condition->p_declaration_specifiers =
                    p_selection_statement->p_init_statement->p_simple_declaration->p_declaration_specifiers;
                p_selection_statement->p_init_statement->p_simple_declaration->p_declaration_specifiers = NULL;
            }


            init_statement_delete(p_selection_statement->p_init_statement);
            p_selection_statement->p_init_statement = NULL;
        }

        if (ctx->current == NULL)
        {
            throw;
        }

        p_selection_statement->close_parentesis_token = ctx->current;
        if (parser_match_tk(ctx, ')') != 0)
            throw;

        //if (constant_value_is_valid(&p_selection_statement->init_statement_expression->constant_value))
        //{
            //compiler_diagnostic_message(W_CONDITIONAL_IS_CONSTANT, ctx, p_selection_statement->init_statement_expression->first_token, "conditional expression is constant");
        //}

        const struct selection_statement* _Opt previous = ctx->p_current_selection_statement;
        ctx->p_current_selection_statement = p_selection_statement;

        struct  switch_value_list* _Opt previous_switch_value_list = ctx->p_switch_value_list;
        struct  switch_value_list  switch_value_list = { 0 };
        ctx->p_switch_value_list = &switch_value_list;

        struct secondary_block* _Owner _Opt p_secondary_block = secondary_block(ctx);

        if (p_secondary_block == NULL)
        {
            switch_value_destroy(&switch_value_list);
            throw;
        }

        if (p_secondary_block->statement->unlabeled_statement &&
            p_secondary_block->statement->unlabeled_statement->expression_statement &&
            p_secondary_block->statement->unlabeled_statement->expression_statement->expression_opt == NULL)
        {
            compiler_diagnostic_message(W_SWITCH,
                            ctx,
                            p_secondary_block->first_token,
                            NULL,
                            "empty controlled statement found; is this the intent?");

        }


        assert(p_selection_statement->secondary_block == NULL);
        p_selection_statement->secondary_block = p_secondary_block;

        if (p_selection_statement->first_token->type == TK_KEYWORD_SWITCH)
        {
            //switch of enum without default, then we check if all items were used
            if (switch_value_list.p_default == NULL)
            {
                const struct enum_specifier* _Opt p_enum_specifier = NULL;

                if (ctx->p_current_selection_statement->condition &&
                    ctx->p_current_selection_statement->condition->expression &&
                    ctx->p_current_selection_statement->condition->expression->type.enum_specifier)
                {
                    p_enum_specifier = get_complete_enum_specifier(ctx->p_current_selection_statement->condition->expression->type.enum_specifier);
                }

                if (p_enum_specifier)
                {
                    struct enumerator* _Opt p = p_enum_specifier->enumerator_list.head;
                    while (p)
                    {
                        struct switch_value* _Opt p_used = switch_value_list_find(&switch_value_list, constant_value_to_signed_long_long(&p->value));

                        if (p_used == NULL)
                        {
                            compiler_diagnostic_message(W_SWITCH,
                                ctx,
                                ctx->current, NULL,
                                "enumeration value '%s' not handled in switch", p->token->lexeme);
                        }
                        p = p->next;
                    }
                }
            }
        }

        ctx->p_current_selection_statement = previous;

        ctx->p_switch_value_list = previous_switch_value_list;

        switch_value_destroy(&switch_value_list);

        if (is_if && ctx->current && ctx->current->type == TK_KEYWORD_ELSE)
        {
            p_selection_statement->else_token_opt = ctx->current;
            parser_match(ctx);
            assert(p_selection_statement->else_secondary_block_opt == NULL);

            struct secondary_block* _Owner _Opt p_secondary_block2 = secondary_block(ctx);
            if (p_secondary_block2 == NULL) throw;

            p_selection_statement->else_secondary_block_opt = p_secondary_block2;
        }

        if (ctx->current == NULL)
        {
            throw;
        }
        struct token* _Opt p_tk = previous_parser_token(ctx->current);
        if (p_tk == NULL)
        {
            throw;
        }

        p_selection_statement->last_token = p_tk;
    }
    catch
    {
        selection_statement_delete(p_selection_statement);
        p_selection_statement = NULL;
    }
    scope_list_pop(&ctx->scopes);
    scope_destroy(&if_scope);

    return p_selection_statement;
}

struct defer_statement* _Owner _Opt defer_statement(struct parser_ctx* ctx)
{
    struct defer_statement* _Owner _Opt p_defer_statement = NULL;
    try
    {
        if (ctx->current == NULL)
            throw;

        p_defer_statement = calloc(1, sizeof(struct defer_statement));

        if (p_defer_statement == NULL)
            throw;

        if (ctx->current->type == TK_KEYWORD_DEFER)
        {
            p_defer_statement->first_token = ctx->current;
            parser_match(ctx);

            struct secondary_block* _Owner _Opt p_secondary_block = secondary_block(ctx);
            if (p_secondary_block == NULL) throw;

            p_defer_statement->secondary_block = p_secondary_block;
            if (ctx->previous == NULL) throw;

            p_defer_statement->last_token = ctx->previous;
        }
    }
    catch
    {
        defer_statement_delete(p_defer_statement);
        p_defer_statement = NULL;
    }
    return p_defer_statement;
}

void iteration_statement_delete(struct iteration_statement* _Owner _Opt p)
{
    if (p)
    {
        expression_delete(p->expression0);
        expression_delete(p->expression1);
        expression_delete(p->expression2);
        declaration_delete(p->declaration);
        secondary_block_delete(p->secondary_block);
        free(p);
    }
}

struct iteration_statement* _Owner _Opt iteration_statement(struct parser_ctx* ctx)
{
    /*
    iteration-statement:
      while ( expression ) statement
      do statement while ( expression ) ;
      for ( expressionopt ; expressionopt ; expressionopt ) statement
      for ( declaration expressionopt ; expressionopt ) statement
    */
    struct iteration_statement* _Owner _Opt p_iteration_statement = NULL;
    try
    {
        if (ctx->current == NULL)
            throw;

        p_iteration_statement = calloc(1, sizeof(struct iteration_statement));

        if (p_iteration_statement == NULL)
            throw;

        p_iteration_statement->first_token = ctx->current;
        if (ctx->current->type == TK_KEYWORD_DO)
        {
            parser_match(ctx);

            struct secondary_block* _Owner _Opt p_secondary_block = secondary_block(ctx);
            if (p_secondary_block == NULL) throw;

            p_iteration_statement->secondary_block = p_secondary_block;

            if (ctx->current == NULL)
                throw;

            p_iteration_statement->second_token = ctx->current;

            if (parser_match_tk(ctx, TK_KEYWORD_WHILE) != 0)
                throw;
            if (parser_match_tk(ctx, '(') != 0)
                throw;

            p_iteration_statement->expression1 = expression(ctx);
            if (parser_match_tk(ctx, ')') != 0)
                throw;
            if (parser_match_tk(ctx, ';') != 0)
                throw;
        }
        else if (ctx->current->type == TK_KEYWORD_WHILE)
        {
            parser_match(ctx);
            if (parser_match_tk(ctx, '(') != 0)
                throw;

            p_iteration_statement->expression1 = expression(ctx);
            if (parser_match_tk(ctx, ')') != 0)
                throw;
            struct secondary_block* _Owner _Opt p_secondary_block = secondary_block(ctx);
            if (p_secondary_block == NULL) throw;
            p_iteration_statement->secondary_block = p_secondary_block;
        }
        else if (ctx->current->type == TK_KEYWORD_FOR)
        {
            parser_match(ctx);
            if (parser_match_tk(ctx, '(') != 0)
                throw;
            if (first_of_declaration_specifier(ctx))
            {
                struct scope for_scope = { 0 };
                scope_list_push(&ctx->scopes, &for_scope);

                p_iteration_statement->declaration = declaration(ctx, NULL, STORAGE_SPECIFIER_AUTOMATIC_STORAGE);

                if (ctx->current == NULL)
                {
                    scope_list_pop(&ctx->scopes);
                    scope_destroy(&for_scope);
                    throw;
                }

                if (ctx->current->type != ';')
                {
                    p_iteration_statement->expression1 = expression(ctx);
                    if (p_iteration_statement->expression1 == NULL)
                    {
                        scope_list_pop(&ctx->scopes);
                        scope_destroy(&for_scope);
                        throw;
                    }
                }

                if (parser_match_tk(ctx, ';') != 0)
                {
                    scope_list_pop(&ctx->scopes);
                    scope_destroy(&for_scope);
                    throw;
                }

                if (ctx->current == NULL)
                {
                    scope_list_pop(&ctx->scopes);
                    scope_destroy(&for_scope);
                    throw;
                }

                if (ctx->current->type != ')')
                    p_iteration_statement->expression2 = expression(ctx);

                if (parser_match_tk(ctx, ')') != 0)
                {
                    scope_list_pop(&ctx->scopes);
                    scope_destroy(&for_scope);
                    throw;
                }

                struct secondary_block* _Owner _Opt p_secondary_block = secondary_block(ctx);
                if (p_secondary_block == NULL)
                {
                    scope_list_pop(&ctx->scopes);
                    scope_destroy(&for_scope);
                    throw;
                }

                p_iteration_statement->secondary_block = p_secondary_block;

                scope_list_pop(&ctx->scopes);

                scope_destroy(&for_scope);
            }
            else
            {
                /*
                 *   int i;
                 *   for (i = 0; i < 10; i++)
                 *   {
                 *   }
                 */

                if (ctx->current == NULL)
                    throw;

                if (ctx->current->type != ';')
                    p_iteration_statement->expression0 = expression(ctx);
                if (parser_match_tk(ctx, ';') != 0)
                    throw;

                if (ctx->current == NULL)
                    throw;

                if (ctx->current->type != ';')
                    p_iteration_statement->expression1 = expression(ctx);

                if (parser_match_tk(ctx, ';') != 0)
                    throw;

                if (ctx->current == NULL)
                    throw;

                if (ctx->current->type != ')')
                    p_iteration_statement->expression2 = expression(ctx);

                if (parser_match_tk(ctx, ')') != 0)
                    throw;

                if (ctx->current == NULL)
                    throw;

                struct secondary_block* _Owner _Opt p_secondary_block = secondary_block(ctx);
                if (p_secondary_block == NULL) throw;

                p_iteration_statement->secondary_block = p_secondary_block;
            }
        }
    }
    catch
    {
        iteration_statement_delete(p_iteration_statement);
        p_iteration_statement = NULL;
    }
    return p_iteration_statement;
}

void jump_statement_delete(struct jump_statement* _Owner _Opt p)
{
    if (p)
    {
        expression_delete(p->expression_opt);
        free(p);
    }
}

struct jump_statement* _Owner _Opt jump_statement(struct parser_ctx* ctx)
{
    /*
      jump-statement:
            goto identifier ;
            continue ;
            break ;
            return expressionopt ;
    */

    /*
       throw; (extension)
    */

    struct jump_statement* _Owner _Opt p_jump_statement = NULL;
    try
    {
        if (ctx->current == NULL)
            throw;

        p_jump_statement = calloc(1, sizeof(struct jump_statement));

        if (p_jump_statement == NULL)
            throw;

        p_jump_statement->first_token = ctx->current;

        if (ctx->current->type == TK_KEYWORD_GOTO)
        {
            parser_match(ctx);

            if (ctx->current == NULL)
                throw;

            p_jump_statement->label = ctx->current;
            if (parser_match_tk(ctx, TK_IDENTIFIER) != 0)
                throw;
        }
        else if (ctx->current->type == TK_KEYWORD_CONTINUE)
        {
            parser_match(ctx);
        }
        else if (ctx->current->type == TK_KEYWORD_BREAK)
        {
            parser_match(ctx);
        }
        else if (ctx->current->type == TK_KEYWORD_THROW)
        {
            if (ctx->p_current_try_statement_opt == NULL)
            {
                compiler_diagnostic_message(C_ERROR_THROW_STATEMENT_NOT_WITHIN_TRY_BLOCK, ctx, ctx->current, NULL, "throw statement not within try block");
            }
            else
            {
                p_jump_statement->try_catch_block_index = ctx->p_current_try_statement_opt->try_catch_block_index;
            }

            parser_match(ctx);
        }
        else if (ctx->current->type == TK_KEYWORD_RETURN)
        {
            const struct token* const p_return_token = ctx->current;
            parser_match(ctx);

            if (ctx->current == NULL)
                throw;

            if (ctx->current->type != ';')
            {
                p_jump_statement->expression_opt = expression(ctx);

                if (p_jump_statement->expression_opt)
                {
                    /*
                     * Check is return type is compatible with function return
                     */
                    struct type return_type =
                        get_function_return_type(&ctx->p_current_function_opt->init_declarator_list.head->p_declarator->type);

                    if (type_is_void(&return_type))
                    {
                        compiler_diagnostic_message(C_ERROR_VOID_FUNCTION_SHOULD_NOT_RETURN_VALUE,
                            ctx,
                            p_return_token, NULL,
                            "void function '%s' should not return a value",
                            ctx->p_current_function_opt->init_declarator_list.head->p_declarator->name_opt->lexeme);
                    }
                    else
                    {
                        check_assigment(ctx,
                            &return_type,
                            p_jump_statement->expression_opt,
                            ASSIGMENT_TYPE_RETURN);
                    }

                    type_destroy(&return_type);
                }
            }
        }
        else
        {
            assert(false);
        }

        if (ctx->current == NULL)
        {
            throw;
        }

        p_jump_statement->last_token = ctx->current;
        if (parser_match_tk(ctx, ';') != 0)
            throw;
    }
    catch
    {
        jump_statement_delete(p_jump_statement);
        p_jump_statement = NULL;
    }
    return p_jump_statement;
}

void expression_statement_delete(struct expression_statement* _Owner _Opt p)
{
    if (p)
    {
        attribute_specifier_sequence_delete(p->p_attribute_specifier_sequence_opt);
        expression_delete(p->expression_opt);
        free(p);
    }
}

struct expression_statement* _Owner _Opt  expression_statement(struct parser_ctx* ctx, bool ignore_semicolon)
{
    struct expression_statement* _Owner _Opt p_expression_statement = calloc(1, sizeof(struct expression_statement));
    try
    {
        /*
         expression-statement:
           expression _Opt ;
           attribute-specifier-sequence expression ;
        */
        if (p_expression_statement == NULL)
            throw;

        p_expression_statement->p_attribute_specifier_sequence_opt =
            attribute_specifier_sequence_opt(ctx);

        if (ctx->current == NULL)
            throw;

        if (ctx->current->type != ';')
        {
            p_expression_statement->expression_opt = expression(ctx);
            if (p_expression_statement->expression_opt == NULL)
                throw;
        }

        if (!ignore_semicolon && parser_match_tk(ctx, ';') != 0)
            throw;
    }
    catch
    {
        expression_statement_delete(p_expression_statement);
        p_expression_statement = NULL;
    }
    return p_expression_statement;
}

void declaration_list_add(struct declaration_list* list, struct declaration* _Owner p_declaration)
{
    if (list->head == NULL)
    {
        list->head = p_declaration;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_declaration;
    }
    list->tail = p_declaration;
}

void simple_declaration_delete(struct simple_declaration* _Owner _Opt p_simple_declaration)
{
    if (p_simple_declaration)
    {
        declaration_specifiers_delete(p_simple_declaration->p_declaration_specifiers);
        init_declarator_list_destroy(&p_simple_declaration->init_declarator_list);
        attribute_specifier_sequence_delete(p_simple_declaration->p_attribute_specifier_sequence_opt);

        free(p_simple_declaration);
    }
}

void condition_delete(struct condition* _Owner _Opt p_condition)
{
    if (p_condition)
    {
        init_declarator_delete(p_condition->p_init_declarator);
        expression_delete(p_condition->expression);

        attribute_specifier_sequence_delete(p_condition->p_attribute_specifier_sequence_opt);
        declaration_specifiers_delete(p_condition->p_declaration_specifiers);
        free(p_condition);
    }
}

struct condition* _Owner _Opt condition(struct parser_ctx* ctx)
{


    /*
    condition :
       expression
       attribute-specifier-seq _Opt decl-specifier-seq declarator initializer
    */
    struct condition* _Owner _Opt p_condition = NULL;
    try
    {
        if (ctx->current == NULL)
            throw;

        p_condition = calloc(1, sizeof * p_condition);
        if (p_condition == NULL)
            throw;

        p_condition->first_token = ctx->current;
        if (first_of_declaration_specifier(ctx))
        {
            p_condition->p_attribute_specifier_sequence_opt = attribute_specifier_sequence(ctx);
            p_condition->p_declaration_specifiers = declaration_specifiers(ctx, STORAGE_SPECIFIER_AUTOMATIC_STORAGE);

            struct init_declarator* _Owner _Opt p_init_declarator =
                init_declarator(ctx, p_condition->p_declaration_specifiers);

            if (p_init_declarator == NULL)
            {
                throw;
            }
            p_condition->p_init_declarator = p_init_declarator;
        }
        else
        {
            p_condition->expression = expression(ctx);
            if (p_condition->expression == NULL) throw;
        }

        if (ctx->current == NULL)
            throw;

        struct token* _Opt previous = previous_parser_token(ctx->current);

        if (previous)
        {
            //shoult never be null
            p_condition->last_token = previous;
        }
    }
    catch
    {
        condition_delete(p_condition);
        p_condition = NULL;
    }
    return p_condition;
}

void init_statement_delete(struct init_statement* _Owner _Opt p_init_statement)
{
    if (p_init_statement)
    {
        expression_statement_delete(p_init_statement->p_expression_statement);
        simple_declaration_delete(p_init_statement->p_simple_declaration);
        free(p_init_statement);
    }
}

struct init_statement* _Owner _Opt init_statement(struct parser_ctx* ctx, bool ignore_semicolon)
{
    /*
       expression-statement
       simple-declaration
    */
    struct init_statement* _Owner _Opt p_init_statement = NULL;
    try
    {
        p_init_statement = calloc(1, sizeof * p_init_statement);

        if (p_init_statement == NULL)
            throw;

        if (first_of_declaration_specifier(ctx))
        {
            p_init_statement->p_simple_declaration = simple_declaration(ctx, NULL, ignore_semicolon);
        }
        else
        {
            p_init_statement->p_expression_statement = expression_statement(ctx, ignore_semicolon);
        }
    }
    catch
    {
        init_statement_delete(p_init_statement);
        p_init_statement = NULL;
    }
    return p_init_statement;
}

void declaration_delete(struct declaration* _Owner _Opt p)
{
    if (p)
    {

        attribute_specifier_sequence_delete(p->p_attribute_specifier_sequence_opt);
        static_assert_declaration_delete(p->static_assert_declaration);

        declaration_specifiers_delete(p->declaration_specifiers);

        compound_statement_delete(p->function_body);
        pragma_declaration_delete(p->pragma_declaration);

        init_declarator_list_destroy(&p->init_declarator_list);
        assert(p->next == NULL);
        free(p);
    }
}

void declaration_list_destroy(struct declaration_list* _Obj_owner list)
{
    struct declaration* _Owner _Opt p = list->head;
    while (p)
    {
        struct declaration* _Owner _Opt next = p->next;
        p->next = NULL;
        declaration_delete(p);
        p = next;
    }
}

struct declaration_list translation_unit(struct parser_ctx* ctx, bool* berror)
{
    *berror = false;
    struct declaration_list declaration_list = { 0 };
    /*
      translation_unit:
      external_declaration
      translation_unit external_declaration
    */
    try
    {
        while (ctx->current != NULL)
        {
            struct declaration* _Owner _Opt p = external_declaration(ctx);
            if (p == NULL)
                throw;
            declaration_list_add(&declaration_list, p);
        }
    }
    catch
    {
        *berror = true;
    }
    return declaration_list;
}

struct declaration* _Owner _Opt external_declaration(struct parser_ctx* ctx)
{
    /*
     function_definition
     declaration
     */
    return function_definition_or_declaration(ctx);
}

struct compound_statement* _Owner _Opt function_body(struct parser_ctx* ctx)
{

    /*
     * Used to give an unique index (inside the function)
     * for try-catch blocks
     */
    ctx->try_catch_block_index = 0;
    ctx->p_current_try_statement_opt = NULL;
    return compound_statement(ctx);
}

static void show_unused_file_scope(struct parser_ctx* ctx)
{
    if (ctx->scopes.head == NULL)
        return;

    for (int i = 0; i < ctx->scopes.head->variables.capacity; i++)
    {
        if (ctx->scopes.head->variables.table == NULL)
            continue;
        struct map_entry* _Opt entry = ctx->scopes.head->variables.table[i];
        while (entry)
        {

            if (entry->type != TAG_TYPE_ONLY_DECLARATOR &&
                entry->type != TAG_TYPE_INIT_DECLARATOR)
            {
                entry = entry->next;
                continue;
            }

            struct declarator* _Opt p_declarator = NULL;
            struct init_declarator* _Opt p_init_declarator = NULL;
            if (entry->type == TAG_TYPE_INIT_DECLARATOR)
            {
                p_init_declarator = entry->p;
                p_declarator = p_init_declarator->p_declarator;
            }
            else
            {
                p_declarator = entry->p;
            }

            if (p_declarator &&
                p_declarator->first_token_opt &&
                p_declarator->first_token_opt->level == 0 &&
                declarator_is_function(p_declarator) &&
                p_declarator->declaration_specifiers &&
                (p_declarator->declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_STATIC))
            {
                if (!type_is_maybe_unused(&p_declarator->type) &&
                    p_declarator->num_uses == 0)
                {
                    if (p_declarator->name_opt)
                    {
                        compiler_diagnostic_message(W_UNUSED_VARIABLE,
                            ctx,
                            p_declarator->name_opt,
                            NULL,
                            "declarator '%s' not used", p_declarator->name_opt->lexeme);
                    }
                }
            }

            entry = entry->next;
        }
    }
}

struct declaration_list parse(struct parser_ctx* ctx, struct token_list* list, bool* berror)
{
    *berror = false;
    s_anonymous_struct_count = 0;
    struct declaration_list l = { 0 };
    struct scope file_scope = { 0 };
    try
    {
        scope_list_push(&ctx->scopes, &file_scope);
        ctx->input_list = *list;
        ctx->current = ctx->input_list.head;
        parser_skip_blanks(ctx);

        bool local_error = false;
        l = translation_unit(ctx, &local_error);
        if (local_error)
            throw;
        show_unused_file_scope(ctx); // cannot be executed on error becase scope have dangling pointers
    }
    catch
    {
        *berror = true;
    }
    scope_destroy(&file_scope);

    return l;
}

int fill_preprocessor_options(int argc, const char** argv, struct preprocessor_ctx* prectx)
{
    /*first loop used to collect options*/
    for (int i = 1; i < argc; i++)
    {
        if (argv[i][0] != '-')
            continue;

        if (argv[i][1] == 'I')
        {
            include_dir_add(&prectx->include_dir, argv[i] + 2);
            continue;
        }
        if (argv[i][1] == 'D')
        {
            char buffer[200] = { 0 };
            snprintf(buffer, sizeof buffer, "#define %s \n", argv[i] + 2);

            /*TODO make it more precise*/
            char* p = &buffer[7];
            while (*p)
            {
                if (*p == '=')
                {
                    *p = ' ';
                    break;
                }
                p++;
            }

            struct tokenizer_ctx tctx = { 0 };
            struct token_list l1 = tokenizer(&tctx, buffer, "", 0, TK_FLAG_NONE);
            struct token_list r = preprocessor(prectx, &l1, 0);
            token_list_destroy(&l1);
            token_list_destroy(&r);
            continue;
        }
    }
    return 0;
}

void append_msvc_include_dir(struct preprocessor_ctx* prectx)
{

#ifdef _WIN32

    WINBASEAPI unsigned long WINAPI GetEnvironmentVariableA(const char* name,
    char* buffer,
    unsigned long size);


    char env[2000] = { 0 };
    int n = GetEnvironmentVariableA("INCLUDE", env, sizeof(env));

    if (n > 0)
    {

        const char* p = env;
        for (;;)
        {
            if (*p == '\0')
            {
                break;
            }
            char filename_local[500] = { 0 };
            int count = 0;
            while (*p != '\0' && (*p != ';' && *p != '\n'))
            {
                filename_local[count] = *p;
                p++;
                count++;
            }
            filename_local[count] = 0;
            if (count > 0)
            {
                strcat(filename_local, "/");
                include_dir_add(&prectx->include_dir, filename_local);
            }
            if (*p == '\0')
            {
                break;
            }
            p++;
        }
    }
#endif
}

const char* _Owner _Opt format_code(struct options* options, const char* content)
{
    struct ast ast = { 0 };
    const char* _Owner _Opt s = NULL;

    struct preprocessor_ctx prectx = { 0 };

    prectx.macros.capacity = 5000;
    add_standard_macros(&prectx);

    struct report report = { 0 };
    struct parser_ctx ctx = { 0 };
    ctx.options = *options;
    ctx.p_report = &report;
    struct tokenizer_ctx tctx = { 0 };
    struct token_list tokens = { 0 };

    try
    {
        prectx.options = *options;
        append_msvc_include_dir(&prectx);

        tokens = tokenizer(&tctx, content, "", 0, TK_FLAG_NONE);
        ast.token_list = preprocessor(&prectx, &tokens, 0);
        if (prectx.n_errors != 0)
            throw;

        bool berror = false;
        ast.declaration_list = parse(&ctx, &ast.token_list, &berror);
        if (berror || report.error_count > 0)
            throw;

        struct format_visit_ctx visit_ctx = { 0 };
        visit_ctx.ast = ast;
        format_visit(&visit_ctx);

        if (options->direct_compilation)
            s = get_code_as_compiler_see(&visit_ctx.ast.token_list);
        else
            s = get_code_as_we_see(&visit_ctx.ast.token_list, options->remove_comments);
    }
    catch
    {
    }

    token_list_destroy(&tokens);

    parser_ctx_destroy(&ctx);
    ast_destroy(&ast);
    preprocessor_ctx_destroy(&prectx);
    return s;
}

void ast_format_visit(struct ast* ast)
{
    /*format input source before transformation*/
    struct format_visit_ctx visit_ctx = { 0 };
    visit_ctx.ast = *ast;
    format_visit(&visit_ctx);
}

void c_visit(struct ast* ast)
{}


int generate_config_file(const char* configpath)
{
    FILE* _Owner _Opt outfile = NULL;
    int error = 0;
    try
    {
        outfile = fopen(configpath, "w");
        if (outfile == NULL)
        {
            printf("Cannot open the file '%s' for writing.\n", configpath);
            error = errno;
            throw;
        }

        fprintf(outfile, "//This was generated by running cake -autoconfig \n");


#ifdef __linux__

        fprintf(outfile, "This file was generated reading the output of\n");
        fprintf(outfile, "//echo | gcc -v -E - 2>&1\n");
        fprintf(outfile, "\n");

        char path[400] = { 0 };
        char* command = "echo | gcc -v -E - 2>&1";
        int in_include_section = 0;

        // Open the command for reading
        FILE* fp = popen(command, "r");
        if (fp == NULL)
        {
            fprintf(stderr, "Failed to run command\n");
            error = errno;
            throw;
        }

        // Read the output a line at a time
        while (fgets(path, sizeof(path), fp) != NULL)
        {
            // Check if we are in the "#include <...> search starts here:" section
            if (strstr(path, "#include <...> search starts here:") != NULL)
            {
                in_include_section = 1;
                continue;
            }
            // Check if we have reached the end of the include section
            if (in_include_section && strstr(path, "End of search list.") != NULL)
            {
                break;
            }
            // Print the include directories
            if (in_include_section)
            {
                const char* p = path;
                while (*p == ' ') p++;

                int len = strlen(path);
                if (path[len - 1] == '\n')
                    path[len - 1] = '\0';

                fprintf(outfile, "#pragma dir \"%s\"\n", p);
            }
        }

        fprintf(outfile, "\n");

        // Close the command stream
        pclose(fp);

#endif

#ifdef _WIN32
        char env[2000] = { 0 };
        int n = GetEnvironmentVariableA("INCLUDE", env, sizeof(env));

        if (n <= 0)
        {
            printf("INCLUDE not found.\nPlease, run cake -autoconfig inside visual studio command prompty.\n");
            error = 1;
            throw;
        }

        fprintf(outfile, "//This file was generated reading the variable INCLUDE inside Visual Studio Command Prompt.\n");
        fprintf(outfile, "//echo %%INCLUDE%% \n");

        const char* p = env;
        for (;;)
        {
            if (*p == '\0')
            {
                break;
            }
            char filename_local[500] = { 0 };
            int count = 0;
            while (*p != '\0' && (*p != ';' && *p != '\n'))
            {
                filename_local[count] = *p;
                p++;
                count++;
            }
            filename_local[count] = 0;
            if (count > 0)
            {
                strcat(filename_local, "/");
                char* pch = filename_local;
                while (*pch)
                {
                    if (*pch == '\\')
                        *pch = '/';
                    pch++;
                }

                fprintf(outfile, "#pragma dir \"%s\"\n", filename_local);
            }
            if (*p == '\0')
            {
                break;
            }
            p++;
        }
#endif
    }
    catch
    {
    }
    if (outfile)
        fclose(outfile);

    if (error == 0)
    {
        printf("file '%s'\n", configpath);
        printf("successfully generated\n");
    }
    return error;
}

int compile_one_file(const char* file_name,
    struct options* options,
    const char* out_file_name,
    int argc,
    const char** argv,
    struct report* report)
{
    printf("%s\n", file_name);
    struct preprocessor_ctx prectx = { 0 };

    prectx.macros.capacity = 5000;

    add_standard_macros(&prectx);

    if (include_config_header(&prectx, file_name) != 0)
    {
        //cakeconfig.h is optional               
    }
    // print_all_macros(&prectx);

    struct ast ast = { 0 };

    const char* _Owner _Opt s = NULL;

    struct parser_ctx ctx = { 0 };
    struct visit_ctx visit_ctx = { 0 };
    struct tokenizer_ctx tctx = { 0 };
    struct token_list tokens = { 0 };

    ctx.options = *options;
    ctx.p_report = report;
    char* _Owner _Opt content = NULL;

    try
    {
        //-D , -I etc..
        if (fill_preprocessor_options(argc, argv, &prectx) != 0)
        {
            throw;
        }

        prectx.options = *options;
        append_msvc_include_dir(&prectx);

        content = read_file(file_name);
        if (content == NULL)
        {
            report->error_count++;
            printf("file not found '%s'\n", file_name);
            throw;
        }

        if (options->sarif_output)
        {
            char sarif_file_name[260] = { 0 };
            if (options->sarifpath[0] != '\0')
            {
                mkdir(options->sarifpath, 0777);
                snprintf(sarif_file_name, sizeof sarif_file_name, "%s/%s.cake.sarif", options->sarifpath, basename(file_name));
            }
            else
            {
                snprintf(sarif_file_name, sizeof sarif_file_name, "%s.cake.sarif", file_name);
            }

            ctx.sarif_file = (FILE * _Owner _Opt) fopen(sarif_file_name, "w");
            if (ctx.sarif_file)
            {
                const char* begin_sarif =
                    "{\n"
                    "  \"version\": \"2.1.0\",\n"
                    "  \"$schema\": \"https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0-rtm.5.json\",\n"
                    "  \"runs\": [\n"
                    "    {\n"
                    "      \"results\": [\n"
                    "\n";

                fprintf(ctx.sarif_file, "%s", begin_sarif);
            }
            else
            {
                report->error_count++;
                printf("cannot open Sarif output file '%s'\n", sarif_file_name);
                throw;
            }
        }

        tokens = tokenizer(&tctx, content, file_name, 0, TK_FLAG_NONE);

        if (options->dump_tokens)
        {
            print_tokens(tokens.head);
        }

        ast.token_list = preprocessor(&prectx, &tokens, 0);

        report->warnings_count += prectx.n_warnings;
        report->error_count += prectx.n_errors;

        if (prectx.n_errors > 0)
        {
            throw;
        }

        if (options->dump_pptokens)
        {
            if (ast.token_list.head != NULL)
                print_tokens(ast.token_list.head);
        }

        if (options->preprocess_only)
        {
            const char* _Owner _Opt s2 = print_preprocessed_to_string2(ast.token_list.head);
            printf("%s", s2);
            free((void* _Owner _Opt)s2);
        }
        else
        {
            bool berror = false;
            ast.declaration_list = parse(&ctx, &ast.token_list, &berror);
            if (berror || report->error_count > 0)
                throw;

            // ast_wasm_visit(&ast);

            if (!options->no_output)
            {
                if (options->format_input)
                {
                    struct format_visit_ctx f = { .ast = ast, .indentation = 4 };
                    format_visit(&f);
                }

                visit_ctx.target = options->target;
                visit_ctx.hide_non_used_declarations = options->direct_compilation;

                visit_ctx.ast = ast;
                visit(&visit_ctx);

                if (options->direct_compilation)
                    s = get_code_as_compiler_see(&visit_ctx.ast.token_list);
                else
                    s = get_code_as_we_see(&visit_ctx.ast.token_list, options->remove_comments);

                if (s && options->format_ouput)
                {
                    /*re-parser output and format*/
                    const char* _Owner _Opt s2 = format_code(options, s);
                    free((void* _Owner _Opt)s);
                    s = s2;
                }

                FILE* _Owner _Opt outfile = fopen(out_file_name, "w");
                if (outfile)
                {
                    if (s)
                        fprintf(outfile, "%s", s);

                    fclose(outfile);
                    // printf("%-30s ", path);
                }
                else
                {
                    report->error_count++;
                    printf("cannot open output file '%s' - %s\n", out_file_name, get_posix_error_message(errno));
                    throw;
                }
            }
        }

        if (ctx.sarif_file)
        {

#define SARIF_FOOTER                                                             \
    "      ],\n"                                                        \
    "      \"tool\": {\n"                                               \
    "        \"driver\": {\n"                                           \
    "          \"name\": \"cake\",\n"                                   \
    "          \"fullName\": \"cake code analysis\",\n"                 \
    "          \"version\": \"" CAKE_VERSION  "\",\n"                   \
    "          \"informationUri\": \"https://https://github.com/thradams/cake\"\n" \
    "        }\n"                                                       \
    "      }\n"                                                         \
    "    }\n"                                                           \
    "  ]\n"                                                             \
    "}\n"                                                               \
    "\n"
            fprintf(ctx.sarif_file, "%s", SARIF_FOOTER);
            fclose(ctx.sarif_file);
            ctx.sarif_file = NULL;
        }
    }
    catch
    {
        // printf("Error %s\n", error->message);
    }

    if (ctx.options.test_mode)
    {
        //lets check if the generated file is the expected
        char buf[MYMAX_PATH] = { 0 };
        snprintf(buf, sizeof buf, "%s.txt", file_name);
        char* _Owner _Opt content_expected = read_file(buf);
        if (content_expected)
        {
            if (s && strcmp(content_expected, s) != 0)
            {
                printf("diferent");
                report->error_count++;
            }
            free(content_expected);
        }

        if (report->fatal_error_expected != 0)
        {
            if (report->last_diagnostics_ids[0] == report->fatal_error_expected)
            {
                report->error_count--;
            }
        }
        if (report->error_count > 0 || report->warnings_count > 0)
        {

            printf("-------------------------------------------\n");
            printf("%s", content);
            printf("\n-------------------------------------------\n");
            printf(LIGHTRED "TEST FAILED" RESET " : error=%d, warnings=%d\n", report->error_count, report->warnings_count);
            printf("\n\n");
            report->test_failed++;
        }
        else
        {

            report->test_succeeded++;
            printf(LIGHTGREEN "TEST OK\n" RESET);
        }
    }

    token_list_destroy(&tokens);
    visit_ctx_destroy(&visit_ctx);
    parser_ctx_destroy(&ctx);
    free((void* _Owner _Opt)s);
    free(content);
    ast_destroy(&ast);
    preprocessor_ctx_destroy(&prectx);

    return report->error_count > 0;
}

int compile_many_files(const char* file_name,
    struct options* options,
    const char* out_file_name,
    int argc,
    const char** argv,
    struct report* report)
{
    const char* const file_name_name = basename(file_name);
    const char* _Opt const file_name_extension = strrchr((char*)file_name_name, '.');

    if (file_name_extension == NULL)
    {
        assert(false);
    }

    int num_files = 0;

    char path[MYMAX_PATH] = { 0 };
    snprintf(path, sizeof path, "%s", file_name);
    dirname(path);
    DIR* _Owner _Opt dir = opendir(path);

    if (dir == NULL)
    {
        return errno;
    }

    struct dirent* _Opt dp;
    while ((dp = readdir(dir)) != NULL)
    {
        if (strcmp(dp->d_name, ".") == 0 || strcmp(dp->d_name, "..") == 0)
        {
            /* skip self and parent */
            continue;
        }

        char fromlocal[257] = { 0 };
        snprintf(fromlocal, sizeof fromlocal, "%s/%s", "", dp->d_name);

        if (dp->d_type & DT_DIR)
        {

        }
        else
        {
            const char* const file_name_iter = basename(dp->d_name);
            const char* _Opt const file_extension = strrchr((char*)file_name_iter, '.');

            if (file_name_extension &&
                file_extension &&
                strcmp(file_name_extension, file_extension) == 0)
            {
                //Fixes the output file name replacing the current name
                char out_file_name_final[MYMAX_PATH] = { 0 };
                strcpy(out_file_name_final, out_file_name);
                dirname(out_file_name_final);
                strcat(out_file_name_final, "/");
                strcat(out_file_name_final, file_name_iter);

                char in_file_name_final[MYMAX_PATH] = { 0 };
                strcpy(in_file_name_final, file_name);
                dirname(in_file_name_final);
                strcat(in_file_name_final, "/");
                strcat(in_file_name_final, file_name_iter);


                struct report report_local = { 0 };
                report_local.test_mode = report->test_mode;
                compile_one_file(in_file_name_final,
                                 options,
                                 out_file_name_final,
                                 argc,
                                 argv,
                                 &report_local);


                report->fatal_error_expected = report_local.fatal_error_expected;
                report->error_count += report_local.error_count;
                report->warnings_count += report_local.warnings_count;
                report->info_count += report_local.info_count;
                report->test_succeeded += report_local.test_succeeded;
                report->test_failed += report_local.test_failed;
                num_files++;
            }
        }
    }

    closedir(dir);
    return num_files;
}

static void longest_common_path(int argc, const char** argv, char root_dir[MYMAX_PATH])
{
    /*
     find the longest common path
    */
    for (int i = 1; i < argc; i++)
    {
        if (argv[i][0] == '-')
            continue;

        char fullpath_i[MYMAX_PATH] = { 0 };
        realpath(argv[i], fullpath_i);
        strcpy(root_dir, fullpath_i);
        dirname(root_dir);

        for (int k = 0; k < MYMAX_PATH; k++)
        {
            const char ch = fullpath_i[k];
            for (int j = 2; j < argc; j++)
            {
                if (argv[j][0] == '-')
                    continue;

                char fullpath_j[MYMAX_PATH] = { 0 };
                realpath(argv[j], fullpath_j);
                if (fullpath_j[k] != ch)
                {
                    strncpy(root_dir, fullpath_j, k);
                    root_dir[k] = '\0';
                    dirname(root_dir);
                    goto exit;
                }
            }
            if (ch == '\0')
                break;
        }
    }
exit:;
}

static int create_multiple_paths(const char* root, const char* outdir)
{
    /*
       This function creates all dirs (folder1, forder2 ..) after root
       root   : C:/folder
       outdir : C:/folder/folder1/folder2 ...
    */
#if !defined __EMSCRIPTEN__
    const char* p = outdir + strlen(root) + 1;
    for (;;)
    {
        if (*p != '\0' && *p != '/' && *p != '\\')
        {
            p++;
            continue;
        }

        char temp[MYMAX_PATH] = { 0 };
        strncpy(temp, outdir, p - outdir);

        int er = mkdir(temp, 0777);
        if (er != 0)
        {
            er = errno;
            if (er != EEXIST)
            {
                printf("error creating output folder '%s' - %s\n", temp, get_posix_error_message(er));
                return er;
            }
        }
        if (*p == '\0')
            break;
        p++;
    }
    return 0;
#else
    return -1;
#endif
}

int compile(int argc, const char** argv, struct report* report)
{
    struct options options = { 0 };
    if (fill_options(&options, argc, argv) != 0)
    {
        return 1;
    }

    char executable_path[MAX_PATH - sizeof(CAKE_CFG_FNAME)] = { 0 };
    get_self_path(executable_path, sizeof(executable_path));
    dirname(executable_path);
    char cakeconfig_path[MAX_PATH] = { 0 };
    snprintf(cakeconfig_path, sizeof cakeconfig_path, "%s" CAKE_CFG_FNAME, executable_path);

    if (options.auto_config) //-autoconfig
    {
        report->ignore_this_report = true;
        return generate_config_file(cakeconfig_path);
    }

    report->test_mode = options.test_mode;

    clock_t begin_clock = clock();
    int no_files = 0;

    char root_dir[MYMAX_PATH] = { 0 };

    if (!options.no_output)
    {
        longest_common_path(argc, argv, root_dir);
    }

    const int root_dir_len = strlen(root_dir);

    /*second loop to compile each file*/
    for (int i = 1; i < argc; i++)
    {
        if (strcmp(argv[i], "-o") == 0 ||
            strcmp(argv[i], "-sarif-path") == 0)
        {
            //consumes next
            i++;
            continue;
        }

        if (argv[i][0] == '-')
            continue;

        no_files++;
        char output_file[MYMAX_PATH] = { 0 };

        if (!options.no_output)
        {
            if (no_files == 1 && options.output[0] != '\0')
            {
                /*
                   -o outputname
                   works when we compile just one file
                */
                strcat(output_file, options.output);
            }
            else
            {
                char fullpath[MYMAX_PATH] = { 0 };
                realpath(argv[i], fullpath);

                strcpy(output_file, root_dir);
                strcat(output_file, "/out");

                strcat(output_file, fullpath + root_dir_len);

                char outdir[MYMAX_PATH] = { 0 };
                strcpy(outdir, output_file);
                dirname(outdir);
                if (create_multiple_paths(root_dir, outdir) != 0)
                {
                    return 1;
                }
            }
        }

        char fullpath[MYMAX_PATH] = { 0 };
        realpath(argv[i], fullpath);

        const char* file_extension = basename(fullpath);

        if (file_extension[0] == '*')
        {
            no_files--; //does not count *.c 
            no_files += compile_many_files(fullpath, &options, output_file, argc, argv, report);
        }
        else
        {
            struct report report_local = { 0 };
            compile_one_file(fullpath, &options, output_file, argc, argv, &report_local);

            report->fatal_error_expected = report_local.fatal_error_expected;
            report->error_count += report_local.error_count;
            report->warnings_count += report_local.warnings_count;
            report->info_count += report_local.info_count;
            report->test_succeeded += report_local.test_succeeded;
            report->test_failed += report_local.test_failed;
        }
    }

    clock_t end_clock = clock();
    double cpu_time_used = ((double)(end_clock - begin_clock)) / CLOCKS_PER_SEC;
    report->no_files = no_files;
    report->cpu_time_used_sec = cpu_time_used;
    return 0;
}

struct ast get_ast(struct options* options,
    const char* filename,
    const char* source,
    struct report* report)
{
    struct ast ast = { 0 };
    struct tokenizer_ctx tctx = { 0 };

    struct token_list list = tokenizer(&tctx, source, filename, 0, TK_FLAG_NONE);

    struct preprocessor_ctx prectx = { 0 };

    struct parser_ctx ctx = { .p_report = report };
    try
    {
        prectx.options = *options;
        prectx.macros.capacity = 5000;

        add_standard_macros(&prectx);

        ast.token_list = preprocessor(&prectx, &list, 0);
        if (prectx.n_errors != 0)
            throw;

        ctx.options = *options;

        bool berror = false;
        ast.declaration_list = parse(&ctx, &ast.token_list, &berror);
        if (berror)
            throw;
    }
    catch
    {
    }
    parser_ctx_destroy(&ctx);
    token_list_destroy(&list);
    preprocessor_ctx_destroy(&prectx);

    return ast;
}

/*
* given a string s, produce argv by modifying the input string
* return argc
*/
int strtoargv(char* s, int n, const char* argv[/*n*/])
{
    int argvc = 0;
    char* p = s;
    while (*p)
    {
        while (*p == ' ')
            p++;
        if (*p == 0)
            break;
        argv[argvc] = p;
        argvc++;
        while (*p != ' ' && *p != '\0')
            p++;
        if (*p == 0)
            break;
        *p = 0;
        p++;
        if (argvc >= n)
            break; /*nao tem mais lugares*/
    }
    return argvc;
}

const char* _Owner _Opt compile_source(const char* pszoptions, const char* content, struct report* report)
{
    const char* argv[100] = { 0 };
    char string[200] = { 0 };
    snprintf(string, sizeof string, "exepath %s", pszoptions);

    const int argc = strtoargv(string, 10, argv);

    const char* _Owner _Opt s = NULL;

    struct preprocessor_ctx prectx = { 0 };
    struct ast ast = { 0 };
    struct options options = { .input = LANGUAGE_CAK };

    _Opt struct visit_ctx visit_ctx = { 0 };
    try
    {
        if (fill_options(&options, argc, argv) != 0)
        {
            throw;
        }

        visit_ctx.target = options.target;
        visit_ctx.hide_non_used_declarations = options.direct_compilation;
        prectx.options = options;
        add_standard_macros(&prectx);

        if (options.preprocess_only)
        {
            struct tokenizer_ctx tctx = { 0 };
            struct token_list tokens = tokenizer(&tctx, content, "c:/main.c", 0, TK_FLAG_NONE);

            struct token_list token_list = preprocessor(&prectx, &tokens, 0);
            if (prectx.n_errors == 0)
            {
                s = print_preprocessed_to_string2(token_list.head);
            }

            token_list_destroy(&tokens);
            token_list_destroy(&token_list);
        }
        else
        {

            ast = get_ast(&options, "c:/main.c", content, report);
            if (report->error_count > 0)
                throw;

            visit_ctx.ast = ast;
            visit(&visit_ctx);

            if (options.direct_compilation)
            {
                s = get_code_as_compiler_see(&visit_ctx.ast.token_list);
            }
            else
            {
                s = get_code_as_we_see(&visit_ctx.ast.token_list, options.remove_comments);
            }
            if (s && options.format_ouput)
            {
                /*re-parser output and format*/
                const char* _Owner _Opt s2 = format_code(&options, s);
                free((void* _Owner _Opt)s);
                s = s2;
            }
        }
    }
    catch
    {
    }

    preprocessor_ctx_destroy(&prectx);
    visit_ctx_destroy(&visit_ctx);
    ast_destroy(&ast);

    return s;
}

char* _Owner _Opt CompileText(const char* pszoptions, const char* content)
{
    /*
      This function is called by the web playground
    */
    printf(WHITE "Cake " CAKE_VERSION RESET "\n");
    printf(WHITE "cake %s main.c\n", pszoptions);
    struct report report = { 0 };
    return (char* _Owner _Opt)compile_source(pszoptions, content, &report);
}

void ast_destroy(struct ast* _Obj_owner ast)
{
    token_list_destroy(&ast->token_list);
    declaration_list_destroy(&ast->declaration_list);
}

static bool is_all_upper(const char* text)
{
    const char* p = text;
    while (*p)
    {
        if (*p != toupper(*p))
        {
            return false;
        }
        p++;
    }
    return true;
}

static bool is_snake_case(const char* text)
{
    if (!(*text >= 'a' && *text <= 'z'))
    {
        return false;
    }

    while (*text)
    {
        if ((*text >= 'a' && *text <= 'z') ||
            *text == '_' ||
            (*text >= '0' && *text <= '9'))

        {
            // ok
        }
        else
            return false;
        text++;
    }

    return true;
}

static bool is_camel_case(const char* text)
{
    if (!(*text >= 'a' && *text <= 'z'))
    {
        return false;
    }

    while (*text)
    {
        if ((*text >= 'a' && *text <= 'z') ||
            (*text >= 'A' && *text <= 'Z') ||
            (*text >= '0' && *text <= '9'))
        {
            // ok
        }
        else
            return false;
        text++;
    }

    return true;
}

static bool is_pascal_case(const char* text)
{
    if (!(text[0] >= 'A' && text[0] <= 'Z'))
    {
        /*first letter uppepr case*/
        return false;
    }

    while (*text)
    {
        if ((*text >= 'a' && *text <= 'z') ||
            (*text >= 'A' && *text <= 'Z') ||
            (*text >= '0' && *text <= '9'))
        {
            // ok
        }
        else
            return false;
        text++;
    }

    return true;
}

/*
 * This naming conventions are not ready yet...
 * but not dificult to implement.maybe options to choose style
 */
void naming_convention_struct_tag(struct parser_ctx* ctx, struct token* token)
{
    if (!parser_is_diagnostic_enabled(ctx, W_STYLE) || token->level != 0)
    {
        return;
    }

    if (ctx->options.style == STYLE_CAKE)
    {
        if (!is_snake_case(token->lexeme))
        {
            compiler_diagnostic_message(W_STYLE, ctx, token, NULL, "use snake_case for struct/union tags");
        }
    }
    else if (ctx->options.style == STYLE_MICROSOFT)
    {
        if (!is_pascal_case(token->lexeme))
        {
            compiler_diagnostic_message(W_STYLE, ctx, token, NULL, "use camelCase for struct/union tags");
        }
    }
}

void naming_convention_enum_tag(struct parser_ctx* ctx, struct token* token)
{
    if (!parser_is_diagnostic_enabled(ctx, W_STYLE) || token->level != 0)
    {
        return;
    }

    if (ctx->options.style == STYLE_CAKE)
    {
        if (!is_snake_case(token->lexeme))
        {
            compiler_diagnostic_message(W_STYLE, ctx, token, NULL, "use snake_case for enum tags");
        }
    }
    else if (ctx->options.style == STYLE_MICROSOFT)
    {
        if (!is_pascal_case(token->lexeme))
        {
            compiler_diagnostic_message(W_STYLE, ctx, token, NULL, "use PascalCase for enum tags");
        }
    }
}

void naming_convention_function(struct parser_ctx* ctx, struct token* token)
{
    if (!parser_is_diagnostic_enabled(ctx, W_STYLE) || token->level != 0)
    {
        return;
    }

    if (ctx->options.style == STYLE_CAKE)
    {
        if (!is_snake_case(token->lexeme))
        {
            compiler_diagnostic_message(W_STYLE, ctx, token, NULL, "use snake_case for functions");
        }
    }
    else if (ctx->options.style == STYLE_MICROSOFT)
    {
        if (!is_pascal_case(token->lexeme))
        {
            compiler_diagnostic_message(W_STYLE, ctx, token, NULL, "use PascalCase for functions");
        }
    }
}

void naming_convention_global_var(struct parser_ctx* ctx, struct token* token, struct type* type, enum storage_class_specifier_flags storage)
{
    if (!parser_is_diagnostic_enabled(ctx, W_STYLE) || token->level != 0)
    {
        return;
    }

    if (!type_is_function_or_function_pointer(type))
    {
        if (storage & STORAGE_SPECIFIER_STATIC)
        {
            if (type_is_const(type))
            {
                //all upper
            }
            else
            {
                if (token->lexeme[0] != 's' || token->lexeme[1] != '_')
                {
                    compiler_diagnostic_message(W_STYLE, ctx, token, NULL, "use prefix s_ for static global variables");
                }
            }
        }
        if (!is_snake_case(token->lexeme))
        {
            compiler_diagnostic_message(W_STYLE, ctx, token, NULL, "use snake_case global variables");
        }
    }
}

void naming_convention_local_var(struct parser_ctx* ctx, struct token* token, struct type* type)
{
    if (!parser_is_diagnostic_enabled(ctx, W_STYLE) || token->level != 0)
    {
        return;
    }

    if (ctx->options.style == STYLE_CAKE)
    {
        if (!is_snake_case(token->lexeme))
        {
            compiler_diagnostic_message(W_STYLE, ctx, token, NULL, "use snake_case for local variables");
        }
    }
    else if (ctx->options.style == STYLE_MICROSOFT)
    {
        if (!is_camel_case(token->lexeme))
        {
            compiler_diagnostic_message(W_STYLE, ctx, token, NULL, "use camelCase for local variables");
        }
    }
}

void naming_convention_enumerator(struct parser_ctx* ctx, struct token* token)
{
    if (!parser_is_diagnostic_enabled(ctx, W_STYLE) || token->level != 0)
    {
        return;
    }

    if (!is_all_upper(token->lexeme))
    {
        compiler_diagnostic_message(W_STYLE, ctx, token, NULL, "use UPPERCASE for enumerators");
    }
}

void naming_convention_struct_member(struct parser_ctx* ctx, struct token* token, struct type* type)
{
    if (!parser_is_diagnostic_enabled(ctx, W_STYLE) || token->level != 0)
    {
        return;
    }

    if (!is_snake_case(token->lexeme))
    {
        compiler_diagnostic_message(W_STYLE, ctx, token, NULL, "use snake_case for struct members");
    }
}

void naming_convention_parameter(struct parser_ctx* ctx, struct token* token, struct type* type)
{
    if (!parser_is_diagnostic_enabled(ctx, W_STYLE) || token->level != 0)
    {
        return;
    }

    if (!is_snake_case(token->lexeme))
    {
        compiler_diagnostic_message(W_STYLE, ctx, token, NULL, "use snake_case for arguments");
    }
}


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

#pragma safety enable


/*imagine tou press DEL key*/
static void del(struct token* from, struct token* to)
{
    struct token* _Opt p = from;
    while (p)
    {
        p->flags |= TK_C_BACKEND_FLAG_HIDE;

        if (p == to)
            break;
        p = p->next;
    }
}

/*imagine tou press CUT key - (tokens are never removed, they become invisible)*/
static struct token_list cut(struct token* from, struct token* to)
{
    struct token_list l = { 0 };
    try
    {
        struct token* _Opt p = from;
        while (p)
        {
            if (p->level == 0 &&
                !(p->flags & TK_FLAG_MACRO_EXPANDED) &&
                !(p->flags & TK_C_BACKEND_FLAG_HIDE) &&
                p->type != TK_BEGIN_OF_FILE)
            {
                struct token* _Owner _Opt clone = clone_token(p);
                if (clone == NULL) throw;

                p->flags |= TK_C_BACKEND_FLAG_HIDE;
                token_list_add(&l, clone);
                if (p == to)
                    break;
            }

            if (p == to)
                break;
            p = p->next;
        }
    }
    catch
    {
    }
    return l;
}


void defer_scope_delete_all(struct defer_scope* _Owner p);

void visit_ctx_destroy(struct visit_ctx* _Obj_owner ctx)
{
    if (ctx->tail_block)
        defer_scope_delete_all(ctx->tail_block);

    token_list_destroy(&ctx->insert_before_declaration);
    token_list_destroy(&ctx->insert_before_block_item);
}

static void visit_attribute_specifier_sequence(struct visit_ctx* ctx, struct attribute_specifier_sequence* p_visit_attribute_specifier_sequence);
static void visit_declaration(struct visit_ctx* ctx, struct declaration* p_declaration);

struct token* _Opt next_parser_token(struct token* token)
{
    struct token* _Opt r = token->next;

    while (r && !(r->flags & TK_FLAG_FINAL))
    {
        r = r->next;
    }
    return r;
}

static void visit_struct_or_union_specifier(struct visit_ctx* ctx, struct struct_or_union_specifier* p_struct_or_union_specifier);
static void visit_expression(struct visit_ctx* ctx, struct expression* p_expression);
static void visit_statement(struct visit_ctx* ctx, struct statement* p_statement);
static void visit_enum_specifier(struct visit_ctx* ctx, struct enum_specifier* p_enum_specifier);
static void visit_type_specifier(struct visit_ctx* ctx, struct type_specifier* p_type_specifier);

void convert_if_statement(struct visit_ctx* ctx, struct selection_statement* p_selection_statement)
{
    /*
      OBS:
      To debug this code use
      print_code_as_we_see(&ctx->ast.token_list, false);
      before and after each transformation
    */

    if (p_selection_statement->p_init_statement == NULL &&
        p_selection_statement->condition != NULL &&
        p_selection_statement->condition->expression)
    {
        return;
    }


    token_list_paste_string_before(&ctx->ast.token_list, p_selection_statement->first_token, "{");


    struct token_list init_tokens_cut = { 0 };
    if (p_selection_statement->p_init_statement &&
        p_selection_statement->p_init_statement->p_expression_statement)
    {
        if (p_selection_statement->p_init_statement->p_expression_statement->expression_opt)
        {
            init_tokens_cut = cut(p_selection_statement->p_init_statement->p_expression_statement->expression_opt->first_token,
                p_selection_statement->p_init_statement->p_expression_statement->expression_opt->last_token);
        }
        else
        {
            assert(false);
        }
    }
    else if (p_selection_statement->p_init_statement &&
        p_selection_statement->p_init_statement->p_simple_declaration)
    {
        init_tokens_cut = cut(p_selection_statement->p_init_statement->p_simple_declaration->first_token,
            p_selection_statement->p_init_statement->p_simple_declaration->last_token);
    }

    token_list_insert_before(&ctx->ast.token_list, p_selection_statement->first_token, &init_tokens_cut);


    struct token_list condition_tokens_cut = { 0 };
    if (p_selection_statement->condition && p_selection_statement->condition->expression)
    {
        /*leave it */
    }
    else if (p_selection_statement->condition &&
        p_selection_statement->condition->p_declaration_specifiers)
    {
        condition_tokens_cut = cut(p_selection_statement->condition->first_token,
            p_selection_statement->condition->last_token);

        token_list_insert_before(&ctx->ast.token_list, p_selection_statement->first_token, &condition_tokens_cut);
        token_list_paste_string_before(&ctx->ast.token_list, p_selection_statement->first_token, ";");

        if (p_selection_statement->condition->p_init_declarator &&
            p_selection_statement->condition->p_init_declarator->p_declarator->name_opt)
        {
            token_list_paste_string_before(&ctx->ast.token_list, p_selection_statement->close_parentesis_token,
                p_selection_statement->condition->p_init_declarator->p_declarator->name_opt->lexeme
            );
        }
        else
        {
            assert(false);
        }


    }

    token_list_paste_string_after(&ctx->ast.token_list, p_selection_statement->last_token, "}");
    token_list_destroy(&condition_tokens_cut);
    token_list_destroy(&init_tokens_cut);
}

void print_block_defer(struct defer_scope* defer_block, struct osstream* ss, bool hide_tokens)
{
    struct defer_scope* _Opt defer_child = defer_block->lastchild;
    while (defer_child != NULL)
    {
        if (defer_child->defer_statement == NULL)
        {
            assert(false);
            return;
        }

        _View struct token_list l = { 0 };

        l.head = defer_child->defer_statement->first_token;
        l.tail = defer_child->defer_statement->last_token;

        l.head->flags |= TK_C_BACKEND_FLAG_HIDE;
        const char* _Owner _Opt s = get_code_as_compiler_see(&l);
        if (s != NULL)
        {
            if (hide_tokens)
                token_range_add_flag(l.head, l.tail, TK_C_BACKEND_FLAG_HIDE);

            ss_fprintf(ss, "%s", s);
            free((void* _Owner)s);
        }
        defer_child = defer_child->previous;
    }
}


void hide_block_defer(struct defer_scope* deferblock)
{
    struct defer_scope* _Opt deferchild = deferblock->lastchild;
    while (deferchild != NULL)
    {
        if (deferchild->defer_statement == NULL)
        {
            assert(false);
            return;
        }

        struct token* head = deferchild->defer_statement->first_token;
        struct token* tail = deferchild->defer_statement->last_token;
        token_range_add_flag(head, tail, TK_C_BACKEND_FLAG_HIDE);
        deferchild = deferchild->previous;
    }
}


void print_all_defer_until_try(struct defer_scope* deferblock, struct osstream* ss)
{
    struct defer_scope* _Opt p_defer = deferblock;
    while (p_defer != NULL)
    {
        print_block_defer(p_defer, ss, false);

        if (p_defer->p_try_statement)
        {
            break;
        }

        p_defer = p_defer->previous;
    }
}

bool find_label_statement(struct statement* statement, const char* label);
bool find_label_unlabeled_statement(struct unlabeled_statement* p_unlabeled_statement, const char* label)
{
    if (p_unlabeled_statement->primary_block)
    {
        if (p_unlabeled_statement->primary_block->compound_statement)
        {
            struct block_item* _Opt block_item =
                p_unlabeled_statement->primary_block->compound_statement->block_item_list.head;
            while (block_item)
            {
                if (block_item->label &&
                    block_item->label->p_identifier_opt &&
                    strcmp(block_item->label->p_identifier_opt->lexeme, label) == 0)
                {
                    /*achou*/
                    return true;
                }
                else if (block_item->unlabeled_statement)
                {
                    if (find_label_unlabeled_statement(block_item->unlabeled_statement, label))
                    {
                        return true;
                    }
                }

                block_item = block_item->next;
            }
        }
        else if (p_unlabeled_statement->primary_block->selection_statement)
        {
            if (find_label_statement(p_unlabeled_statement->primary_block->selection_statement->secondary_block->statement, label))
            {
                return true;
            }
            if (p_unlabeled_statement->primary_block->selection_statement->else_secondary_block_opt)
            {
                if (find_label_statement(p_unlabeled_statement->primary_block->selection_statement->else_secondary_block_opt->statement, label))
                {
                    return true;
                }
            }
        }
        else if (p_unlabeled_statement->primary_block->try_statement)
        {
            if (find_label_statement(p_unlabeled_statement->primary_block->try_statement->secondary_block->statement, label))
            {
                return true;
            }
            if (p_unlabeled_statement->primary_block->try_statement->catch_secondary_block_opt)
            {
                if (find_label_statement(p_unlabeled_statement->primary_block->try_statement->catch_secondary_block_opt->statement, label))
                {
                    return true;
                }
            }
        }
        else if (p_unlabeled_statement->primary_block->iteration_statement)
        {
            if (find_label_statement(p_unlabeled_statement->primary_block->iteration_statement->secondary_block->statement, label))
            {
                return true;
            }
        }
    }
    return false;
}

bool find_label_statement(struct statement* statement, const char* label)
{
    if (statement->labeled_statement &&
        statement->labeled_statement->label->p_identifier_opt)
    {
        if (strcmp(statement->labeled_statement->label->p_identifier_opt->lexeme, label) == 0)
        {
            return true;
        }
    }
    else if (statement->unlabeled_statement)
    {
        if (find_label_unlabeled_statement(statement->unlabeled_statement, label))
            return true;
    }
    return false;
}

static bool find_label_scope(struct defer_scope* deferblock, const char* label)
{
    if (deferblock->p_iteration_statement)
    {

        if (find_label_statement(deferblock->p_iteration_statement->secondary_block->statement, label))
            return true;

    }
    else if (deferblock->p_selection_statement)
    {
        if (find_label_statement(deferblock->p_selection_statement->secondary_block->statement, label))
            return true;

        if (deferblock->p_selection_statement->else_secondary_block_opt)
        {
            if (find_label_statement(deferblock->p_selection_statement->else_secondary_block_opt->statement, label))
                return true;
        }
    }
    else if (deferblock->p_try_statement)
    {

        if (find_label_statement(deferblock->p_try_statement->secondary_block->statement, label))
            return true;


        if (deferblock->p_try_statement->catch_secondary_block_opt)
        {
            if (find_label_statement(deferblock->p_try_statement->catch_secondary_block_opt->statement, label))
                return true;
        }
    }
    else if (deferblock->p_statement)
    {
        if (find_label_statement(deferblock->p_statement, label))
            return true;
    }
    return false;
}

void print_all_defer_until_label(struct defer_scope* deferblock, const char* label, struct osstream* ss)
{
    /*
    * Precisamos saber quantos escopos nós saimos até achar o label.
    * Para isso procuramos no escopo atual aonde aparede o goto.
    * Se o label não esta diretamente neste escopo ou dentro de algum escopo interno
    * Não nós imprimos os defers pois estamos saindo do escopo e vamos para o escopo
    * de cima. Assim vamos repetindo em cada saida de escopo imprimos o defer.
    */
    struct defer_scope* _Opt p_defer = deferblock;

    while (p_defer != NULL)
    {
        if (!find_label_scope(p_defer, label))
        {
            print_block_defer(p_defer, ss, false);
        }
        else
        {
            break;
        }
        p_defer = p_defer->previous;
    }

}

void print_all_defer_until_iter(struct defer_scope* deferblock, struct osstream* ss)
{
    struct defer_scope* _Opt p_defer = deferblock;
    while (p_defer != NULL)
    {
        print_block_defer(p_defer, ss, false);
        if (p_defer->p_iteration_statement)
        {
            break;
        }
        p_defer = p_defer->previous;
    }
}

void print_all_defer_until_end(struct defer_scope* deferblock, struct osstream* ss)
{
    struct defer_scope* _Opt p_defer = deferblock;
    while (p_defer != NULL)
    {
        print_block_defer(p_defer, ss, false);
        p_defer = p_defer->previous;
    }
}

static void visit_secondary_block(struct visit_ctx* ctx, struct secondary_block* p_secondary_block)
{
    visit_statement(ctx, p_secondary_block->statement);
}
struct defer_scope* _Opt visit_ctx_push_tail_child(struct visit_ctx* ctx)
{
    struct defer_scope* _Owner _Opt p_defer = calloc(1, sizeof * p_defer);
    if (p_defer == NULL)
        return NULL;

    if (ctx->tail_block == NULL)
    {
        ctx->tail_block = p_defer;
        return ctx->tail_block;
    }

    p_defer->previous = ctx->tail_block->lastchild;
    ctx->tail_block->lastchild = p_defer;
    return ctx->tail_block->lastchild;
}


struct defer_scope* _Opt visit_ctx_push_tail_block(struct visit_ctx* ctx)
{
    struct defer_scope* _Owner _Opt p_defer = calloc(1, sizeof * p_defer);
    if (p_defer == NULL)
        return NULL;

    p_defer->previous = ctx->tail_block;
    ctx->tail_block = p_defer;

    return ctx->tail_block;
}
static void visit_defer_statement(struct visit_ctx* ctx, struct defer_statement* p_defer_statement)
{
    if (!ctx->is_second_pass)
    {
        //add as child of the last block
        struct defer_scope* _Opt p_defer = visit_ctx_push_tail_child(ctx);
        if (p_defer == NULL)
            return;

        p_defer->defer_statement = p_defer_statement;

        visit_secondary_block(ctx, p_defer_statement->secondary_block);
    }
    else //if (ctx->is_second_pass)
    {
        visit_secondary_block(ctx, p_defer_statement->secondary_block);
    }
}



void defer_scope_delete_one(struct defer_scope* _Owner p_block);

void visit_ctx_pop_tail_block(struct visit_ctx* ctx)
{
    if (ctx->tail_block)
    {
        struct defer_scope* _Owner _Opt previous = ctx->tail_block->previous;
        ctx->tail_block->previous = NULL;
        defer_scope_delete_one(ctx->tail_block);
        ctx->tail_block = previous;
    }
}

static void visit_try_statement(struct visit_ctx* ctx, struct try_statement* p_try_statement)
{
    struct osstream ss = { 0 };
    try
    {
        if (!ctx->is_second_pass)
        {
            struct defer_scope* _Opt p_defer = visit_ctx_push_tail_block(ctx);
            if (p_defer == NULL)
                return;

            p_defer->p_try_statement = p_try_statement;

            visit_secondary_block(ctx, p_try_statement->secondary_block);

            print_block_defer(p_defer, &ss, true);

            if (ss.c_str == NULL)
            {
                throw;
            }

            struct tokenizer_ctx tctx = { 0 };
            struct token_list l = tokenizer(&tctx, ss.c_str, NULL, 0, TK_FLAG_FINAL);
            token_list_insert_after(&ctx->ast.token_list, p_try_statement->secondary_block->last_token->prev, &l);


            visit_ctx_pop_tail_block(ctx);
            char* _Opt _Owner temp0 = strdup("if (1) /*try*/");
            if (temp0 == NULL)
            {
                token_list_destroy(&l);
                throw;
            }

            free(p_try_statement->first_token->lexeme);
            p_try_statement->first_token->lexeme = temp0;


            char buffer[50] = { 0 };
            if (p_try_statement->catch_secondary_block_opt)
            {
                assert(p_try_statement->catch_token_opt != NULL);

                snprintf(buffer, sizeof buffer, "else _catch_label_%d:", p_try_statement->try_catch_block_index);

                char* _Opt _Owner temp = strdup(buffer);
                if (temp == NULL)
                {
                    token_list_destroy(&l);
                    throw;
                }

                free(p_try_statement->catch_token_opt->lexeme);
                p_try_statement->catch_token_opt->lexeme = temp;

                visit_secondary_block(ctx, p_try_statement->catch_secondary_block_opt);
            }
            else
            {


                snprintf(buffer, sizeof buffer, "} else {_catch_label_%d:;}", p_try_statement->try_catch_block_index);

                char* _Opt _Owner temp = strdup(buffer);
                if (temp == NULL)
                {
                    token_list_destroy(&l);
                    throw;
                }

                free(p_try_statement->last_token->lexeme);
                p_try_statement->last_token->lexeme = temp;
            }


            token_list_destroy(&l);
        }
    }
    catch
    {
    }
    ss_close(&ss);
}

static void visit_declaration_specifiers(struct visit_ctx* ctx,
    struct declaration_specifiers* p_declaration_specifiers,
    struct type* _Opt p_type);

static void visit_init_declarator_list(struct visit_ctx* ctx, struct init_declarator_list* p_init_declarator_list);

static void visit_simple_declaration(struct visit_ctx* ctx, struct simple_declaration* p_simple_declaration)
{
    if (p_simple_declaration->p_attribute_specifier_sequence_opt)
        visit_attribute_specifier_sequence(ctx, p_simple_declaration->p_attribute_specifier_sequence_opt);
    visit_declaration_specifiers(ctx, p_simple_declaration->p_declaration_specifiers, NULL);
    visit_init_declarator_list(ctx, &p_simple_declaration->init_declarator_list);
}
static void visit_expression_statement(struct visit_ctx* ctx, struct expression_statement* p_expression_statement);

static void visit_init_statement(struct visit_ctx* ctx, struct init_statement* p_init_statement)
{
    if (p_init_statement->p_expression_statement)
        visit_expression_statement(ctx, p_init_statement->p_expression_statement);
    if (p_init_statement->p_simple_declaration)
        visit_simple_declaration(ctx, p_init_statement->p_simple_declaration);
}

static void visit_initializer(struct visit_ctx* ctx, struct initializer* p_initializer);

static void visit_declarator(struct visit_ctx* ctx, struct declarator* p_declarator);

static void visit_init_declarator(struct visit_ctx* ctx, struct init_declarator* p_init_declarator)
{
    visit_declarator(ctx, p_init_declarator->p_declarator);

    if (p_init_declarator->initializer)
        visit_initializer(ctx, p_init_declarator->initializer);
}
static void visit_condition(struct visit_ctx* ctx, struct condition* p_condition)
{
    if (p_condition->p_declaration_specifiers)
    {
        visit_declaration_specifiers(ctx,
            p_condition->p_declaration_specifiers,
            &p_condition->p_init_declarator->p_declarator->type);
    }

    if (p_condition->p_init_declarator)
        visit_init_declarator(ctx, p_condition->p_init_declarator);


    if (p_condition->expression)
        visit_expression(ctx, p_condition->expression);
}

static void visit_selection_statement(struct visit_ctx* ctx, struct selection_statement* p_selection_statement)
{
    struct defer_scope* _Opt p_defer = visit_ctx_push_tail_block(ctx);
    if (p_defer == NULL)
        return;

    p_defer->p_selection_statement = p_selection_statement;

    if (p_selection_statement->p_init_statement)
        visit_init_statement(ctx, p_selection_statement->p_init_statement);

    if (p_selection_statement->condition)
        visit_condition(ctx, p_selection_statement->condition);


    visit_secondary_block(ctx, p_selection_statement->secondary_block);

    struct osstream ss = { 0 };
    print_block_defer(p_defer, &ss, true);

    if (ss.c_str == NULL)
        return;

    if (ss.size > 0)
    {
        struct tokenizer_ctx tctx = { 0 };
        struct token_list l = tokenizer(&tctx, ss.c_str, NULL, 0, TK_FLAG_FINAL);
        token_list_insert_after(&ctx->ast.token_list, p_selection_statement->secondary_block->last_token->prev, &l);
        token_list_destroy(&l);
    }

    visit_ctx_pop_tail_block(ctx);

    if (p_selection_statement->else_secondary_block_opt)
        visit_secondary_block(ctx, p_selection_statement->else_secondary_block_opt);

    ss_close(&ss);

    //afte all visits and changes we visit again
    if (ctx->target < LANGUAGE_C2Y)
    {
        convert_if_statement(ctx, p_selection_statement);
    }
}

static void visit_compound_statement(struct visit_ctx* ctx, struct compound_statement* p_compound_statement);



char* _Opt remove_char(char* input, char ch)
{
    char* p_write = input;
    const char* p = input;
    while (*p)
    {
        if (p[0] == ch)
        {
            p++;
        }
        else
        {
            *p_write = *p;
            p++;
            p_write++;
        }
    }
    *p_write = 0;
    return input;
}

static void visit_initializer_list(struct visit_ctx* ctx, struct initializer_list* p_initializer_list);

static void visit_bracket_initializer_list(struct visit_ctx* ctx, struct braced_initializer* p_bracket_initializer_list)
{
    if (p_bracket_initializer_list->initializer_list == NULL)
    {
        if (ctx->target < LANGUAGE_C23)
        {
            assert(p_bracket_initializer_list->first_token->type == '{');

            const int level = p_bracket_initializer_list->first_token->level;
            //Criar token 0
            struct tokenizer_ctx tctx = { 0 };
            struct token_list list2 = tokenizer(&tctx, "0", NULL, level, TK_FLAG_FINAL);

            //inserir na frente
            token_list_insert_after(&ctx->ast.token_list, p_bracket_initializer_list->first_token, &list2);
            token_list_destroy(&list2);
        }
    }
    else
    {
        visit_initializer_list(ctx, p_bracket_initializer_list->initializer_list);
    }
}

static void visit_designation(struct visit_ctx* ctx, struct designation* p_designation)
{}

static void visit_initializer(struct visit_ctx* ctx, struct initializer* p_initializer)
{
    if (p_initializer->designation)
    {
        visit_designation(ctx, p_initializer->designation);
    }

    if (p_initializer->assignment_expression)
    {
        visit_expression(ctx, p_initializer->assignment_expression);
    }
    else if (p_initializer->braced_initializer)
    {
        visit_bracket_initializer_list(ctx, p_initializer->braced_initializer);
    }
}

static void visit_initializer_list(struct visit_ctx* ctx, struct initializer_list* p_initializer_list)
{
    struct initializer* _Opt p_initializer = p_initializer_list->head;
    while (p_initializer)
    {
        visit_initializer(ctx, p_initializer);
        p_initializer = p_initializer->next;
    }
}

static void visit_type_qualifier(struct visit_ctx* ctx, struct type_qualifier* p_type_qualifier)
{
    if (ctx->target < LANGUAGE_C99 && p_type_qualifier->token->type == TK_KEYWORD_RESTRICT)
    {
        char* _Opt _Owner temp = strdup("/*restrict*/");
        if (temp == NULL)
            return;

        free(p_type_qualifier->token->lexeme);
        p_type_qualifier->token->lexeme = temp;
    }

    if (p_type_qualifier->token->type == TK_KEYWORD__OUT ||
        p_type_qualifier->token->type == TK_KEYWORD__OPT ||
        p_type_qualifier->token->type == TK_KEYWORD__OWNER ||
        p_type_qualifier->token->type == TK_KEYWORD__OBJ_OWNER ||
        p_type_qualifier->token->type == TK_KEYWORD__VIEW)
    {
        char temp[100] = { 0 };
        snprintf(temp, sizeof temp, "/*%s*/", p_type_qualifier->token->lexeme);

        char* _Opt _Owner s = strdup(temp);
        if (s == NULL)
            return;

        free(p_type_qualifier->token->lexeme);
        p_type_qualifier->token->lexeme = s;
    }
}

static void visit_specifier_qualifier(struct visit_ctx* ctx, struct type_specifier_qualifier* p_specifier_qualifier)
{
    if (p_specifier_qualifier->type_specifier)
        visit_type_specifier(ctx, p_specifier_qualifier->type_specifier);

    if (p_specifier_qualifier->type_qualifier)
        visit_type_qualifier(ctx, p_specifier_qualifier->type_qualifier);
}

static void visit_specifier_qualifier_list(struct visit_ctx* ctx,
    struct specifier_qualifier_list* p_specifier_qualifier_list,
    struct type* p_type)
{

    //(typeof(int[2])*)
    // 
    //TODO se tiver typeof em qualquer parte tem que imprimir todo  tipo
    // tem que refazer
    if (p_specifier_qualifier_list->type_specifier_flags & TYPE_SPECIFIER_TYPEOF)
    {
        const int level = p_specifier_qualifier_list->first_token->level;

        token_range_add_flag(p_specifier_qualifier_list->first_token,
            p_specifier_qualifier_list->last_token, TK_C_BACKEND_FLAG_HIDE);

        struct osstream ss = { 0 };
        print_type_no_names(&ss, type_get_specifer_part(p_type));

        if (ss.c_str == NULL)
            return;

        struct tokenizer_ctx tctx = { 0 };
        struct token_list l2 = tokenizer(&tctx, ss.c_str, NULL, level, TK_FLAG_FINAL);
        token_list_insert_after(&ctx->ast.token_list, p_specifier_qualifier_list->last_token, &l2);

        ss_close(&ss);
        token_list_destroy(&l2);
    }

    if (p_specifier_qualifier_list->struct_or_union_specifier)
    {
        visit_struct_or_union_specifier(ctx, p_specifier_qualifier_list->struct_or_union_specifier);
    }
    else if (p_specifier_qualifier_list->enum_specifier)
    {
        visit_enum_specifier(ctx, p_specifier_qualifier_list->enum_specifier);
    }
    else if (p_specifier_qualifier_list->typedef_declarator)
    {
        //typedef name
    }
    //else if (p_specifier_qualifier_list->p_typeof_expression_opt)
    //{
      //  visit_expression(ctx, p_specifier_qualifier_list->p_typeof_expression_opt);
    //}
    else
    {
        struct type_specifier_qualifier* _Opt p_specifier_qualifier = p_specifier_qualifier_list->head;
        while (p_specifier_qualifier)
        {
            visit_specifier_qualifier(ctx, p_specifier_qualifier);
            p_specifier_qualifier = p_specifier_qualifier->next;
        }
    }
}

static void visit_type_name(struct visit_ctx* ctx, struct type_name* p_type_name)
{

    visit_specifier_qualifier_list(ctx, p_type_name->specifier_qualifier_list, &p_type_name->type);
    visit_declarator(ctx, p_type_name->abstract_declarator);


    /*
    * Vamos esconder tudo e gerar um novo
    *  Exemplo
    *  (const typeof(int (*)())) -> *  ( int (*const )() )
    */
}



static void visit_argument_expression_list(struct visit_ctx* ctx, struct argument_expression_list* p_argument_expression_list)
{
    struct argument_expression* _Opt p_argument_expression = p_argument_expression_list->head;
    while (p_argument_expression)
    {
        visit_expression(ctx, p_argument_expression->expression);
        p_argument_expression = p_argument_expression->next;
    }
}

static void visit_generic_selection(struct visit_ctx* ctx, struct generic_selection* p_generic_selection)
{
    if (p_generic_selection->expression)
    {
        visit_expression(ctx, p_generic_selection->expression);
    }
    else if (p_generic_selection->type_name)
    {
        visit_type_name(ctx, p_generic_selection->type_name);
    }

    struct generic_association* _Opt p = p_generic_selection->generic_assoc_list.head;
    while (p)
    {
        if (p->p_type_name) visit_type_name(ctx, p->p_type_name);
        visit_expression(ctx, p->expression);
        p = p->next;
    }

    if (ctx->target < LANGUAGE_C11)
    {

        /*the select part will be temporally hidden*/
        if (p_generic_selection->p_view_selected_expression)
        {
            for (struct token* current = p_generic_selection->p_view_selected_expression->first_token;
                current != p_generic_selection->p_view_selected_expression->last_token->next;
                current = current->next)
            {
                if (!(current->flags & TK_C_BACKEND_FLAG_HIDE))
                {
                    current->flags |= TK_C_BACKEND_FLAG_SHOW_AGAIN;
                }
                if (current->next == NULL)
                {
                    break;
                }
            }
        }

        /*let's hide everything first*/
        token_range_add_flag(p_generic_selection->first_token, p_generic_selection->last_token, TK_C_BACKEND_FLAG_HIDE);

        /*lets show again just the part of the select that was visible*/
        if (p_generic_selection->p_view_selected_expression)
        {
            for (struct token* current = p_generic_selection->p_view_selected_expression->first_token;
                 current != p_generic_selection->p_view_selected_expression->last_token->next;
                 current = current->next)
            {
                if ((current->flags & TK_C_BACKEND_FLAG_HIDE) &&
                    (current->flags & TK_C_BACKEND_FLAG_SHOW_AGAIN))
                {
                    current->flags = current->flags & ~(TK_C_BACKEND_FLAG_SHOW_AGAIN | TK_C_BACKEND_FLAG_HIDE);
                }
                if (current->next == NULL)
                {
                    break;
                }
            }
        }
    }

}


static void visit_expression(struct visit_ctx* ctx, struct expression* p_expression)
{
    switch (p_expression->expression_type)
    {
    case EXPRESSION_TYPE_INVALID:
        assert(false);
        break;

    case PRIMARY_EXPRESSION__FUNC__:
        break;

    case PRIMARY_EXPRESSION_ENUMERATOR:
        if (ctx->target < LANGUAGE_C23)
        {
            struct type t = type_get_enum_type(&p_expression->type);
            if (t.type_specifier_flags != TYPE_SPECIFIER_INT)
            {
                struct osstream ss0 = { 0 };
                print_type(&ss0, &t);
                if (ss0.c_str == NULL)
                {
                    type_destroy(&t);
                    return;
                }

                struct osstream ss = { 0 };
                ss_fprintf(&ss, "((%s)%s)", ss0.c_str, p_expression->first_token->lexeme);
                if (ss.c_str == NULL)
                {
                    ss_close(&ss0);
                    type_destroy(&t);
                    return;
                }

                free(p_expression->first_token->lexeme);
                p_expression->first_token->lexeme = ss.c_str;
                ss.c_str = NULL; /*MOVED*/
                ss_close(&ss);
                ss_close(&ss0);
            }
            type_destroy(&t);
        }
        break;
    case PRIMARY_EXPRESSION_DECLARATOR:

        if (ctx->target < LANGUAGE_C23)
        {
            if (constant_value_is_valid(&p_expression->constant_value))
            {
                free((void* _Owner)p_expression->type.name_opt);
                p_expression->type.name_opt = NULL;

                struct osstream ss = { 0 };
                print_type(&ss, &p_expression->type);
                if (ss.c_str == NULL)
                    return;

                struct osstream ss1 = { 0 };

                /*
                  this is the way we handle constexpr, replacing the declarator
                  for it's number and changing the expression type
                  we are not handling &a at this moment
                */
                char buffer[40] = { 0 };
                constant_value_to_string(&p_expression->constant_value, buffer, sizeof buffer);

                ss_fprintf(&ss1, "((%s)%s)", ss.c_str, buffer);
                if (ss1.c_str == NULL)
                {
                    ss_close(&ss);
                    return;
                }

                free(p_expression->first_token->lexeme);
                p_expression->first_token->lexeme = ss1.c_str;
                ss1.c_str = NULL;// MOVED
                p_expression->expression_type = PRIMARY_EXPRESSION_NUMBER;

                ss_close(&ss);
                ss_close(&ss1);
            }
        }

        break;
    case PRIMARY_EXPRESSION_STRING_LITERAL:
        break;
    case PRIMARY_EXPRESSION_CHAR_LITERAL:
        break;
    case PRIMARY_EXPRESSION_NUMBER:
        break;

    case PRIMARY_EXPRESSION_PREDEFINED_CONSTANT:
        if (p_expression->first_token->type == TK_KEYWORD_NULLPTR)
        {
            if (ctx->target < LANGUAGE_C23)
            {
                char* _Opt _Owner temp = strdup("((void*)0)");
                if (temp == NULL)
                    return;

                free(p_expression->first_token->lexeme);
                p_expression->first_token->lexeme = temp;
            }
        }
        else if (p_expression->first_token->type == TK_KEYWORD_TRUE)
        {
            if (ctx->target < LANGUAGE_C99)
            {
                char* _Owner _Opt temp = strdup("1");;
                if (temp == NULL)
                    return;

                free(p_expression->first_token->lexeme);
                p_expression->first_token->lexeme = temp;
            }
            else if (ctx->target < LANGUAGE_C23)
            {
                char* _Opt _Owner temp = strdup("((_Bool)1)");
                if (temp == NULL)
                    return;

                free(p_expression->first_token->lexeme);
                p_expression->first_token->lexeme = temp;
            }
        }
        else if (p_expression->first_token->type == TK_KEYWORD_FALSE)
        {
            if (ctx->target < LANGUAGE_C99)
            {
                char* _Opt _Owner temp = strdup("0");
                if (temp == NULL)
                    return;

                free(p_expression->first_token->lexeme);
                p_expression->first_token->lexeme = temp;
            }
            else if (ctx->target < LANGUAGE_C23)
            {
                char* _Opt _Owner temp = strdup("((_Bool)0)");
                if (temp == NULL)
                    return;

                free(p_expression->first_token->lexeme);
                p_expression->first_token->lexeme = temp;
            }
        }
        break;

    case PRIMARY_EXPRESSION_PARENTESIS:
        assert(p_expression->right != NULL);
        visit_expression(ctx, p_expression->right);
        break;

    case PRIMARY_EXPRESSION_GENERIC:
        assert(p_expression->generic_selection != NULL);
        visit_generic_selection(ctx, p_expression->generic_selection);
        break;

    case POSTFIX_DOT:
    case POSTFIX_ARROW:
    case POSTFIX_INCREMENT:
    case POSTFIX_DECREMENT:
        if (p_expression->left)
            visit_expression(ctx, p_expression->left);
        if (p_expression->right)
            visit_expression(ctx, p_expression->right);
        break;
    case POSTFIX_ARRAY:
        //visit_expression(ctx, p_expression->left);
        break;
    case POSTFIX_FUNCTION_CALL:

        if (p_expression->left)
            visit_expression(ctx, p_expression->left);
        if (p_expression->right)
            visit_expression(ctx, p_expression->right);

        visit_argument_expression_list(ctx, &p_expression->argument_expression_list);
        break;
    case POSTFIX_EXPRESSION_FUNCTION_LITERAL:
    {
        assert(p_expression->compound_statement != NULL);
        assert(p_expression->type_name != NULL);

        ctx->has_lambda = true;
        ctx->is_inside_lambda = true;
        visit_type_name(ctx, p_expression->type_name);
        visit_compound_statement(ctx, p_expression->compound_statement);
        ctx->is_inside_lambda = false;

        if (ctx->is_second_pass)
        {
            /*no segundo passo nós copiamos a funcao*/
            char name[100] = { 0 };
            snprintf(name, sizeof name, " _lit_func_%d", ctx->lambdas_index);
            ctx->lambdas_index++;

            struct osstream ss = { 0 };



            bool is_first = true;
            print_type_qualifier_flags(&ss, &is_first, p_expression->type_name->abstract_declarator->type.type_qualifier_flags);
            print_type_specifier_flags(&ss, &is_first, p_expression->type_name->abstract_declarator->type.type_specifier_flags);


            free((void* _Owner)p_expression->type_name->abstract_declarator->type.name_opt);
            p_expression->type_name->abstract_declarator->type.name_opt = strdup(name);

            struct osstream ss0 = { 0 };

            print_type(&ss0, &p_expression->type_name->abstract_declarator->type);
            ss_fprintf(&ss, "static %s", ss0.c_str);

            ss_close(&ss0);

            if (ss.c_str == NULL)
                return;

            struct tokenizer_ctx tctx = { 0 };
            struct token_list l1 = tokenizer(&tctx, ss.c_str, NULL, 0, TK_FLAG_FINAL);

            token_list_append_list(&ctx->insert_before_declaration, &l1);
            ss_close(&ss);
            token_list_destroy(&l1);

            for (struct token* current = p_expression->compound_statement->first_token;
                current != p_expression->compound_statement->last_token->next;
                current = current->next)
            {
                token_list_clone_and_add(&ctx->insert_before_declaration, current);
                if (current->next == NULL)
                    break;
            }

            token_range_add_flag(p_expression->first_token, p_expression->last_token, TK_C_BACKEND_FLAG_HIDE);


            struct token_list l3 = tokenizer(&tctx, "\n\n", NULL, 0, TK_FLAG_NONE);
            token_list_append_list(&ctx->insert_before_declaration, &l3);
            token_list_destroy(&l3);

            struct token_list l2 = tokenizer(&tctx, name, NULL, 0, TK_FLAG_FINAL);
            token_list_insert_after(&ctx->ast.token_list, p_expression->last_token, &l2);
            token_list_destroy(&l2);
        }
    }
    break;

    case POSTFIX_EXPRESSION_COMPOUND_LITERAL:

        assert(p_expression->braced_initializer != NULL);
        if (p_expression->type_name)
        {
            visit_type_name(ctx, p_expression->type_name);
        }

        visit_bracket_initializer_list(ctx, p_expression->braced_initializer);

        assert(p_expression->left == NULL);
        assert(p_expression->right == NULL);

        break;

    case UNARY_EXPRESSION_ALIGNOF:

        if (ctx->target < LANGUAGE_C11)
        {
            const int level = p_expression->first_token->level;
            token_range_add_flag(p_expression->first_token, p_expression->last_token, TK_C_BACKEND_FLAG_HIDE);
            char buffer[30] = { 0 };
            snprintf(buffer, sizeof buffer, "%lld", constant_value_to_signed_long_long(&p_expression->constant_value));
            struct tokenizer_ctx tctx = { 0 };
            struct token_list l3 = tokenizer(&tctx, buffer, NULL, level, TK_FLAG_FINAL);
            if (l3.head == NULL)
            {
                return;
            }

            l3.head->flags = p_expression->last_token->flags;
            token_list_insert_after(&ctx->ast.token_list, p_expression->last_token, &l3);
            token_list_destroy(&l3);
        }

        if (p_expression->right)
        {
            visit_expression(ctx, p_expression->right);
        }

        if (p_expression->type_name)
        {
            /*sizeof*/
            visit_type_name(ctx, p_expression->type_name);
        }
        break;

    case UNARY_EXPRESSION_NELEMENTSOF_TYPE:

        del(p_expression->first_token, p_expression->first_token);

        struct tokenizer_ctx tctx = { 0 };


        if (p_expression->right)
        {
            visit_expression(ctx, p_expression->right);

            struct token_list l = { .head = p_expression->right->first_token,
                                    .tail = p_expression->right->last_token };

            const char* _Owner _Opt exprstr = get_code_as_we_see(&l, true);
            char buffer[200] = { 0 };
            snprintf(buffer, sizeof buffer, "sizeof(%s)/sizeof((%s)[0])", exprstr, exprstr);

            struct token_list l2 = tokenizer(&tctx, buffer, NULL, 0, TK_FLAG_FINAL);

            token_list_insert_before(&ctx->ast.token_list,
                p_expression->last_token,
                &l2);

            del(p_expression->right->first_token, p_expression->right->last_token);
            free((char* _Owner)exprstr);

            token_list_destroy(&l2);
        }

        if (p_expression->type_name)
        {
            visit_type_name(ctx, p_expression->type_name);

            if (constant_value_is_valid(&p_expression->constant_value))
            {
                int u = constant_value_to_unsigned_int(&p_expression->constant_value);

                char buffer[50] = { 0 };
                snprintf(buffer, sizeof buffer, "%d", u);

                struct token_list l2 = tokenizer(&tctx, buffer, NULL, 0, TK_FLAG_FINAL);

                token_list_insert_before(&ctx->ast.token_list,
                    p_expression->last_token,
                    &l2);

                del(p_expression->type_name->first_token, p_expression->type_name->last_token);


                token_list_destroy(&l2);
            }
            else
            {
                //error
            }
        }
        break;

    case UNARY_EXPRESSION_SIZEOF_EXPRESSION:
    case UNARY_EXPRESSION_SIZEOF_TYPE:
    case UNARY_EXPRESSION_INCREMENT:
    case UNARY_EXPRESSION_DECREMENT:

    case UNARY_EXPRESSION_NOT:
    case UNARY_EXPRESSION_BITNOT:
    case UNARY_EXPRESSION_NEG:
    case UNARY_EXPRESSION_PLUS:
    case UNARY_EXPRESSION_CONTENT:
    case UNARY_EXPRESSION_ADDRESSOF:
    case UNARY_EXPRESSION_ASSERT:

        if (p_expression->right)
        {
            visit_expression(ctx, p_expression->right);
        }

        if (p_expression->type_name)
        {
            /*sizeof*/
            visit_type_name(ctx, p_expression->type_name);
        }

        break;




    case ASSIGNMENT_EXPRESSION:
    case CAST_EXPRESSION:
    case MULTIPLICATIVE_EXPRESSION_MULT:
    case MULTIPLICATIVE_EXPRESSION_DIV:
    case MULTIPLICATIVE_EXPRESSION_MOD:
    case ADDITIVE_EXPRESSION_PLUS:
    case ADDITIVE_EXPRESSION_MINUS:
    case SHIFT_EXPRESSION_RIGHT:
    case SHIFT_EXPRESSION_LEFT:
    case RELATIONAL_EXPRESSION_BIGGER_THAN:
    case RELATIONAL_EXPRESSION_LESS_THAN:
    case EQUALITY_EXPRESSION_EQUAL:
    case EQUALITY_EXPRESSION_NOT_EQUAL:
    case AND_EXPRESSION:
    case EXCLUSIVE_OR_EXPRESSION:
    case INCLUSIVE_OR_EXPRESSION:

    case RELATIONAL_EXPRESSION_LESS_OR_EQUAL_THAN:
    case RELATIONAL_EXPRESSION_BIGGER_OR_EQUAL_THAN:

    case LOGICAL_AND_EXPRESSION:
    case LOGICAL_OR_EXPRESSION:


        if (p_expression->left)
        {
            visit_expression(ctx, p_expression->left);
        }
        if (p_expression->right)
        {
            visit_expression(ctx, p_expression->right);
        }
        if (p_expression->type_name)
        {
            visit_type_name(ctx, p_expression->type_name);
        }


        break;

    case UNARY_EXPRESSION_TRAITS:
    {
        if (ctx->target < LANGUAGE_CAK)
        {
            struct tokenizer_ctx tctx2 = { 0 };
            struct token_list l2 = { 0 };

            if (constant_value_to_bool(&p_expression->constant_value))
                l2 = tokenizer(&tctx2, "1", NULL, 0, TK_FLAG_FINAL);
            else
                l2 = tokenizer(&tctx2, "0", NULL, 0, TK_FLAG_FINAL);


            token_list_insert_after(&ctx->ast.token_list,
                p_expression->last_token,
                &l2);

            token_range_add_flag(p_expression->first_token,
                p_expression->last_token,
                TK_C_BACKEND_FLAG_HIDE);

            token_list_destroy(&l2);
        }
    }
    break;

    case UNARY_EXPRESSION_IS_SAME:
        break;

    case UNARY_DECLARATOR_ATTRIBUTE_EXPR:
        break;

    case CONDITIONAL_EXPRESSION:
        if (p_expression->condition_expr)
        {
            visit_expression(ctx, p_expression->condition_expr);
        }

        if (p_expression->left)
        {
            visit_expression(ctx, p_expression->left);
        }
        if (p_expression->right)
        {
            visit_expression(ctx, p_expression->right);
        }

        break;

        //default:
          //  break;
    }
}

static void visit_expression_statement(struct visit_ctx* ctx, struct expression_statement* p_expression_statement)
{
    if (p_expression_statement->expression_opt)
        visit_expression(ctx, p_expression_statement->expression_opt);
}

static void visit_block_item_list(struct visit_ctx* ctx, struct block_item_list* p_block_item_list);

static void visit_compound_statement(struct visit_ctx* ctx, struct compound_statement* p_compound_statement)
{
    visit_block_item_list(ctx, &p_compound_statement->block_item_list);
}

//
static void visit_iteration_statement(struct visit_ctx* ctx, struct iteration_statement* p_iteration_statement)
{

    if (p_iteration_statement->expression0)
    {
        visit_expression(ctx, p_iteration_statement->expression0);
    }

    if (p_iteration_statement->expression1)
    {
        visit_expression(ctx, p_iteration_statement->expression1);
    }

    if (p_iteration_statement->expression2)
    {
        visit_expression(ctx, p_iteration_statement->expression2);
    }


    struct defer_scope* _Opt p_defer = visit_ctx_push_tail_block(ctx);
    if (p_defer == NULL)
        return;

    p_defer->p_iteration_statement = p_iteration_statement;

    visit_secondary_block(ctx, p_iteration_statement->secondary_block);

    struct osstream ss = { 0 };
    print_block_defer(p_defer, &ss, true);

    if (ss.c_str == NULL)
    {
        return;
    }

    struct tokenizer_ctx tctx = { 0 };
    struct token_list l = tokenizer(&tctx, ss.c_str, NULL, 0, TK_FLAG_FINAL);
    token_list_insert_after(&ctx->ast.token_list, p_iteration_statement->secondary_block->last_token->prev, &l);


    visit_ctx_pop_tail_block(ctx);

    ss_close(&ss);
    token_list_destroy(&l);

}


static void visit_jump_statement(struct visit_ctx* ctx, struct jump_statement* p_jump_statement)
{

    if (p_jump_statement->first_token->type == TK_KEYWORD_THROW)
    {
        assert(ctx->tail_block != NULL);
        struct osstream ss0 = { 0 };
        print_all_defer_until_try(ctx->tail_block, &ss0);

        if (ss0.size > 0)
        {
            struct osstream ss = { 0 };
            ss_fprintf(&ss, "{ %s ", ss0.c_str);
            ss_fprintf(&ss, "goto _catch_label_%d;", p_jump_statement->try_catch_block_index);
            ss_fprintf(&ss, "}");
            if (ss.c_str == NULL)
            {
                ss_close(&ss0);
                return;
            }

            free(p_jump_statement->first_token->lexeme);
            p_jump_statement->first_token->lexeme = ss.c_str;


            p_jump_statement->last_token->flags |= TK_C_BACKEND_FLAG_HIDE;

        }
        else
        {
            struct osstream ss = { 0 };
            ss_fprintf(&ss, "goto _catch_label_%d", p_jump_statement->try_catch_block_index);
            if (ss.c_str == NULL)
            {
                ss_close(&ss0);
                return;
            }

            free(p_jump_statement->first_token->lexeme);
            p_jump_statement->first_token->lexeme = ss.c_str; /*MOVED*/
        }

        ss_close(&ss0);
    }
    else if (p_jump_statement->first_token->type == TK_KEYWORD_RETURN)
    {
        const bool constant_expression =
            p_jump_statement->expression_opt == NULL ||
            constant_value_is_valid(&p_jump_statement->expression_opt->constant_value);

        if (p_jump_statement->expression_opt)
            visit_expression(ctx, p_jump_statement->expression_opt);

        if (constant_expression)
        {
            assert(ctx->tail_block != NULL);
            struct osstream ss0 = { 0 };
            print_all_defer_until_end(ctx->tail_block, &ss0);

            if (ss0.size > 0)
            {
                struct osstream ss = { 0 };
                ss_fprintf(&ss, "{ %s ", ss0.c_str);
                ss_fprintf(&ss, "return");

                if (ss.c_str == NULL)
                {
                    ss_close(&ss0);
                    return;
                }

                free(p_jump_statement->first_token->lexeme);
                p_jump_statement->first_token->lexeme = ss.c_str;
                ss.c_str = NULL; /*MOVED*/

                char* _Opt _Owner temp = strdup(";}");
                if (temp == NULL)
                {
                    ss_close(&ss0);
                    return;
                }

                free(p_jump_statement->last_token->lexeme);
                p_jump_statement->last_token->lexeme = temp;
                ss_close(&ss);
            }
            ss_close(&ss0);
        }
        else
        {
            assert(ctx->tail_block != NULL);
            //defer must run after return
            struct osstream defer_str = { 0 };
            print_all_defer_until_end(ctx->tail_block, &defer_str);

            if (defer_str.c_str == NULL)
                return;

            struct type t = type_dup(&p_jump_statement->expression_opt->type);
            type_add_const(&t);
            type_remove_names(&t);
            struct osstream return_type_str = { 0 };
            print_type(&return_type_str, &t);

            struct osstream sst = { 0 };
            ss_fprintf(&sst, "{ ");
            ss_fprintf(&sst, " %s _tmp = ", return_type_str.c_str);

            ss_close(&return_type_str);

            if (sst.c_str == NULL)
            {
                type_destroy(&t);
                ss_close(&defer_str);
                return;
            }

            free(p_jump_statement->first_token->lexeme);
            p_jump_statement->first_token->lexeme = sst.c_str;

            sst.c_str = NULL; //moved
            struct osstream ss = { 0 };
            ss_fprintf(&ss, "; %s return _tmp;}", defer_str.c_str);
            if (ss.c_str == NULL)
            {
                ss_close(&defer_str);
                type_destroy(&t);
                return;
            }

            free(p_jump_statement->last_token->lexeme);
            p_jump_statement->last_token->lexeme = ss.c_str;
            ss.c_str = NULL; /*MOVED*/
            ss_close(&ss);
            type_destroy(&t);
            ss_close(&defer_str);
        }
    }
    else if (p_jump_statement->first_token->type == TK_KEYWORD_BREAK ||
        p_jump_statement->first_token->type == TK_KEYWORD_CONTINUE)
    {
        assert(ctx->tail_block != NULL);

        struct osstream ss0 = { 0 };
        print_all_defer_until_iter(ctx->tail_block, &ss0);
        if (ss0.size > 0)
        {
            struct osstream ss = { 0 };
            ss_fprintf(&ss, "{ %s ", ss0.c_str);
            ss_fprintf(&ss, "break;");
            ss_fprintf(&ss, "}");
            if (ss.c_str == NULL)
            {
                ss_close(&ss0);
                return;
            }

            free(p_jump_statement->first_token->lexeme);
            p_jump_statement->first_token->lexeme = ss.c_str;
            ss.c_str = NULL;

            p_jump_statement->last_token->flags |= TK_C_BACKEND_FLAG_HIDE;
            ss_close(&ss);
        }

        ss_close(&ss0);
    }
    else if (p_jump_statement->first_token->type == TK_KEYWORD_GOTO)
    {
        assert(p_jump_statement->label != NULL);
        assert(ctx->tail_block != NULL);

        struct osstream ss0 = { 0 };
        print_all_defer_until_label(ctx->tail_block, p_jump_statement->label->lexeme, &ss0);
        if (ss0.c_str == NULL)
            return;

        struct osstream ss = { 0 };
        ss_fprintf(&ss, "{ %s ", ss0.c_str);
        ss_fprintf(&ss, "goto");
        if (ss.c_str == NULL)
        {
            ss_close(&ss0);
            return;
        }

        free(p_jump_statement->first_token->lexeme);
        p_jump_statement->first_token->lexeme = ss.c_str;
        ss.c_str = NULL; /*MOVED*/

        char* _Owner _Opt temp = strdup(";}");
        if (temp == NULL)
        {
            ss_close(&ss0);
            ss_close(&ss);
            return;
        }

        free(p_jump_statement->last_token->lexeme);
        p_jump_statement->last_token->lexeme = temp;
        ss_close(&ss);
        ss_close(&ss0);
    }
    else
    {
        assert(false);
    }
}


static void visit_labeled_statement(struct visit_ctx* ctx, struct labeled_statement* p_labeled_statement)
{
    visit_statement(ctx, p_labeled_statement->statement);
}

static void visit_primary_block(struct visit_ctx* ctx, struct primary_block* p_primary_block)
{
    if (p_primary_block->defer_statement)
    {
        visit_defer_statement(ctx, p_primary_block->defer_statement);
    }
    else
    {
        if (p_primary_block->compound_statement)
        {
            visit_compound_statement(ctx, p_primary_block->compound_statement);
        }
        else if (p_primary_block->iteration_statement)
        {
            visit_iteration_statement(ctx, p_primary_block->iteration_statement);
        }
        else if (p_primary_block->selection_statement)
        {
            visit_selection_statement(ctx, p_primary_block->selection_statement);
        }
        else if (p_primary_block->try_statement)
        {
            visit_try_statement(ctx, p_primary_block->try_statement);
        }
    }

}

static void visit_unlabeled_statement(struct visit_ctx* ctx, struct unlabeled_statement* p_unlabeled_statement)
{
    if (p_unlabeled_statement->primary_block)
    {
        visit_primary_block(ctx, p_unlabeled_statement->primary_block);
    }
    else if (p_unlabeled_statement->expression_statement)
    {
        visit_expression_statement(ctx, p_unlabeled_statement->expression_statement);
    }
    else if (p_unlabeled_statement->jump_statement)
    {
        visit_jump_statement(ctx, p_unlabeled_statement->jump_statement);
    }
    else
    {
        assert(false);
    }
}



static void visit_statement(struct visit_ctx* ctx, struct statement* p_statement)
{
    if (p_statement->labeled_statement)
    {
        visit_labeled_statement(ctx, p_statement->labeled_statement);
    }
    else if (p_statement->unlabeled_statement)
    {
        visit_unlabeled_statement(ctx, p_statement->unlabeled_statement);
    }
}

static void visit_label(struct visit_ctx* ctx, struct label* p_label)
{
    //p_label->name
}
static void visit_block_item(struct visit_ctx* ctx, struct block_item* p_block_item)
{
    if (p_block_item->declaration)
    {
        visit_declaration(ctx, p_block_item->declaration);
    }
    else if (p_block_item->unlabeled_statement)
    {
        visit_unlabeled_statement(ctx, p_block_item->unlabeled_statement);
    }
    else if (p_block_item->label)
    {
        visit_label(ctx, p_block_item->label);
    }
    if (ctx->insert_before_block_item.head != NULL)
    {
        token_list_insert_after(&ctx->ast.token_list, p_block_item->first_token->prev, &ctx->insert_before_block_item);
    }
}

static void visit_block_item_list(struct visit_ctx* ctx, struct block_item_list* p_block_item_list)
{
    struct block_item* _Opt p_block_item = p_block_item_list->head;
    while (p_block_item)
    {
        visit_block_item(ctx, p_block_item);
        p_block_item = p_block_item->next;
    }
}

static void visit_pragma_declaration(struct visit_ctx* ctx, struct pragma_declaration* p_pragma_declaration)
{
    p_pragma_declaration;
}

static void visit_static_assert_declaration(struct visit_ctx* ctx, struct static_assert_declaration* p_static_assert_declaration)
{
    visit_expression(ctx, p_static_assert_declaration->constant_expression);

    if (ctx->target < LANGUAGE_C11)
    {
        /*let's hide everything first*/
        token_range_add_flag(p_static_assert_declaration->first_token,
            p_static_assert_declaration->last_token,
            TK_C_BACKEND_FLAG_HIDE);
    }
    else if (ctx->target == LANGUAGE_C11)
    {
        if (p_static_assert_declaration->string_literal_opt == NULL)
        {
            struct token* _Opt rp = previous_parser_token(p_static_assert_declaration->last_token);

            if (rp != NULL)
                rp = previous_parser_token(rp);

            struct tokenizer_ctx tctx = { 0 };
            struct token_list list1 = tokenizer(&tctx, ", \"error\"", "", 0, TK_FLAG_FINAL);
            token_list_insert_after(&ctx->ast.token_list, rp, &list1);
            token_list_destroy(&list1);
        }
        if (strcmp(p_static_assert_declaration->first_token->lexeme, "static_assert") == 0)
        {
            char* _Owner _Opt temp = strdup("_Static_assert");
            if (temp == NULL)
                return;

            /*C23 has static_assert but C11 _Static_assert*/
            free(p_static_assert_declaration->first_token->lexeme);
            p_static_assert_declaration->first_token->lexeme = temp;
        }
    }
    else
    {
        char* _Owner _Opt temp = strdup("static_assert");
        if (temp == NULL)
            return;

        free(p_static_assert_declaration->first_token->lexeme);
        p_static_assert_declaration->first_token->lexeme = temp;
    }
}


static void visit_direct_declarator(struct visit_ctx* ctx, struct direct_declarator* p_direct_declarator)
{
    if (p_direct_declarator->function_declarator)
    {
        struct parameter_declaration* _Opt parameter = NULL;

        if (p_direct_declarator->function_declarator->parameter_type_list_opt &&
            p_direct_declarator->function_declarator->parameter_type_list_opt->parameter_list)
        {
            parameter = p_direct_declarator->function_declarator->parameter_type_list_opt->parameter_list->head;
        }

        while (parameter)
        {
            if (parameter->attribute_specifier_sequence_opt)
            {
                visit_attribute_specifier_sequence(ctx, parameter->attribute_specifier_sequence_opt);
            }

            visit_declaration_specifiers(ctx, parameter->declaration_specifiers, &parameter->declarator->type);
            if (parameter->declarator)
            {
                visit_declarator(ctx, parameter->declarator);
            }

            parameter = parameter->next;
        }

    }
    else if (p_direct_declarator->array_declarator)
    {
        if (p_direct_declarator->array_declarator->assignment_expression)
        {
            visit_expression(ctx, p_direct_declarator->array_declarator->assignment_expression);
        }

        if (ctx->target < LANGUAGE_C99)
        {
            /*static and type qualifiers in parameter array declarators where added in C99*/
            if (p_direct_declarator->array_declarator->static_token_opt)
            {
                p_direct_declarator->array_declarator->static_token_opt->flags |= TK_C_BACKEND_FLAG_HIDE;

                if (p_direct_declarator->array_declarator->type_qualifier_list_opt)
                {
                    struct type_qualifier* _Opt p_type_qualifier =
                        p_direct_declarator->array_declarator->type_qualifier_list_opt->head;

                    while (p_type_qualifier)
                    {
                        p_type_qualifier->token->flags |= TK_C_BACKEND_FLAG_HIDE;
                        p_type_qualifier = p_type_qualifier->next;
                    }
                }
            }
        }
    }
}

static void visit_declarator(struct visit_ctx* ctx, struct declarator* p_declarator)
{
    bool need_transformation = false;

    if (p_declarator->pointer)
    {
        struct pointer* _Opt p = p_declarator->pointer;
        while (p)
        {
            if (p->type_qualifier_list_opt)
            {
                struct type_qualifier* _Opt current = p->type_qualifier_list_opt->head;
                while (current)
                {
                    visit_type_qualifier(ctx, current);
                    current = current->next;
                }
            }
            p = p->pointer;
        }
    }

    if (ctx->target < LANGUAGE_C23)
    {
        if (p_declarator->declaration_specifiers)
        {
            if (p_declarator->declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_AUTO)
            {
                need_transformation = true;
            }
            if (p_declarator->declaration_specifiers->type_specifier_flags & TYPE_SPECIFIER_TYPEOF)
            {
                need_transformation = true;
            }
        }

        if (p_declarator->specifier_qualifier_list &&
            p_declarator->specifier_qualifier_list->type_specifier_flags & TYPE_SPECIFIER_TYPEOF)
        {
            need_transformation = true;
        }
    }


    //we may have a diference type from the current syntax 
    if (need_transformation)
    {

        struct osstream ss = { 0 };

        /*types like nullptr are converted to other types like void* */
        struct type new_type = type_convert_to(&p_declarator->type, ctx->target);

        type_remove_names(&new_type);
        if (p_declarator->name_opt)
        {
            free((void* _Owner)new_type.name_opt);
            new_type.name_opt = strdup(p_declarator->name_opt->lexeme);
        }

        print_type_declarator(&ss, &new_type);

        if (ss.c_str != NULL)
        {
            const int level = p_declarator->first_token_opt ? p_declarator->first_token_opt->level : 0;
            struct tokenizer_ctx tctx = { 0 };
            struct token_list l2 = tokenizer(&tctx, ss.c_str, NULL, level, TK_FLAG_FINAL);
            if (l2.head == NULL)
            {
                ss_close(&ss);
                type_destroy(&new_type);
                return;
            }

            /*let's hide the old declarator*/
              /*let's hide the old declarator*/
            if (p_declarator->first_token_opt != NULL &&
                p_declarator->last_token_opt != NULL &&
                p_declarator->first_token_opt != p_declarator->last_token_opt)
            {
                l2.head->flags = p_declarator->first_token_opt->flags;
                token_list_insert_after(&ctx->ast.token_list, p_declarator->last_token_opt, &l2);
                token_range_add_flag(p_declarator->first_token_opt, p_declarator->last_token_opt, TK_C_BACKEND_FLAG_HIDE);
            }
            else
            {

                if (p_declarator->first_token_opt == NULL &&
                    p_declarator->last_token_opt != NULL)
                {
                    l2.head->flags = p_declarator->last_token_opt->flags;
                    /*it is a empty declarator, so first_token is not part of declarator it only marks de position*/
                    token_list_insert_after(&ctx->ast.token_list, p_declarator->last_token_opt->prev, &l2);
                }
                else if (p_declarator->first_token_opt != NULL &&
                         p_declarator->last_token_opt != NULL)
                {
                    l2.head->flags = p_declarator->first_token_opt->flags;
                    /*it is a empty declarator, so first_token is not part of declarator it only marks de position*/
                    token_list_insert_after(&ctx->ast.token_list, p_declarator->last_token_opt, &l2);
                    token_range_add_flag(p_declarator->first_token_opt, p_declarator->last_token_opt, TK_C_BACKEND_FLAG_HIDE);
                }

            }
            token_list_destroy(&l2);
        }

        type_destroy(&new_type);
        ss_close(&ss);
    }


    if (p_declarator->direct_declarator)
    {
        visit_direct_declarator(ctx, p_declarator->direct_declarator);
    }
}

static void visit_init_declarator_list(struct visit_ctx* ctx, struct init_declarator_list* p_init_declarator_list)
{
    struct init_declarator* _Opt p_init_declarator = p_init_declarator_list->head;

    while (p_init_declarator)
    {

        visit_declarator(ctx, p_init_declarator->p_declarator);

        if (p_init_declarator->initializer)
        {
            if (p_init_declarator->initializer->assignment_expression)
            {
                visit_expression(ctx, p_init_declarator->initializer->assignment_expression);
            }
            else
            {
                if (p_init_declarator->initializer->braced_initializer)
                {
                    visit_bracket_initializer_list(ctx,
                        p_init_declarator->initializer->braced_initializer);
                }

            }
        }

        p_init_declarator = p_init_declarator->next;
    }
}



static void visit_member_declarator(struct visit_ctx* ctx, struct member_declarator* p_member_declarator)
{
    if (p_member_declarator->declarator)
    {
        visit_declarator(ctx, p_member_declarator->declarator);
    }
}

static void visit_member_declarator_list(struct visit_ctx* ctx, struct member_declarator_list* p_member_declarator_list)
{
    struct member_declarator* _Opt p_member_declarator = p_member_declarator_list->head;
    while (p_member_declarator)
    {
        visit_member_declarator(ctx, p_member_declarator);
        p_member_declarator = p_member_declarator->next;
    }
}
static void visit_member_declaration(struct visit_ctx* ctx, struct member_declaration* p_member_declaration)
{
    if (p_member_declaration->member_declarator_list_opt)
    {
        visit_specifier_qualifier_list(ctx,
            p_member_declaration->specifier_qualifier_list,
            &p_member_declaration->member_declarator_list_opt->head->declarator->type); /*se nao tem?*/
    }

    if (p_member_declaration->member_declarator_list_opt)
    {
        visit_member_declarator_list(ctx, p_member_declaration->member_declarator_list_opt);
    }
}

static void visit_member_declaration_list(struct visit_ctx* ctx, struct member_declaration_list* p_member_declaration_list)
{
    struct member_declaration* _Opt p_member_declaration = p_member_declaration_list->head;
    while (p_member_declaration)
    {
        visit_member_declaration(ctx, p_member_declaration);
        p_member_declaration = p_member_declaration->next;
    }
}

static void visit_attribute_specifier(struct visit_ctx* ctx, struct attribute_specifier* p_attribute_specifier)
{
    if (ctx->target < LANGUAGE_C23)
    {
        token_range_add_flag(p_attribute_specifier->first_token, p_attribute_specifier->last_token, TK_C_BACKEND_FLAG_HIDE);
    }
}

static void visit_attribute_specifier_sequence(struct visit_ctx* ctx, struct attribute_specifier_sequence* p_visit_attribute_specifier_sequence)
{
    struct attribute_specifier* _Opt current = p_visit_attribute_specifier_sequence->head;
    while (current)
    {
        visit_attribute_specifier(ctx, current);
        current = current->next;
    }
}

static void visit_struct_or_union_specifier(struct visit_ctx* ctx, struct struct_or_union_specifier* p_struct_or_union_specifier)
{

    if (p_struct_or_union_specifier->attribute_specifier_sequence_opt)
        visit_attribute_specifier_sequence(ctx, p_struct_or_union_specifier->attribute_specifier_sequence_opt);

    struct struct_or_union_specifier* _Opt p_complete = get_complete_struct_or_union_specifier(p_struct_or_union_specifier);

    if (p_struct_or_union_specifier->show_anonymous_tag && !ctx->is_second_pass)
    {
        struct token* first = p_struct_or_union_specifier->first_token;

        const char* tag = p_struct_or_union_specifier->tag_name;
        char buffer[sizeof(p_struct_or_union_specifier->tag_name) + 8] = { 0 };
        snprintf(buffer, sizeof buffer, " %s", tag);
        struct tokenizer_ctx tctx = { 0 };
        struct token_list l2 = tokenizer(&tctx, buffer, NULL, 0, TK_FLAG_FINAL);
        token_list_insert_after(&ctx->ast.token_list, first, &l2);
        token_list_destroy(&l2);
    }

    if (p_complete)
    {
        if (ctx->is_inside_lambda && !ctx->is_second_pass)
        {
            /*
              Na primeira passada marcamos os tipos que são renomeados
            */
            if (p_complete->scope_level >
                p_struct_or_union_specifier->scope_level &&
                p_complete->visit_moved == 0)
            {
                char newtag[212] = { 0 };
                snprintf(newtag, sizeof newtag, "_%s%d", p_struct_or_union_specifier->tag_name, ctx->capture_index);
                ctx->capture_index++;

                char* _Opt _Owner temp = strdup(newtag);
                if (temp == NULL)
                    return;

                if (p_complete->tagtoken != NULL)
                {
                    free(p_complete->tagtoken->lexeme);
                    p_complete->tagtoken->lexeme = temp;
                }
                else
                {
                    free(temp);
                    assert(false);
                }
                p_complete->visit_moved = 1;
            }
        }
        else if (ctx->is_second_pass)
        {
            /*
             Na segunda passada vou renomear quem usa este tag exporado
            */
            if (p_complete->visit_moved == 1)
            {
                if (p_struct_or_union_specifier != p_complete &&
                    p_complete->tagtoken != NULL &&
                    p_struct_or_union_specifier->tagtoken != NULL)
                {
                    char* _Opt _Owner temp = strdup(p_complete->tagtoken->lexeme);
                    if (temp == NULL)
                        return;

                    free(p_struct_or_union_specifier->tagtoken->lexeme);
                    p_struct_or_union_specifier->tagtoken->lexeme = temp;
                }
            }
        }
    }



    visit_member_declaration_list(ctx, &p_struct_or_union_specifier->member_declaration_list);

}

static void visit_enumerator(struct visit_ctx* ctx, struct enumerator* p_enumerator)
{
    if (p_enumerator->constant_expression_opt)
        visit_expression(ctx, p_enumerator->constant_expression_opt);

}

//struct enumerator_list* enumerator_list;
static void visit_enumerator_list(struct visit_ctx* ctx, struct enumerator_list* p_enumerator_list)
{
    struct enumerator* _Opt current = p_enumerator_list->head;
    while (current)
    {
        visit_enumerator(ctx, current);
        current = current->next;
    }
}

static void visit_enum_specifier(struct visit_ctx* ctx, struct enum_specifier* p_enum_specifier)
{
    if (ctx->target < LANGUAGE_C23)
    {
        if (p_enum_specifier->specifier_qualifier_list)
        {
            struct token* _Opt tk = p_enum_specifier->specifier_qualifier_list->first_token;
            while (tk)
            {
                if (tk->type == ':')
                    break;
                tk = tk->prev;
            }

            if (tk == NULL)
            {
                //error
                return;
            }

            token_range_add_flag(tk,
                p_enum_specifier->specifier_qualifier_list->last_token,
                TK_C_BACKEND_FLAG_HIDE);
        }

        const struct enum_specifier* _Opt p_complete_enum_specifier =
            get_complete_enum_specifier(p_enum_specifier);

        if (p_complete_enum_specifier != NULL &&
            p_enum_specifier != p_complete_enum_specifier &&
            p_complete_enum_specifier->specifier_qualifier_list)
        {
            p_enum_specifier->first_token->flags |= TK_C_BACKEND_FLAG_HIDE;

            if (p_enum_specifier->tag_token)
                p_enum_specifier->tag_token->flags |= TK_C_BACKEND_FLAG_HIDE;

            struct osstream ss = { 0 };
            bool b_first = true;

            print_type_qualifier_flags(&ss, &b_first, p_complete_enum_specifier->specifier_qualifier_list->type_qualifier_flags);
            print_type_specifier_flags(&ss, &b_first, p_complete_enum_specifier->specifier_qualifier_list->type_specifier_flags);

            if (ss.c_str == NULL)
                return;

            struct tokenizer_ctx tctx = { 0 };
            struct token_list l2 = tokenizer(&tctx, ss.c_str, NULL, 0, TK_FLAG_NONE);

            token_list_insert_after(&ctx->ast.token_list,
                p_enum_specifier->tag_token,
                &l2);

            ss_close(&ss);
            token_list_destroy(&l2);
        }

    }

    if (p_enum_specifier->attribute_specifier_sequence_opt)
    {
        visit_attribute_specifier_sequence(ctx, p_enum_specifier->attribute_specifier_sequence_opt);
    }

    visit_enumerator_list(ctx, &p_enum_specifier->enumerator_list);
}

static void visit_typeof_specifier(struct visit_ctx* ctx, struct typeof_specifier* p_typeof_specifier)
{}

static void visit_type_specifier(struct visit_ctx* ctx, struct type_specifier* p_type_specifier)
{
    try
    {
        if (p_type_specifier->typeof_specifier)
        {
            visit_typeof_specifier(ctx, p_type_specifier->typeof_specifier);
        }

        if (p_type_specifier->struct_or_union_specifier)
        {
            visit_struct_or_union_specifier(ctx, p_type_specifier->struct_or_union_specifier);
        }

        if (p_type_specifier->enum_specifier)
        {
            visit_enum_specifier(ctx, p_type_specifier->enum_specifier);
        }


        if (p_type_specifier->atomic_type_specifier)
        {
            //visit_deped(ctx, p_type_specifier->enum_specifier);
        }

        if (p_type_specifier->flags & TYPE_SPECIFIER_BOOL)
        {
            if (ctx->target < LANGUAGE_C99)
            {
                char* _Owner _Opt temp = strdup("unsigned char");
                if (temp == NULL) throw;

                free(p_type_specifier->token->lexeme);
                p_type_specifier->token->lexeme = temp;
            }
            else
            {
                if (ctx->target < LANGUAGE_C23)
                {
                    if (strcmp(p_type_specifier->token->lexeme, "bool") == 0)
                    {
                        char* _Owner _Opt temp = strdup("_Bool");
                        if (temp == NULL) throw;

                        free(p_type_specifier->token->lexeme);
                        p_type_specifier->token->lexeme = temp;
                    }
                }
                else
                {
                    char* _Owner _Opt temp = strdup("bool");
                    if (temp == NULL) throw;

                    free(p_type_specifier->token->lexeme);
                    p_type_specifier->token->lexeme = temp;
                }
            }
        }
    }
    catch
    {
    }
}

static void visit_type_specifier_qualifier(struct visit_ctx* ctx, struct type_specifier_qualifier* p_type_specifier_qualifier)
{
    if (p_type_specifier_qualifier->type_qualifier)
    {
        visit_type_qualifier(ctx, p_type_specifier_qualifier->type_qualifier);
    }
    else if (p_type_specifier_qualifier->type_specifier)
    {
        visit_type_specifier(ctx, p_type_specifier_qualifier->type_specifier);
    }
    else if (p_type_specifier_qualifier->alignment_specifier)
    {
    }
}

static void visit_storage_class_specifier(struct visit_ctx* ctx, struct storage_class_specifier* p_storage_class_specifier)
{
    if (p_storage_class_specifier->flags & STORAGE_SPECIFIER_AUTO)
    {
        if (ctx->target < LANGUAGE_C23)
        {
            p_storage_class_specifier->token->flags |= TK_C_BACKEND_FLAG_HIDE;
        }
    }
}

static void visit_declaration_specifier(struct visit_ctx* ctx, struct declaration_specifier* p_declaration_specifier)
{
    if (p_declaration_specifier->function_specifier)
    {
        if (p_declaration_specifier->function_specifier->token->type == TK_KEYWORD__NORETURN)
        {
            if (ctx->target < LANGUAGE_C11)
            {
                char* _Opt _Owner temp = strdup("/*[[noreturn]]*/");
                if (temp == NULL)
                    return;

                free(p_declaration_specifier->function_specifier->token->lexeme);
                p_declaration_specifier->function_specifier->token->lexeme = temp;
            }
            else if (ctx->target == LANGUAGE_C11)
            {
                /*nothing*/
            }
            else if (ctx->target > LANGUAGE_C11)
            {
                char* _Opt _Owner temp = strdup("[[noreturn]]");
                if (temp == NULL)
                    return;

                /*use attributes*/
                free(p_declaration_specifier->function_specifier->token->lexeme);
                p_declaration_specifier->function_specifier->token->lexeme = temp;
            }

        }
    }


    if (p_declaration_specifier->storage_class_specifier)
    {
        visit_storage_class_specifier(ctx, p_declaration_specifier->storage_class_specifier);

    }

    if (p_declaration_specifier->type_specifier_qualifier)
    {
        visit_type_specifier_qualifier(ctx, p_declaration_specifier->type_specifier_qualifier);

    }

}

static void visit_declaration_specifiers(struct visit_ctx* ctx,
    struct declaration_specifiers* p_declaration_specifiers,
    struct type* _Opt p_type_opt)
{
    /*
        * Se tiver typeof ou auto vamos apagar todos type specifiers.
        * e trocar por um novo
        * const typeof(int (*)()) a;
           //a = 1;
          auto p = (const typeof(int (*)())) 0;

          TODO esconder os type spefiver e qualifider , esconder auto.
          o resto tipo static deixar.

        */
        //
    if (!ctx->is_second_pass &&
        ctx->target < LANGUAGE_C23 &&
        (p_declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_AUTO ||
            p_declaration_specifiers->type_specifier_flags & TYPE_SPECIFIER_TYPEOF))
    {

        struct declaration_specifier* _Opt p_declaration_specifier = p_declaration_specifiers->head;
        while (p_declaration_specifier)
        {
            if (p_declaration_specifier->function_specifier)
            {
            }
            if (p_declaration_specifier->storage_class_specifier)
            {
            }
            if (p_declaration_specifier->type_specifier_qualifier)
            {
                if (p_declaration_specifier->type_specifier_qualifier->type_qualifier)
                {
                    p_declaration_specifier->type_specifier_qualifier->type_qualifier->token->flags |= TK_C_BACKEND_FLAG_HIDE;
                }
                if (p_declaration_specifier->type_specifier_qualifier->type_specifier)
                {
                    if (p_declaration_specifier->type_specifier_qualifier->type_specifier->typeof_specifier)
                    {
                        token_range_add_flag(p_declaration_specifier->type_specifier_qualifier->type_specifier->typeof_specifier->first_token,
                            p_declaration_specifier->type_specifier_qualifier->type_specifier->typeof_specifier->last_token,
                            TK_C_BACKEND_FLAG_HIDE);
                    }
                    p_declaration_specifier->type_specifier_qualifier->type_specifier->token->flags |= TK_C_BACKEND_FLAG_HIDE;
                }
            }
            p_declaration_specifier = p_declaration_specifier->next;
        }


        /*now we print new specifiers then convert to tokens*/
        struct osstream ss0 = { 0 };
        struct type new_type = { 0 };

        if (p_type_opt)
            new_type = type_convert_to(p_type_opt, ctx->target);

        const struct type* p = type_get_specifer_part(&new_type);
        print_type_qualifier_specifiers(&ss0, p);

        const int level = p_declaration_specifiers->last_token->level;
        struct tokenizer_ctx tctx = { 0 };

        if (ss0.c_str == NULL)
        {
            type_destroy(&new_type);
            return;
        }

        struct token_list l2 = tokenizer(&tctx, ss0.c_str, NULL, level, TK_FLAG_FINAL);

        token_list_insert_after(&ctx->ast.token_list, p_declaration_specifiers->last_token, &l2);


        type_destroy(&new_type);
        ss_close(&ss0);
        token_list_destroy(&l2);
    }

    struct declaration_specifier* _Opt p_declaration_specifier = p_declaration_specifiers->head;

    struct declaration_specifier* _Opt p_constexpr_declaration_specifier = NULL;
    while (p_declaration_specifier)
    {
        if (p_declaration_specifier->storage_class_specifier &&
            p_declaration_specifier->storage_class_specifier->flags & STORAGE_SPECIFIER_CONSTEXPR)
        {
            p_constexpr_declaration_specifier = p_declaration_specifier;
        }

        visit_declaration_specifier(ctx, p_declaration_specifier);
        p_declaration_specifier = p_declaration_specifier->next;
    }


    if (ctx->target < LANGUAGE_C23)
    {
        /*
          fixing constexpr, we add static const if necessary
        */
        if (p_constexpr_declaration_specifier &&
            p_declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_CONSTEXPR)
        {
            struct osstream ss = { 0 };
            const bool is_file_scope =
                p_declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_CONSTEXPR_STATIC;

            const bool has_static =
                p_declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_STATIC;

            const bool has_const =
                p_declaration_specifiers->type_qualifier_flags & TYPE_QUALIFIER_CONST;


            if (is_file_scope && !has_static)
            {
                ss_fprintf(&ss, "static");
                if (!has_const)
                {
                    ss_fprintf(&ss, " const");
                }
            }
            else
            {
                if (!has_const)
                {
                    ss_fprintf(&ss, "const");
                }
                else
                {
                    ss_fprintf(&ss, " ");
                }
            }

            if (ss.c_str == NULL)
                return;

            assert(p_constexpr_declaration_specifier->storage_class_specifier != NULL);

            free(p_constexpr_declaration_specifier->storage_class_specifier->token->lexeme);
            p_constexpr_declaration_specifier->storage_class_specifier->token->lexeme = ss.c_str;
            ss.c_str = NULL; /*MOVED*/

            ss_close(&ss);
        }
    }

}

/*
* retorna true se o ultimo item for um return
*/
static bool is_last_item_return(struct compound_statement* p_compound_statement)
{
    if (/*p_compound_statement &&*/
        p_compound_statement->block_item_list.tail &&
        p_compound_statement->block_item_list.tail->unlabeled_statement &&
        p_compound_statement->block_item_list.tail->unlabeled_statement->jump_statement &&
        p_compound_statement->block_item_list.tail->unlabeled_statement->jump_statement->first_token->type == TK_KEYWORD_RETURN)
    {
        return true;
    }
    return false;
}

void defer_scope_delete_one(struct defer_scope* _Owner p_block)
{

    struct defer_scope* _Owner _Opt child = p_block->lastchild;
    while (child != NULL)
    {
        struct defer_scope* _Owner _Opt prev = child->previous;

        child->previous = NULL;
        defer_scope_delete_one(child);

        child = prev;
    }

    assert(p_block->previous == NULL);
    free(p_block);

}

void defer_scope_delete_all(struct defer_scope* _Owner p)
{
    struct defer_scope* _Owner _Opt p_block = p;
    while (p_block != NULL)
    {
        struct defer_scope* _Owner _Opt prev_block = p_block->previous;
        p_block->previous = NULL;
        defer_scope_delete_one(p_block);
        p_block = prev_block;
    }
}

static void visit_declaration(struct visit_ctx* ctx, struct declaration* p_declaration)
{
    if (p_declaration->static_assert_declaration)
    {
        visit_static_assert_declaration(ctx, p_declaration->static_assert_declaration);
    }

    if (p_declaration->pragma_declaration)
    {
        visit_pragma_declaration(ctx, p_declaration->pragma_declaration);
    }

    if (p_declaration->p_attribute_specifier_sequence_opt)
    {
        visit_attribute_specifier_sequence(ctx, p_declaration->p_attribute_specifier_sequence_opt);
    }

    if (p_declaration->declaration_specifiers)
    {
        if (p_declaration->init_declarator_list.head)
        {
            visit_declaration_specifiers(ctx, p_declaration->declaration_specifiers,
                &p_declaration->init_declarator_list.head->p_declarator->type);
        }
        else
        {
            visit_declaration_specifiers(ctx, p_declaration->declaration_specifiers, NULL);
        }

    }

    if (p_declaration->p_attribute_specifier_sequence_opt)
    {
        if (!ctx->is_second_pass)
        {
            token_range_add_flag(p_declaration->p_attribute_specifier_sequence_opt->first_token,
                p_declaration->p_attribute_specifier_sequence_opt->last_token,
                TK_C_BACKEND_FLAG_HIDE);

        }
    }
    if (ctx->is_second_pass)
    {

        if (p_declaration->declaration_specifiers &&
            p_declaration->declaration_specifiers->type_specifier_flags == TYPE_SPECIFIER_STRUCT_OR_UNION)
        {
            assert(p_declaration->declaration_specifiers->struct_or_union_specifier != NULL);
            if (p_declaration->declaration_specifiers->struct_or_union_specifier->tagtoken == NULL)
            {
                assert(false);
                return;
            }

            if (p_declaration->declaration_specifiers->struct_or_union_specifier->visit_moved == 1)
            {
                struct tokenizer_ctx tctx = { 0 };
                struct token_list list0 = tokenizer(&tctx, "struct ", NULL, 0, TK_FLAG_FINAL);
                token_list_append_list(&ctx->insert_before_declaration, &list0);
                token_list_destroy(&list0);


                struct token_list list = tokenizer(&tctx, p_declaration->declaration_specifiers->struct_or_union_specifier->tagtoken->lexeme, NULL, 0, TK_FLAG_FINAL);
                token_list_append_list(&ctx->insert_before_declaration, &list);
                token_list_destroy(&list);

                //struct token_list list3 = tokenizer("{", NULL, 0, TK_FLAG_FINAL);
                //token_list_append_list(&ctx->insert_before_declaration, &list3);



                struct token* first = p_declaration->declaration_specifiers->struct_or_union_specifier->member_declaration_list.first_token;
                struct token* last = p_declaration->declaration_specifiers->struct_or_union_specifier->member_declaration_list.last_token;
                for (struct token* current = first;
                    current != last->next;
                    current = current->next)
                {
                    token_list_clone_and_add(&ctx->insert_before_declaration, current);
                    //current->flags |= TK_FLAG_FINAL;
                    if (current->next == NULL)
                        break;
                }

                struct token_list list3 = tokenizer(&tctx, ";\n", NULL, 0, TK_FLAG_FINAL);
                token_list_append_list(&ctx->insert_before_declaration, &list3);


                if (p_declaration->init_declarator_list.head == NULL)
                {
                    token_range_add_flag(p_declaration->declaration_specifiers->struct_or_union_specifier->first_token,
                        p_declaration->declaration_specifiers->struct_or_union_specifier->last_token,
                        TK_C_BACKEND_FLAG_HIDE);
                }
                else
                {
                    token_range_add_flag(p_declaration->declaration_specifiers->struct_or_union_specifier->member_declaration_list.first_token,
                        p_declaration->declaration_specifiers->struct_or_union_specifier->member_declaration_list.last_token,
                        TK_C_BACKEND_FLAG_HIDE);
                }
                token_list_destroy(&list3);
            }
        }
    }


    if (p_declaration->init_declarator_list.head)
    {
        visit_init_declarator_list(ctx, &p_declaration->init_declarator_list);
    }

    if (p_declaration->function_body)
    {
        ctx->has_lambda = false;
        ctx->is_second_pass = false;


        struct defer_scope* _Opt p_defer = visit_ctx_push_tail_block(ctx);
        if (p_defer == NULL)
            return;

        p_defer->p_function_body = p_declaration->function_body;

        visit_compound_statement(ctx, p_declaration->function_body);

        if (!is_last_item_return(p_declaration->function_body))
        {
            struct osstream ss = { 0 };
            print_block_defer(p_defer, &ss, true);

            if (ss.size > 0)
            {
                assert(ss.c_str != NULL);
                struct tokenizer_ctx tctx = { 0 };
                struct token_list l = tokenizer(&tctx, ss.c_str, NULL, 0, TK_FLAG_FINAL);
                token_list_insert_after(&ctx->ast.token_list, p_declaration->function_body->last_token->prev, &l);
                token_list_destroy(&l);
            }
            ss_close(&ss);
        }
        else
        {
            //ja tem um return antes que chama defer
            hide_block_defer(p_defer);
        }

        visit_ctx_pop_tail_block(ctx);



        if (ctx->has_lambda)
        {
            /*functions with lambdas requires two phases*/
            ctx->is_second_pass = true;
            visit_compound_statement(ctx, p_declaration->function_body);
        }
    }


    /*
       In direct mode, we hide non used declarations (just to make the result smaller)
    */
    if (ctx->hide_non_used_declarations &&
        p_declaration->init_declarator_list.head)
    {
        if (p_declaration->init_declarator_list.head->p_declarator->num_uses == 0 &&
            p_declaration->init_declarator_list.head->p_declarator->function_body == NULL)
        {
            /*
              transformations must keep first_token and last_token correct - updated
            */
            token_range_add_flag(p_declaration->first_token, p_declaration->last_token, TK_C_BACKEND_FLAG_HIDE);
        }
    }
}

int visit_literal_string(struct visit_ctx* ctx, struct token* current)
{
    try
    {
        bool has_u8_prefix =
            current->lexeme[0] == 'u' && current->lexeme[1] == '8';

        if (has_u8_prefix && ctx->target < LANGUAGE_C11)
        {
            struct osstream ss = { 0 };
            unsigned char* psz = (unsigned char*)(current->lexeme + 2);

            while (*psz)
            {
                if (*psz >= 128)
                {
                    ss_fprintf(&ss, "\\x%x", *psz);
                }
                else
                {
                    ss_fprintf(&ss, "%c", *psz);
                }
                psz++;
            }

            if (ss.c_str == NULL)
            {
                throw;
            }

            free(current->lexeme);
            current->lexeme = ss.c_str;
            ss.c_str = NULL;
            ss_close(&ss);
        }
    }
    catch
    {
    }

    return 0;
}

int visit_tokens(struct visit_ctx* ctx)
{
    try
    {
        struct token* _Opt current = ctx->ast.token_list.head;
        while (current)
        {

            if (current->type == TK_STRING_LITERAL)
            {
                //C99 u8 prefix
                visit_literal_string(ctx, current);

                current = current->next;
                continue;
            }

            if (ctx->target < LANGUAGE_C99 && current->type == TK_LINE_COMMENT)
            {
                struct osstream ss = { 0 };
                //TODO  check /* inside
                ss_fprintf(&ss, "/*%s*/", current->lexeme + 2);
                if (ss.c_str == NULL)
                {
                    throw;
                }

                free(current->lexeme);
                current->lexeme = ss.c_str;

                current = current->next;
                continue;
            }

            if (current->type == TK_CHAR_CONSTANT)
            {
                if (ctx->target < LANGUAGE_C23 && current->lexeme[0] == 'u' && current->lexeme[1] == '8')
                {
                    char buffer[25] = { 0 };
                    snprintf(buffer, sizeof buffer, "((unsigned char)%s)", current->lexeme + 2);
                    char* _Owner _Opt newlexeme = strdup(buffer);
                    if (newlexeme)
                    {
                        free(current->lexeme);
                        current->lexeme = newlexeme;
                    }
                    current = current->next;
                    continue;
                }

                if (ctx->target < LANGUAGE_C11 && current->lexeme[0] == 'u' && current->lexeme[1] == '\'')
                {
                    const unsigned char* _Opt s = (const unsigned char*)(current->lexeme + 2);
                    unsigned int c;
                    s = utf8_decode(s, &c);

                    char buffer[25] = { 0 };
                    snprintf(buffer, sizeof buffer, "((unsigned short)%d)", c);
                    char* _Opt _Owner newlexeme = strdup(buffer);
                    if (newlexeme)
                    {
                        free(current->lexeme);
                        current->lexeme = newlexeme;
                    }
                    current = current->next;
                    continue;
                }

                if (ctx->target < LANGUAGE_C11 && current->lexeme[0] == 'U' && current->lexeme[1] == '\'')
                {
                    const unsigned char* _Opt s = (const unsigned char*)current->lexeme + 2;
                    unsigned int c;
                    s = utf8_decode(s, &c);

                    char buffer[25] = { 0 };
                    snprintf(buffer, sizeof buffer, "%du", c);
                    char* _Owner _Opt newlexeme = strdup(buffer);
                    if (newlexeme)
                    {
                        free(current->lexeme);
                        current->lexeme = newlexeme;
                    }
                    current = current->next;
                    continue;
                }

            }

            if (current->type == TK_COMPILER_DECIMAL_CONSTANT ||
                current->type == TK_COMPILER_OCTAL_CONSTANT ||
                current->type == TK_COMPILER_HEXADECIMAL_CONSTANT ||
                current->type == TK_COMPILER_DECIMAL_FLOATING_CONSTANT ||
                current->type == TK_PPNUMBER ||
                current->type == TK_COMPILER_HEXADECIMAL_FLOATING_CONSTANT)
            {
                if (ctx->target < LANGUAGE_C23)
                {
                    /*remove C23 digit separators*/
                    remove_char(current->lexeme, '\'');
                }

                if (ctx->target < LANGUAGE_C99 && current->type == TK_COMPILER_HEXADECIMAL_FLOATING_CONSTANT)
                {
                    /*
                     * C99 Hexadecimal floating constants to C89.
                     */
                    long double d = strtold(current->lexeme, NULL);
                    char buffer[50] = { 0 };
                    snprintf(buffer, sizeof buffer, "%Lg", d);

                    char* _Owner _Opt temp = strdup(buffer);
                    if (temp == NULL)
                        throw;

                    free(current->lexeme);
                    current->lexeme = temp;
                }

                if (ctx->target < LANGUAGE_C2Y && current->type == TK_COMPILER_OCTAL_CONSTANT)
                {
                    if (current->lexeme[1] == 'o' || current->lexeme[1] == 'O')
                    {
                        //We remove the prefix O o
                        //C2Y
                        //https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3319.htm

                        char buffer[50] = { 0 };
                        snprintf(buffer, sizeof buffer, "0%s", current->lexeme + 2);

                        char* _Owner _Opt temp = strdup(buffer);
                        if (temp == NULL)
                            throw;

                        free(current->lexeme);
                        current->lexeme = temp;
                    }
                }

                current = current->next;
                continue;
            }


            if ((current->type == TK_COMPILER_BINARY_CONSTANT) ||
                      (current->type == TK_PPNUMBER && current->lexeme[0] == '0' &&
                          (current->lexeme[1] == 'b' || current->lexeme[1] == 'B')) /*dentro macros*/
                      )
            {
                if (ctx->target < LANGUAGE_C23)
                {
                    /*remove C23 digit separators*/
                    remove_char(current->lexeme, '\'');
                }

                if (ctx->target < LANGUAGE_C23)
                {
                    /*
                    * Convert C23 binary literals to C99 hex
                    */
                    current->type = TK_COMPILER_HEXADECIMAL_CONSTANT;
                    int value = strtol(current->lexeme + 2, NULL, 2);
                    char buffer[33 + 2] = { '0', 'x' };
                    snprintf(buffer, sizeof buffer, "0x%x", value);

                    char* _Opt _Owner p_temp = strdup(buffer);
                    if (p_temp == NULL)
                    {
                        throw;
                    }

                    free(current->lexeme);
                    current->lexeme = p_temp;
                }

                current = current->next;
                continue;
            }


            if (current->type == TK_PREPROCESSOR_LINE)
            {
                struct token* first_preprocessor_token = current;
                struct token* _Opt last_preprocessor_token = current;

                while (last_preprocessor_token)
                {
                    if (last_preprocessor_token->next == NULL ||
                        last_preprocessor_token->next->type == TK_NEWLINE ||
                        last_preprocessor_token->next->type == TK_PRAGMA_END)
                    {
                        break;
                    }
                    last_preprocessor_token = last_preprocessor_token->next;
                }

                current = current->next;

                while (current && current->type == TK_BLANKS)
                {
                    current = current->next;
                }

                if (current == NULL) break;

                if (strcmp(current->lexeme, "pragma") == 0)
                {
                    current = current->next;

                    /*skip blanks*/
                    while (current && current->type == TK_BLANKS)
                    {
                        current = current->next;
                    }

                    if (current == NULL) break;

                    if (strcmp(current->lexeme, "safety") == 0 ||
                        strcmp(current->lexeme, "nullable") == 0 ||
                        strcmp(current->lexeme, "expand") == 0 ||
                        strcmp(current->lexeme, "flow") == 0)
                    {
                        del(first_preprocessor_token, last_preprocessor_token);

                        current = current->next;
                        continue;
                    }
                }

                if (ctx->target < LANGUAGE_C23 &&
                    strcmp(current->lexeme, "warning") == 0)
                {
                    /*
                      change C23 #warning to comment
                    */
                    free(first_preprocessor_token->lexeme);
                    char* _Opt _Owner temp = strdup("//#");
                    if (temp == NULL)
                    {
                        throw;
                    }

                    first_preprocessor_token->lexeme = temp;

                    current = current->next;
                    continue;
                }

                if (ctx->target < LANGUAGE_C23 &&
                    strcmp(current->lexeme, "elifdef") == 0)
                {
                    /*
                      change C23 #elifdef to #elif defined e #elifndef to C11
                    */
                    free(current->lexeme);
                    char* _Opt _Owner temp = strdup("elif defined ");
                    if (temp == NULL)
                    {
                        throw;
                    }

                    current->lexeme = temp;
                    current = current->next;
                    continue;
                }

                if (ctx->target < LANGUAGE_C23 &&
                    strcmp(current->lexeme, "elifndef") == 0)
                {
                    /*
                     change C23 #elifndef to #elif !defined
                    */

                    free(current->lexeme);
                    char* _Owner _Opt temp = strdup("elif ! defined ");
                    if (temp == NULL)
                    {
                        throw;
                    }

                    current->lexeme = temp;

                    current = current->next;
                    continue;
                }
            }

            current = current->next;
        }
    }
    catch
    {
    }

    return 0;
}

void visit(struct visit_ctx* ctx)
{
    ctx->capture_index = 0;
    ctx->lambdas_index = 0;

    if (visit_tokens(ctx) != 0)
        return;

    struct declaration* _Opt p_declaration = ctx->ast.declaration_list.head;
    while (p_declaration)
    {
        visit_declaration(ctx, p_declaration);

        if (ctx->insert_before_block_item.head != NULL)
        {
            if (p_declaration->first_token->prev)
            {
                token_list_insert_after(&ctx->ast.token_list, p_declaration->first_token->prev, &ctx->insert_before_block_item);
            }
        }

        /*
        * Tem que inserir algo antes desta declaracao?
        */
        if (ctx->insert_before_declaration.head != NULL)
        {
            if (p_declaration->first_token->prev)
            {
                token_list_insert_after(&ctx->ast.token_list, p_declaration->first_token->prev, &ctx->insert_before_declaration);
            }

        }

        p_declaration = p_declaration->next;
    }
    //if (ctx->instanciations.head != NULL)
    //{
    //    token_list_append_list(&ctx->ast.token_list, &ctx->instanciations);
    //}
}



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/

#pragma safety enable



/*
              NULL
                |
            [function] (NULL <- child0 <- last_child)
                |
              [try]  (NULL <- child0 <- last_child)
                |
tail_block-> [while] (NULL <- child0 <- last_child)

*/

struct flow_defer_scope
{

    //things must called at end of scope
    struct declarator* _Opt declarator; // declarator
    struct defer_statement* _Opt defer_statement; // defer

    //statements for controlling where jump like break, throw stop.

    struct try_statement* _Opt p_try_statement; //try
    struct selection_statement* _Opt p_selection_statement; //if switch
    struct iteration_statement* _Opt p_iteration_statement; //for do while
    struct statement* _Opt p_statement;//
    struct compound_statement* _Opt p_compound_statement;
    struct compound_statement* _Opt p_function_body;
    struct secondary_block* _Opt p_secondary_block;
    struct primary_block* _Opt p_primary_block;

    struct flow_defer_scope* _Owner _Opt last_child; /**/
    struct flow_defer_scope* _Owner _Opt previous;
};

void flow_visit_declaration(struct flow_visit_ctx* ctx, struct declaration* p_declaration);
static void flow_visit_attribute_specifier_sequence(struct flow_visit_ctx* ctx, struct attribute_specifier_sequence* p_visit_attribute_specifier_sequence);

static void flow_visit_secondary_block(struct flow_visit_ctx* ctx, struct secondary_block* p_secondary_block);
static void flow_visit_struct_or_union_specifier(struct flow_visit_ctx* ctx, struct struct_or_union_specifier* p_struct_or_union_specifier);
struct true_false_set;
static void flow_visit_expression(struct flow_visit_ctx* ctx, struct expression* p_expression, struct true_false_set* a);
static void flow_visit_statement(struct flow_visit_ctx* ctx, struct statement* p_statement);
static void flow_visit_enum_specifier(struct flow_visit_ctx* ctx, struct enum_specifier* p_enum_specifier);
static void flow_visit_type_specifier(struct flow_visit_ctx* ctx, struct type_specifier* p_type_specifier);
static void flow_visit_bracket_initializer_list(struct flow_visit_ctx* ctx, struct braced_initializer* p_bracket_initializer_list);
static void flow_visit_expression_statement(struct flow_visit_ctx* ctx, struct expression_statement* p_expression_statement);

enum boolean_flag
{
    BOOLEAN_FLAG_NONE = 0,
    BOOLEAN_FLAG_TRUE = 1 << 0,
    BOOLEAN_FLAG_FALSE = 1 << 1,
};

struct true_false_set_item
{
    struct expression* p_expression;
    enum boolean_flag true_branch_state;
    enum boolean_flag false_branch_state;
};


struct true_false_set
{
    //see also
    //  true_false_set_set_objects_to_false_branch
    //  true_false_set_set_objects_to_true_branch
    // 
    //The number of variables determines the possible number of combinations.
    //10 variables requires 2^10 = 1024 evaluations.
    struct true_false_set_item* _Owner _Opt data;
    int size;
    int capacity;
};

void true_false_set_clear(struct true_false_set* p)
{
    free(p->data);
    p->data = NULL;
    p->size = 0;
    p->capacity = 0;
}

enum merge_options
{
    MERGE_OPTIONS_A_TRUE = 1 << 0,
    MERGE_OPTIONS_A_FALSE = 1 << 1,
    MERGE_OPTIONS_B_TRUE = 1 << 2,
    MERGE_OPTIONS_B_FALSE = 1 << 3
};

void true_false_set_destroy(struct true_false_set* _Obj_owner p)
{
    free(p->data);
}

int true_false_set_reserve(struct true_false_set* p, int n)
{
    if (n > p->capacity)
    {
        if ((size_t)n > (SIZE_MAX / (sizeof(p->data[0]))))
        {
            return EOVERFLOW;
        }

        void* _Owner _Opt pnew = realloc(p->data, n * sizeof(p->data[0]));
        if (pnew == NULL)
            return ENOMEM;
        static_set(p->data, "moved");
        p->data = pnew;
        p->capacity = n;
    }
    return 0;
}

int true_false_set_push_back(struct true_false_set* p, const struct true_false_set_item* book)
{
    if (p->size == INT_MAX)
    {
        return EOVERFLOW;
    }

    if (p->size + 1 > p->capacity)
    {
        int new_capacity = 0;
        if (p->capacity > (INT_MAX - p->capacity / 2))
        {
            /*overflow*/
            new_capacity = INT_MAX;
        }
        else
        {
            new_capacity = p->capacity + p->capacity / 2;
            if (new_capacity < p->size + 1)
            {
                new_capacity = p->size + 1;
            }
        }

        int error = true_false_set_reserve(p, new_capacity);
        if (error != 0)
        {
            return error;
        }
    }

    p->data[p->size] = *book; /*COPIED*/


    p->size++;

    return 0;
}

static void true_false_set_invert(struct true_false_set* true_false_set)
{
    for (int i = 0; i < true_false_set->size; i++)
    {
        enum boolean_flag temp = true_false_set->data[i].true_branch_state;
        true_false_set->data[i].true_branch_state = true_false_set->data[i].false_branch_state;
        true_false_set->data[i].false_branch_state = temp;
    }
}

static void true_false_set_swap(struct true_false_set* a, struct true_false_set* b)
{
    struct true_false_set temp = *a;
    *a = *b;
    *b = temp;
}

static int find_item_index_by_expression(const struct true_false_set* a, const struct expression* p_expression)
{
    for (int i = 0; i < a->size; i++)
    {
        if (a->data[i].p_expression == p_expression)
            return i;
    }
    return -1;
}


//1
// 
//true true, false false
//true true, false false
void true_false_set_merge(struct true_false_set* result,
    struct true_false_set* a,
    struct true_false_set* b,
    enum merge_options options_true,
    enum merge_options options_false)
{

    for (int i = 0; i < a->size; i++)
    {
        const struct true_false_set_item* p_item_a = &a->data[i];

        struct true_false_set_item new_item =
        {
         .p_expression = p_item_a->p_expression
        };

        if (options_true & MERGE_OPTIONS_A_TRUE)
            new_item.true_branch_state |= p_item_a->true_branch_state;

        if (options_true & MERGE_OPTIONS_A_FALSE)
            new_item.true_branch_state |= p_item_a->false_branch_state;

        if (options_false & MERGE_OPTIONS_A_TRUE)
            new_item.false_branch_state |= p_item_a->true_branch_state;

        if (options_false & MERGE_OPTIONS_A_FALSE)
            new_item.true_branch_state |= p_item_a->false_branch_state;


        true_false_set_push_back(result, &new_item);
    }

    for (int k = 0; k < b->size; k++)
    {
        const struct true_false_set_item* p_item_b = &b->data[k];

        int index = find_item_index_by_expression(result, p_item_b->p_expression);
        if (index == -1)
        {
            index = result->size;
            struct true_false_set_item item2 = { 0 };
            item2.p_expression = p_item_b->p_expression;
            true_false_set_push_back(result, &item2);
        }

        struct true_false_set_item* p_item_result = &result->data[index];

        if (options_true & MERGE_OPTIONS_B_TRUE)
            p_item_result->true_branch_state |= p_item_b->true_branch_state;

        if (options_true & MERGE_OPTIONS_B_FALSE)
            p_item_result->true_branch_state |= p_item_b->false_branch_state;

        if (options_false & MERGE_OPTIONS_B_TRUE)
            p_item_result->false_branch_state |= p_item_b->true_branch_state;

        if (options_false & MERGE_OPTIONS_B_FALSE)
            p_item_result->true_branch_state |= p_item_b->false_branch_state;
    }
}

static void true_false_set_set_objects_to_core_branch(struct flow_visit_ctx* ctx,
    struct true_false_set* a,
    bool nullable_enabled,
    bool true_branch)
{
    for (int i = 0; i < a->size; i++)
    {
        if (a->data[i].p_expression != NULL)
        {

            struct flow_object* _Opt p_object =
                expression_get_object(ctx, a->data[i].p_expression, nullable_enabled);

            if (p_object)
            {
                if (p_object->current.state == OBJECT_STATE_NOT_NULL ||
                    p_object->current.state == OBJECT_STATE_NULL ||
                    p_object->current.state == OBJECT_STATE_MOVED ||
                    p_object->current.state == OBJECT_STATE_ZERO ||
                    p_object->current.state == OBJECT_STATE_NOT_ZERO ||
                    p_object->current.state == OBJECT_STATE_LIFE_TIME_ENDED)
                {
                    continue;
                }

                const enum boolean_flag flag =
                    true_branch ?
                    a->data[i].true_branch_state :
                    a->data[i].false_branch_state;



                if ((flag & BOOLEAN_FLAG_TRUE) && (flag & BOOLEAN_FLAG_FALSE))
                {
                }
                else if (flag & BOOLEAN_FLAG_FALSE)
                {
                    p_object->current.state &= ~OBJECT_STATE_NOT_NULL;
                    p_object->current.state &= ~OBJECT_STATE_MOVED;
                }
                else if (flag & BOOLEAN_FLAG_TRUE)
                {
                    p_object->current.state &= ~OBJECT_STATE_NULL;
                    p_object->current.state &= ~OBJECT_STATE_ZERO;

                }


            }
        }
    }
}

static void true_false_set_set_objects_to_true_branch(struct flow_visit_ctx* ctx, struct true_false_set* a, bool nullable_enabled)
{
    true_false_set_set_objects_to_core_branch(ctx, a, nullable_enabled, true);
}

static void true_false_set_set_objects_to_false_branch(struct flow_visit_ctx* ctx, struct true_false_set* a, bool nullable_enabled)
{
    true_false_set_set_objects_to_core_branch(ctx, a, nullable_enabled, false);
}

static int arena_add_copy_of_current_state(struct flow_visit_ctx* ctx, const char* name);


static void arena_remove_state(struct flow_visit_ctx* ctx, int state_number);

struct visit_objects {
    struct flow_defer_scope* current_block;
    struct flow_defer_scope* next_child;
};


static struct flow_defer_scope* _Opt flow_visit_ctx_push_tail_block(struct flow_visit_ctx* ctx)
{
    struct flow_defer_scope* _Owner _Opt p_block = calloc(1, sizeof * p_block);
    if (p_block)
    {
        p_block->previous = ctx->tail_block;
        ctx->tail_block = p_block;
    }
    else
    {
        //ops
    }
    return ctx->tail_block;
}

static struct flow_defer_scope* _Opt flow_visit_ctx_push_child(struct flow_visit_ctx* ctx)
{
    if (ctx->tail_block == NULL)
        return NULL;

    struct flow_defer_scope* _Owner _Opt child = calloc(1, sizeof * child);
    if (child)
    {
        child->previous = ctx->tail_block->last_child;
        ctx->tail_block->last_child = child;
    }
    else
    {
        //ops
    }
    return ctx->tail_block->last_child;
}

static void flow_defer_scope_delete_one(struct flow_defer_scope* _Owner p)
{
    struct flow_defer_scope* _Owner p_block = p;
    struct flow_defer_scope* _Owner _Opt child = p_block->last_child;

    while (child != NULL)
    {
        struct flow_defer_scope* _Owner _Opt previous = child->previous;
        child->previous = NULL;
        flow_defer_scope_delete_one(child);
        child = previous;
    }
    assert(p_block->previous == NULL);
    free(p_block);
}


static void flow_visit_ctx_pop_tail_block(struct flow_visit_ctx* ctx)
{
    if (ctx->tail_block)
    {
        struct flow_defer_scope* _Owner _Opt previous = ctx->tail_block->previous;
        ctx->tail_block->previous = NULL;
        flow_defer_scope_delete_one(ctx->tail_block);
        ctx->tail_block = previous;
    }
}

static void flow_exit_block_visit(struct flow_visit_ctx* ctx,
    struct flow_defer_scope* deferblock,
    struct token* position_token)
{
    struct flow_defer_scope* _Opt deferchild = deferblock->last_child;
    while (deferchild != NULL)
    {
        if (deferchild->defer_statement)
        {
            const int error_count = ctx->ctx->p_report->error_count;
            const int warnings_count = ctx->ctx->p_report->warnings_count;
            const int info_count = ctx->ctx->p_report->info_count;

            flow_visit_secondary_block(ctx, deferchild->defer_statement->secondary_block);

            if (error_count != ctx->ctx->p_report->error_count ||
                warnings_count != ctx->ctx->p_report->warnings_count ||
                info_count != ctx->ctx->p_report->info_count)
            {
                compiler_diagnostic_message(W_LOCATION, ctx->ctx, position_token, NULL, "defer end of scope");
            }
        }
        else if (deferchild->declarator)
        {
            struct declarator* p_declarator = deferchild->declarator;
            const char* name = p_declarator->name_opt ? p_declarator->name_opt->lexeme : "?";

            if (p_declarator->p_object)
            {
                flow_end_of_block_visit(ctx,
                    &p_declarator->type,
                    type_is_view(&p_declarator->type),
                    p_declarator->p_object,
                    position_token,
                    name);
            }
            else
            {
                assert(0);
            }
        }
        deferchild = deferchild->previous;
    }
}

static void flow_end_of_storage_visit(struct flow_visit_ctx* ctx,
    struct flow_defer_scope* deferblock,
    struct token* position_token)
{

    struct flow_defer_scope* _Opt deferchild = deferblock->last_child;
    while (deferchild != NULL)
    {
        if (deferchild->defer_statement)
        {
        }
        else if (deferchild->declarator)
        {
            struct declarator* p_declarator = deferchild->declarator;

            if (p_declarator->p_object)
            {
                object_set_end_of_lifetime(&p_declarator->type, p_declarator->p_object);
            }
            else
            {
                assert(0);
            }
        }
        deferchild = deferchild->previous;
    }
}

static bool flow_find_label_unlabeled_statement(struct flow_visit_ctx* ctx, struct unlabeled_statement* p_unlabeled_statement, const char* label);

static void check_all_defer_until_try(struct flow_visit_ctx* ctx, struct flow_defer_scope* deferblock,
    struct token* position_token)
{
    struct flow_defer_scope* _Opt p_defer = deferblock;
    while (p_defer != NULL)
    {
        flow_exit_block_visit(ctx, p_defer, position_token);

        if (p_defer->p_try_statement)
        {
            break;
        }

        p_defer = p_defer->previous;
    }
}

static bool flow_find_label_block_item_list(struct flow_visit_ctx* ctx, struct block_item_list* p_block_item, const char* label)
{
    struct block_item* _Opt block_item = p_block_item->head;
    while (block_item)
    {
        if (block_item->label &&
            block_item->label->p_identifier_opt &&
            strcmp(block_item->label->p_identifier_opt->lexeme, label) == 0)
        {
            return true;
        }
        else if (block_item->unlabeled_statement)
        {
            if (flow_find_label_unlabeled_statement(ctx, block_item->unlabeled_statement, label))
            {
                return true;
            }
        }

        block_item = block_item->next;
    }

    return false;
}

static bool flow_find_label_statement(struct flow_visit_ctx* ctx, struct statement* statement, const char* label);
static bool flow_find_label_unlabeled_statement(struct flow_visit_ctx* ctx, struct unlabeled_statement* p_unlabeled_statement, const char* label)
{
    if (p_unlabeled_statement->primary_block)
    {
        if (p_unlabeled_statement->primary_block->compound_statement)
        {
            if (flow_find_label_block_item_list(ctx,
                &p_unlabeled_statement->primary_block->compound_statement->block_item_list,
                label))
            {
                return true;
            }
        }
        else if (p_unlabeled_statement->primary_block->selection_statement)
        {
            if (flow_find_label_statement(ctx, p_unlabeled_statement->primary_block->selection_statement->secondary_block->statement, label))
            {
                return true;
            }
            if (p_unlabeled_statement->primary_block->selection_statement->else_secondary_block_opt)
            {
                if (flow_find_label_statement(ctx, p_unlabeled_statement->primary_block->selection_statement->else_secondary_block_opt->statement, label))
                {
                    return true;
                }
            }
        }
        else if (p_unlabeled_statement->primary_block->try_statement)
        {
            if (flow_find_label_statement(ctx, p_unlabeled_statement->primary_block->try_statement->secondary_block->statement, label))
            {
                return true;
            }
            if (p_unlabeled_statement->primary_block->try_statement->catch_secondary_block_opt)
            {
                if (flow_find_label_statement(ctx, p_unlabeled_statement->primary_block->try_statement->catch_secondary_block_opt->statement, label))
                {
                    return true;
                }
            }
        }
        else if (p_unlabeled_statement->primary_block->iteration_statement)
        {
            if (flow_find_label_statement(ctx, p_unlabeled_statement->primary_block->iteration_statement->secondary_block->statement, label))
            {
                return true;
            }
        }
    }
    return false;
}

static bool flow_find_label_statement(struct flow_visit_ctx* ctx, struct statement* statement, const char* label)
{
    if (statement->labeled_statement &&
        statement->labeled_statement->label->p_identifier_opt)
    {
        if (/*statement->labeled_statement->label &&*/
            strcmp(statement->labeled_statement->label->p_identifier_opt->lexeme, label) == 0)
        {
            return true;
        }
    }
    else if (statement->unlabeled_statement)
    {
        if (flow_find_label_unlabeled_statement(ctx, statement->unlabeled_statement, label))
            return true;
    }
    return false;
}

static bool flow_find_label_scope(struct flow_visit_ctx* ctx, struct flow_defer_scope* deferblock, const char* label)
{
    if (deferblock->p_iteration_statement)
    {
        if (flow_find_label_statement(ctx, deferblock->p_iteration_statement->secondary_block->statement, label))
            return true;
    }
    else if (deferblock->p_selection_statement)
    {
        if (flow_find_label_statement(ctx, deferblock->p_selection_statement->secondary_block->statement, label))
            return true;

        if (deferblock->p_selection_statement->else_secondary_block_opt)
        {
            if (flow_find_label_statement(ctx, deferblock->p_selection_statement->else_secondary_block_opt->statement, label))
                return true;
        }
    }
    else if (deferblock->p_try_statement)
    {
        if (flow_find_label_statement(ctx, deferblock->p_try_statement->secondary_block->statement, label))
            return true;

        if (deferblock->p_try_statement->catch_secondary_block_opt)
        {
            if (flow_find_label_statement(ctx, deferblock->p_try_statement->catch_secondary_block_opt->statement, label))
                return true;
        }
    }
    else if (deferblock->p_statement)
    {
        if (flow_find_label_statement(ctx, deferblock->p_statement, label))
            return true;
    }
    else if (deferblock->p_function_body)
    {
        if (flow_find_label_block_item_list(ctx,
            &deferblock->p_function_body->block_item_list,
            label))
        {
            return true;
        }
    }
    else if (deferblock->p_compound_statement)
    {
        if (flow_find_label_block_item_list(ctx,
            &deferblock->p_compound_statement->block_item_list,
            label))
        {
            return true;
        }
    }
    return false;
}

static void check_all_defer_until_label(struct flow_visit_ctx* ctx, struct flow_defer_scope* deferblock, const char* label,
    struct token* position_token)
{
    /*
    * We need to know how many scopes we exited until we found the label.
    * To do this, we look in the current scope for where the goto appears.
    * If the label is not directly in this scope or within some internal scope
    * No, we print the defers because we are exiting the scope and going to the scope
    * above. So we repeat this at each scope exit, printing the defer.
    */
    struct flow_defer_scope* _Opt p_defer = deferblock;

    while (p_defer != NULL)
    {
        if (!flow_find_label_scope(ctx, p_defer, label))
        {
            flow_exit_block_visit(ctx, p_defer, position_token);
        }
        else
        {
            break;
        }
        p_defer = p_defer->previous;
    }
}

static void check_all_defer_until_iter(struct flow_visit_ctx* ctx,
    struct flow_defer_scope* deferblock,
    struct token* position_token)
{
    struct flow_defer_scope* _Opt p_defer = deferblock;
    while (p_defer != NULL)
    {
        flow_exit_block_visit(ctx, p_defer, position_token);
        if (p_defer->p_iteration_statement)
        {
            break;
        }
        p_defer = p_defer->previous;
    }
}

static void flow_exit_iteration_or_switch_statement_visit(struct flow_visit_ctx* ctx,
    struct flow_defer_scope* deferblock,
    struct token* position_token)
{
    struct flow_defer_scope* _Opt p_defer = deferblock;
    while (p_defer != NULL)
    {
        flow_exit_block_visit(ctx, p_defer, position_token);

        if (p_defer->p_iteration_statement || p_defer->p_selection_statement)
        {
            //break can be used in loops or switch
            break;
        }
        p_defer = p_defer->previous;
    }
}

static void flow_exit_function_visit(struct flow_visit_ctx* ctx, struct flow_defer_scope* deferblock, struct token* position_token)
{
    struct flow_defer_scope* _Opt p_defer = deferblock;
    while (p_defer != NULL)
    {
        flow_exit_block_visit(ctx, p_defer, position_token);
        p_defer = p_defer->previous;
    }
}


static void flow_visit_secondary_block(struct flow_visit_ctx* ctx, struct secondary_block* p_secondary_block)
{

    flow_visit_statement(ctx, p_secondary_block->statement);

}

static void flow_visit_defer_statement(struct flow_visit_ctx* ctx, struct defer_statement* p_defer_statement)
{
    struct flow_defer_scope* _Opt p_defer = flow_visit_ctx_push_child(ctx);
    if (p_defer)
    {
        p_defer->defer_statement = p_defer_statement;
    }
    /*
      We are not going to visit the secondary block here because
      this is not the place were defer is executed.
    */
}

NODISCARD
static int arena_add_copy_of_current_state(struct flow_visit_ctx* ctx, const char* name)
{
    int state_number = ctx->state_number_generator;
    ctx->state_number_generator++;
    for (int i = 0; i < ctx->arena.size; i++)
    {
        flow_object_add_new_state_as_a_copy_of_current_state(ctx->arena.data[i], name, state_number);
    }
    return state_number;
}


static int arena_add_empty_state(struct flow_visit_ctx* ctx, const char* name)
{
    int state_number = ctx->state_number_generator;
    ctx->state_number_generator++;

    for (int i = 0; i < ctx->arena.size; i++)
    {
        struct flow_object* p_object = ctx->arena.data[i];
        struct flow_object_state* _Owner _Opt p_flow_object_state = calloc(1, sizeof * p_flow_object_state);
        if (p_flow_object_state)
        {
            p_flow_object_state->dbg_name = name;
            p_flow_object_state->state_number = state_number;
            flow_object_add_state(p_object, p_flow_object_state);
        }

    }
    return state_number;
}

void flow_object_set_state_from_current(struct flow_object* object, int state_number)
{
    struct flow_object_state* _Opt p_flow_object_state = object->current.next;
    while (p_flow_object_state)
    {
        if (p_flow_object_state->state_number == state_number)
        {
            flow_object_state_copy(p_flow_object_state, &object->current);
            break;
        }
        p_flow_object_state = p_flow_object_state->next;
    }
}

static void arena_set_state_from_current(struct flow_visit_ctx* ctx, int number_state)
{
    for (int i = 0; i < ctx->arena.size; i++)
    {
        struct flow_object* p_object = ctx->arena.data[i];
        flow_object_set_state_from_current(p_object, number_state);
    }
}

static int flow_object_merge_current_with_state(struct flow_visit_ctx* ctx, struct flow_object* object, int state_number)
{
    try
    {
        struct flow_object_state* _Opt it = object->current.next;
        while (it)
        {
            if (it->state_number == state_number)
            {
                it->state |= object->current.state;
                if (object->current.pointed == NULL && it->pointed == NULL)
                {
                    //nothing
                }
                else if (object->current.pointed == NULL && it->pointed != NULL)
                {
                    //mesmo
                }
                else if (object->current.pointed != NULL && it->pointed == NULL)
                {
                    it->pointed = object->current.pointed;
                }
                else if (object->current.pointed != it->pointed)
                {
                    assert(object->current.pointed != NULL);
                    assert(it->pointed != NULL);

                    struct flow_object* _Opt p_new_object = arena_new_object(ctx);
                    if (p_new_object == NULL) throw;

                    struct flow_object_state* _Owner _Opt p_new_state = calloc(1, sizeof * p_new_state);
                    if (p_new_state == NULL) throw;

                    p_new_state->dbg_name = "merged";
                    p_new_state->state_number = state_number;
                    objects_view_push_back(&p_new_state->alternatives, object->current.pointed);
                    objects_view_push_back(&p_new_state->alternatives, it->pointed);
                    flow_object_add_state(p_new_object, p_new_state);

                    int n_childs_1 = object->current.pointed->members.size;
                    int n_childs_2 = it->pointed->members.size;
                    if (n_childs_1 == n_childs_2)
                    {

                        for (int j = 0; j < n_childs_1; j++)
                        {
                            struct flow_object* _Opt p_new_child = arena_new_object(ctx);
                            if (p_new_child == NULL) throw;

                            p_new_child->parent = p_new_object;

                            struct flow_object* child1 = object->current.pointed->members.data[j];
                            struct flow_object* child2 = it->pointed->members.data[j];

                            struct flow_object_state* _Owner _Opt p_child_new_state = calloc(1, sizeof * p_child_new_state);
                            if (p_child_new_state == NULL) throw;

                            p_child_new_state->dbg_name = "merged";
                            p_child_new_state->state_number = state_number;
                            p_child_new_state->state = child1->current.state | it->state;
                            objects_view_push_back(&p_child_new_state->alternatives, child1);
                            objects_view_push_back(&p_child_new_state->alternatives, child2);
                            flow_object_add_state(p_new_child, p_child_new_state);
                            objects_view_push_back(&p_new_object->members, p_new_child);
                        }
                    }
                    else
                    {
                        //ops
                        //dbg_break();
                    }

                    it->pointed = p_new_object;
                }
                break;
            }
            it = it->next;
        }
    }
    catch
    {
    }
    return 0;
}
static void arena_merge_current_state_with_state_number(struct flow_visit_ctx* ctx, int number_state)
{
    for (int i = 0; i < ctx->arena.size; i++)
    {
        //constantes nao precisam desta copia.
        flow_object_merge_current_with_state(ctx, ctx->arena.data[i], number_state);
    }

}


static void object_restore_current_state_from2(struct flow_visit_ctx* ctx, struct flow_object* object, int state_number)
{
    struct flow_object_state* _Opt it = object->current.next;
    while (it)
    {
        if (it->state_number == state_number)
        {
            flow_object_state_copy(&object->current, it);
            break;
        }
        it = it->next;
    }
}

static void arena_restore_current_state_from(struct flow_visit_ctx* ctx, int number_state)
{
    for (int i = 0; i < ctx->arena.size; i++)
    {
        //constantes nao precisam desta copia.
        object_restore_current_state_from2(ctx, ctx->arena.data[i], number_state);
    }

}

static void arena_remove_state(struct flow_visit_ctx* ctx, int state_number)
{
    for (int i = 0; i < ctx->arena.size; i++)
    {
        //constantes nao precisam desta copia.
        object_remove_state(ctx->arena.data[i], state_number);
    }
}



static void flow_visit_initializer(struct flow_visit_ctx* ctx, struct initializer* p_initializer);
static void flow_visit_declarator(struct flow_visit_ctx* ctx, struct declarator* p_declarator);

static void braced_initializer_set_object(struct braced_initializer* p, struct type* type, struct flow_object* object)
{
    if (p->initializer_list == NULL)
    {
    }
    //TODO currently it is zero

    object_set_zero(type, object);
}

static void flow_visit_init_declarator(struct flow_visit_ctx* ctx, struct init_declarator* p_init_declarator)
{
    const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;

    try
    {
        flow_visit_declarator(ctx, p_init_declarator->p_declarator);

        if (p_init_declarator->initializer)
        {
            if (p_init_declarator->initializer->assignment_expression)
            {
                struct true_false_set a = { 0 };
                flow_visit_expression(ctx, p_init_declarator->initializer->assignment_expression, &a);
                true_false_set_destroy(&a);
            }
            else
            {
                if (p_init_declarator->initializer->braced_initializer)
                {
                    flow_visit_bracket_initializer_list(ctx,
                        p_init_declarator->initializer->braced_initializer);
                }
                else
                {
                    assert(false);
                }
            }
        }

        if (p_init_declarator->p_declarator->type.category != TYPE_CATEGORY_FUNCTION)
        {
            if (p_init_declarator->initializer &&
                p_init_declarator->initializer->assignment_expression)
            {
                struct flow_object* _Opt p_right_object =
                    expression_get_object(ctx, p_init_declarator->initializer->assignment_expression, nullable_enabled);

                if (p_right_object)
                {
                    struct marker a_marker = {
                        .p_token_begin = p_init_declarator->p_declarator->first_token_opt,
                        .p_token_end = p_init_declarator->p_declarator->last_token_opt,
                    };

                    struct marker b_marker = {
                        .p_token_begin = p_init_declarator->initializer->assignment_expression->first_token,
                        .p_token_end = p_init_declarator->initializer->assignment_expression->last_token,
                    };

                    flow_check_assignment(ctx,
                                        p_init_declarator->initializer->assignment_expression->first_token,
                                        &a_marker,
                                        &b_marker,
                                        ASSIGMENT_TYPE_OBJECTS,
                                        false,
                                        type_is_view(&p_init_declarator->p_declarator->type),
                                        type_is_nullable(&p_init_declarator->p_declarator->type, ctx->ctx->options.null_checks_enabled),
                                        &p_init_declarator->p_declarator->type,
                                        p_init_declarator->p_declarator->p_object,
                                        &p_init_declarator->initializer->assignment_expression->type,
                                        p_right_object,
                                        NULL);
                }
                //cast?
                if (expression_is_malloc(p_init_declarator->initializer->assignment_expression))
                {
                    struct type t = type_remove_pointer(&p_init_declarator->p_declarator->type);
                    struct flow_object* _Opt po = make_object(ctx, &t, p_init_declarator->p_declarator, NULL);
                    object_set_pointer(p_init_declarator->p_declarator->p_object, po);
                    type_destroy(&t);
                    p_init_declarator->p_declarator->p_object->current.state = OBJECT_STATE_NOT_NULL | OBJECT_STATE_NULL;
                }
                else if (expression_is_calloc(p_init_declarator->initializer->assignment_expression))
                {
                    struct type t = type_remove_pointer(&p_init_declarator->p_declarator->type);
                    struct flow_object* _Opt po = make_object(ctx, &t, p_init_declarator->p_declarator, NULL);
                    if (po == NULL)
                    {
                        type_destroy(&t);
                        throw;
                    }

                    object_set_zero(&t, po);
                    object_set_pointer(p_init_declarator->p_declarator->p_object, po);
                    type_destroy(&t);
                    p_init_declarator->p_declarator->p_object->current.state = OBJECT_STATE_NOT_NULL | OBJECT_STATE_NULL;
                }

                //object_destroy(&temp_obj);
            }
            else  if (p_init_declarator->initializer &&
                p_init_declarator->initializer->braced_initializer)
            {
                struct flow_object* _Opt po = make_object(ctx, &p_init_declarator->p_declarator->type, p_init_declarator->p_declarator, NULL);
                if (po == NULL)
                {
                    throw;
                }

                braced_initializer_set_object(p_init_declarator->initializer->braced_initializer,
                    &p_init_declarator->p_declarator->type,
                    po);

                struct marker a_marker = {
                  .p_token_begin = p_init_declarator->p_declarator->first_token_opt,
                  .p_token_end = p_init_declarator->p_declarator->last_token_opt,
                };
                struct marker b_marker = {
                    .p_token_begin = p_init_declarator->initializer->braced_initializer->first_token,
                    .p_token_end = p_init_declarator->initializer->braced_initializer->last_token,
                };


                struct flow_object* _Opt p_right_object = po;
                flow_check_assignment(ctx,
                                       p_init_declarator->p_declarator->first_token_opt,
                                       &a_marker,
                                       &b_marker,
                                       ASSIGMENT_TYPE_OBJECTS,
                                       false,
                                       type_is_view(&p_init_declarator->p_declarator->type),
                                       type_is_nullable(&p_init_declarator->p_declarator->type, ctx->ctx->options.null_checks_enabled),
                                       &p_init_declarator->p_declarator->type,
                                       p_init_declarator->p_declarator->p_object,
                                       &p_init_declarator->p_declarator->type,
                                       p_right_object,
                                       NULL);
                //object_destroy(&o);
            }
            else
            {
                //struct object * po = make_object(ctx, &p_init_declarator->p_declarator->type, p_init_declarator->p_declarator, NULL);

                if (p_init_declarator->p_declarator->declaration_specifiers &&
                    (
                        (p_init_declarator->p_declarator->declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_EXTERN) ||
                        (p_init_declarator->p_declarator->declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_STATIC)
                        )
                    )
                {
                    object_set_zero(&p_init_declarator->p_declarator->type, p_init_declarator->p_declarator->p_object);
                }
                else
                {
                    object_set_uninitialized(&p_init_declarator->p_declarator->type, p_init_declarator->p_declarator->p_object);
                }
                //struct object* p_right_object = po;
                //object_assignment3(ctx,
                  //                     p_init_declarator->p_declarator->first_token,
                    //                   ASSIGMENT_TYPE_OBJECTS,
                      //                 false,
                        //               type_is_view(&p_init_declarator->p_declarator->type),
                          //             type_is_nullable(&p_init_declarator->p_declarator->type, ctx->ctx->options.null_checks_enabled),
                            //           &p_init_declarator->p_declarator->type,
                              //         p_init_declarator->p_declarator->p_object,
                                //       &p_init_declarator->p_declarator->type,
                                  //     p_right_object);
                //object_destroy(&o);
            }
        }
    }
    catch
    {
        //some unexpected error
    }
}


static void flow_visit_init_declarator_list(struct flow_visit_ctx* ctx, struct init_declarator_list* p_init_declarator_list);

static void flow_visit_declaration_specifiers(struct flow_visit_ctx* ctx,
    struct declaration_specifiers* p_declaration_specifiers,
    struct type* _Opt p_type);


static void flow_visit_simple_declaration(struct flow_visit_ctx* ctx, struct simple_declaration* p_simple_declaration)
{
    flow_visit_declaration_specifiers(ctx, p_simple_declaration->p_declaration_specifiers, NULL);
    flow_visit_init_declarator_list(ctx, &p_simple_declaration->init_declarator_list);
}

static void flow_check_pointer_used_as_bool(struct flow_visit_ctx* ctx, struct expression* p_expression);

void print_arena(struct flow_visit_ctx* ctx)
{
    int extra_cols = 0;
    for (int i = 0; i < ctx->arena.size; i++)
    {
        struct flow_object* p_object = ctx->arena.data[i];
        struct flow_object_state* _Opt p_state = p_object->current.next;
        int count = 0;
        while (p_state)
        {
            count++;
            p_state = p_state->next;
        }
        if (count > extra_cols)
            extra_cols = count;
    }


    //┐
    printf("\n");
    printf("┌──┬──────────────────┬─────────────────────────");
    if (extra_cols > 0)
    {
        for (int i = 0; i < extra_cols; i++)
        {
            if (i < extra_cols - 1)
                printf("┬─────────────────────────");
            else
                printf("┬─────────────────────────");
        }
    }

    printf("┐");

    printf("\n");

    for (int i = 0; i < ctx->arena.size; i++)
    {
        struct flow_object* p = ctx->arena.data[i];
        print_object_line(p, extra_cols);
    }
    printf("└──┴──────────────────┴─────────────────────────");
    if (extra_cols > 0)
    {
        for (int i = 0; i < extra_cols; i++)
        {
            if (i < extra_cols - 1)
                printf("┴─────────────────────────");
            else
                printf("┴─────────────────────────");
        }
    }

    printf("┘");

    printf("\n");
    printf("\n");
}

static void flow_visit_if_statement(struct flow_visit_ctx* ctx, struct selection_statement* p_selection_statement)
{

    const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;

    struct flow_defer_scope* _Opt p_defer = flow_visit_ctx_push_tail_block(ctx);
    if (p_defer == NULL)
        return;

    p_defer->p_selection_statement = p_selection_statement;

    if (p_selection_statement->p_init_statement &&
        p_selection_statement->p_init_statement->p_expression_statement)
        flow_visit_expression_statement(ctx, p_selection_statement->p_init_statement->p_expression_statement);

    if (p_selection_statement->p_init_statement &&
        p_selection_statement->p_init_statement->p_simple_declaration)
        flow_visit_simple_declaration(ctx, p_selection_statement->p_init_statement->p_simple_declaration);


    struct true_false_set true_false_set = { 0 };

    if (p_selection_statement->condition &&
        p_selection_statement->condition->expression)
    {
        flow_check_pointer_used_as_bool(ctx, p_selection_statement->condition->expression);
        flow_visit_expression(ctx, p_selection_statement->condition->expression, &true_false_set);
    }

    if (p_selection_statement->condition &&
        p_selection_statement->condition->p_init_declarator)
    {
        flow_visit_init_declarator(ctx, p_selection_statement->condition->p_init_declarator);
    }

    assert(p_selection_statement->first_token->type == TK_KEYWORD_IF);



    /*
       This index is from the end of top of stack going to base of statck
    */
    const int before_if_state_number = arena_add_copy_of_current_state(ctx, "before-if");



    true_false_set_set_objects_to_true_branch(ctx, &true_false_set, nullable_enabled);
    flow_visit_secondary_block(ctx, p_selection_statement->secondary_block);


    const bool true_branch_ends_with_jump =
        secondary_block_ends_with_jump(p_selection_statement->secondary_block);


    /*let's make a copy of the state we left true branch*/
    //const int true_branch = 1;
    const int left_true_branch_state_number = arena_add_copy_of_current_state(ctx, "left-true-branch");

    arena_restore_current_state_from(ctx, before_if_state_number);


    if (p_selection_statement->else_secondary_block_opt)
    {
        true_false_set_set_objects_to_false_branch(ctx, &true_false_set, nullable_enabled);
        flow_visit_secondary_block(ctx, p_selection_statement->else_secondary_block_opt);
    }
    else
    {
        //we emulate a empty else {}
        true_false_set_set_objects_to_false_branch(ctx, &true_false_set, nullable_enabled);
    }

    bool else_ends_with_jump =
        p_selection_statement->else_secondary_block_opt ?
        secondary_block_ends_with_jump(p_selection_statement->else_secondary_block_opt) :
        false;


    if (true_branch_ends_with_jump)
    {
        if (else_ends_with_jump)
        {
            /*
               if (){
                 return
               }
               else
               {
                 return;
               }
            */
            /*no merge*/
        }
        else
        {
            /*
               if (){
                 return
               }
               else
               {

               }
            */

        }
    }
    else
    {
        if (else_ends_with_jump)
        {
            /*
               if (){

               }
               else
               {
                 return;
               }
            */

            arena_restore_current_state_from(ctx, left_true_branch_state_number);
        }
        else
        {
            /*
               if (){
               }
               else {

               }
            */

            arena_merge_current_state_with_state_number(ctx, left_true_branch_state_number);

            arena_restore_current_state_from(ctx, left_true_branch_state_number);

        }
    }

    flow_exit_block_visit(ctx, p_defer, p_selection_statement->last_token);

    flow_end_of_storage_visit(ctx, p_defer, p_selection_statement->last_token);
    flow_visit_ctx_pop_tail_block(ctx);

    arena_remove_state(ctx, before_if_state_number);
    arena_remove_state(ctx, left_true_branch_state_number);
    true_false_set_destroy(&true_false_set);

}

static void flow_visit_block_item(struct flow_visit_ctx* ctx, struct block_item* p_block_item);


static void flow_visit_try_statement(struct flow_visit_ctx* ctx, struct try_statement* p_try_statement)
{
    try
    {
        const int throw_join_state_old = ctx->throw_join_state;
        struct secondary_block* _Opt catch_secondary_block_old = ctx->catch_secondary_block_opt;

        ctx->catch_secondary_block_opt = p_try_statement->catch_secondary_block_opt;

        ctx->throw_join_state = arena_add_empty_state(ctx, "try");

        const int original_state_number = arena_add_copy_of_current_state(ctx, "original");

        struct flow_defer_scope* _Opt p_defer = flow_visit_ctx_push_tail_block(ctx);
        if (p_defer == NULL)
        {
            //TODO restore
            throw;
        }

        p_defer->p_try_statement = p_try_statement;

        flow_visit_secondary_block(ctx, p_try_statement->secondary_block);
        arena_set_state_from_current(ctx, original_state_number); //state of end of secondary block

        if (p_try_statement->catch_secondary_block_opt)
        {
            //current all possible states of throw
            arena_restore_current_state_from(ctx, ctx->throw_join_state);
            flow_visit_secondary_block(ctx, p_try_statement->catch_secondary_block_opt);
            //current has the state at the end of catch block
        }

        bool try_reached_the_end = !secondary_block_ends_with_jump(p_try_statement->secondary_block);
        bool catch_reached_the_end = !secondary_block_ends_with_jump(p_try_statement->catch_secondary_block_opt);

        if (try_reached_the_end && catch_reached_the_end)
        {
            //we could merge directly at current
            arena_merge_current_state_with_state_number(ctx, original_state_number);
            arena_restore_current_state_from(ctx, original_state_number);
        }
        else if (try_reached_the_end)
        {
            arena_restore_current_state_from(ctx, original_state_number);
        }
        else if (catch_reached_the_end)
        {
            //ctx_object_restore_current_state_from(ctx, orignial);       
        }


        flow_exit_block_visit(ctx, p_defer, p_try_statement->secondary_block->last_token);

        flow_end_of_storage_visit(ctx, p_defer, p_try_statement->secondary_block->last_token);
        flow_visit_ctx_pop_tail_block(ctx);

        arena_remove_state(ctx, original_state_number);
        arena_remove_state(ctx, ctx->throw_join_state);

        ctx->throw_join_state = throw_join_state_old; //restore
        ctx->catch_secondary_block_opt = catch_secondary_block_old; //restore
    }
    catch
    {
    }
}

static void flow_visit_switch_statement(struct flow_visit_ctx* ctx, struct selection_statement* p_selection_statement)
{
    const int old_initial_state = ctx->initial_state;
    const int old_break_join_state = ctx->break_join_state;

    struct flow_defer_scope* _Opt p_defer = flow_visit_ctx_push_tail_block(ctx);
    if (p_defer == NULL)
    {
        return;
    }

    ctx->initial_state = arena_add_copy_of_current_state(ctx, "original");
    ctx->break_join_state = arena_add_empty_state(ctx, "break join");

    p_defer->p_selection_statement = p_selection_statement;

    flow_visit_secondary_block(ctx, p_selection_statement->secondary_block);

    bool reached_the_end = !secondary_block_ends_with_jump(p_selection_statement->secondary_block);

    if (!reached_the_end)
    {
        arena_restore_current_state_from(ctx, ctx->break_join_state);
    }

    flow_exit_block_visit(ctx, p_defer, p_selection_statement->secondary_block->last_token);

    flow_end_of_storage_visit(ctx, p_defer, p_selection_statement->secondary_block->last_token);
    flow_visit_ctx_pop_tail_block(ctx);


    arena_remove_state(ctx, ctx->initial_state);
    arena_remove_state(ctx, ctx->break_join_state);

    //restore
    ctx->initial_state = old_initial_state;
    ctx->break_join_state = old_break_join_state;
}

static void flow_visit_selection_statement(struct flow_visit_ctx* ctx, struct selection_statement* p_selection_statement)
{

    if (p_selection_statement->first_token->type == TK_KEYWORD_IF)
    {
        flow_visit_if_statement(ctx, p_selection_statement);
    }
    else if (p_selection_statement->first_token->type == TK_KEYWORD_SWITCH)
    {
        flow_visit_switch_statement(ctx, p_selection_statement);
    }
    else
        assert(false);


}

static void flow_visit_compound_statement(struct flow_visit_ctx* ctx, struct compound_statement* p_compound_statement);

static void flow_visit_initializer_list(struct flow_visit_ctx* ctx, struct initializer_list* p_initializer_list);

static void flow_visit_bracket_initializer_list(struct flow_visit_ctx* ctx, struct braced_initializer* p_bracket_initializer_list)
{
    if (p_bracket_initializer_list->initializer_list == NULL)
    {

    }
    else
    {
        flow_visit_initializer_list(ctx, p_bracket_initializer_list->initializer_list);
    }
}

static void flow_visit_designation(struct flow_visit_ctx* ctx, struct designation* p_designation)
{}

static void flow_visit_bracket_initializer_list(struct flow_visit_ctx* ctx, struct braced_initializer* p_bracket_initializer_list);

static void flow_visit_initializer(struct flow_visit_ctx* ctx, struct initializer* p_initializer)
{
    if (p_initializer->designation)
    {
        flow_visit_designation(ctx, p_initializer->designation);
    }

    if (p_initializer->assignment_expression)
    {
        struct true_false_set a = { 0 };
        flow_visit_expression(ctx, p_initializer->assignment_expression, &a);
        true_false_set_destroy(&a);
    }
    else if (p_initializer->braced_initializer)
    {
        flow_visit_bracket_initializer_list(ctx, p_initializer->braced_initializer);
    }
}

static void flow_visit_initializer_list(struct flow_visit_ctx* ctx, struct initializer_list* p_initializer_list)
{
    struct initializer* _Opt p_initializer = p_initializer_list->head;
    while (p_initializer)
    {
        flow_visit_initializer(ctx, p_initializer);
        p_initializer = p_initializer->next;
    }
}

static void flow_visit_type_qualifier(struct flow_visit_ctx* ctx, struct type_qualifier* p_type_qualifier)
{

}

static void flow_visit_specifier_qualifier(struct flow_visit_ctx* ctx, struct type_specifier_qualifier* p_specifier_qualifier)
{
    if (p_specifier_qualifier->type_specifier)
        flow_visit_type_specifier(ctx, p_specifier_qualifier->type_specifier);

    if (p_specifier_qualifier->type_qualifier)
        flow_visit_type_qualifier(ctx, p_specifier_qualifier->type_qualifier);
}

static void flow_visit_specifier_qualifier_list(struct flow_visit_ctx* ctx, struct specifier_qualifier_list* _Opt p_specifier_qualifier_list_opt,
    struct type* p_type)
{
    if (p_specifier_qualifier_list_opt == NULL)
        return;

    if (p_specifier_qualifier_list_opt->struct_or_union_specifier)
    {
        flow_visit_struct_or_union_specifier(ctx, p_specifier_qualifier_list_opt->struct_or_union_specifier);
    }
    else if (p_specifier_qualifier_list_opt->enum_specifier)
    {
        flow_visit_enum_specifier(ctx, p_specifier_qualifier_list_opt->enum_specifier);
    }
    else if (p_specifier_qualifier_list_opt->typedef_declarator)
    {
        //typedef name
    }
    //else if (p_specifier_qualifier_list->p_typeof_expression_opt)
    //{
      //  flow_visit_expression(ctx, p_specifier_qualifier_list->p_typeof_expression_opt);
    //}
    else
    {
        struct type_specifier_qualifier* _Opt p_specifier_qualifier = p_specifier_qualifier_list_opt->head;
        while (p_specifier_qualifier)
        {
            flow_visit_specifier_qualifier(ctx, p_specifier_qualifier);
            p_specifier_qualifier = p_specifier_qualifier->next;
        }
    }
}


static void flow_visit_type_name(struct flow_visit_ctx* ctx, struct type_name* p_type_name)
{

    flow_visit_specifier_qualifier_list(ctx, p_type_name->specifier_qualifier_list, &p_type_name->type);
    flow_visit_declarator(ctx, p_type_name->abstract_declarator);


    /*
    * Vamos esconder tudo e gerar um novo
    *  Exemplo
    *  (const typeof(int (*)())) -> *  ( int (*const )() )
    */
}

static void flow_visit_generic_selection(struct flow_visit_ctx* ctx, struct generic_selection* p_generic_selection)
{
    if (p_generic_selection->expression)
    {
        struct true_false_set a = { 0 };
        flow_visit_expression(ctx, p_generic_selection->expression, &a);
        true_false_set_destroy(&a);
    }
    else if (p_generic_selection->type_name)
    {
        flow_visit_type_name(ctx, p_generic_selection->type_name);
    }
}


static void compare_function_arguments3(struct flow_visit_ctx* ctx,
    struct type* p_type,
    struct argument_expression_list* p_argument_expression_list)
{
    try
    {
        const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;

        const struct param_list* _Opt p_param_list = type_get_func_or_func_ptr_params(p_type);
        if (p_param_list == NULL) throw;

        struct param* _Opt p_current_parameter_type = p_param_list->head;
        struct argument_expression* _Opt p_current_argument = p_argument_expression_list->head;

        while (p_current_argument && p_current_parameter_type)
        {

            struct true_false_set a = { 0 };

            struct diagnostic temp =
                ctx->ctx->options.diagnostic_stack.stack[ctx->ctx->options.diagnostic_stack.top_index];

            //we don´t report W_FLOW_UNINITIALIZED here because it is checked next.. (TODO parts of expression)
            diagnostic_remove(&ctx->ctx->options.diagnostic_stack.stack[ctx->ctx->options.diagnostic_stack.top_index], W_FLOW_UNINITIALIZED);

            flow_visit_expression(ctx, p_current_argument->expression, &a);

            ctx->ctx->options.diagnostic_stack.stack[ctx->ctx->options.diagnostic_stack.top_index] = temp;

            true_false_set_destroy(&a);

            struct flow_object* _Opt p_argument_object =
                expression_get_object(ctx, p_current_argument->expression, nullable_enabled);

            if (p_argument_object)
            {
                struct flow_object* _Opt parameter_object = make_object(ctx, &p_current_parameter_type->type, NULL, p_current_argument->expression);
                if (parameter_object == NULL) throw;

                object_set_uninitialized(&p_current_parameter_type->type, parameter_object);

                struct marker a_marker = {
                    .p_token_begin = p_current_argument->expression->first_token,
                    .p_token_end = p_current_argument->expression->last_token
                };

                //TODO pass real function to get location
                struct marker b_marker = {
                    .p_token_begin = p_current_argument->expression->first_token,
                    .p_token_end = p_current_argument->expression->last_token
                };

                flow_check_assignment(ctx,
                  p_current_argument->expression->first_token,
                  &a_marker,
                  &b_marker,
                  ASSIGMENT_TYPE_PARAMETER,
                  true,
                  type_is_view(&p_current_parameter_type->type),
                  type_is_nullable(&p_current_parameter_type->type, ctx->ctx->options.null_checks_enabled),
                  &p_current_parameter_type->type,
                  parameter_object, /*dest object*/

                  &p_current_argument->expression->type,
                  p_argument_object,
                  &p_current_argument->set_unkown
                );
            }
            p_current_argument = p_current_argument->next;
            p_current_parameter_type = p_current_parameter_type->next;
        }

        while (p_current_argument)
        {
            /*
               We have more argument than parameters, this happens with variadic functions
            */

            struct flow_object* _Opt p_argument_object =
                expression_get_object(ctx, p_current_argument->expression, nullable_enabled);

            if (p_argument_object)
            {
                struct marker marker = {
                    .p_token_begin = p_current_argument->expression->first_token,
                    .p_token_end = p_current_argument->expression->last_token
                };
                checked_read_object(ctx,
                    &p_current_argument->expression->type,
                    type_is_nullable(&p_current_argument->expression->type, ctx->ctx->options.null_checks_enabled),
                    p_argument_object,
                    p_current_argument->expression->first_token,
                    &marker,
                    false);
            }
            else
            {
                //
            }
            p_current_argument = p_current_argument->next;
        }

        //////////////////////////// SECOND PASS ////////////////////////////
        /*
            //consider this sample...
            void f(struct X *p,  int * p);

            int main()
            {
                struct X *  pX = make();
                if (pX->p)
                {
                   //cake is making pX->p  unkown before function call..it must be after
                   f(pX, pX->p);
                }
            }
        */

        /*struct param* */ p_current_parameter_type = p_param_list->head;
        /*struct argument_expression* */ p_current_argument = p_argument_expression_list->head;


        while (p_current_argument && p_current_parameter_type)
        {
            if (p_current_argument->set_unkown &&
                type_is_pointer(&p_current_argument->expression->type))
            {
                struct type pointed_type = type_remove_pointer(&p_current_argument->expression->type);

                struct flow_object* _Opt p_argument_object =
                    expression_get_object(ctx, p_current_argument->expression, nullable_enabled);


                if (p_argument_object)
                {
                    const bool argument_type_is_nullable =
                        type_is_nullable(&pointed_type, ctx->ctx->options.null_checks_enabled);

                    if (p_argument_object->current.pointed)
                    {
                        object_set_unknown(&pointed_type,
                                           argument_type_is_nullable,
                                           p_argument_object->current.pointed,
                                           ctx->ctx->options.null_checks_enabled);
                    }
                    else
                    {
                        //assert(false);
                    }
                }

                type_destroy(&pointed_type);
            }
            p_current_argument = p_current_argument->next;
            p_current_parameter_type = p_current_parameter_type->next;
        }

        while (p_current_argument)
        {
            /*
               We have more argument than parameters, this happens with variadic functions
            */

            struct flow_object* _Opt p_argument_object =
                expression_get_object(ctx, p_current_argument->expression, nullable_enabled);

            if (p_argument_object)
            {
                //??
            }
            else
            {
                //??
            }
            p_current_argument = p_current_argument->next;
        }
    }
    catch
    {
    }
}

static void check_uninitialized(struct flow_visit_ctx* ctx, struct expression* p_expression)
{
    if (p_expression->is_assignment_expression)
        return;

    const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;

    if (type_is_function(&p_expression->type) ||
        type_is_void(&p_expression->type) ||
        type_is_nullptr_t(&p_expression->type))
    {
        return;
    }

    struct flow_object* _Opt p_object = expression_get_object(ctx, p_expression, nullable_enabled);

    if (!ctx->expression_is_not_evaluated)
    {
        if (p_object && p_object->current.state == OBJECT_STATE_UNINITIALIZED)
        {
            if (p_expression->expression_type == PRIMARY_EXPRESSION_DECLARATOR &&
                p_expression->declarator &&
                p_expression->declarator->name_opt)
            {
                compiler_diagnostic_message(W_FLOW_UNINITIALIZED,
                    ctx->ctx,
                    p_expression->first_token, NULL, "using a uninitialized object '%s'", p_expression->declarator->name_opt->lexeme);
            }
            else
            {
                compiler_diagnostic_message(W_FLOW_UNINITIALIZED,
                    ctx->ctx,
                    p_expression->first_token, NULL, "using a uninitialized object");
            }
        }
        else if (p_object && p_object->current.state & OBJECT_STATE_UNINITIALIZED)
        {
            if (ctx->ctx->options.ownership_enabled)
            {
                if (p_expression->declarator && p_expression->declarator->name_opt)
                {
                    compiler_diagnostic_message(W_FLOW_UNINITIALIZED,
                        ctx->ctx,
                        p_expression->first_token,
                        NULL,
                        "object '%s' can be uninitialized ",
                        p_expression->declarator->name_opt->lexeme);
                }
                else
                {
                    compiler_diagnostic_message(W_FLOW_UNINITIALIZED,
                        ctx->ctx,
                        p_expression->first_token, NULL, "maybe using a uninitialized object");
                }
            }
        }
    }
    //object_destroy(&temp_obj);
}

void object_push_states_from(const struct flow_object* p_object_from, struct flow_object* p_object_to)
{
    struct flow_object_state* _Opt it_from = p_object_from->current.next;
    while (it_from)
    {
#if 0
        flow_object_add_state(
        p_object_to,
        p_object_to->current.state,
        &p_object_to->current.ref,
        it_from->dbg_name,
        it_from->state_number);
#endif

        it_from = it_from->next;
    }

    for (int i = 0; i < p_object_to->members.size; i++)
    {
        object_push_states_from(p_object_from, p_object_to->members.data[i]);
    }
}


static void flow_check_pointer_used_as_bool(struct flow_visit_ctx* ctx, struct expression* p_expression)
{
    //when pointer as used as bool, like if (p) or p && p->i we check
    //if the pointer has a flow condition always true or false.

    const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;

    if (type_is_pointer(&p_expression->type))
    {

        struct flow_object* _Opt p_object = expression_get_object(ctx, p_expression, nullable_enabled);
        if (p_object)
        {
            struct marker marker = {
                 .p_token_begin = p_expression->first_token,
                 .p_token_end = p_expression->last_token
            };

            if (flow_object_is_null(p_object))
            {
                compiler_diagnostic_message(W_FLOW_NON_NULL,
                        ctx->ctx,
                        NULL,
                        &marker,
                        "pointer is always null");

            }
            else if (flow_object_is_not_null(p_object))
            {
                compiler_diagnostic_message(W_FLOW_NON_NULL,
                        ctx->ctx,
                        NULL,
                        &marker,
                        "pointer is always not-null");
            }
        }
        //object_destroy(&temp);
    }
}

static void arena_broadcast_change(struct flow_visit_ctx* ctx, struct flow_object* p)
{
    for (int i = 0; i < ctx->arena.size; i++)
    {
        struct flow_object* p_obj = ctx->arena.data[i];
        if (p_obj)
        {
            for (int j = 0; j < p_obj->current.alternatives.size; j++)
            {
                if (p_obj->current.alternatives.data[j] == p)
                {
                    flow_object_update_current(p_obj);
                    break;
                }
            }
        }
    }
}

static void flow_visit_expression(struct flow_visit_ctx* ctx, struct expression* p_expression, struct true_false_set* expr_true_false_set)
{
    true_false_set_clear(expr_true_false_set); //_Out

    const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;

    switch (p_expression->expression_type)
    {
    case EXPRESSION_TYPE_INVALID:
        assert(false);
        break;

    case PRIMARY_EXPRESSION__FUNC__:
        break;

    case PRIMARY_EXPRESSION_ENUMERATOR:

        break;
    case PRIMARY_EXPRESSION_DECLARATOR:
    {
        struct true_false_set_item item;
        item.p_expression = p_expression;
        item.true_branch_state = BOOLEAN_FLAG_TRUE;
        item.false_branch_state = BOOLEAN_FLAG_FALSE;
        true_false_set_push_back(expr_true_false_set, &item);
        check_uninitialized(ctx, p_expression);
    }
    break;

    case PRIMARY_EXPRESSION_PARENTESIS:
        assert(p_expression->right != NULL);
        flow_visit_expression(ctx, p_expression->right, expr_true_false_set);
        break;

    case PRIMARY_EXPRESSION_STRING_LITERAL:
    case PRIMARY_EXPRESSION_CHAR_LITERAL:
    case PRIMARY_EXPRESSION_NUMBER:
    case PRIMARY_EXPRESSION_PREDEFINED_CONSTANT:
        break;

    case PRIMARY_EXPRESSION_GENERIC:
        assert(p_expression->generic_selection != NULL);
        flow_visit_generic_selection(ctx, p_expression->generic_selection);
        break;

    case POSTFIX_DOT:
    {
        assert(p_expression->left != NULL);

        struct true_false_set left_set = { 0 };
        flow_visit_expression(ctx, p_expression->left, &left_set);

        true_false_set_destroy(&left_set);

        struct true_false_set_item item;
        item.p_expression = p_expression;
        item.true_branch_state = BOOLEAN_FLAG_TRUE;
        item.false_branch_state = BOOLEAN_FLAG_FALSE;
        true_false_set_push_back(expr_true_false_set, &item);
    }
    break;

    case POSTFIX_ARROW:
    {
        assert(p_expression->left != NULL);

        struct true_false_set left_set = { 0 };
        flow_visit_expression(ctx, p_expression->left, &left_set);
        true_false_set_destroy(&left_set);

        struct flow_object* _Opt p_object = expression_get_object(ctx, p_expression->left, nullable_enabled);

        if (p_object != NULL)
        {
            if (flow_object_can_be_null(p_object))
            {
                if (ctx->expression_is_not_evaluated)
                {
                }
                else
                {
                    struct marker marker = { 0 };
                    marker.p_token_begin = p_expression->left->first_token;
                    marker.p_token_end = p_expression->left->last_token;
                    compiler_diagnostic_message(W_FLOW_NULL_DEREFERENCE,
                            ctx->ctx,
                            NULL,
                            &marker,
                           "pointer may be null");
                }
            }
            else if (flow_object_can_be_uninitialized(p_object))
            {
                if (ctx->expression_is_not_evaluated)
                {
                }
                else
                {
                    compiler_diagnostic_message(W_FLOW_NULL_DEREFERENCE,
                            ctx->ctx,
                            p_expression->left->first_token, NULL, "object is possibly uninitialized");
                }
            }
            else if (flow_object_can_have_its_lifetime_ended(p_object))
            {
                if (ctx->expression_is_not_evaluated)
                {
                }
                else
                {
                    compiler_diagnostic_message(W_FLOW_LIFETIME_ENDED,
                            ctx->ctx,
                            p_expression->left->first_token, NULL, "object lifetime ended");
                }
            }
        }

        if (!ctx->expression_is_not_evaluated)
        {
            struct flow_object* _Opt p_object2 = expression_get_object(ctx, p_expression, nullable_enabled);
            if (p_object2 && flow_object_can_have_its_lifetime_ended(p_object2))
            {
                struct marker marker = {
                    .p_token_begin = p_expression->first_token,
                    .p_token_end = p_expression->last_token
                };
                compiler_diagnostic_message(W_FLOW_LIFETIME_ENDED,
                        ctx->ctx,
                        NULL,
                        &marker,
                        "object lifetime ended");
            }
        }

        struct true_false_set_item item;
        item.p_expression = p_expression;
        item.true_branch_state = BOOLEAN_FLAG_TRUE;
        item.false_branch_state = BOOLEAN_FLAG_FALSE;
        true_false_set_push_back(expr_true_false_set, &item);
    }
    break;

    case POSTFIX_INCREMENT:
    case POSTFIX_DECREMENT:
    {
        assert(p_expression->left != NULL);

        struct flow_object* const _Opt p_object = expression_get_object(ctx, p_expression->left, nullable_enabled);
        if (p_object)
        {
            if (flow_object_is_null(p_object))
            {
                //p_object->current.state &= ~OBJECT_STATE_NULL;
                p_object->current.state = OBJECT_STATE_NOT_NULL;
            }
            else if (flow_object_is_zero(p_object))
            {
                //p_object->current.state &= ~OBJECT_STATE_ZERO;
                p_object->current.state = OBJECT_STATE_NOT_ZERO;
            }
        }
        flow_visit_expression(ctx, p_expression->left, expr_true_false_set);
    }
    break;

    case POSTFIX_ARRAY:
    {
        assert(p_expression->right != NULL);
        assert(p_expression->left != NULL);

        flow_visit_expression(ctx, p_expression->left, expr_true_false_set);
        flow_visit_expression(ctx, p_expression->right, expr_true_false_set);
        true_false_set_clear(expr_true_false_set);

        struct true_false_set_item item;
        item.p_expression = p_expression;
        item.true_branch_state = BOOLEAN_FLAG_TRUE;
        item.false_branch_state = BOOLEAN_FLAG_FALSE;
        true_false_set_push_back(expr_true_false_set, &item);

    }
    break;

    case POSTFIX_FUNCTION_CALL:
    {
        assert(p_expression->left != NULL);

        struct true_false_set left_local = { 0 };
        flow_visit_expression(ctx, p_expression->left, &left_local);

        //new function waiting all test to pass to become active
        compare_function_arguments3(ctx, &p_expression->left->type, &p_expression->argument_expression_list);
        true_false_set_destroy(&left_local);
    }
    break;

    case POSTFIX_EXPRESSION_FUNCTION_LITERAL:
        assert(p_expression->compound_statement != NULL);
        flow_visit_compound_statement(ctx, p_expression->compound_statement);

        break;

    case POSTFIX_EXPRESSION_COMPOUND_LITERAL:

        assert(p_expression->left == NULL);
        assert(p_expression->right == NULL);
        assert(p_expression->type_name != NULL);
        assert(p_expression->braced_initializer != NULL);

        flow_visit_type_name(ctx, p_expression->type_name);

        flow_visit_bracket_initializer_list(ctx, p_expression->braced_initializer);

        struct flow_object* _Opt temp2 = make_object(ctx, &p_expression->type, NULL, p_expression);
        if (temp2 == NULL)
        {
            return;
        }

        if (p_expression->type_name->abstract_declarator->p_object)
        {
            object_swap(temp2, p_expression->type_name->abstract_declarator->p_object);
            //object_destroy(&temp2);

            //TODO the state of object depends of the initializer        
            object_set_zero(&p_expression->type, p_expression->type_name->abstract_declarator->p_object);
        }

        break;

    case UNARY_EXPRESSION_ALIGNOF:

        if (p_expression->right)
        {
            flow_visit_expression(ctx, p_expression->right, expr_true_false_set);
        }

        if (p_expression->type_name)
        {
            /*sizeof*/
            flow_visit_type_name(ctx, p_expression->type_name);
        }
        break;

    case UNARY_EXPRESSION_ASSERT:

        if (p_expression->right)
        {
            struct true_false_set true_false_set4 = { 0 };
            bool old = ctx->inside_assert;
            ctx->inside_assert = true;
            flow_visit_expression(ctx, p_expression->right, &true_false_set4); //assert(p == 0);            
            ctx->inside_assert = old;
            true_false_set_set_objects_to_true_branch(ctx, &true_false_set4, nullable_enabled);
            true_false_set_destroy(&true_false_set4);
        }

        break;

    case UNARY_EXPRESSION_SIZEOF_EXPRESSION:

        if (p_expression->right)
        {
            const bool t2 = ctx->expression_is_not_evaluated;
            ctx->expression_is_not_evaluated = true;
            flow_visit_expression(ctx, p_expression->right, expr_true_false_set);
            ctx->expression_is_not_evaluated = t2;
        }

        if (p_expression->type_name)
        {
            /*sizeof*/
            flow_visit_type_name(ctx, p_expression->type_name);
        }


        break;

    case UNARY_EXPRESSION_NEG:
    case UNARY_EXPRESSION_PLUS:
        assert(p_expression->right != NULL);
        flow_visit_expression(ctx, p_expression->right, expr_true_false_set);
        break;

    case UNARY_EXPRESSION_NOT:
        assert(p_expression->right != NULL);
        flow_check_pointer_used_as_bool(ctx, p_expression->right);
        flow_visit_expression(ctx, p_expression->right, expr_true_false_set);
        true_false_set_invert(expr_true_false_set);
        break;

    case UNARY_EXPRESSION_SIZEOF_TYPE:
    case UNARY_EXPRESSION_NELEMENTSOF_TYPE:
    case UNARY_EXPRESSION_INCREMENT:
    case UNARY_EXPRESSION_DECREMENT:

    case UNARY_EXPRESSION_BITNOT:


    case UNARY_EXPRESSION_ADDRESSOF:
    {

        if (p_expression->type_name)
        {
            /*sizeof*/
            flow_visit_type_name(ctx, p_expression->type_name);
        }
    }
    break;

    case UNARY_EXPRESSION_CONTENT:
    {
        assert(p_expression->right != NULL);

        struct flow_object* _Opt p_object0 = expression_get_object(ctx, p_expression->right, nullable_enabled);

        if (p_object0 && p_object0->current.state == OBJECT_STATE_UNINITIALIZED)
        {
            if (!ctx->expression_is_not_evaluated)
            {
                struct marker marker = { 0 };
                marker.p_token_begin = p_expression->right->first_token;
                marker.p_token_end = p_expression->right->last_token;
                compiler_diagnostic_message(W_FLOW_UNINITIALIZED,
                    ctx->ctx,
                    NULL, &marker, "using a uninitialized object");
            }
        }
        else if (p_object0 && flow_object_can_be_null(p_object0))
        {
            /*
              *p = 1*
            */
            if (!ctx->expression_is_not_evaluated)
            {
                compiler_diagnostic_message(W_FLOW_NULL_DEREFERENCE,
                    ctx->ctx,
                    p_expression->right->first_token, NULL, "dereference a NULL object");
            }
        }

        struct true_false_set local_true_false = { 0 };
        flow_visit_expression(ctx, p_expression->right, &local_true_false);
        /*empty set*/
        true_false_set_destroy(&local_true_false);
    }
    break;


    case ASSIGNMENT_EXPRESSION:
    {
        assert(p_expression->right != NULL);
        assert(p_expression->left != NULL);

        struct true_false_set left_set = { 0 };
        flow_visit_expression(ctx, p_expression->left, &left_set);
        true_false_set_swap(expr_true_false_set, &left_set);
        true_false_set_destroy(&left_set);

        struct true_false_set right_set = { 0 };
        flow_visit_expression(ctx, p_expression->right, &right_set);
        true_false_set_destroy(&right_set);

        //struct object temp_obj1 = { 0 };
        struct flow_object* const _Opt p_right_object = expression_get_object(ctx, p_expression->right, nullable_enabled);

        //struct object temp_obj2 = { 0 };
        struct flow_object* const _Opt p_dest_object = expression_get_object(ctx, p_expression->left, nullable_enabled);

        if (p_dest_object == NULL || p_right_object == NULL)
        {
            //assert(false);
            return;
        }
        struct marker a_marker = {
          .p_token_begin = p_expression->left->first_token,
          .p_token_end = p_expression->left->last_token
        };

        struct marker b_marker = {
          .p_token_begin = p_expression->right->first_token,
          .p_token_end = p_expression->right->last_token
        };

        flow_check_assignment(ctx,
            p_expression->left->first_token,
            &a_marker,
            &b_marker,
            ASSIGMENT_TYPE_OBJECTS,
            true,
            type_is_view(&p_expression->left->type), /*dest type*/
            type_is_nullable(&p_expression->left->type, ctx->ctx->options.null_checks_enabled), /*dest type*/
            &p_expression->left->type, /*dest type*/
            p_dest_object, /*dest object*/
            &p_expression->right->type, /*source type*/
            p_right_object /*source*/,
            NULL);

        //we could havea arena_broadcast
        /*
          built-in malloc, calloc assignment
        */
        arena_broadcast_change(ctx, p_dest_object);

        if (expression_is_malloc(p_expression->right))
        {
            struct type t = type_remove_pointer(&p_expression->left->type);
            struct flow_object* _Opt po = make_object(ctx, &t, NULL, p_expression->left);
            if (po == NULL)
            {
                type_destroy(&t);
                return;
            }
            object_set_pointer(p_dest_object, po);
            type_destroy(&t);
            p_dest_object->current.state = OBJECT_STATE_NOT_NULL | OBJECT_STATE_NULL;
        }
        else if (expression_is_calloc(p_expression->right))
        {
            struct type t = type_remove_pointer(&p_expression->left->type);
            struct flow_object* _Opt po = make_object(ctx, &t, NULL, p_expression->left);
            if (po == NULL)
            {
                type_destroy(&t);
                return;
            }
            object_set_zero(&t, po);
            object_set_pointer(p_dest_object, po);
            type_destroy(&t);
            p_dest_object->current.state = OBJECT_STATE_NOT_NULL | OBJECT_STATE_NULL;
        }

        //object_destroy(&temp_obj1);
        //object_destroy(&temp_obj2);
    }
    break;
    case MULTIPLICATIVE_EXPRESSION_DIV:
    {
        assert(p_expression->right != NULL);
        assert(p_expression->left != NULL);

        struct true_false_set left_set = { 0 };
        struct true_false_set right_set = { 0 };

        flow_visit_expression(ctx, p_expression->left, &left_set);

        struct flow_object* _Opt p_object = expression_get_object(ctx, p_expression->right, ctx->ctx->options.null_checks_enabled);
        if (p_object)
        {
            if (flow_object_can_be_zero(p_object))
            {
                compiler_diagnostic_message(W_FLOW_DIVIZION_BY_ZERO, ctx->ctx, p_expression->right->first_token, NULL, "possible division by zero");
            }
        }

        /*
                               true_set               false_set
             b / a             b_true_set a_true_set  a_true_set
             0 / a             -                      a_true_set a_true_set
        */

        flow_visit_expression(ctx, p_expression->right, &right_set);
        true_false_set_merge(expr_true_false_set, &left_set, &right_set,
            MERGE_OPTIONS_A_TRUE | MERGE_OPTIONS_B_TRUE,
            MERGE_OPTIONS_A_TRUE | MERGE_OPTIONS_B_TRUE);

        true_false_set_destroy(&left_set);
        true_false_set_destroy(&right_set);
    }
    break;
    case CAST_EXPRESSION:
    case MULTIPLICATIVE_EXPRESSION_MULT:
    case MULTIPLICATIVE_EXPRESSION_MOD:
    case ADDITIVE_EXPRESSION_PLUS:
    case ADDITIVE_EXPRESSION_MINUS:
    case SHIFT_EXPRESSION_RIGHT:
    case SHIFT_EXPRESSION_LEFT:
    {
        if (p_expression->left)
        {
            struct true_false_set left_set = { 0 };
            flow_visit_expression(ctx, p_expression->left, &left_set);
            true_false_set_destroy(&left_set);
        }

        if (p_expression->right)
        {
            struct true_false_set right_set = { 0 };
            flow_visit_expression(ctx, p_expression->right, &right_set);
            true_false_set_destroy(&right_set);
        }
    }
    break;

    case RELATIONAL_EXPRESSION_BIGGER_OR_EQUAL_THAN:
    case RELATIONAL_EXPRESSION_LESS_OR_EQUAL_THAN:
    case RELATIONAL_EXPRESSION_BIGGER_THAN:
    case RELATIONAL_EXPRESSION_LESS_THAN:
    {
        assert(p_expression->right != NULL);
        assert(p_expression->left != NULL);

        //TODO a > 1
        //     a > -1 etc...

        /*
                     true_set         false_set
           a > 0     a_true           a_true a_false
           a < 0     a_true           a_true a_false


           a >= 0    a_true a_false   a_true
           b <= 0    a_true a_false   a_true
        */

        const bool left_is_constant = constant_value_is_valid(&p_expression->left->constant_value);
        const bool right_is_constant = constant_value_is_valid(&p_expression->right->constant_value);

        if (left_is_constant)
        {
            const long long left_value = constant_value_to_signed_long_long(&p_expression->left->constant_value);

            struct true_false_set true_false_set_right = { 0 };
            flow_visit_expression(ctx, p_expression->right, &true_false_set_right);
            if (left_value == 0)
            {
                true_false_set_swap(expr_true_false_set, &true_false_set_right);
                for (int i = 0; i < expr_true_false_set->size; i++)
                {
                    struct true_false_set_item* item = &expr_true_false_set->data[i];
                    item->false_branch_state |= item->true_branch_state;
                }

                if (p_expression->expression_type == RELATIONAL_EXPRESSION_BIGGER_OR_EQUAL_THAN ||
                    p_expression->expression_type == RELATIONAL_EXPRESSION_LESS_OR_EQUAL_THAN)
                {
                    true_false_set_invert(expr_true_false_set);
                }
            }
            true_false_set_destroy(&true_false_set_right);
        }

        else if (right_is_constant)
        {
            const long long right_value = constant_value_to_signed_long_long(&p_expression->right->constant_value);
            struct true_false_set true_false_set_left3 = { 0 };
            flow_visit_expression(ctx, p_expression->left, &true_false_set_left3);
            if (right_value == 0)
            {
                true_false_set_swap(expr_true_false_set, &true_false_set_left3);
                for (int i = 0; i < expr_true_false_set->size; i++)
                {
                    struct true_false_set_item* item = &expr_true_false_set->data[i];
                    item->false_branch_state |= item->true_branch_state;
                }
                if (p_expression->expression_type == RELATIONAL_EXPRESSION_BIGGER_OR_EQUAL_THAN ||
                    p_expression->expression_type == RELATIONAL_EXPRESSION_LESS_OR_EQUAL_THAN)
                {
                    true_false_set_invert(expr_true_false_set);
                }
            }
            true_false_set_destroy(&true_false_set_left3);
        }
        else
        {
            struct true_false_set true_false_set = { 0 };
            flow_visit_expression(ctx, p_expression->left, &true_false_set);
            flow_visit_expression(ctx, p_expression->right, &true_false_set);
            true_false_set_destroy(&true_false_set);
        }
    }
    break;

    case EQUALITY_EXPRESSION_NOT_EQUAL:
    case EQUALITY_EXPRESSION_EQUAL:
    {
        assert(p_expression->right != NULL);
        assert(p_expression->left != NULL);

        long long value = 0;
        struct expression* _Opt p_comp_expression = NULL;
        if (constant_value_is_valid(&p_expression->left->constant_value) &&
            !constant_value_is_valid(&p_expression->right->constant_value))
        {
            value = constant_value_to_signed_long_long(&p_expression->left->constant_value);
            p_comp_expression = p_expression->right;
        }
        else if (constant_value_is_valid(&p_expression->right->constant_value) &&
                !constant_value_is_valid(&p_expression->left->constant_value))
        {
            value = constant_value_to_signed_long_long(&p_expression->right->constant_value);
            p_comp_expression = p_expression->left;
        }


        if (p_comp_expression)
        {
            struct true_false_set true_false_set = { 0 };
            flow_visit_expression(ctx, p_comp_expression, &true_false_set);

            //constant == p_comp_expression  |  p_comp_expression == constant
            //constant != p_comp_expression  |  p_comp_expression != constant

            struct flow_object* _Opt p_object = expression_get_object(ctx, p_comp_expression, nullable_enabled);
            if (p_object)
            {
                struct marker marker = {
                     .p_token_begin = p_comp_expression->first_token,
                     .p_token_end = p_comp_expression->last_token
                };


                if ((flow_object_is_null(p_object) || flow_object_is_zero(p_object)) && value == 0)
                {
                    if (p_expression->expression_type == EQUALITY_EXPRESSION_EQUAL)
                    {
                        if (ctx->inside_assert)
                        {
                            /*
                             assert checks in runtime the same state we have at compile time
                             assert(p == NULL);
                            */
                        }
                        else
                        {
                            //if (p == NULL) { } //warning  p is always null
                            if (type_is_pointer(&p_comp_expression->type))
                                compiler_diagnostic_message(W_FLOW_NON_NULL, ctx->ctx, NULL, &marker, "pointer is always null");
                            else
                                compiler_diagnostic_message(W_FLOW_NON_NULL, ctx->ctx, NULL, &marker, "value is always zero");
                        }
                    }
                    else if (p_expression->expression_type == EQUALITY_EXPRESSION_NOT_EQUAL)
                    {
                        /*
                           runtime check is diferent from static state
                           assert(p != NULL);
                        */
                        if (type_is_pointer(&p_comp_expression->type))
                            compiler_diagnostic_message(W_FLOW_NON_NULL, ctx->ctx, NULL, &marker, "pointer is always null");
                        else
                            compiler_diagnostic_message(W_FLOW_NON_NULL, ctx->ctx, NULL, &marker, "value is always zero");
                    }
                }
                else if ((flow_object_is_not_null(p_object) || flow_object_is_not_zero(p_object)) && value == 0)
                {
                    if (p_expression->expression_type == EQUALITY_EXPRESSION_EQUAL)
                    {
                        /*
                           runtime check is diferent from static state
                           assert(p == NULL);
                        */
                        if (type_is_pointer(&p_comp_expression->type))
                            compiler_diagnostic_message(W_FLOW_NON_NULL, ctx->ctx, NULL, &marker, "pointer is always non-null");
                        else
                            compiler_diagnostic_message(W_FLOW_NON_NULL, ctx->ctx, NULL, &marker, "value is always non-zero");
                    }
                    else if (p_expression->expression_type == EQUALITY_EXPRESSION_NOT_EQUAL)
                    {
                        /*
                           assert checks in runtime the same state we have at compile time
                           assert(p != NULL);
                        */
                        if (ctx->inside_assert)
                        {
                            /*
                             assert checks in runtime the same state we have at compile time
                             assert(p == NULL);
                            */
                        }
                        else
                        {
                            if (type_is_pointer(&p_comp_expression->type))
                                compiler_diagnostic_message(W_FLOW_NON_NULL, ctx->ctx, NULL, &marker, "pointer is always non-null");
                            else
                                compiler_diagnostic_message(W_FLOW_NON_NULL, ctx->ctx, NULL, &marker, "value is always non-zero");
                        }
                    }
                }
            }

            true_false_set_swap(expr_true_false_set, &true_false_set);
            if (p_expression->expression_type == EQUALITY_EXPRESSION_EQUAL && value == 0)
            {
                true_false_set_invert(expr_true_false_set);
            }
            else if (p_expression->expression_type == EQUALITY_EXPRESSION_NOT_EQUAL && value != 0)
            {
                true_false_set_invert(expr_true_false_set);
            }
            true_false_set_destroy(&true_false_set);
        }
        else
        {
            struct true_false_set true_false_set = { 0 };
            flow_visit_expression(ctx, p_expression->left, &true_false_set);
            flow_visit_expression(ctx, p_expression->right, &true_false_set);
            true_false_set_destroy(&true_false_set);
        }
    }
    break;

    case LOGICAL_OR_EXPRESSION:
    {
        assert(p_expression->right != NULL);
        assert(p_expression->left != NULL);

        flow_check_pointer_used_as_bool(ctx, p_expression->left);
        flow_check_pointer_used_as_bool(ctx, p_expression->right);

        const int original_state_number = arena_add_copy_of_current_state(ctx, "original");

        struct true_false_set left_set = { 0 };
        flow_visit_expression(ctx, p_expression->left, &left_set);



        //Set all variables to false state, because otherwise, the right branch
        // would not be evaluated
        true_false_set_set_objects_to_false_branch(ctx, &left_set, nullable_enabled);

        struct true_false_set right_set = { 0 };
        flow_visit_expression(ctx, p_expression->right, &right_set);

        //  true_false_set_merge(expr_true_false_set, &left_set, &right_set,
        //         MERGE_OPTIONS_A_TRUE | MERGE_OPTIONS_A_FALSE | MERGE_OPTIONS_B_TRUE | MERGE_OPTIONS_B_FALSE,
        //         MERGE_OPTIONS_A_FALSE| MERGE_OPTIONS_B_FALSE);

        //Tudo que faz left ser true ou right ser true

        for (int i = 0; i < left_set.size; i++)
        {
            struct true_false_set_item item5;

            item5.p_expression = left_set.data[i].p_expression;
            item5.true_branch_state |= (left_set.data[i].true_branch_state | left_set.data[i].false_branch_state);
            item5.false_branch_state |= left_set.data[i].false_branch_state;
            true_false_set_push_back(expr_true_false_set, &item5);
        }

        for (int k = 0; k < right_set.size; k++)
        {
            int index =
                find_item_index_by_expression(expr_true_false_set, right_set.data[k].p_expression);
            if (index == -1)
            {
                index = expr_true_false_set->size;
                struct true_false_set_item item4 = { 0 };
                true_false_set_push_back(expr_true_false_set, &item4);
            }

            //Tudo que faz left true e right true faz expressao se true
            expr_true_false_set->data[index].p_expression = right_set.data[k].p_expression;
            //d->data[index].true_branch_state |= right_set.data[k].true_branch_state;
            //Tudo que faz left true ou left false, e right false faz ser false
            expr_true_false_set->data[index].false_branch_state |= right_set.data[k].false_branch_state;

            //No path true seria possivel nao ser feito o right
            expr_true_false_set->data[index].true_branch_state |= (BOOLEAN_FLAG_TRUE | BOOLEAN_FLAG_FALSE);

        }

        arena_restore_current_state_from(ctx, original_state_number);
        arena_remove_state(ctx, original_state_number);
        true_false_set_destroy(&left_set);
        true_false_set_destroy(&right_set);
    }
    break;

    case LOGICAL_AND_EXPRESSION:
    {
        assert(p_expression->right != NULL);
        assert(p_expression->left != NULL);

        flow_check_pointer_used_as_bool(ctx, p_expression->left);
        flow_check_pointer_used_as_bool(ctx, p_expression->right);

        const int original_state_number = arena_add_copy_of_current_state(ctx, "original");

        struct true_false_set left_set = { 0 };
        flow_visit_expression(ctx, p_expression->left, &left_set);


        //Set all variables to true state, because otherwise, the right branch
        // would not be evaluated
        true_false_set_set_objects_to_true_branch(ctx, &left_set, nullable_enabled);

        struct true_false_set right_set = { 0 };
        flow_visit_expression(ctx, p_expression->right, &right_set);
        //arena_restore_current_state_from(ctx, original_state_number);

       //Anything that makes left and right true also makes left && right true. 
       //Anything that makes left false or right false also makes left && right false.

        for (int i = 0; i < left_set.size; i++)
        {
            const struct true_false_set_item* p_item_left = &left_set.data[i];

            struct true_false_set_item left_and_right = { 0 };
            left_and_right.p_expression = p_item_left->p_expression;

            left_and_right.true_branch_state |= p_item_left->true_branch_state;
            left_and_right.false_branch_state |= p_item_left->true_branch_state | p_item_left->false_branch_state;

            true_false_set_push_back(expr_true_false_set, &left_and_right);
        }

        for (int k = 0; k < right_set.size; k++)
        {
            const struct true_false_set_item* p_item_right = &right_set.data[k];

            int index = find_item_index_by_expression(expr_true_false_set, p_item_right->p_expression);
            if (index == -1)
            {
                index = expr_true_false_set->size;
                struct true_false_set_item item2 = { 0 };
                true_false_set_push_back(expr_true_false_set, &item2);
            }

            //Tudo que faz left true e right true faz expressao se true
            expr_true_false_set->data[index].p_expression = p_item_right->p_expression;
            expr_true_false_set->data[index].true_branch_state |= p_item_right->true_branch_state;
            //Tudo que faz left true ou left false, e right false faz ser false
            expr_true_false_set->data[index].false_branch_state |= p_item_right->false_branch_state;

            //right expression may not be evaluated, in this case all previous states are also valid
            //so if the variable could be true and false then we need to add            
            expr_true_false_set->data[index].false_branch_state |= (BOOLEAN_FLAG_TRUE | BOOLEAN_FLAG_FALSE);

        }

        arena_restore_current_state_from(ctx, original_state_number);
        arena_remove_state(ctx, original_state_number);
        true_false_set_destroy(&left_set);
        true_false_set_destroy(&right_set);
    }
    break;

    case INCLUSIVE_OR_EXPRESSION:
    {
        assert(p_expression->right != NULL);
        assert(p_expression->left != NULL);

        // A | B
        struct true_false_set true_false_set = { 0 };

        flow_visit_expression(ctx, p_expression->left, &true_false_set);
        flow_visit_expression(ctx, p_expression->right, &true_false_set);

        true_false_set_destroy(&true_false_set);
    }
    break;

    case AND_EXPRESSION:
    case EXCLUSIVE_OR_EXPRESSION:

        assert(p_expression->right != NULL);
        assert(p_expression->left != NULL);

        flow_visit_expression(ctx, p_expression->left, expr_true_false_set);
        flow_visit_expression(ctx, p_expression->right, expr_true_false_set);


        break;

    case UNARY_EXPRESSION_TRAITS:
    {

    }
    break;

    case UNARY_EXPRESSION_IS_SAME:
        break;

    case UNARY_DECLARATOR_ATTRIBUTE_EXPR:
        break;

    case CONDITIONAL_EXPRESSION:
    {
        assert(p_expression->condition_expr != NULL);
        assert(p_expression->right != NULL);
        assert(p_expression->left != NULL);


        struct true_false_set true_false_set = { 0 };

        flow_check_pointer_used_as_bool(ctx, p_expression->condition_expr);
        flow_visit_expression(ctx, p_expression->condition_expr, &true_false_set);

        const int before_if_state_number = arena_add_copy_of_current_state(ctx, "before-if");

        true_false_set_set_objects_to_true_branch(ctx, &true_false_set, nullable_enabled);

        struct true_false_set set = { 0 };
        flow_visit_expression(ctx, p_expression->left, &set);
        true_false_set_destroy(&set);


        const int left_true_branch_state_number = arena_add_copy_of_current_state(ctx, "left-true-branch");

        arena_restore_current_state_from(ctx, before_if_state_number);

        true_false_set_set_objects_to_false_branch(ctx, &true_false_set, nullable_enabled);

        struct true_false_set set2 = { 0 };
        flow_visit_expression(ctx, p_expression->right, &set2);
        true_false_set_destroy(&set2);

        arena_merge_current_state_with_state_number(ctx, left_true_branch_state_number);

        arena_restore_current_state_from(ctx, left_true_branch_state_number);
        arena_remove_state(ctx, before_if_state_number);
        arena_remove_state(ctx, left_true_branch_state_number);
        true_false_set_destroy(&true_false_set);
    }
    break;

    }
}
static void flow_visit_expression_statement(struct flow_visit_ctx* ctx, struct expression_statement* p_expression_statement)
{
    struct true_false_set d = { 0 };
    if (p_expression_statement->expression_opt)
        flow_visit_expression(ctx, p_expression_statement->expression_opt, &d);
    true_false_set_destroy(&d);

}

static void flow_visit_block_item_list(struct flow_visit_ctx* ctx, struct block_item_list* p_block_item_list);

static void flow_visit_compound_statement(struct flow_visit_ctx* ctx, struct compound_statement* p_compound_statement)
{

    struct flow_defer_scope* _Opt p_defer = flow_visit_ctx_push_tail_block(ctx);
    if (p_defer == NULL)
    {
        return;
    }

    p_defer->p_compound_statement = p_compound_statement;

    flow_visit_block_item_list(ctx, &p_compound_statement->block_item_list);

    flow_exit_block_visit(ctx, p_defer, p_compound_statement->last_token);

    flow_end_of_storage_visit(ctx, p_defer, p_compound_statement->last_token);
    flow_visit_ctx_pop_tail_block(ctx);
}

static void flow_visit_do_while_statement(struct flow_visit_ctx* ctx, struct iteration_statement* p_iteration_statement)
{
    assert(p_iteration_statement->first_token->type == TK_KEYWORD_DO);
    const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;

    struct true_false_set true_false_set = { 0 };

    try
    {
        if (p_iteration_statement->expression1)
        {
            flow_visit_expression(ctx, p_iteration_statement->expression1, &true_false_set);
        }

        struct flow_defer_scope* _Opt p_defer = flow_visit_ctx_push_tail_block(ctx);
        if (p_defer == NULL) throw;

        p_defer->p_iteration_statement = p_iteration_statement;

        flow_visit_secondary_block(ctx, p_iteration_statement->secondary_block);

        flow_exit_block_visit(ctx, p_defer, p_iteration_statement->secondary_block->last_token);

        flow_end_of_storage_visit(ctx, p_defer, p_iteration_statement->secondary_block->last_token);
        flow_visit_ctx_pop_tail_block(ctx);

        bool was_last_statement_inside_true_branch_return =
            secondary_block_ends_with_jump(p_iteration_statement->secondary_block);


        if (was_last_statement_inside_true_branch_return)
        {
            //restore_state(ctx, 0);
            //if (p_object_compared_with_not_null)
            //{
                //do {}  while (p);
              //  p_object_compared_with_not_null->state = OBJECT_STATE_NULL;
            //}
        }
        else
        {
            //do { } while (p);
            true_false_set_set_objects_to_false_branch(ctx, &true_false_set, nullable_enabled);
        }
    }
    catch
    {
    }

    true_false_set_destroy(&true_false_set);
}

static void flow_visit_while_statement(struct flow_visit_ctx* ctx, struct iteration_statement* p_iteration_statement)
{
    assert(p_iteration_statement->first_token->type == TK_KEYWORD_WHILE);

    if (p_iteration_statement->expression1 == NULL)
        return;

    const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;

    const int old_initial_state = ctx->initial_state;
    const int old_break_join_state = ctx->break_join_state;

    ctx->initial_state = arena_add_copy_of_current_state(ctx, "original");
    ctx->break_join_state = arena_add_empty_state(ctx, "break join");

    struct true_false_set true_false_set = { 0 };

    /*
        we do like this to acumulate states.

        if (expression)
        {
           statements...
           if (expression)
           {
             statements...
           }
        }
        break_exit:
    */

    //We do a visit but this is not conclusive..so we ignore warnings
    diagnostic_stack_push_empty(&ctx->ctx->options.diagnostic_stack);
    flow_visit_expression(ctx, p_iteration_statement->expression1, &true_false_set);
    struct flow_defer_scope* _Opt p_defer = flow_visit_ctx_push_tail_block(ctx);
    if (p_defer == NULL)
    {
        true_false_set_destroy(&true_false_set);
        return;
    }

    p_defer->p_iteration_statement = p_iteration_statement;
    true_false_set_set_objects_to_true_branch(ctx, &true_false_set, nullable_enabled);

    flow_visit_secondary_block(ctx, p_iteration_statement->secondary_block);

    //Second pass warning is ON
    diagnostic_stack_pop(&ctx->ctx->options.diagnostic_stack);

    struct true_false_set true_false_set2 = { 0 };
    flow_visit_expression(ctx, p_iteration_statement->expression1, &true_false_set2);
    true_false_set_destroy(&true_false_set2);

    //visit secondary_block again
    true_false_set_set_objects_to_true_branch(ctx, &true_false_set, nullable_enabled);
    flow_visit_secondary_block(ctx, p_iteration_statement->secondary_block);

    flow_exit_block_visit(ctx, p_defer, p_iteration_statement->secondary_block->last_token);


    const bool was_last_statement_inside_true_branch_return =
        secondary_block_ends_with_jump(p_iteration_statement->secondary_block);

    if (was_last_statement_inside_true_branch_return)
    {
        /*
           while (p) { return; }
        */
        arena_restore_current_state_from(ctx, ctx->initial_state);
        true_false_set_set_objects_to_false_branch(ctx, &true_false_set, nullable_enabled);
    }
    else
    {
        true_false_set_set_objects_to_false_branch(ctx, &true_false_set, nullable_enabled);
        arena_merge_current_state_with_state_number(ctx, ctx->break_join_state);
        arena_restore_current_state_from(ctx, ctx->break_join_state);
    }

    flow_end_of_storage_visit(ctx, p_defer, p_iteration_statement->secondary_block->last_token);
    flow_visit_ctx_pop_tail_block(ctx);

    arena_remove_state(ctx, ctx->initial_state);
    arena_remove_state(ctx, ctx->break_join_state);


    //restore
    ctx->initial_state = old_initial_state;
    ctx->break_join_state = old_break_join_state;
    true_false_set_destroy(&true_false_set);
}

static void flow_visit_for_statement(struct flow_visit_ctx* ctx, struct iteration_statement* p_iteration_statement)
{
    /*
      TODO
       {
        int i = 0;
        if (condition)
        {
            //second-block
            i++;
            if (condition)
            {
                //second-block
                i++;
                //recursive
            }
        }
    }
    */

    assert(p_iteration_statement->first_token->type == TK_KEYWORD_FOR);

    struct true_false_set d = { 0 };

    try
    {
        if (p_iteration_statement->declaration &&
            p_iteration_statement->declaration->init_declarator_list.head)
        {
            flow_visit_init_declarator_list(ctx, &p_iteration_statement->declaration->init_declarator_list);
        }

        if (p_iteration_statement->expression0)
        {
            flow_visit_expression(ctx, p_iteration_statement->expression0, &d);
        }

        if (p_iteration_statement->expression1)
        {
            flow_check_pointer_used_as_bool(ctx, p_iteration_statement->expression1);
            flow_visit_expression(ctx, p_iteration_statement->expression1, &d);
        }

        //TODO we need to merge states inside loops

        //Disable warning because the state is temporary..missing a visit
        diagnostic_stack_push_empty(&ctx->ctx->options.diagnostic_stack);

        struct flow_defer_scope* _Opt p_defer = flow_visit_ctx_push_tail_block(ctx);
        if (p_defer == NULL)
            throw;

        p_defer->p_iteration_statement = p_iteration_statement;
        flow_visit_secondary_block(ctx, p_iteration_statement->secondary_block);
        flow_visit_ctx_pop_tail_block(ctx);

        diagnostic_stack_pop(&ctx->ctx->options.diagnostic_stack);


        if (p_iteration_statement->expression2)
        {
            flow_visit_expression(ctx, p_iteration_statement->expression2, &d);
        }
        const bool b_secondary_block_ends_with_jump =
            secondary_block_ends_with_jump(p_iteration_statement->secondary_block);

        /*we visit again*/
        if (!b_secondary_block_ends_with_jump)
        {
            struct flow_defer_scope* _Opt p_defer2 = flow_visit_ctx_push_tail_block(ctx);
            if (p_defer2 == NULL) throw;

            p_defer2->p_iteration_statement = p_iteration_statement;
            flow_visit_secondary_block(ctx, p_iteration_statement->secondary_block);

            flow_exit_block_visit(ctx, p_defer2, p_iteration_statement->secondary_block->last_token);

            flow_end_of_storage_visit(ctx, p_defer2, p_iteration_statement->secondary_block->last_token);
            flow_visit_ctx_pop_tail_block(ctx);
        }

    }
    catch
    {
    }
    true_false_set_destroy(&d);
}


static void flow_visit_iteration_statement(struct flow_visit_ctx* ctx, struct iteration_statement* p_iteration_statement)
{
    switch (p_iteration_statement->first_token->type)
    {
    case  TK_KEYWORD_WHILE:
        flow_visit_while_statement(ctx, p_iteration_statement);
        break;
    case TK_KEYWORD_DO:
        flow_visit_do_while_statement(ctx, p_iteration_statement);
        break;
    case TK_KEYWORD_FOR:
        flow_visit_for_statement(ctx, p_iteration_statement);
        break;
    default:
        assert(false);
        break;
    }
}

static void flow_visit_jump_statement(struct flow_visit_ctx* ctx, struct jump_statement* p_jump_statement)
{
    assert(ctx->tail_block != NULL);

    const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;
    try
    {
        if (p_jump_statement->first_token->type == TK_KEYWORD_THROW)
        {
            arena_merge_current_state_with_state_number(ctx, ctx->throw_join_state);
            assert(ctx->tail_block != NULL);
            check_all_defer_until_try(ctx, ctx->tail_block, p_jump_statement->first_token);
        }
        else if (p_jump_statement->first_token->type == TK_KEYWORD_RETURN)
        {
            if (ctx->p_return_type == NULL)
            {
                //we must be inside a function and we need this return set.
                throw;
            }

            if (p_jump_statement->expression_opt)
            {
                struct true_false_set d = { 0 };
                flow_visit_expression(ctx, p_jump_statement->expression_opt, &d);
                true_false_set_destroy(&d);
            }

            /*
              returning a declarator will move the ownership
            */
            if (p_jump_statement->expression_opt)
            {
                struct flow_object* _Opt p_object =
                    expression_get_object(ctx, p_jump_statement->expression_opt, nullable_enabled);

                if (p_object)
                {
                    assert(ctx->p_return_type != NULL);
                    struct flow_object* _Opt p_dest_object =
                        make_object(ctx, ctx->p_return_type, NULL, p_jump_statement->expression_opt);

                    if (p_dest_object == NULL)
                    {
                        throw;
                    }

                    assert(ctx->p_return_type != NULL);
                    object_set_zero(ctx->p_return_type, p_dest_object);

                    struct marker a_marker = {
                       .p_token_begin = p_jump_statement->expression_opt->first_token,
                       .p_token_end = p_jump_statement->expression_opt->last_token,
                    };
                    struct marker b_marker = {
                       .p_token_begin = p_jump_statement->expression_opt->first_token,
                       .p_token_end = p_jump_statement->expression_opt->last_token,
                    };

                    assert(ctx->p_return_type != NULL);

                    flow_check_assignment(ctx,
                     p_jump_statement->expression_opt->first_token,
                     &a_marker,
                     &b_marker,
                     ASSIGMENT_TYPE_RETURN,
                     true,
                        type_is_view(ctx->p_return_type), /*dest type*/
                        type_is_nullable(ctx->p_return_type, ctx->ctx->options.null_checks_enabled), /*dest type*/
                        ctx->p_return_type, /*dest type*/
                        p_dest_object, /*dest object*/
                        &p_jump_statement->expression_opt->type, /*source type*/
                        p_object, /*source*/
                        NULL
                    );

                    //WTF??
                    //p_dest_object->current.state = OBJECT_STATE_LIFE_TIME_ENDED;
                }

                if (p_object && p_object->is_temporary)
                {
                    //a + b
                    p_object->current.state = OBJECT_STATE_LIFE_TIME_ENDED;
                }

            }

            assert(ctx->tail_block != NULL);
            flow_exit_function_visit(ctx, ctx->tail_block, p_jump_statement->first_token);
        }
        else if (p_jump_statement->first_token->type == TK_KEYWORD_CONTINUE)
        {

            check_all_defer_until_iter(ctx, ctx->tail_block, p_jump_statement->first_token);
        }
        else if (p_jump_statement->first_token->type == TK_KEYWORD_BREAK)
        {
            assert(ctx->tail_block != NULL);
            arena_merge_current_state_with_state_number(ctx, ctx->break_join_state);

            assert(ctx->tail_block != NULL);
            flow_exit_iteration_or_switch_statement_visit(ctx, ctx->tail_block, p_jump_statement->first_token);
        }
        else if (p_jump_statement->first_token->type == TK_KEYWORD_GOTO)
        {
            //goto needs a label
            assert(p_jump_statement->label != NULL);

            int label_state_number = -1;
            for (int i = 0; i < ctx->labels_size; i++)
            {
                if (ctx->labels[i].state_number == label_state_number)
                {
                    break; //already exist
                }
            }
            if (label_state_number == -1)
            {
                label_state_number = arena_add_empty_state(ctx, p_jump_statement->label->lexeme);
                ctx->labels[ctx->labels_size].state_number = label_state_number;
                ctx->labels[ctx->labels_size].label_name = p_jump_statement->label->lexeme;
                ctx->labels_size++;
            }

            arena_merge_current_state_with_state_number(ctx, label_state_number);

            assert(ctx->tail_block != NULL);
            check_all_defer_until_label(ctx, ctx->tail_block, p_jump_statement->label->lexeme, p_jump_statement->first_token);
        }
        else
        {
            assert(false);
        }
    }
    catch
    {
    }
}

static void flow_visit_label(struct flow_visit_ctx* ctx, struct label* p_label);

static void flow_visit_labeled_statement(struct flow_visit_ctx* ctx, struct labeled_statement* p_labeled_statement)
{
    flow_visit_label(ctx, p_labeled_statement->label);
    flow_visit_statement(ctx, p_labeled_statement->statement);
}

static void flow_visit_primary_block(struct flow_visit_ctx* ctx, struct primary_block* p_primary_block)
{

    if (p_primary_block->defer_statement)
    {
        flow_visit_defer_statement(ctx, p_primary_block->defer_statement);
    }
    else
    {
        if (p_primary_block->compound_statement)
        {
            flow_visit_compound_statement(ctx, p_primary_block->compound_statement);
        }
        else if (p_primary_block->iteration_statement)
        {
            flow_visit_iteration_statement(ctx, p_primary_block->iteration_statement);
        }
        else if (p_primary_block->selection_statement)
        {
            flow_visit_selection_statement(ctx, p_primary_block->selection_statement);
        }
        else if (p_primary_block->try_statement)
        {
            flow_visit_try_statement(ctx, p_primary_block->try_statement);
        }
    }
}

static void flow_visit_unlabeled_statement(struct flow_visit_ctx* ctx, struct unlabeled_statement* p_unlabeled_statement)
{

    if (p_unlabeled_statement->primary_block)
    {
        flow_visit_primary_block(ctx, p_unlabeled_statement->primary_block);
    }
    else if (p_unlabeled_statement->expression_statement)
    {
        flow_visit_expression_statement(ctx, p_unlabeled_statement->expression_statement);
    }
    else if (p_unlabeled_statement->jump_statement)
    {
        flow_visit_jump_statement(ctx, p_unlabeled_statement->jump_statement);
    }
    else
    {
        assert(false);
    }
}

static void flow_visit_statement(struct flow_visit_ctx* ctx, struct statement* p_statement)
{
    if (p_statement->labeled_statement)
    {
        flow_visit_labeled_statement(ctx, p_statement->labeled_statement);
    }
    else if (p_statement->unlabeled_statement)
    {
        flow_visit_unlabeled_statement(ctx, p_statement->unlabeled_statement);
    }
}

static void flow_visit_label(struct flow_visit_ctx* ctx, struct label* p_label)
{

    if (p_label->p_identifier_opt)
    {
        for (int i = 0; i < ctx->labels_size; i++)
        {
            if (strcmp(ctx->labels[i].label_name, p_label->p_identifier_opt->lexeme) == 0)
            {

                arena_restore_current_state_from(ctx, ctx->labels[i].state_number);

                break; //already exist
            }
        }
    }
    else
    {
        //case, default
        arena_restore_current_state_from(ctx, ctx->initial_state);
    }
}

static void flow_visit_block_item(struct flow_visit_ctx* ctx, struct block_item* p_block_item)
{

    if (p_block_item->declaration)
    {
        flow_visit_declaration(ctx, p_block_item->declaration);
    }
    else if (p_block_item->unlabeled_statement)
    {
        flow_visit_unlabeled_statement(ctx, p_block_item->unlabeled_statement);
    }
    else if (p_block_item->label)
    {
        flow_visit_label(ctx, p_block_item->label);
    }

}

static void flow_visit_block_item_list(struct flow_visit_ctx* ctx, struct block_item_list* p_block_item_list)
{
    struct block_item* _Opt p_block_item = p_block_item_list->head;
    while (p_block_item)
    {
        flow_visit_block_item(ctx, p_block_item);
        p_block_item = p_block_item->next;
    }
}

static enum object_state parse_string_state(const char* s, bool* invalid)
{
    //TODO faling with _
    *invalid = false;

    enum object_state e = 0;
    const char* p = s;

    while (*p)
    {
        if (isalpha(*p))
        {
            int sz = 0;
            const char* start = p;
            while (isalpha(*p) || *p == '-')
            {
                sz++;
                p++;
            }

            if (strncmp(start, "moved", sz) == 0)
                e |= OBJECT_STATE_MOVED;

            else if (strncmp(start, "null", sz) == 0)
                e |= OBJECT_STATE_NULL;
            else if (strncmp(start, "not-null", sz) == 0)
                e |= OBJECT_STATE_NOT_NULL;
            else if (strncmp(start, "maybe-null", sz) == 0)
                e |= (OBJECT_STATE_NOT_NULL | OBJECT_STATE_NULL);
            else if (strncmp(start, "uninitialized", sz) == 0)
                e |= OBJECT_STATE_UNINITIALIZED;
            else if (strncmp(start, "zero", sz) == 0)
                e |= OBJECT_STATE_ZERO;
            else if (strncmp(start, "not-zero", sz) == 0)
                e |= OBJECT_STATE_NOT_ZERO;
            else if (strncmp(start, "any", sz) == 0)
                e |= (OBJECT_STATE_NOT_ZERO | OBJECT_STATE_ZERO);
            else
            {
                *invalid = true;
                return 0; //error invalid name
            }
        }
        else
        {
            p++;
        }
    }

    return e;

}


static void flow_visit_pragma_declaration(struct flow_visit_ctx* ctx, struct pragma_declaration* p_pragma_declaration)
{
    execute_pragma(ctx->ctx, p_pragma_declaration, true);
}

static void flow_visit_static_assert_declaration(struct flow_visit_ctx* ctx, struct static_assert_declaration* p_static_assert_declaration)
{
    const bool t2 = ctx->expression_is_not_evaluated;
    ctx->expression_is_not_evaluated = true;
    const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;

    struct true_false_set a = { 0 };
    flow_visit_expression(ctx, p_static_assert_declaration->constant_expression, &a);

    ctx->expression_is_not_evaluated = t2; //restore


    if (p_static_assert_declaration->first_token->type == TK_KEYWORD_STATIC_DEBUG ||
        p_static_assert_declaration->first_token->type == TK_KEYWORD_STATIC_DEBUG_EX)
    {
        bool ex = p_static_assert_declaration->first_token->type == TK_KEYWORD_STATIC_DEBUG_EX;

        compiler_diagnostic_message(W_LOCATION, ctx->ctx, p_static_assert_declaration->first_token, NULL, "static_debug");

        struct flow_object* _Opt p_obj =
            expression_get_object(ctx, p_static_assert_declaration->constant_expression, nullable_enabled);

        if (p_obj)
        {
            print_object(&p_static_assert_declaration->constant_expression->type, p_obj, !ex);
            if (p_obj->is_temporary)
            {
                p_obj->current.state = OBJECT_STATE_LIFE_TIME_ENDED;
            }
        }

        if (ex)
        {
            print_arena(ctx);
        }
    }
    else if (p_static_assert_declaration->first_token->type == TK_KEYWORD_STATIC_STATE)
    {
        /*TODO
           check state

        */

        bool is_invalid = false;
        enum object_state e = 0;
        if (p_static_assert_declaration->string_literal_opt)
            e = parse_string_state(p_static_assert_declaration->string_literal_opt->lexeme, &is_invalid);
        if (is_invalid)
        {
            compiler_diagnostic_message(C_ANALIZER_ERROR_STATIC_STATE_FAILED, ctx->ctx, p_static_assert_declaration->first_token, NULL, "invalid parameter %s", p_static_assert_declaration->string_literal_opt->lexeme);
        }
        else
        {

            struct flow_object* _Opt p_obj =
                expression_get_object(ctx, p_static_assert_declaration->constant_expression, nullable_enabled);
            if (p_obj)
            {


                if (e != p_obj->current.state)
                {
                    compiler_diagnostic_message(C_ANALIZER_ERROR_STATIC_STATE_FAILED, ctx->ctx, p_static_assert_declaration->first_token, NULL, "static_state failed");
                    if (p_static_assert_declaration->string_literal_opt)
                        printf("expected :%s\n", p_static_assert_declaration->string_literal_opt->lexeme);
                    printf("current  :");
                    flow_object_print_state(p_obj);
                    printf("\n");
                }
            }
            else
            {
                if (e != OBJECT_STATE_NOT_APPLICABLE)
                {
                    compiler_diagnostic_message(C_ANALIZER_ERROR_STATIC_STATE_FAILED, ctx->ctx, p_static_assert_declaration->first_token, NULL, "static_state failed");
                }
            }

            if (p_obj && p_obj->is_temporary)
            {
                p_obj->current.state = OBJECT_STATE_LIFE_TIME_ENDED;
            }

        }
    }
    else if (p_static_assert_declaration->first_token->type == TK_KEYWORD_STATIC_SET)
    {


        struct flow_object* _Opt p_obj =
            expression_get_object(ctx, p_static_assert_declaration->constant_expression, nullable_enabled);

        if (p_obj)
        {
            if (p_static_assert_declaration->string_literal_opt)
            {

                const char* lexeme =
                    p_static_assert_declaration->string_literal_opt->lexeme;

                if (strcmp(lexeme, "\"zero\"") == 0)
                {
                    //gives the semantics of {0} or calloc
                    object_set_zero(&p_static_assert_declaration->constant_expression->type, p_obj);
                }
                else
                {
                    bool is_invalid = false;
                    enum object_state e =
                        parse_string_state(p_static_assert_declaration->string_literal_opt->lexeme, &is_invalid);

                    if (!is_invalid)
                    {
                        if (p_obj->members.size > 0)
                        {
                            compiler_diagnostic_message(C_ERROR_STATIC_SET, ctx->ctx, p_static_assert_declaration->first_token, NULL, "use only for non agregates");
                        }
                        p_obj->current.state = e;
                    }
                    else
                    {
                        compiler_diagnostic_message(C_ERROR_STATIC_SET, ctx->ctx, p_static_assert_declaration->first_token, NULL, "invalid parameter %s", p_static_assert_declaration->string_literal_opt->lexeme);
                    }
                }
            }

        }
        if (p_obj && p_obj->is_temporary)
        {
            p_obj->current.state = OBJECT_STATE_LIFE_TIME_ENDED;
        }

    }

    true_false_set_destroy(&a);
}

static void flow_visit_direct_declarator(struct flow_visit_ctx* ctx, struct direct_declarator* p_direct_declarator)
{
    if (p_direct_declarator->function_declarator)
    {
        struct parameter_declaration* _Opt parameter = NULL;

        if (p_direct_declarator->function_declarator->parameter_type_list_opt &&
            p_direct_declarator->function_declarator->parameter_type_list_opt->parameter_list)
        {
            parameter = p_direct_declarator->function_declarator->parameter_type_list_opt->parameter_list->head;
        }

        ctx->parameter_list++;

        while (parameter)
        {
            if (parameter->attribute_specifier_sequence_opt)
            {
                flow_visit_attribute_specifier_sequence(ctx, parameter->attribute_specifier_sequence_opt);
            }

            flow_visit_declaration_specifiers(ctx, parameter->declaration_specifiers, &parameter->declarator->type);

            if (parameter->declarator)
            {
                flow_visit_declarator(ctx, parameter->declarator);
            }

            parameter = parameter->next;
        }

        ctx->parameter_list--;

    }
    else if (p_direct_declarator->array_declarator)
    {
        if (p_direct_declarator->array_declarator->assignment_expression)
        {
            struct true_false_set a = { 0 };
            flow_visit_expression(ctx, p_direct_declarator->array_declarator->assignment_expression, &a);
            true_false_set_destroy(&a);
        }

    }
}

static void flow_visit_declarator(struct flow_visit_ctx* ctx, struct declarator* p_declarator)
{
    const bool nullable_enabled = ctx->ctx->options.null_checks_enabled;
    try
    {
        if (ctx->tail_block &&
            p_declarator->type.category != TYPE_CATEGORY_FUNCTION)
        {

            if (ctx->parameter_list > 1)
            {
                /*
                 The objective here is to avoid including the arguments
                 of function pointers inside the scope.
                 Sample
                 void x_destroy(void (*f)(void * _Owner p))
                 We add f but not p.
                */
                return;
            }

            struct flow_defer_scope* _Opt p_defer = flow_visit_ctx_push_child(ctx);
            if (p_defer == NULL) throw;

            p_defer->declarator = p_declarator;


            p_declarator->p_object = make_object(ctx, &p_declarator->type, p_declarator, NULL);
            if (p_declarator->p_object == NULL)
            {
                throw;
            }

            object_set_uninitialized(&p_declarator->type, p_declarator->p_object);


            if (p_declarator->declaration_specifiers &&
                p_declarator->declaration_specifiers->storage_class_specifier_flags & STORAGE_SPECIFIER_PARAMETER)
            {
                if (type_is_pointer(&p_declarator->type))
                {
                    if (type_is_nullable(&p_declarator->type, ctx->ctx->options.null_checks_enabled))
                    {
                        p_declarator->p_object->current.state = OBJECT_STATE_NOT_NULL | OBJECT_STATE_NULL;
                    }
                    else
                    {
                        p_declarator->p_object->current.state = OBJECT_STATE_NOT_NULL;
                    }

                    if (type_is_pointer_to_out(&p_declarator->type))
                    {
                        struct type t = type_remove_pointer(&p_declarator->type);
                        struct flow_object* _Opt po = make_object(ctx, &t, p_declarator, NULL);
                        if (po == NULL)
                        {
                            type_destroy(&t);
                            throw;
                        }
                        object_set_uninitialized(&t, po);
                        object_set_pointer(p_declarator->p_object, po); //MOVED                    
                        type_destroy(&t);
                    }
                    else if (type_is_any_owner(&p_declarator->type))
                    {
                        struct type t = type_remove_pointer(&p_declarator->type);
                        struct flow_object* _Opt po = make_object(ctx, &t, p_declarator, NULL);
                        if (po == NULL)
                        {
                            type_destroy(&t);
                            throw;
                        }
                        const bool t_is_nullable = type_is_nullable(&t, ctx->ctx->options.null_checks_enabled);
                        object_set_unknown(&t, t_is_nullable, po, nullable_enabled);
                        object_set_pointer(p_declarator->p_object, po); //MOVED                    
                        type_destroy(&t);
                    }
                }
                else if (type_is_struct_or_union(&p_declarator->type))
                {
                    const bool is_nullable = type_is_nullable(&p_declarator->type, nullable_enabled);
                    object_set_unknown(&p_declarator->type, is_nullable, p_declarator->p_object, nullable_enabled);
                }
                else if (type_is_array(&p_declarator->type))
                {
                    // assert(false);//TODO
                     //object_set_unknown(&p_declarator->type, &p_declarator->object);
                    p_declarator->p_object->current.state = OBJECT_STATE_NOT_ZERO;
                }
                else
                {
                    p_declarator->p_object->current.state = OBJECT_STATE_ZERO | OBJECT_STATE_NOT_ZERO;
                }


#if 0
                if (type_is_pointer(&p_declarator->type))
                {
                    //TODO necessary?
                    struct type t2 = type_remove_pointer(&p_declarator->type);
                    if (p_declarator->p_object->pointed)
                    {
                        set_object(&t2, p_declarator->p_object->pointed, (OBJECT_STATE_NOT_NULL | OBJECT_STATE_NULL));
                }
                    type_destroy(&t2);
            }
#endif
        }
    }

        /*if (p_declarator->pointer)
        {
            struct pointer* p = p_declarator->pointer;
            while (p)
            {
                p = p->pointer;
            }
        }*/


        if (p_declarator->direct_declarator)
        {
            flow_visit_direct_declarator(ctx, p_declarator->direct_declarator);
        }
}
    catch
    {
    }
}

static void flow_visit_init_declarator_list(struct flow_visit_ctx* ctx, struct init_declarator_list* p_init_declarator_list)
{
    struct init_declarator* _Opt p_init_declarator = p_init_declarator_list->head;
    while (p_init_declarator)
    {
        flow_visit_init_declarator(ctx, p_init_declarator);
        p_init_declarator = p_init_declarator->next;
    }
}

static void flow_visit_member_declarator(struct flow_visit_ctx* ctx, struct member_declarator* p_member_declarator)
{
    if (p_member_declarator->declarator)
    {
        flow_visit_declarator(ctx, p_member_declarator->declarator);
    }
}

static void flow_visit_member_declarator_list(struct flow_visit_ctx* ctx, struct member_declarator_list* p_member_declarator_list)
{
    struct member_declarator* _Opt p_member_declarator = p_member_declarator_list->head;
    while (p_member_declarator)
    {
        flow_visit_member_declarator(ctx, p_member_declarator);
        p_member_declarator = p_member_declarator->next;
    }
}

static void flow_visit_member_declaration(struct flow_visit_ctx* ctx, struct member_declaration* p_member_declaration)
{
    if (p_member_declaration->member_declarator_list_opt)
    {
        flow_visit_specifier_qualifier_list(ctx,
            p_member_declaration->specifier_qualifier_list,
            &p_member_declaration->member_declarator_list_opt->head->declarator->type); /*se nao tem?*/
    }

    if (p_member_declaration->member_declarator_list_opt)
    {
        flow_visit_member_declarator_list(ctx, p_member_declaration->member_declarator_list_opt);
    }
}

static void flow_visit_member_declaration_list(struct flow_visit_ctx* ctx, struct member_declaration_list* p_member_declaration_list)
{
    struct member_declaration* _Opt p_member_declaration = p_member_declaration_list->head;
    while (p_member_declaration)
    {
        flow_visit_member_declaration(ctx, p_member_declaration);
        p_member_declaration = p_member_declaration->next;
    }
}

static void flow_visit_attribute_specifier(struct flow_visit_ctx* ctx, struct attribute_specifier* p_attribute_specifier)
{

}

static void flow_visit_attribute_specifier_sequence(struct flow_visit_ctx* ctx, struct attribute_specifier_sequence* p_visit_attribute_specifier_sequence)
{
    struct attribute_specifier* _Opt current = p_visit_attribute_specifier_sequence->head;
    while (current)
    {
        flow_visit_attribute_specifier(ctx, current);
        current = current->next;
    }
}

static void flow_visit_struct_or_union_specifier(struct flow_visit_ctx* ctx, struct struct_or_union_specifier* p_struct_or_union_specifier)
{

    if (p_struct_or_union_specifier->attribute_specifier_sequence_opt)
        flow_visit_attribute_specifier_sequence(ctx, p_struct_or_union_specifier->attribute_specifier_sequence_opt);

    //struct struct_or_union_specifier* p_complete = get_complete_struct_or_union_specifier(p_struct_or_union_specifier);


    flow_visit_member_declaration_list(ctx, &p_struct_or_union_specifier->member_declaration_list);

}

static void flow_visit_enumerator(struct flow_visit_ctx* ctx, struct enumerator* p_enumerator)
{
    struct true_false_set a = { 0 };
    if (p_enumerator->constant_expression_opt)
        flow_visit_expression(ctx, p_enumerator->constant_expression_opt, &a);
    true_false_set_destroy(&a);

}

static void flow_visit_enumerator_list(struct flow_visit_ctx* ctx, struct enumerator_list* p_enumerator_list)
{
    struct enumerator* _Opt current = p_enumerator_list->head;
    while (current)
    {
        flow_visit_enumerator(ctx, current);
        current = current->next;
    }
}

static void flow_visit_enum_specifier(struct flow_visit_ctx* ctx, struct enum_specifier* p_enum_specifier)
{
    if (p_enum_specifier->attribute_specifier_sequence_opt)
    {
        flow_visit_attribute_specifier_sequence(ctx, p_enum_specifier->attribute_specifier_sequence_opt);
    }

    flow_visit_enumerator_list(ctx, &p_enum_specifier->enumerator_list);
}

static void flow_visit_typeof_specifier(struct flow_visit_ctx* ctx, struct typeof_specifier* p_typeof_specifier)
{}

static void flow_visit_type_specifier(struct flow_visit_ctx* ctx, struct type_specifier* p_type_specifier)
{
    if (p_type_specifier->typeof_specifier)
    {
        flow_visit_typeof_specifier(ctx, p_type_specifier->typeof_specifier);
    }

    if (p_type_specifier->struct_or_union_specifier)
    {
        flow_visit_struct_or_union_specifier(ctx, p_type_specifier->struct_or_union_specifier);
    }

    if (p_type_specifier->enum_specifier)
    {
        flow_visit_enum_specifier(ctx, p_type_specifier->enum_specifier);
    }


    if (p_type_specifier->atomic_type_specifier)
    {
        //visit_deped(ctx, p_type_specifier->enum_specifier);
    }

}

static void flow_visit_type_specifier_qualifier(struct flow_visit_ctx* ctx, struct type_specifier_qualifier* p_type_specifier_qualifier)
{
    if (p_type_specifier_qualifier->type_qualifier)
    {
    }
    else if (p_type_specifier_qualifier->type_specifier)
    {
        flow_visit_type_specifier(ctx, p_type_specifier_qualifier->type_specifier);
    }
    else if (p_type_specifier_qualifier->alignment_specifier)
    {
    }
}

static void flow_visit_storage_class_specifier(struct flow_visit_ctx* ctx, struct storage_class_specifier* p_storage_class_specifier)
{
    if (p_storage_class_specifier->flags & STORAGE_SPECIFIER_AUTO)
    {

    }
}

static void flow_visit_declaration_specifier(struct flow_visit_ctx* ctx, struct declaration_specifier* p_declaration_specifier)
{

    if (p_declaration_specifier->function_specifier)
    {

    }


    if (p_declaration_specifier->storage_class_specifier)
    {
        flow_visit_storage_class_specifier(ctx, p_declaration_specifier->storage_class_specifier);

    }

    if (p_declaration_specifier->type_specifier_qualifier)
    {
        flow_visit_type_specifier_qualifier(ctx, p_declaration_specifier->type_specifier_qualifier);

    }

}

static void flow_visit_declaration_specifiers(struct flow_visit_ctx* ctx,
    struct declaration_specifiers* p_declaration_specifiers,
    struct type* _Opt p_type_opt)
{
    /*
        * Se tiver typeof ou auto vamos apagar todos type specifiers.
        * e trocar por um novo
        * const typeof(int (*)()) a;
           //a = 1;
          auto p = (const typeof(int (*)())) 0;

          TODO esconder os type spefiver e qualifider , esconder auto.
          o resto tipo static deixar.

        */
        //

    struct declaration_specifier* _Opt p_declaration_specifier = p_declaration_specifiers->head;


    while (p_declaration_specifier)
    {
        flow_visit_declaration_specifier(ctx, p_declaration_specifier);
        p_declaration_specifier = p_declaration_specifier->next;
    }
}

/*
* retorna true se o ultimo item for um return
*/
static bool flow_is_last_item_return(struct compound_statement* p_compound_statement)
{
#pragma CAKE diagnostic push
#pragma CAKE diagnostic ignored "-Wflow-not-null"

    if (p_compound_statement &&
        p_compound_statement->block_item_list.tail &&
        p_compound_statement->block_item_list.tail->unlabeled_statement &&
        p_compound_statement->block_item_list.tail->unlabeled_statement->jump_statement &&
        p_compound_statement->block_item_list.tail->unlabeled_statement->jump_statement->first_token &&
        p_compound_statement->block_item_list.tail->unlabeled_statement->jump_statement->first_token->type == TK_KEYWORD_RETURN)
    {
        return true;
    }
    return false;

#pragma CAKE diagnostic pop
}

void flow_visit_declaration(struct flow_visit_ctx* ctx, struct declaration* p_declaration)
{
    if (p_declaration->static_assert_declaration)
    {
        flow_visit_static_assert_declaration(ctx, p_declaration->static_assert_declaration);
    }

    if (p_declaration->pragma_declaration)
    {
        flow_visit_pragma_declaration(ctx, p_declaration->pragma_declaration);
    }


    if (p_declaration->p_attribute_specifier_sequence_opt)
    {
        flow_visit_attribute_specifier_sequence(ctx, p_declaration->p_attribute_specifier_sequence_opt);
    }


    if (p_declaration->declaration_specifiers)
    {
        if (p_declaration->init_declarator_list.head)
        {
            flow_visit_declaration_specifiers(ctx, p_declaration->declaration_specifiers,
                &p_declaration->init_declarator_list.head->p_declarator->type);
        }
        else
        {
            flow_visit_declaration_specifiers(ctx, p_declaration->declaration_specifiers, NULL);

        }

    }

    if (p_declaration->p_attribute_specifier_sequence_opt)
    {
    }

    if (p_declaration->init_declarator_list.head)
    {
        flow_visit_init_declarator_list(ctx, &p_declaration->init_declarator_list);
    }

    if (p_declaration->function_body)
    {

        assert(ctx->p_return_type == NULL);

        struct type type = get_function_return_type(&p_declaration->init_declarator_list.head->p_declarator->type);
        ctx->p_return_type = &type;

        //struct flow_defer_scope* p_defer = flow_visit_ctx_push_tail_block(ctx);
        //p_defer->p_statement = p_declaration->function_body;

        flow_visit_compound_statement(ctx, p_declaration->function_body);
        type_destroy(&type);
        ctx->p_return_type = NULL;
    }

}

void flow_start_visit_declaration(struct flow_visit_ctx* ctx, struct declaration* p_declaration)
{
    ctx->labels_size = 0;
    objects_clear(&ctx->arena);


    ctx->state_number_generator = 1; //reserva 0 p current

    if (p_declaration->function_body)
    {

        assert(ctx->tail_block == NULL);
        struct flow_defer_scope* _Opt p_defer = flow_visit_ctx_push_tail_block(ctx);
        if (p_defer == NULL)
        {
            return;
        }
        p_defer->p_function_body = p_declaration->function_body;

        flow_visit_declaration(ctx, p_declaration);
        assert(p_declaration->function_body != NULL); //flow_visit_declaration does not change this

        if (!flow_is_last_item_return(p_declaration->function_body))
        {
            flow_exit_block_visit(ctx, p_defer, p_declaration->function_body->last_token);

        }

        flow_end_of_storage_visit(ctx, p_defer, p_declaration->function_body->last_token);
        flow_visit_ctx_pop_tail_block(ctx);
    }
    else
    {
        struct flow_defer_scope* _Opt p_defer = flow_visit_ctx_push_tail_block(ctx);
        if (p_defer == NULL)
        {
            return;
        }
        flow_visit_declaration(ctx, p_declaration);
        flow_visit_ctx_pop_tail_block(ctx);
    }


    objects_clear(&ctx->arena);
}

#pragma CAKE diagnostic push
#pragma CAKE diagnostic ignored "-Wanalyzer-maybe-uninitialized" 

_Opt struct flow_object* _Opt arena_new_object(struct flow_visit_ctx* ctx)
{
    _Opt struct flow_object* _Owner _Opt p = calloc(1, sizeof * p);
    if (p != NULL)
    {
        p->current.dbg_name = "current";
        p->id = ctx->arena.size + 1;
        if (objects_push_back(&ctx->arena, p) != 0)
        {
            p = NULL;
        }
    }
    return (struct flow_object* _Opt)p; //warning removed
}

#pragma CAKE diagnostic pop


void flow_visit_ctx_destroy(struct flow_visit_ctx* _Obj_owner p)
{
    assert(p->tail_block == NULL);
    objects_destroy(&p->arena);
}

void flow_analysis_visit(struct flow_visit_ctx* ctx)
{
    struct declaration* _Opt p_declaration = ctx->ast.declaration_list.head;
    while (p_declaration)
    {
        flow_visit_declaration(ctx, p_declaration);
        p_declaration = p_declaration->next;
    }
}



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/


#pragma safety enable


#ifdef _WIN32


#include <winerror.h>
//#include <winsock2.h>
#endif

void throw_break_point()
{
    /*
      put a break point here to stop when throw is called
    */
}

const char* get_posix_error_message(int error)
{
    switch (error)
    {
    case EPERM:
        return "Operation not permitted";
    case  ENOENT:
        return "No such file or directory";
    case  ESRCH:
        return "No such process";
    case  EINTR:
        return "Interrupted system call";
    case  EIO:
        return "I/O error";
    case  ENXIO:
        return "No such device or address";
    case  E2BIG:
        return "Arg list too long";
    case  ENOEXEC:
        return "Exec string_format error";
    case  EBADF:
        return "Bad file number";
    case  ECHILD:
        return "No child processes";
    case  EAGAIN:
        return "Try again";
    case  ENOMEM:
        return "Out of memory";
    case  EACCES:
        return "Permission denied";
    case  EFAULT:
        return "Bad address";
    case  EBUSY:
        return "Device or resource busy";
    case  EEXIST:
        return "File exists";
    case  EXDEV:
        return "Cross-device link";
    case  ENODEV:
        return "No such device";
    case  ENOTDIR:
        return "Not a directory";
    case  EISDIR:
        return "Is a directory";
    case  EINVAL:
        return "Invalid argument";
    case  ENFILE:
        return "File table overflow";
    case  EMFILE:
        return "Too many open files";
    case  ENOTTY:
        return "Not a typewriter";
    case  ETXTBSY:
        return "Text file busy";
    case  EFBIG:
        return "File too large";
    case  ENOSPC:
        return "No space left on device";
    case  ESPIPE:
        return "Illegal seek";
    case  EROFS:
        return "Read-only file system";
    case  EMLINK:
        return "Too many links";
    case  EPIPE:
        return "Broken pipe";
    case  EDOM:
        return "Math argument out of domain of func";
    case  ERANGE:
        return "Math result not representable";
    case  EDEADLK:
        return "Resource deadlock would occur";
    case  ENAMETOOLONG:
        return "File name too long";
    case  ENOLCK:
        return "No record locks available";
    case  ENOSYS:
        return "Function not implemented";
    case  ENOTEMPTY:
        return "Directory not empty";
    case  ELOOP:
        return "Too many symbolic links encountered";
        //case  EWOULDBLOCK:
        //case EAGAIN:  return "Operation would block";
    case  ENOMSG:
        return "No message of desired type";
    case  EIDRM:
        return "Identifier removed";
    case  ENOSTR:
        return "Device not a stream";
    case  ENODATA:
        return "No data available";
    case  ETIME:
        return "Timer expired";
    case  ENOSR:
        return "Out of streams resources";

    case  ENOLINK:
        return "Link has been severed";
    case  EPROTO:
        return "Protocol error";
    case  EBADMSG:
        return "Not a data message";
    case  EOVERFLOW:
        return "Value too large for defined data type";
    case  EILSEQ:
        return "Illegal byte sequence";
    case  ENOTSOCK:
        return "Socket operation on non-socket";
    case  EDESTADDRREQ:
        return "Destination address required";
    case  EMSGSIZE:
        return "Message too long";
    case  EPROTOTYPE:
        return "Protocol wrong type for socket";
    case  ENOPROTOOPT:
        return "Protocol not available";
    case  EPROTONOSUPPORT:
        return "Protocol not supported";

    case  EOPNOTSUPP:
        return "Operation not supported on transport endpoint";

    case  EAFNOSUPPORT:
        return "Address family not supported by protocol";
    case  EADDRINUSE:
        return "Address already in use";
    case  EADDRNOTAVAIL:
        return "Cannot assign requested address";
    case  ENETDOWN:
        return "Network is down";
    case  ENETUNREACH:
        return "Network is unreachable";
    case  ENETRESET:
        return "Network dropped connection because of reset";
    case  ECONNABORTED:
        return "Software caused connection abort";
    case  ECONNRESET:
        return "Connection reset by peer";
    case  ENOBUFS:
        return "No buffer space available";
    case  EISCONN:
        return "Transport endpoint is already connected";
    case  ENOTCONN:
        return "Transport endpoint is not connected";

    case  ETIMEDOUT:
        return "Connection timed out";
    case  ECONNREFUSED:
        return "Connection refused";

    case  EHOSTUNREACH:
        return "No route to host";
    case  EALREADY:
        return "Operation already in progress";
    case  EINPROGRESS:
        return "Operation now in progress";
#ifndef _WIN32
    case  ENOTBLK:
        return "Block device required";
#ifndef __APPLE__
    case  ECHRNG:
        return "Channel number out of range";
    case  EL2NSYNC:
        return "Level 2 not synchronized";
    case  EL3HLT:
        return "Level 3 halted";
    case  EL3RST:
        return "Level 3 reset";
    case  ELNRNG:
        return "Link number out of range";
    case  EUNATCH:
        return "Protocol driver not attached";
    case  ENOCSI:
        return "No CSI structure available";
    case  EL2HLT:
        return "Level 2 halted";
    case  EBADE:
        return "Invalid ex   ";
    case  EBADR:
        return "Invalid request descriptor";
    case  EXFULL:
        return "Exchange full";
    case  ENOANO:
        return "No anode";
    case  EBADRQC:
        return "Invalid request code";
    case  EBADSLT:
        return "Invalid slot";

        //case  EDEADLOCK:
        //case EDEADLK:

    case  EBFONT:
        return "Bad font file string_format";
    case  ENONET:
        return "Machine is not on the network";
    case  ENOPKG:
        return "Package not installed";
    case  EREMOTE:
        return "Object is remote";

    case  EMULTIHOP:
        return "Multihop attempted";
    case  EDOTDOT:
        return "RFS specific error";
    case  EADV:
        return "Advertise error";
    case  ESRMNT:
        return "Srmount error";
    case  ECOMM:
        return "Communication error on send";
    case  ERESTART:
        return "Interrupted system call should be restarted";
    case  ESTRPIPE:
        return "Streams pipe error";
    case  EUSERS:
        return "Too many users";
    case  ENOTUNIQ:
        return "Email not unique on network";
    case  EBADFD:
        return "File descriptor in bad state";
    case  EREMCHG:
        return "Remote address changed";
    case  ELIBACC:
        return "Can not access a needed shared library";
    case  ELIBBAD:
        return "Accessing a corrupted shared library";
    case  ELIBSCN:
        return ".lib section in a.out corrupted";
    case  ELIBMAX:
        return "Attempting to link in too many shared libraries";
    case  ELIBEXEC:
        return "Cannot exec a shared library directly";
    case  EUCLEAN:
        return "Structure needs cleaning";
    case  ENOTNAM:
        return "Not a XENIX named type file";
    case  ENAVAIL:
        return "No XENIX semaphores available";
    case  EISNAM:
        return "Is a named type file";
    case  EREMOTEIO:
        return "Remote I/O error";
    case  EDQUOT:
        return "Quota exceeded";
    case  ENOMEDIUM:
        return "No medium found";
    case  EMEDIUMTYPE:
        return "Wrong medium type";
#endif

    case  ESOCKTNOSUPPORT:
        return "Socket type not supported";
    case  EPFNOSUPPORT:
        return "Protocol family not supported";
    case  EHOSTDOWN:
        return "Host is down";
    case  ESHUTDOWN:
        return "Cannot send after transport endpoint shutdown";
    case  ETOOMANYREFS:
        return "Too many references: cannot splice";
    case  ESTALE:
        return "Stale NFS file handle";

#endif
    default:
        break;

    }

    return "Unknown";
}
#ifdef _WIN32


int windows_error_to_posix(int i)
{
    switch (i)
    {
    case ERROR_ACCESS_DENIED:
        return EACCES;
    case ERROR_ALREADY_EXISTS:
        return EEXIST;
    case ERROR_BAD_UNIT:
        return ENODEV;
    case ERROR_BUFFER_OVERFLOW:
        return ENAMETOOLONG;
    case ERROR_BUSY:
        return EBUSY;
    case ERROR_BUSY_DRIVE:
        return EBUSY;
    case ERROR_CANNOT_MAKE:
        return EACCES;
    case ERROR_CANTOPEN:
        return EIO;
    case ERROR_CANTREAD:
        return EIO;
    case ERROR_CANTWRITE:
        return EIO;
    case ERROR_CURRENT_DIRECTORY:
        return EACCES;
    case ERROR_DEV_NOT_EXIST:
        return ENODEV;
    case ERROR_DEVICE_IN_USE:
        return EBUSY;
    case ERROR_DIR_NOT_EMPTY:
        return ENOTEMPTY;
    case ERROR_DIRECTORY:
        return EINVAL;
    case ERROR_DISK_FULL:
        return ENOSPC;
    case ERROR_FILE_EXISTS:
        return EEXIST;
    case ERROR_FILE_NOT_FOUND:
        return ENOENT;
    case ERROR_HANDLE_DISK_FULL:
        return ENOSPC;
    case ERROR_INVALID_ACCESS:
        return EACCES;
    case ERROR_INVALID_DRIVE:
        return ENODEV;
    case ERROR_INVALID_FUNCTION:
        return ENOSYS;
    case ERROR_INVALID_HANDLE:
        return EINVAL;
    case ERROR_INVALID_NAME:
        return EINVAL;
    case ERROR_LOCK_VIOLATION:
        return ENOLCK;
    case ERROR_LOCKED:
        return ENOLCK;
    case ERROR_NEGATIVE_SEEK:
        return EINVAL;
    case ERROR_NOACCESS:
        return EACCES;
    case ERROR_NOT_ENOUGH_MEMORY:
        return ENOMEM;
    case ERROR_NOT_READY:
        return EAGAIN;
    case ERROR_NOT_SAME_DEVICE:
        return EXDEV;
    case ERROR_OPEN_FAILED:
        return EIO;
    case ERROR_OPEN_FILES:
        return EBUSY;
    case ERROR_OPERATION_ABORTED:
        return ECANCELED;
    case ERROR_OUTOFMEMORY:
        return ENOMEM;
    case ERROR_PATH_NOT_FOUND:
        return ENOENT;
    case ERROR_READ_FAULT:
        return EIO;
    case ERROR_RETRY:
        return EAGAIN;
    case ERROR_SEEK:
        return EIO;
    case ERROR_SHARING_VIOLATION:
        return EACCES;
    case ERROR_TOO_MANY_OPEN_FILES:
        return EMFILE;
    case ERROR_WRITE_FAULT:
        return EIO;
    case ERROR_WRITE_PROTECT:
        return EACCES;
    case WSAEACCES:
        return EACCES;
    case WSAEADDRINUSE:
        return EADDRINUSE;
    case WSAEADDRNOTAVAIL:
        return EADDRNOTAVAIL;
    case WSAEAFNOSUPPORT:
        return EAFNOSUPPORT;
    case WSAEALREADY:
        return EALREADY;
    case WSAEBADF:
        return EBADF;
    case WSAECONNABORTED:
        return ECONNABORTED;
    case WSAECONNREFUSED:
        return ECONNREFUSED;
    case WSAECONNRESET:
        return ECONNRESET;
    case WSAEDESTADDRREQ:
        return EDESTADDRREQ;
    case WSAEFAULT:
        return EFAULT;
    case WSAEHOSTUNREACH:
        return EHOSTUNREACH;
    case WSAEINPROGRESS:
        return EINPROGRESS;
    case WSAEINTR:
        return EINTR;
    case WSAEINVAL:
        return EINVAL;
    case WSAEISCONN:
        return EISCONN;
    case WSAEMFILE:
        return EMFILE;
    case WSAEMSGSIZE:
        return EMSGSIZE;
    case WSAENETDOWN:
        return ENETDOWN;
    case WSAENETRESET:
        return ENETRESET;
    case WSAENETUNREACH:
        return ENETUNREACH;
    case WSAENOBUFS:
        return ENOBUFS;
    case WSAENOPROTOOPT:
        return ENOPROTOOPT;
    case WSAENOTCONN:
        return ENOTCONN;
    case WSAENOTSOCK:
        return ENOTSOCK;
    case WSAEOPNOTSUPP:
        return EOPNOTSUPP;
    case WSAEPROTONOSUPPORT:
        return EPROTONOSUPPORT;
    case WSAEPROTOTYPE:
        return EPROTOTYPE;
    case WSAETIMEDOUT:
        return ETIMEDOUT;
    case WSAEWOULDBLOCK:
        return EWOULDBLOCK;
    default:
        break;
    }
    return EPERM;
}
#endif
/*
int GetWindowsOrLinuxSocketLastErrorAsPosix(void)
{
#ifdef _WIN32
    return windows_error_to_posix(WSAGetLastError());
#else
    return errno;
#endif
}
*/



/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/
#pragma safety enable




void ajust_line_and_identation(struct token* token, struct format_visit_ctx* ctx)
{
    /*
    * Before this token we must have a indentation and before indentation a new line.
    * If we don't have it we need to insert.
    */
    try
    {
        if (token->level == 0)
        {
            struct token* _Opt previous_token = token->prev;
            if (previous_token)
            {
                if (previous_token->type == TK_BLANKS)
                {
                    char blanks[50] = { 0 };
                    if (ctx->indentation > 0)
                        snprintf(blanks, sizeof blanks, "%*c", (ctx->indentation * 4), ' ');

                    /*only adjust the number of spaces*/
                    free(previous_token->lexeme);
                    char* _Opt _Owner spc = strdup(blanks);
                    if (spc == NULL) throw;
                    previous_token->lexeme = spc;

                    struct token* _Opt previous_previous_token = previous_token->prev;

                    if (previous_previous_token &&
                        previous_previous_token->type != TK_NEWLINE)
                    {
                        struct tokenizer_ctx tctx = { 0 };
                        struct token_list list = tokenizer(&tctx, "\n", NULL, 0, TK_FLAG_NONE);
                        token_list_insert_after(&ctx->ast.token_list, previous_previous_token, &list);
                        token_list_destroy(&list);
                    }
                }
                else if (previous_token->type != TK_NEWLINE)
                {
                    char blanks[50] = { 0 };
                    if (ctx->indentation > 0)
                    {
                        snprintf(blanks, sizeof blanks, "\n%*c", (ctx->indentation * 4), ' ');
                    }
                    else
                    {
                        snprintf(blanks, sizeof blanks, "\n");
                    }

                    struct tokenizer_ctx tctx = { 0 };
                    struct token_list list = tokenizer(&tctx, blanks, NULL, 0, TK_FLAG_NONE);
                    token_list_insert_after(&ctx->ast.token_list, previous_token, &list);
                    token_list_destroy(&list);
                }
            }
        }
    }
    catch
    {
    }
}

void ajust_if_begin(struct token* token, struct format_visit_ctx* ctx)
{
    try
    {
        /*
        * if we have
          newline blancks
          then we ident
        */
        if (token->level == 0)
        {
            struct token* _Opt previous_token = token->prev;
            if (previous_token && previous_token->type == TK_BLANKS)
            {
                struct token* _Opt previous_previous_token = previous_token->prev;
                if (previous_previous_token &&
                    previous_previous_token->type == TK_NEWLINE)
                {
                    char blanks[50] = { 0 };
                    if (ctx->indentation > 0)
                        snprintf(blanks, sizeof blanks, "%*c", (ctx->indentation * 4), ' ');

                    /*only adjust the number of spaces*/
                    free(previous_token->lexeme);
                    char* _Opt _Owner spc = strdup(blanks);
                    if (spc == NULL) throw;
                    previous_token->lexeme = spc;
                }
            }
        }
    }
    catch
    {
    }
}

static void format_visit_unlabeled_statement(struct format_visit_ctx* ctx, struct unlabeled_statement* p_unlabeled_statement);
static void format_visit_labeled_statement(struct format_visit_ctx* ctx, struct labeled_statement* p_labeled_statement);

static void format_visit_statement(struct format_visit_ctx* ctx, struct statement* p_statement)
{
    if (p_statement->labeled_statement)
    {
        format_visit_labeled_statement(ctx, p_statement->labeled_statement);
    }
    else if (p_statement->unlabeled_statement)
    {
        format_visit_unlabeled_statement(ctx, p_statement->unlabeled_statement);
    }
}



static void format_visit_selection_statement(struct format_visit_ctx* ctx, struct selection_statement* p_selection_statement)
{

    ajust_line_and_identation(p_selection_statement->secondary_block->first_token, ctx);

    if (p_selection_statement->secondary_block->statement->unlabeled_statement &&
        p_selection_statement->secondary_block->statement->unlabeled_statement->primary_block &&
        p_selection_statement->secondary_block->statement->unlabeled_statement->primary_block->compound_statement)
    {
        format_visit_statement(ctx, p_selection_statement->secondary_block->statement);
    }
    else
    {
        ajust_line_and_identation(p_selection_statement->secondary_block->first_token, ctx);

        format_visit_statement(ctx, p_selection_statement->secondary_block->statement);
    }


    if (p_selection_statement->else_secondary_block_opt)
    {
        if (p_selection_statement->else_token_opt)
        {
            ajust_line_and_identation(p_selection_statement->else_token_opt, ctx);
        }

        ajust_line_and_identation(p_selection_statement->else_secondary_block_opt->first_token, ctx);

        if (p_selection_statement->else_secondary_block_opt->statement->unlabeled_statement &&
            p_selection_statement->else_secondary_block_opt->statement->unlabeled_statement->primary_block &&
            p_selection_statement->else_secondary_block_opt->statement->unlabeled_statement->primary_block->compound_statement)
        {
            /*compound statement*/
            format_visit_statement(ctx, p_selection_statement->else_secondary_block_opt->statement);
        }
        else
        {
            format_visit_statement(ctx, p_selection_statement->else_secondary_block_opt->statement);
        }
    }

}

static void format_visit_jump_statement(struct format_visit_ctx* ctx, struct jump_statement* p_jump_statement)
{



    if (p_jump_statement->first_token->type == TK_KEYWORD_THROW ||
        p_jump_statement->first_token->type == TK_KEYWORD_RETURN ||
        p_jump_statement->first_token->type == TK_KEYWORD_BREAK ||
        p_jump_statement->first_token->type == TK_KEYWORD_CONTINUE ||
        p_jump_statement->first_token->type == TK_KEYWORD_GOTO)
    {
        ajust_line_and_identation(p_jump_statement->first_token, ctx);
    }
    else
    {
        assert(false);
    }
}

static void format_visit_compound_statement(struct format_visit_ctx* ctx, struct compound_statement* p_compound_statement);


static void format_visit_secondary_block(struct format_visit_ctx* ctx, struct secondary_block* p_secondary_block)
{
    format_visit_statement(ctx, p_secondary_block->statement);
}

static void format_visit_iteration_statement(struct format_visit_ctx* ctx, struct iteration_statement* p_iteration_statement)
{
    ajust_line_and_identation(p_iteration_statement->first_token, ctx);

    if (p_iteration_statement->expression1)
    {
        //format_visit_expression(ctx, p_iteration_statement->expression1);
    }

    if (p_iteration_statement->expression2)
    {
        //format_visit_expression(ctx, p_iteration_statement->expression2);
    }

    if (p_iteration_statement->first_token->type == TK_KEYWORD_DO)
    {
        ajust_line_and_identation(p_iteration_statement->second_token, ctx);
    }


    format_visit_secondary_block(ctx, p_iteration_statement->secondary_block);
}

static void format_visit_try_statement(struct format_visit_ctx* ctx, struct try_statement* p_try_statement)
{
    format_visit_secondary_block(ctx, p_try_statement->secondary_block);

    if (p_try_statement->catch_secondary_block_opt)
    {
        format_visit_secondary_block(ctx, p_try_statement->catch_secondary_block_opt);
    }
}


static void format_visit_primary_block(struct format_visit_ctx* ctx, struct primary_block* p_primary_block)
{

    if (p_primary_block->compound_statement)
    {
        format_visit_compound_statement(ctx, p_primary_block->compound_statement);
    }
    else if (p_primary_block->iteration_statement)
    {
        format_visit_iteration_statement(ctx, p_primary_block->iteration_statement);
    }
    else if (p_primary_block->selection_statement)
    {
        format_visit_selection_statement(ctx, p_primary_block->selection_statement);
    }
    else if (p_primary_block->defer_statement)
    {
        //visit_defer_statement(ctx, p_primary_block->defer_statement);
    }
    else if (p_primary_block->try_statement)
    {
        format_visit_try_statement(ctx, p_primary_block->try_statement);
    }
    else
    {
        assert(false);
    }
}


static void format_visit_expression_statement(struct format_visit_ctx* ctx, struct expression_statement* p_expression_statement)
{
    if (p_expression_statement->expression_opt)
    {
        //ajust_line_and_identation(p_expression_statement->first_token, ctx);
    }
}

static void format_visit_labeled_statement(struct format_visit_ctx* ctx, struct labeled_statement* p_labeled_statement)
{
    if (p_labeled_statement->label->p_identifier_opt)
        ajust_line_and_identation(p_labeled_statement->label->p_identifier_opt, ctx);

    format_visit_statement(ctx, p_labeled_statement->statement);
}

static void format_visit_unlabeled_statement(struct format_visit_ctx* ctx, struct unlabeled_statement* p_unlabeled_statement)
{
    if (p_unlabeled_statement->primary_block)
    {
        format_visit_primary_block(ctx, p_unlabeled_statement->primary_block);
    }
    else if (p_unlabeled_statement->expression_statement)
    {
        format_visit_expression_statement(ctx, p_unlabeled_statement->expression_statement);
    }
    else if (p_unlabeled_statement->jump_statement)
    {
        format_visit_jump_statement(ctx, p_unlabeled_statement->jump_statement);
    }
    else
    {
        assert(false);
    }
}

static void format_visit_block_item(struct format_visit_ctx* ctx, struct block_item* p_block_item)
{
    ajust_line_and_identation(p_block_item->first_token, ctx);

    if (p_block_item->declaration)
    {
        //visit_declaration(ctx, p_block_item->declaration);
    }
    else if (p_block_item->unlabeled_statement)
    {
        format_visit_unlabeled_statement(ctx, p_block_item->unlabeled_statement);
    }
    else if (p_block_item->label)
    {
        //visit_labeled_statement(ctx, p_block_item->labeled_statement);
    }
}

static void format_visit_block_item_list(struct format_visit_ctx* ctx, struct block_item_list* p_block_item_list)
{
    struct block_item* _Opt p_block_item = p_block_item_list->head;
    while (p_block_item)
    {
        format_visit_block_item(ctx, p_block_item);
        p_block_item = p_block_item->next;
    }
}

static void format_visit_compound_statement(struct format_visit_ctx* ctx, struct compound_statement* p_compound_statement)
{
    ajust_line_and_identation(p_compound_statement->first_token, ctx);

    ctx->indentation++;
    format_visit_block_item_list(ctx, &p_compound_statement->block_item_list);

    ctx->indentation++;
    /*fix comments anything that is not part of AST*/
    struct token* _Opt tk = p_compound_statement->first_token;
    while (tk)
    {
        if (tk->type == TK_LINE_COMMENT ||
            tk->type == TK_COMMENT)
        {
            ajust_if_begin(tk, ctx);
        }
        tk = tk->next;
    }
    ctx->indentation--;

    ctx->indentation--;

    ajust_line_and_identation(p_compound_statement->last_token, ctx);
}

static void format_visit_declaration(struct format_visit_ctx* ctx, struct declaration* p_declaration)
{
    if (p_declaration->static_assert_declaration)
    {
        //format_visit_static_assert_declaration(ctx, p_declaration->static_assert_declaration);
    }

    if (p_declaration->declaration_specifiers)
    {
        //format_visit_declaration_specifiers(ctx, p_declaration->declaration_specifiers);

    }

    if (p_declaration->init_declarator_list.head)
    {
        //format_visit_init_declarator_list(ctx, &p_declaration->init_declarator_list);
    }

    if (p_declaration->function_body)
    {
        format_visit_compound_statement(ctx, p_declaration->function_body);
    }
}

void format_visit(struct format_visit_ctx* ctx)
{
    struct declaration* _Opt p_declaration = ctx->ast.declaration_list.head;
    while (p_declaration)
    {
        format_visit_declaration(ctx, p_declaration);
        p_declaration = p_declaration->next;
    }
}


/*
 *  This file is part of cake compiler
 *  https://github.com/thradams/cake
*/


#pragma safety enable



void print_item(struct osstream* ss, bool* first, const char* item)
{
    if (!(*first))
        ss_fprintf(ss, " ");
    ss_fprintf(ss, "%s", item);
    *first = false;

}

bool print_type_specifier_flags(struct osstream* ss, bool* first, enum type_specifier_flags e_type_specifier_flags)
{
    if (e_type_specifier_flags & TYPE_SPECIFIER_VOID)
        print_item(ss, first, "void");

    if (e_type_specifier_flags & TYPE_SPECIFIER_SIGNED)
        print_item(ss, first, "signed");

    if (e_type_specifier_flags & TYPE_SPECIFIER_UNSIGNED)
        print_item(ss, first, "unsigned");

    if (e_type_specifier_flags & TYPE_SPECIFIER_INT)
        print_item(ss, first, "int");

    if (e_type_specifier_flags & TYPE_SPECIFIER_SHORT)
        print_item(ss, first, "short");

    if (e_type_specifier_flags & TYPE_SPECIFIER_LONG)
        print_item(ss, first, "long");

    if (e_type_specifier_flags & TYPE_SPECIFIER_LONG_LONG)
        print_item(ss, first, "long long");

    if (e_type_specifier_flags & TYPE_SPECIFIER_INT16)
        print_item(ss, first, "__int16");

    if (e_type_specifier_flags & TYPE_SPECIFIER_INT32)
        print_item(ss, first, "__int32");

    if (e_type_specifier_flags & TYPE_SPECIFIER_INT64)
        print_item(ss, first, "__int64");

    if (e_type_specifier_flags & TYPE_SPECIFIER_CHAR)
        print_item(ss, first, "char");

    if (e_type_specifier_flags & TYPE_SPECIFIER_DOUBLE)
        print_item(ss, first, "double");

    if (e_type_specifier_flags & TYPE_SPECIFIER_FLOAT)
        print_item(ss, first, "float");

    if (e_type_specifier_flags & TYPE_SPECIFIER_BOOL)
        print_item(ss, first, "_Bool");

    if (e_type_specifier_flags & TYPE_SPECIFIER_COMPLEX)
        print_item(ss, first, "_Complex");

    if (e_type_specifier_flags & TYPE_SPECIFIER_DECIMAL32)
        print_item(ss, first, "_Decimal32");

    if (e_type_specifier_flags & TYPE_SPECIFIER_DECIMAL64)
        print_item(ss, first, "_Decimal64");

    if (e_type_specifier_flags & TYPE_SPECIFIER_DECIMAL128)
        print_item(ss, first, "_Decimal128");

    if (e_type_specifier_flags & TYPE_SPECIFIER_NULLPTR_T)
        print_item(ss, first, "nullptr_t");

    return *first;
}



void print_type_qualifier_flags(struct osstream* ss, bool* first, enum type_qualifier_flags e_type_qualifier_flags)
{

    if (e_type_qualifier_flags & TYPE_QUALIFIER_CONST)
        print_item(ss, first, "const");

    if (e_type_qualifier_flags & TYPE_QUALIFIER_RESTRICT)
        print_item(ss, first, "restrict");

    if (e_type_qualifier_flags & TYPE_QUALIFIER_VOLATILE)
        print_item(ss, first, "volatile");

    if (e_type_qualifier_flags & TYPE_QUALIFIER_OWNER)
        print_item(ss, first, "_Owner");

    if (e_type_qualifier_flags & TYPE_QUALIFIER_OBJ_OWNER)
        print_item(ss, first, "_Obj_owner");

    if (e_type_qualifier_flags & TYPE_QUALIFIER_VIEW)
        print_item(ss, first, "_View");

    if (e_type_qualifier_flags & TYPE_QUALIFIER_NULLABLE)
        print_item(ss, first, "_Opt");

}

void print_type_qualifier_specifiers(struct osstream* ss, const struct type* type)
{
    bool first = true;
    print_type_qualifier_flags(ss, &first, type->type_qualifier_flags);

    if (type->type_specifier_flags & TYPE_SPECIFIER_STRUCT_OR_UNION)
    {
        assert(type->struct_or_union_specifier != NULL);
        print_item(ss, &first, "struct ");
        ss_fprintf(ss, "%s", type->struct_or_union_specifier->tag_name);
    }
    else if (type->type_specifier_flags & TYPE_SPECIFIER_ENUM)
    {
        assert(type->enum_specifier != NULL);
        print_item(ss, &first, "enum ");
        if (type->enum_specifier->tag_token)
            ss_fprintf(ss, "%s", type->enum_specifier->tag_token->lexeme);

    }
    else if (type->type_specifier_flags & TYPE_SPECIFIER_TYPEDEF)
    {
        assert(false);
    }
    else
    {
        print_type_specifier_flags(ss, &first, type->type_specifier_flags);
    }
}

void type_integer_promotion(struct type* a)
{
    //assert(type_is_integer(a));

    if ((a->type_specifier_flags & TYPE_SPECIFIER_BOOL) ||
        (a->type_specifier_flags & TYPE_SPECIFIER_CHAR) ||
        (a->type_specifier_flags & TYPE_SPECIFIER_SHORT) ||
        (a->type_specifier_flags & TYPE_SPECIFIER_INT8) ||
        (a->type_specifier_flags & TYPE_SPECIFIER_INT16))
    {
        a->type_specifier_flags = (TYPE_SPECIFIER_INT);
    }
}

void type_add_const(struct type* p_type)
{
    p_type->type_qualifier_flags |= TYPE_QUALIFIER_CONST;
}

void type_remove_qualifiers(struct type* p_type)
{
    p_type->type_qualifier_flags = 0;
}

struct type type_lvalue_conversion(const struct type* p_type, bool nullchecks_enabled)
{

    enum type_category category = type_get_category(p_type);
    switch (category)
    {
    case TYPE_CATEGORY_FUNCTION:
    {
        /*
           "function returning type" is converted to an expression that has type
           "pointer to function returning type".
        */
        struct type t = type_add_pointer(p_type, nullchecks_enabled);
        t.type_qualifier_flags &= ~TYPE_QUALIFIER_NULLABLE;
        t.storage_class_specifier_flags &= ~STORAGE_SPECIFIER_PARAMETER;
        t.category = t.category;
        return t;
    }
    break;
    case TYPE_CATEGORY_ARRAY:
    {
        /*
          An expression that has type "array of type" is converted
          to an expression with type "pointer to type" that points to the initial element
          of the array object and s not an lvalue.
          If the array object has register storage class, the behavior is undefined.
        */
        struct type t = get_array_item_type(p_type);
        struct type t2 = type_add_pointer(&t, nullchecks_enabled);


        type_remove_qualifiers(&t2);
        /*
        int g(const int a[const 20]) {
            // in this function, a has type const int* const (const pointer to const int)
            }
        */
        type_destroy(&t);
        t2.storage_class_specifier_flags &= ~STORAGE_SPECIFIER_PARAMETER;
        return t2;
    }
    break;
    case TYPE_CATEGORY_POINTER:
        break;
    case TYPE_CATEGORY_ITSELF:
    default:
        break;
    }

    struct type t = type_dup(p_type);
    type_remove_qualifiers(&t);
    t.storage_class_specifier_flags &= ~STORAGE_SPECIFIER_PARAMETER;

    t.category = type_get_category(&t);

    return t;
}

struct type type_convert_to(const struct type* p_type, enum language_version target)
{
    /*
    * Convert types to previous standard format
    */

    if (target < LANGUAGE_C23 && type_is_nullptr_t(p_type))
    {

        struct type t = make_void_ptr_type();
        assert(t.name_opt == NULL);
        if (p_type->name_opt)
        {
            t.name_opt = strdup(p_type->name_opt);
        }
        return t;
    }

    if (target < LANGUAGE_C99 && type_is_bool(p_type))
    {
        struct type t = type_dup(p_type);
        t.type_specifier_flags &= ~TYPE_SPECIFIER_BOOL;
        t.type_specifier_flags |= TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_CHAR;
        return t;
    }

    return type_dup(p_type);
}

void print_type_core(struct osstream* ss, const struct type* p_type, bool onlydeclarator, bool printname)
{
    const struct type* _Opt p = p_type;

    while (p)
    {
        if (onlydeclarator && p->next == NULL)
            break;

        switch (p->category)
        {
        case TYPE_CATEGORY_ITSELF:
        {
            struct osstream local = { 0 };
            bool first = true;

            print_type_qualifier_flags(&local, &first, p->type_qualifier_flags);

            if (p->struct_or_union_specifier)
            {
                ss_fprintf(&local, "struct %s", p->struct_or_union_specifier->tag_name);
            }
            else if (p->enum_specifier)
            {
                if (p->enum_specifier->tag_token)
                {
                    ss_fprintf(&local, "enum %s", p->enum_specifier->tag_token->lexeme);
                }
                else
                {
                    ss_fprintf(&local, "enum ");
                }
            }
            else
            {
                print_type_specifier_flags(&local, &first, p->type_specifier_flags);
            }



            if (printname && p->name_opt)
            {
                if (first)
                {
                    ss_fprintf(ss, " ");
                    first = false;
                }
                ss_fprintf(ss, "%s", p->name_opt);
            }

            struct osstream local2 = { 0 };
            if (ss->c_str)
                ss_fprintf(&local2, "%s %s", local.c_str, ss->c_str);
            else
                ss_fprintf(&local2, "%s", local.c_str);

            ss_swap(ss, &local2);
            ss_close(&local);
            ss_close(&local2);
        }
        break;
        case TYPE_CATEGORY_ARRAY:


            if (printname && p->name_opt)
            {
                //if (first)
                //{
                  //  ss_fprintf(ss, " ");
                    //first = false;
                //}
                ss_fprintf(ss, "%s", p->name_opt);
            }

            ss_fprintf(ss, "[");

            bool b = true;
            if (p->static_array)
            {
                ss_fprintf(ss, "static");
                b = false;
            }

            print_type_qualifier_flags(ss, &b, p->type_qualifier_flags);

            if (p->num_of_elements > 0)
            {
                if (!b)
                    ss_fprintf(ss, " ");

                ss_fprintf(ss, "%d", p->num_of_elements);
            }
            ss_fprintf(ss, "]");

            break;
        case TYPE_CATEGORY_FUNCTION:

            if (printname && p->name_opt)
            {
                //if (first)
                //{
                  //  ss_fprintf(ss, " ");
                    //first = false;
                //}
                ss_fprintf(ss, "%s", p->name_opt);
            }
            ss_fprintf(ss, "(");

            struct param* _Opt pa = p->params.head;
            
            while (pa)
            {
                struct osstream sslocal = { 0 };
                print_type(&sslocal, &pa->type);
                ss_fprintf(ss, "%s", sslocal.c_str);
                if (pa->next)
                    ss_fprintf(ss, ",");
                ss_close(&sslocal);
                pa = pa->next;
            }
            ss_fprintf(ss, ")");
            break;

        case TYPE_CATEGORY_POINTER:
        {
            struct osstream local = { 0 };
            if (p->next && (
                (p->next->category == TYPE_CATEGORY_FUNCTION ||
                    p->next->category == TYPE_CATEGORY_ARRAY)))
            {
                ss_fprintf(&local, "(");
            }

            ss_fprintf(&local, "*");
            bool first = false;
            print_type_qualifier_flags(&local, &first, p->type_qualifier_flags);

            if (printname && p->name_opt)
            {
                if (!first)
                {
                    ss_fprintf(ss, " ");
                }
                ss_fprintf(ss, "%s", p->name_opt);
                first = false;
            }

            if (ss->c_str)
                ss_fprintf(&local, "%s", ss->c_str);

            if (p->next &&
                (p->next->category == TYPE_CATEGORY_FUNCTION ||
                    p->next->category == TYPE_CATEGORY_ARRAY))
            {
                ss_fprintf(&local, ")", ss->c_str);
            }

            ss_swap(ss, &local);
            ss_close(&local);
        }
        break;
        }

        p = p->next;

    }
}

void print_type(struct osstream* ss, const struct type* p_type)
{
    print_type_core(ss, p_type, false, true);
}

void print_type_no_names(struct osstream* ss, const struct type* p_type)
{
    print_type_core(ss, p_type, false, false);
}

void print_type_declarator(struct osstream* ss, const struct type* p_type)
{
    print_type_core(ss, p_type, true, true);
}

void type_print(const struct type* a)
{
    struct osstream ss = { 0 };
    print_type(&ss, a);
    printf("%s", ss.c_str);
    ss_close(&ss);
}

void type_println(const struct type* a)
{
    type_print(a);
    puts("\n");
}

enum type_category type_get_category(const struct type* p_type)
{
    return p_type->category;
}

void param_list_add(struct param_list* list, struct param* _Owner p_item)
{
    if (list->head == NULL)
    {
        list->head = p_item;
    }
    else
    {
        assert(list->tail != NULL);
        assert(list->tail->next == NULL);
        list->tail->next = p_item;
    }
    list->tail = p_item;
}

void param_list_destroy(struct param_list* _Obj_owner p)
{
    struct param* _Owner _Opt item = p->head;
    while (item)
    {
        struct param* _Owner _Opt next = item->next;
        type_destroy(&item->type);
        free(item);
        item = next;
    }
}

void type_destroy_one(_Opt struct type* _Obj_owner p_type)
{
    free((void* _Owner)p_type->name_opt);
    param_list_destroy(&p_type->params);
    assert(p_type->next == NULL);
}

void type_destroy(_Opt struct type* _Obj_owner p_type)
{
    free((void* _Owner)p_type->name_opt);
    param_list_destroy(&p_type->params);

    struct type* _Owner _Opt item = p_type->next;
    while (item)
    {
        struct type* _Owner _Opt next = item->next;
        item->next = NULL;
        type_destroy_one(item);
        free(item);
        item = next;
    }

}

void type_delete(struct type* _Owner _Opt p_type)
{
    if (p_type)
    {
        type_destroy(p_type);
        free(p_type);
    }
}

bool type_has_attribute(const struct type* p_type, enum attribute_flags attributes)
{
    if (p_type->attributes_flags & attributes)
    {
        /*like
          [[maybe_unused]] int i;
        */
        return true;
    }

    struct attribute_specifier_sequence* _Opt p_attribute_specifier_sequence_opt = NULL;

    if (p_type->struct_or_union_specifier)
    {
        /*like
          struct [[maybe_unused]] X { }
          struct X x;
        */
        p_attribute_specifier_sequence_opt = p_type->struct_or_union_specifier->attribute_specifier_sequence_opt;

        struct struct_or_union_specifier* _Opt p_complete =
            get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);

        if (p_attribute_specifier_sequence_opt == NULL && p_complete)
        {
            p_attribute_specifier_sequence_opt = p_complete->attribute_specifier_sequence_opt;
        }
    }
    else if (p_type->enum_specifier)
    {
        const struct enum_specifier* _Opt p_complete_enum_specifier =
            get_complete_enum_specifier(p_type->enum_specifier);

        p_attribute_specifier_sequence_opt = p_type->enum_specifier->attribute_specifier_sequence_opt;

        if (p_attribute_specifier_sequence_opt == NULL && p_complete_enum_specifier)
        {
            p_attribute_specifier_sequence_opt = p_complete_enum_specifier->attribute_specifier_sequence_opt;
        }
    }

    if (p_attribute_specifier_sequence_opt &&
        p_attribute_specifier_sequence_opt->attributes_flags & attributes)
    {
        return true;
    }

    return false;
}

bool type_is_maybe_unused(const struct type* p_type)
{
    return type_has_attribute(p_type, STD_ATTRIBUTE_MAYBE_UNUSED);
}

bool type_is_deprecated(const struct type* p_type)
{
    return type_has_attribute(p_type, STD_ATTRIBUTE_DEPRECATED);
}

bool type_is_nodiscard(const struct type* p_type)
{
    return type_has_attribute(p_type, STD_ATTRIBUTE_NODISCARD);
}

bool type_is_array(const struct type* p_type)
{
    return type_get_category(p_type) == TYPE_CATEGORY_ARRAY;
}

bool type_is_any_owner(const struct type* p_type)
{
    if (type_is_owner(p_type))
    {
        return true;
    }
    return p_type->type_qualifier_flags & TYPE_QUALIFIER_OBJ_OWNER;
}

bool type_is_pointer_to_owner(const struct type* p_type)
{
    if (p_type->next == NULL)
        return false;

    return type_is_owner(p_type->next);
}

bool type_is_obj_owner(const struct type* p_type)
{
    return p_type->type_qualifier_flags & TYPE_QUALIFIER_OBJ_OWNER;
}

bool type_is_owner(const struct type* p_type)
{
    if (p_type->struct_or_union_specifier)
    {
        if (p_type->type_qualifier_flags & TYPE_QUALIFIER_VIEW)
            return false;

        struct struct_or_union_specifier* _Opt p_complete =
            get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);

        if (p_complete && p_complete->is_owner)
        {
            //The objective here is fix a type later.
            /*
             struct X;
             struct X f(); //X is _Owner?
             struct X { char * _Owner p; };
             int main()
             {
               struct X x = 1 ? f() : f();
             }
            */

            return true;
        }
    }

    return p_type->type_qualifier_flags & TYPE_QUALIFIER_OWNER;
}

bool type_is_nullable(const struct type* p_type, bool nullable_enabled)
{
    if (nullable_enabled)
    {
        return p_type->type_qualifier_flags & TYPE_QUALIFIER_NULLABLE;
    }

    //If  nullable_enabled is disabled then all pointers are nullable
    return true;
}

bool type_is_view(const struct type* p_type)
{
    return p_type->type_qualifier_flags & TYPE_QUALIFIER_VIEW;
}

bool type_is_out(const struct type* p_type)
{
    return p_type->type_qualifier_flags & TYPE_QUALIFIER_OUT;
}

bool type_is_const(const struct type* p_type)
{
    return p_type->type_qualifier_flags & TYPE_QUALIFIER_CONST;
}

bool type_is_pointer_to_const(const struct type* p_type)
{
    if (p_type->category == TYPE_CATEGORY_POINTER)
    {
        if (p_type->next)
        {
            return p_type->next->type_qualifier_flags & TYPE_QUALIFIER_CONST;
        }
    }
    return false;
}

bool type_is_void_ptr(const struct type* p_type)
{
    if (p_type->category == TYPE_CATEGORY_POINTER)
    {
        if (p_type->next)
        {
            return p_type->next->type_specifier_flags & TYPE_SPECIFIER_VOID;
        }
    }
    return false;
}

bool type_is_void(const struct type* p_type)
{
    if (p_type->category == TYPE_CATEGORY_ITSELF)
    {
        return p_type->type_specifier_flags & TYPE_SPECIFIER_VOID;
    }

    return false;
}

bool type_is_nullptr_t(const struct type* p_type)
{
    if (p_type->category == TYPE_CATEGORY_ITSELF)
    {
        return p_type->type_specifier_flags & TYPE_SPECIFIER_NULLPTR_T;
    }

    return false;
}

bool type_is_pointer_to_out(const struct type* p_type)
{
    if (p_type->next == NULL)
        return false;

    if (p_type->category == TYPE_CATEGORY_POINTER)
    {
        return p_type->next->type_qualifier_flags & TYPE_QUALIFIER_OUT;
    }
    return false;
}

bool type_is_pointer(const struct type* p_type)
{
    return p_type->category == TYPE_CATEGORY_POINTER;
}

bool type_is_essential_bool(const struct type* p_type)
{
    return p_type->attributes_flags & CAKE_HIDDEN_ATTRIBUTE_LIKE_BOOL;
}
bool type_is_essential_char(const struct type* p_type)
{
    return p_type->attributes_flags & CAKE_HIDDEN_ATTRIBUTE_LIKE_CHAR;
}

bool type_is_enum(const struct type* p_type)
{
    return type_get_category(p_type) == TYPE_CATEGORY_ITSELF &&
        p_type->type_specifier_flags & TYPE_SPECIFIER_ENUM;
}

bool type_is_struct_or_union(const struct type* p_type)
{
    return type_get_category(p_type) == TYPE_CATEGORY_ITSELF &&
        p_type->type_specifier_flags & TYPE_SPECIFIER_STRUCT_OR_UNION;
}

/*
  The three types
  char, signed char, and unsigned char
  are collectively called the character types.
*/
bool type_is_character(const struct type* p_type)
{
    return type_get_category(p_type) == TYPE_CATEGORY_ITSELF &&
        p_type->type_specifier_flags & TYPE_SPECIFIER_CHAR;
}

bool type_is_vla(const struct type* p_type)
{
    const struct type* _Opt it = p_type;

    while (it && type_is_array(it))
    {
        if (it->array_num_elements_expression)
        {            
            if (!constant_value_is_valid(&it->array_num_elements_expression->constant_value))
            {
                // int a[7][n]
                //if any of the array is not constant then it is vla
                return true;
            }
        }
        it = it->next;
    }
    return false;
}

bool type_is_decimal128(const struct type* p_type)
{
    return type_get_category(p_type) == TYPE_CATEGORY_ITSELF &&
        p_type->type_specifier_flags & TYPE_SPECIFIER_DECIMAL128;
}
bool type_is_decimal64(const struct type* p_type)
{
    return type_get_category(p_type) == TYPE_CATEGORY_ITSELF &&
        p_type->type_specifier_flags & TYPE_SPECIFIER_DECIMAL64;
}
bool type_is_decimal32(const struct type* p_type)
{
    return type_get_category(p_type) == TYPE_CATEGORY_ITSELF &&
        p_type->type_specifier_flags & TYPE_SPECIFIER_DECIMAL32;
}
bool type_is_long_double(const struct type* p_type)
{
    if (type_get_category(p_type) != TYPE_CATEGORY_ITSELF)
        return  false;

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_DOUBLE)
    {
        if (p_type->type_specifier_flags & TYPE_SPECIFIER_LONG)
        {
            return true;
        }

    }
    return false;
}

bool type_is_double(const struct type* p_type)
{
    if (type_get_category(p_type) != TYPE_CATEGORY_ITSELF)
        return  false;

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_DOUBLE)
    {
        if (!(p_type->type_specifier_flags & TYPE_SPECIFIER_LONG))
        {
            return true;
        }

    }
    return false;
}

bool type_is_float(const struct type* p_type)
{
    if (type_get_category(p_type) != TYPE_CATEGORY_ITSELF)
        return  false;

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_FLOAT)
    {
        return true;
    }
    return false;
}


bool type_is_bool(const struct type* p_type)
{
    return type_get_category(p_type) == TYPE_CATEGORY_ITSELF &&
        p_type->type_specifier_flags & TYPE_SPECIFIER_BOOL;
}

/*
 There are three standard floating types, designated as
 float, double, and long double.

 There are three decimal floating types, designated as _Decimal32, _Decimal64, and _Decimal128.
*/
bool type_is_floating_point(const struct type* p_type)
{
    if (type_get_category(p_type) != TYPE_CATEGORY_ITSELF)
        return false;

    return p_type->type_specifier_flags &
        (TYPE_SPECIFIER_DOUBLE |
            TYPE_SPECIFIER_FLOAT);
}

bool type_is_unsigned_integer(const struct type* p_type)
{
    if (type_is_integer(p_type) &&
        (p_type->type_specifier_flags & TYPE_SPECIFIER_UNSIGNED))
    {
        return true;
    }

    return false;
}

bool type_is_signed_integer(const struct type* p_type)
{
    if (type_is_integer(p_type) &&
        !(p_type->type_specifier_flags & TYPE_SPECIFIER_UNSIGNED))
    {
        return true;
    }

    return false;
}


/*
  The type char, the signed and unsigned integer types,
  and the enumerated types
  are collectively  called integer types.
*/
bool type_is_integer(const struct type* p_type)
{
    if (type_get_category(p_type) != TYPE_CATEGORY_ITSELF)
        return false;

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_DOUBLE)
    {
        /*we cannot check long without check double*/
        //long double
        return false;
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_ENUM)
    {
        return true;
    }

    return p_type->type_specifier_flags &
        (TYPE_SPECIFIER_CHAR |
            TYPE_SPECIFIER_SHORT |
            TYPE_SPECIFIER_INT |

            TYPE_SPECIFIER_INT16 |
            TYPE_SPECIFIER_INT32 |
            TYPE_SPECIFIER_INT64 |

            TYPE_SPECIFIER_INT |
            TYPE_SPECIFIER_LONG |
            TYPE_SPECIFIER_SIGNED |
            TYPE_SPECIFIER_UNSIGNED |
            TYPE_SPECIFIER_INT8 |
            TYPE_SPECIFIER_INT16 |
            TYPE_SPECIFIER_INT64 |
            TYPE_SPECIFIER_LONG_LONG |
            TYPE_SPECIFIER_BOOL);
}

/*
* Integer and floating types are collectively called arithmetic types.
*/
bool type_is_arithmetic(const struct type* p_type)
{
    return type_is_integer(p_type) || type_is_floating_point(p_type);
}

/*
 Arithmetic types, pointer types, and the nullptr_t type are collectively
 called scalar types.
*/
bool type_is_scalar(const struct type* p_type)
{
    //TODO we need two concepts...is_scalar on real type or is_scalar after lvalue converison

    if (type_is_arithmetic(p_type))
        return true;

    if (type_is_pointer_or_array(p_type))
        return true;

    if (type_get_category(p_type) != TYPE_CATEGORY_ITSELF)
        return false;


    if (p_type->type_specifier_flags & TYPE_SPECIFIER_ENUM)
        return true;
    if (p_type->type_specifier_flags & TYPE_SPECIFIER_NULLPTR_T)
        return true;

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_BOOL)
        return true;

    return false;
}


const struct param_list* _Opt type_get_func_or_func_ptr_params(const struct type* p_type)
{
    if (p_type->category == TYPE_CATEGORY_FUNCTION)
    {
        return &p_type->params;
    }
    else if (p_type->category == TYPE_CATEGORY_POINTER)
    {
        if (p_type->next &&
            p_type->next->category == TYPE_CATEGORY_FUNCTION)
        {
            return &p_type->next->params;
        }
    }
    return NULL;
}

void check_ownership_qualifiers_of_argument_and_parameter(struct parser_ctx* ctx,
    struct argument_expression* current_argument,
    struct type* paramer_type,
    int param_num)
{
    //            _Owner     _Obj_owner  _View parameter
    // _Owner      OK                   OK
    // _Obj_owner  X         OK         OK
    // _View       X (NULL)  X          OK

    const bool paramer_is_obj_owner = type_is_obj_owner(paramer_type);
    const bool paramer_is_owner = type_is_owner(paramer_type);
    const bool paramer_is_view = !paramer_is_obj_owner && !paramer_is_owner;

    const struct type* const argument_type = &current_argument->expression->type;
    const bool argument_is_owner = type_is_owner(&current_argument->expression->type);
    const bool argument_is_obj_owner = type_is_obj_owner(&current_argument->expression->type);
    const bool argument_is_view = !argument_is_owner && !argument_is_obj_owner;

    if (argument_is_owner && paramer_is_owner)
    {
        //ok
    }
    else if (argument_is_owner && paramer_is_obj_owner)
    {
        //ok
    }
    else if (argument_is_owner && paramer_is_view)
    {
        //ok
        if (current_argument->expression->type.storage_class_specifier_flags & STORAGE_SPECIFIER_FUNCTION_RETURN)
        {
            compiler_diagnostic_message(W_OWNERSHIP_USING_TEMPORARY_OWNER,
                ctx,
                current_argument->expression->first_token, NULL,
                "passing a temporary owner to a view");
        }

    }////////////////////////////////////////////////////////////
    else if (argument_is_obj_owner && paramer_is_owner)
    {
        compiler_diagnostic_message(W_OWNERSHIP_MOVE_ASSIGNMENT_OF_NON_OWNER,
            ctx,
            current_argument->expression->first_token, NULL,
            "cannot move _Obj_owner to _Owner");
    }
    else if (argument_is_obj_owner && paramer_is_obj_owner)
    {
        //ok
    }
    else if (argument_is_obj_owner && paramer_is_view)
    {
        //ok
        //ok
        if (current_argument->expression->type.storage_class_specifier_flags & STORAGE_SPECIFIER_FUNCTION_RETURN)
        {
            compiler_diagnostic_message(W_OWNERSHIP_USING_TEMPORARY_OWNER,
                ctx,
                current_argument->expression->first_token, NULL,
                "passing a temporary owner to a view");
        }


    }///////////////////////////////////////////////////////////////
    else if (argument_is_view && paramer_is_owner)
    {
        if (!expression_is_null_pointer_constant(current_argument->expression))
        {
            compiler_diagnostic_message(W_OWNERSHIP_MOVE_ASSIGNMENT_OF_NON_OWNER,
                ctx,
                current_argument->expression->first_token, NULL,
                "passing a _View argument to a _Owner parameter");
        }
    }
    else if (argument_is_view && paramer_is_obj_owner)
    {
        //check if the contented of pointer is _Owner.
        if (type_is_pointer(argument_type))
        {
            struct type t2 = type_remove_pointer(argument_type);
            if (!type_is_owner(&t2))
            {

                compiler_diagnostic_message(W_OWNERSHIP_MOVE_ASSIGNMENT_OF_NON_OWNER,
                    ctx,
                    current_argument->expression->first_token, NULL,
                    "pointed object is not _Owner");

            }
            else
            {
                //pointer object is _Owner
                if (!argument_type->address_of)
                {
                    //we need something created with address of.
                    compiler_diagnostic_message(W_MUST_USE_ADDRESSOF,
                        ctx,
                        current_argument->expression->first_token, NULL,
                        "_Obj_owner pointer must be created using address of operator &");
                }
            }

            type_destroy(&t2);
        }
        else
        {
            if (!expression_is_null_pointer_constant(current_argument->expression))
            {
                compiler_diagnostic_message(W_OWNERSHIP_MOVE_ASSIGNMENT_OF_NON_OWNER,
                    ctx,
                    current_argument->expression->first_token, NULL,
                    "passing a _View argument to a _Obj_owner parameter");
            }
        }

    }
    else if (argument_is_view && paramer_is_view)
    {
        //ok
    }///////////////////////////////////////////////////////////////
}

void check_argument_and_parameter(struct parser_ctx* ctx,
    struct argument_expression* current_argument,
    struct type* paramer_type,
    int param_num)
{
    // TODO use assignment check for everthing..

    if (type_is_any_owner(paramer_type))
    {
        if (type_is_obj_owner(paramer_type))
        {
            if (current_argument->expression->type.category == TYPE_CATEGORY_POINTER)
            {
                if (type_is_pointer(&current_argument->expression->type) &&
                    !type_is_pointer_to_owner(&current_argument->expression->type))
                {
                    compiler_diagnostic_message(W_OWNERSHIP_NOT_OWNER, ctx,
                        current_argument->expression->first_token, NULL,
                        "parameter %d requires a pointer to _Owner object",
                        param_num);
                }
            }
            else
            {
                compiler_diagnostic_message(W_OWNERSHIP_NOT_OWNER, ctx,
                    current_argument->expression->first_token, NULL,
                    "parameter %d requires a pointer to _Owner type",
                    param_num);
            }
        }
    }

    struct type* argument_type = &current_argument->expression->type;
    const bool is_null_pointer_constant = expression_is_null_pointer_constant(current_argument->expression);

    struct type parameter_type_converted = (type_is_array(paramer_type)) ?
        type_lvalue_conversion(paramer_type, ctx->options.null_checks_enabled) :
        type_dup(paramer_type);


    struct type argument_type_converted =
        expression_is_subjected_to_lvalue_conversion(current_argument->expression) ?
        type_lvalue_conversion(argument_type, ctx->options.null_checks_enabled) :
        type_dup(argument_type);

    /*
       less generic tests are first
    */
    if (type_is_enum(argument_type) && type_is_enum(paramer_type))
    {
        if (!type_is_same(argument_type, paramer_type, false))
        {
            compiler_diagnostic_message(C_ERROR_INCOMPATIBLE_TYPES, ctx,
                current_argument->expression->first_token, NULL,
                " incompatible types at argument %d", param_num);
        }

        check_ownership_qualifiers_of_argument_and_parameter(ctx,
            current_argument,
            paramer_type,
            param_num);

        type_destroy(&parameter_type_converted);
        type_destroy(&argument_type_converted);

        return;
    }

    if (type_is_arithmetic(argument_type) && type_is_arithmetic(paramer_type))
    {
        check_ownership_qualifiers_of_argument_and_parameter(ctx,
            current_argument,
            paramer_type,
            param_num);

        type_destroy(&parameter_type_converted);
        type_destroy(&argument_type_converted);

        return;
    }

    if (is_null_pointer_constant && type_is_pointer(paramer_type))
    {
        //TODO void F(int * [[_Opt]] p)
        // F(0) when passing null we will check if the parameter
        //have the anotation [[_Opt]]

        /*can be converted to any type*/
        check_ownership_qualifiers_of_argument_and_parameter(ctx,
            current_argument,
            paramer_type,
            param_num);

        type_destroy(&parameter_type_converted);
        type_destroy(&argument_type_converted);

        return;
    }

    if (is_null_pointer_constant && type_is_array(paramer_type))
    {
        compiler_diagnostic_message(W_FLOW_NON_NULL,
            ctx,
            current_argument->expression->first_token, NULL,
            " passing null as array");

        check_ownership_qualifiers_of_argument_and_parameter(ctx,
            current_argument,
            paramer_type,
            param_num);

        type_destroy(&parameter_type_converted);
        type_destroy(&argument_type_converted);

        return;
    }

    /*
       We have two pointers or pointer/array combination
    */
    if (type_is_pointer_or_array(argument_type) && type_is_pointer_or_array(paramer_type))
    {
        if (type_is_void_ptr(argument_type))
        {
            /*void pointer can be converted to any type*/
            check_ownership_qualifiers_of_argument_and_parameter(ctx,
                current_argument,
                paramer_type,
                param_num);

            type_destroy(&parameter_type_converted);
            type_destroy(&argument_type_converted);

            return;
        }

        if (type_is_void_ptr(paramer_type))
        {
            /*any pointer can be converted to void* */
            check_ownership_qualifiers_of_argument_and_parameter(ctx,
                current_argument,
                paramer_type,
                param_num);

            type_destroy(&parameter_type_converted);
            type_destroy(&argument_type_converted);

            return;
        }


        //TODO  lvalue

        if (type_is_array(paramer_type))
        {
            int parameter_array_size = paramer_type->num_of_elements;
            if (type_is_array(argument_type))
            {
                int argument_array_size = argument_type->num_of_elements;
                if (parameter_array_size != 0 &&
                    argument_array_size < parameter_array_size)
                {
                    compiler_diagnostic_message(C_ERROR_ARGUMENT_SIZE_SMALLER_THAN_PARAMETER_SIZE,
                        ctx,
                        current_argument->expression->first_token, NULL,
                        " argument of size [%d] is smaller than parameter of size [%d]", argument_array_size, parameter_array_size);
                }
            }
            else if (is_null_pointer_constant || type_is_nullptr_t(argument_type))
            {
                compiler_diagnostic_message(W_PASSING_NULL_AS_ARRAY,
                    ctx,
                    current_argument->expression->first_token, NULL,
                    " passing null as array");
            }
        }



        if (!type_is_same(&argument_type_converted, &parameter_type_converted, false))
        {
            type_print(&argument_type_converted);
            type_print(&parameter_type_converted);

            compiler_diagnostic_message(C_ERROR_INCOMPATIBLE_TYPES, ctx,
                current_argument->expression->first_token, NULL,
                " incompatible types at argument %d", param_num);
            //disabled for now util it works correctly
            //return false;
        }

        if (type_is_pointer(&argument_type_converted) && type_is_pointer(&parameter_type_converted))
        {
            //parameter pointer do non const
            //argument const.
            struct type argument_pointer_to = type_remove_pointer(&argument_type_converted);
            struct type parameter_pointer_to = type_remove_pointer(&parameter_type_converted);
            if (type_is_const(&argument_pointer_to) &&
                !type_is_const(&parameter_pointer_to) &&
                !type_is_any_owner(&parameter_pointer_to))
            {
                compiler_diagnostic_message(W_DISCARDED_QUALIFIERS, ctx,
                    current_argument->expression->first_token, NULL,
                    " discarding const at argument %d", param_num);
            }
            type_destroy(&argument_pointer_to);
            type_destroy(&parameter_pointer_to);
        }
        //return true;
    }

    //TODO
    //if (!type_is_same(paramer_type, &current_argument->expression->type, false))
    //{
    //    compiler_diagnostic_message(C1, ctx,
    //        current_argument->expression->first_token,
    //        " incompatible types at argument %d ", param_num);
    //}



    check_ownership_qualifiers_of_argument_and_parameter(ctx,
        current_argument,
        paramer_type,
        param_num);



    type_destroy(&argument_type_converted);
    type_destroy(&parameter_type_converted);
}



bool type_is_function(const struct type* p_type)
{
    return type_get_category(p_type) == TYPE_CATEGORY_FUNCTION;
}

bool type_is_function_or_function_pointer(const struct type* p_type)
{
    if (type_is_function(p_type))
        return true;

    if (type_is_pointer(p_type))
    {
        //TODO not optimized
        struct type t = type_remove_pointer(p_type);
        bool r = type_is_function(&t);
        type_destroy(&t);
        return r;
    }

    return false;
}

bool type_is_empty(const struct type* p_type)
{
    return p_type->type_specifier_flags == TYPE_SPECIFIER_NONE;
}

struct type type_add_pointer(const struct type* p_type, bool null_checks_enabled)
{
    struct type r = type_dup(p_type);
    try
    {
        //waiting test
        //if (type_is_empty(&r)) throw;

        struct type* _Owner _Opt p = calloc(1, sizeof(struct type));
        if (p == NULL) throw;

        *p = r;
        r = (struct type){ 0 };
        r.next = p;
        r.category = TYPE_CATEGORY_POINTER;


        r.storage_class_specifier_flags = p_type->storage_class_specifier_flags;
    }
    catch
    {
    }

    return r;
}

struct type type_remove_pointer(const struct type* p_type)
{
    struct type r = type_dup(p_type);
    if (!type_is_pointer(p_type))
    {
        return r;
    }

    if (r.next)
    {
        struct type next = *r.next;
        /*
          we have moved the contents of r.next, but we also need to delete it's memory
        */
        free(r.next);
        r.next = NULL;
        type_destroy_one(&r);
        r = next;
    }
    else
    {
        assert(false);
    }

    assert(p_type->next != NULL); //guaranteed by type_is_pointer

    r.storage_class_specifier_flags = p_type->next->storage_class_specifier_flags;
    r.type_qualifier_flags = p_type->next->type_qualifier_flags;

    return r;
}


struct type get_array_item_type(const struct type* p_type)
{
    struct type r = type_dup(p_type);

    if (r.next)
    {
        struct type r2 = *r.next;

        free(r.next);
        free((void* _Owner) r.name_opt);
        param_list_destroy(&r.params);
        return r2;
    }

    return r;
}

struct type type_param_array_to_pointer(const struct type* p_type, bool null_checks_enabled)
{
    assert(type_is_array(p_type));
    struct type t = get_array_item_type(p_type);
    struct type t2 = type_add_pointer(&t, null_checks_enabled);

    if (p_type->type_qualifier_flags & TYPE_QUALIFIER_CONST)
    {
        /*
         void F(int a[static const 5]) {
          static_assert((typeof(a)) == (int* const));
        }
        */
        t2.type_qualifier_flags |= TYPE_QUALIFIER_CONST;
    }

    type_destroy(&t);
    t2.storage_class_specifier_flags &= ~STORAGE_SPECIFIER_PARAMETER;

    return t2;
}

bool type_is_pointer_or_array(const struct type* p_type)
{
    const enum type_category category = type_get_category(p_type);

    if (category == TYPE_CATEGORY_POINTER ||
        category == TYPE_CATEGORY_ARRAY)
    {
        return true;
    }

    if (category == TYPE_CATEGORY_ITSELF &&
        p_type->type_specifier_flags == TYPE_SPECIFIER_NULLPTR_T)
    {
        return true;
    }

    return false;
}


//See 6.3.1.1
int type_get_integer_rank(const struct type* p_type1)
{
    if (type_is_pointer_or_array(p_type1))
    {
        assert(false);
        return 40;
    }

    if ((p_type1->type_specifier_flags & TYPE_SPECIFIER_LONG_LONG) ||
        (p_type1->type_specifier_flags & TYPE_SPECIFIER_INT64))
    {
        return 80;
    }
    else if ((p_type1->type_specifier_flags & TYPE_SPECIFIER_NULLPTR_T))
    {
        return 50; //?
    }
    else if ((p_type1->type_specifier_flags & TYPE_SPECIFIER_LONG) ||
        (p_type1->type_specifier_flags & TYPE_SPECIFIER_INT32))
    {
        return 50;
    }
    else if ((p_type1->type_specifier_flags & TYPE_SPECIFIER_INT) ||
        (p_type1->type_specifier_flags & TYPE_SPECIFIER_ENUM))
    {
        return 40;
    }
    else if ((p_type1->type_specifier_flags & TYPE_SPECIFIER_SHORT) ||
        (p_type1->type_specifier_flags & TYPE_SPECIFIER_INT16))
    {
        return 30;
    }
    else if ((p_type1->type_specifier_flags & TYPE_SPECIFIER_CHAR) ||
        (p_type1->type_specifier_flags & TYPE_SPECIFIER_INT8))
    {
        return 20;
    }
    else if ((p_type1->type_specifier_flags & TYPE_SPECIFIER_BOOL))
    {
        return 10;
    }

    return 0;
}

struct type type_get_enum_underlying_type(const struct type* p)
{
    struct type r = type_make_int();
    //TODO
    return r;
}

struct type type_common(const struct type* p_type1, const struct type* p_type2)
{
    //See 6.3.1.8 Usual arithmetic conversions


    /*
       First, if the type of either operand is _Decimal128,
       the other operand is converted to _Decimal128.
    */
    if (type_is_decimal128(p_type1))
    {
        return type_dup(p_type1);
    }

    if (type_is_decimal128(p_type2))
    {
        return type_dup(p_type2);
    }

    /*
      Otherwise, if the type of either operand is _Decimal64,
      the other operand is converted to _Decimal64
    */

    if (type_is_decimal64(p_type1))
    {
        return type_dup(p_type1);
    }

    if (type_is_decimal64(p_type2))
    {
        return type_dup(p_type2);
    }

    /*
      Otherwise, if the type of either operand is _Decimal32,
      the other operand is converted to _Decimal32.
    */
    if (type_is_decimal32(p_type1))
    {
        return type_dup(p_type1);
    }

    if (type_is_decimal32(p_type2))
    {
        return type_dup(p_type2);
    }

    /*
      Otherwise, if the corresponding real type of either operand is long double,
      the other operand is converted, without change of type domain, to a type whose
      corresponding real type is long double
    */
    if (type_is_long_double(p_type1))
    {
        return type_dup(p_type1);
    }

    if (type_is_long_double(p_type2))
    {
        return type_dup(p_type2);
    }

    /*
      Otherwise, if the corresponding real type of either operand is double,
      the other operand is converted, without change of type domain, to a type
      whose corresponding real type is double.
    */

    if (type_is_double(p_type1))
    {
        return type_dup(p_type1);
    }

    if (type_is_double(p_type2))
    {
        return type_dup(p_type2);
    }


    /*
      Otherwise, if the corresponding real type of either operand is float,
      the other operand is converted, without change of type domain,
      to a type whose corresponding real type is float
    */
    if (type_is_float(p_type1))
    {
        return type_dup(p_type1);
    }

    if (type_is_float(p_type2))
    {
        return type_dup(p_type2);
    }

    /*
     Otherwise, if any of the two types is an enumeration, it is converted to its underlying type.
    */
    struct type promoted_a = { 0 };
    struct type promoted_b = { 0 };


    if (type_is_enum(p_type1))
    {
        promoted_a = type_get_enum_underlying_type(p_type1);

    }
    else
    {
        promoted_a = type_dup(p_type1);
    }

    if (type_is_enum(p_type2))
    {
        promoted_b = type_get_enum_underlying_type(p_type2);
    }
    else
    {
        promoted_b = type_dup(p_type2);
    }

    /*
      Then, the integer promotions are performed on both operands. Next, the following rules are
      applied to the promoted operands
    */
    type_integer_promotion(&promoted_a);
    type_integer_promotion(&promoted_b);



    /*
      if both operands have the same type, then no further conversion is needed
    */
    if (type_is_same(&promoted_a, &promoted_b, false))
    {
        type_destroy(&promoted_b);
        return promoted_a;
    }

    /*
     Otherwise, if both operands have signed integer types or both have unsigned integer
     types, the operand with the type of lesser integer conversion rank is converted to the type
     of the operand with greater rank.
    */

    if (type_is_signed_integer(&promoted_a) == type_is_signed_integer(&promoted_b))
    {
        if (type_get_integer_rank(&promoted_a) > type_get_integer_rank(&promoted_b))
        {
            type_destroy(&promoted_b);
            return promoted_a;
        }

        type_destroy(&promoted_a);
        return promoted_b;
    }


    /*
     Otherwise, if the operand that has unsigned integer type has rank greater or equal to
     the rank of the type of the other operand, then the operand with signed integer type is
     converted to the type of the operand with unsigned integer type.
    */

    struct type* p_signed_promoted = type_is_signed_integer(&promoted_a) ? &promoted_a : &promoted_b;
    struct type* p_unsigned_promoted = type_is_unsigned_integer(&promoted_a) ? &promoted_a : &promoted_b;

    assert(p_signed_promoted != p_unsigned_promoted);

    if (type_get_integer_rank(p_unsigned_promoted) >= type_get_integer_rank(p_signed_promoted))
    {
        struct type r = { 0 };
        type_swap(&r, p_unsigned_promoted);
        type_destroy(&promoted_a);
        type_destroy(&promoted_b);
        return r;
    }

    /*
      Otherwise, if the type of the operand with signed integer type can represent all the values
      of the type of the operand with unsigned integer type, then the operand with unsigned
      integer type is converted to the type of the operand with signed integer type
    */

    if (type_get_sizeof(p_signed_promoted) > type_get_sizeof(p_unsigned_promoted))
    {
        struct type r = { 0 };
        type_swap(&r, p_signed_promoted);
        type_destroy(&promoted_a);
        type_destroy(&promoted_b);
        return r;
    }

    /*
      Otherwise, both operands are converted to the unsigned integer type corresponding to
      the type of the operand with signed integer type
    */

    struct type r = { 0 };
    type_swap(&r, p_signed_promoted);
    r.type_specifier_flags |= TYPE_SPECIFIER_UNSIGNED;
    type_destroy(&promoted_a);
    type_destroy(&promoted_b);
    return r;
}

void type_set(struct type* a, const struct type* b)
{
    struct type t = type_dup(b);
    type_swap(&t, a);
    type_destroy(&t);
}

struct type type_dup(const struct type* p_type)
{
    try
    {
        struct type_list l = { 0 };
        const struct type* _Opt p = p_type;
        while (p)
        {
            struct type* _Owner _Opt p_new = calloc(1, sizeof(struct type));
            if (p_new == NULL) 
            {
                type_list_destroy(&l);
                throw;
            }

            *p_new = *p;

            //actually I was not the _Owner of p_new->next
            static_set(p_new->next, "uninitialized");
            p_new->next = NULL;

            if (p->name_opt)
            {
                //actually p_new->name_opt was not mine..
                static_set(p_new->name_opt, "uninitialized");
                p_new->name_opt = strdup(p->name_opt);
            }

            if (p->category == TYPE_CATEGORY_FUNCTION)
            {
                //actually p_new->params.head  p_new->params.tail and was not mine..
                static_set(p_new->params.head, "uninitialized");
                p_new->params.head = NULL;
                static_set(p_new->params.tail, "uninitialized");
                p_new->params.tail = NULL;

                struct param* _Opt p_param = p->params.head;
                while (p_param)
                {
                    struct param* _Owner _Opt p_new_param = calloc(1, sizeof * p_new_param);
                    if (p_new_param == NULL)
                    {
                        type_list_destroy(&l);
                        type_delete(p_new);
                        throw;
                    }

                    p_new_param->type = type_dup(&p_param->type);

                    param_list_add(&p_new->params, p_new_param);
                    p_param = p_param->next;
                }
            }

            type_list_push_back(&l, p_new);
            p = p->next;
        }

        if (l.head == NULL)
            throw;

        struct type r = *l.head;
        /*
           we have moved the content of l.head
           but we also need to delete the memory
        */
        free(l.head);

        return r;
    }
    catch
    {
    }

    struct type empty = { 0 };
    return empty;
}


int get_sizeof_struct(struct struct_or_union_specifier* complete_struct_or_union_specifier)
{
    const bool is_union =
        (complete_struct_or_union_specifier->first_token->type == TK_KEYWORD_UNION);

    int maxalign = 0;
    int size = 0;
    struct member_declaration* _Opt d = complete_struct_or_union_specifier->member_declaration_list.head;
    while (d)
    {
        if (d->member_declarator_list_opt)
        {
            struct member_declarator* _Opt md = d->member_declarator_list_opt->head;
            while (md)
            {
                int align = 1;

                if (md->declarator)
                {
                    align = type_get_alignof(&md->declarator->type);

                    if (align > maxalign)
                    {
                        maxalign = align;
                    }
                    if (size % align != 0)
                    {
                        size += align - (size % align);
                    }
                    const int item_size = type_get_sizeof(&md->declarator->type);
                    if (is_union)
                    {
                        if (item_size > size)
                            size = item_size;
                    }
                    else
                    {
                        size += item_size;
                    }
                }
                else
                {
                    assert(false);//?
                }
                md = md->next;
            }
        }
        else if (d->specifier_qualifier_list)
        {
            if (d->specifier_qualifier_list->struct_or_union_specifier)
            {
                struct type t = { 0 };
                t.category = TYPE_CATEGORY_ITSELF;
                t.struct_or_union_specifier = d->specifier_qualifier_list->struct_or_union_specifier;
                t.type_specifier_flags = TYPE_SPECIFIER_STRUCT_OR_UNION;

                int align = type_get_alignof(&t);

                if (align > maxalign)
                {
                    maxalign = align;
                }
                if (size % align != 0)
                {
                    size += align - (size % align);
                }
                const int item_size = type_get_sizeof(&t);
                if (is_union)
                {
                    if (item_size > size)
                        size = item_size;
                }
                else
                {
                    size += item_size;
                }
                type_destroy(&t);
            }
            else
            {
                assert(false);
            }
        }
        d = d->next;
    }
    if (maxalign != 0)
    {
        if (size % maxalign != 0)
        {
            size += maxalign - (size % maxalign);
        }
    }
    else
    {
        assert(false);
    }

    return size;
}

size_t type_get_alignof(const struct type* p_type);
size_t get_alignof_struct(struct struct_or_union_specifier* complete_struct_or_union_specifier)
{
    int align = 0;
    struct member_declaration* _Opt d = complete_struct_or_union_specifier->member_declaration_list.head;
    while (d)
    {
        if (d->member_declarator_list_opt)
        {
            struct member_declarator* _Opt md = d->member_declarator_list_opt->head;
            while (md)
            {
                if (md->declarator)
                {
                    int temp_align = type_get_alignof(&md->declarator->type);
                    if (temp_align > align)
                    {
                        align = temp_align;
                    }
                }
                else
                {
                    assert(false);
                }
                md = md->next;
            }
        }
        else if (d->specifier_qualifier_list)
        {
            /*We don't have the declarator like in */
            /*
              struct X {
                union {
                    struct {
                        int Zone;
                    };
                    int Value;
                };
            };
            static_assert(alignof(struct X) == 1);
            */

            /*so we create a type using only specifiers*/

            struct type type = { 0 };

            type.type_specifier_flags = d->specifier_qualifier_list->type_specifier_flags;

            type.enum_specifier = d->specifier_qualifier_list->enum_specifier;
            type.struct_or_union_specifier = d->specifier_qualifier_list->struct_or_union_specifier;


            int temp_align = type_get_alignof(&type);
            if (temp_align > align)
            {
                align = temp_align;
            }

            type_destroy(&type);
        }
        else
        {
            /*static_assert*/
        }
        d = d->next;
    }
    assert(align != 0);
    return align;
}

size_t type_get_alignof(const struct type* p_type)
{
    int align = 0;

    enum type_category category = type_get_category(p_type);

    if (category == TYPE_CATEGORY_POINTER)
    {
        align = _Alignof(void*);
    }
    else if (category == TYPE_CATEGORY_FUNCTION)
    {
        align = -1;
        //seterror(error, "sizeof function");
    }
    else if (category == TYPE_CATEGORY_ITSELF)
    {
        if (p_type->type_specifier_flags & TYPE_SPECIFIER_CHAR)
        {
            align = _Alignof(char);
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_BOOL)
        {
            align = _Alignof(_Bool);
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_SHORT)
        {
            align = _Alignof(short);
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_ENUM)
        {
            //TODO enum type
            align = _Alignof(int);
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_LONG)
        {
            align = _Alignof(long);
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_LONG_LONG)
        {
            align = _Alignof(long long);
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_INT) //must be after long
        {
            align = _Alignof(int);
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_INT64)
        {
            align = _Alignof(long long);
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_INT32)
        {
            align = _Alignof(long);
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_INT16)
        {
            align = _Alignof(short);
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_INT8)
        {
            align = _Alignof(char);
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_FLOAT)
        {
            align = _Alignof(float);
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_DOUBLE)
        {
            align = _Alignof(double);
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_STRUCT_OR_UNION)
        {
            if (p_type->struct_or_union_specifier)
            {
                struct struct_or_union_specifier* _Opt p_complete =
                    get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);

                align = 1;
                if (p_complete)
                {
                    align = get_alignof_struct(p_complete);
                }
                else
                {
                    align = -2;
                }
            }
            else
            {
                align = -2;
                assert(false);
            }
        }
        else if (p_type->type_specifier_flags & TYPE_SPECIFIER_ENUM)
        {
            align = _Alignof(int);
        }
        else if (p_type->type_specifier_flags == TYPE_SPECIFIER_NONE)
        {
            align = -3;
            //seterror(error, "type information is missing");
        }
        else if (p_type->type_specifier_flags == TYPE_SPECIFIER_VOID)
        {
            align = 1;
        }
        else
        {
            assert(false);
        }
    }
    else if (category == TYPE_CATEGORY_ARRAY)
    {

        struct type type = get_array_item_type(p_type);
        align = type_get_alignof(&type);
        type_destroy(&type);
    }
    assert(align > 0);
    return align;
}

size_t type_get_sizeof(const struct type* p_type)
{
    const enum type_category category = type_get_category(p_type);

    if (category == TYPE_CATEGORY_POINTER)
    {
        return (int)sizeof(void*);
    }

    if (category == TYPE_CATEGORY_FUNCTION)
    {
        return (size_t)-1;
    }

    if (category == TYPE_CATEGORY_ARRAY)
    {
        if (p_type->storage_class_specifier_flags & STORAGE_SPECIFIER_PARAMETER)
        {
            //void f(int a[2])
            return sizeof(void*);
        }
        else
        {
            if (type_is_vla(p_type))
                return -3;

            int arraysize = p_type->num_of_elements;
            struct type type = get_array_item_type(p_type);
            int sz = type_get_sizeof(&type);
            int size = sz * arraysize;
            type_destroy(&type);
            return size;
        }
    }

    assert(category == TYPE_CATEGORY_ITSELF);


    if (p_type->type_specifier_flags & TYPE_SPECIFIER_CHAR)
    {
        return (int)sizeof(char);
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_BOOL)
    {
        return (int)sizeof(_Bool);
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_SHORT)
    {
        return (int)sizeof(short);
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_ENUM)
    {
        //TODO enum type
        return  (int)sizeof(int);
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_LONG)
    {
        return (int)sizeof(long);
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_LONG_LONG)
    {
        return (int)sizeof(long long);
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_INT) //must be after long
    {
        //typedef long unsigned int uint64_t;
        return (int)sizeof(int);
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_INT64)
    {
        return (int)sizeof(long long);
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_INT32)
    {
        return 4;
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_INT16)
    {
        return 2;
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_INT8)
    {
        return 1;
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_FLOAT)
    {
        return (int)sizeof(float);
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_DOUBLE)
    {
        return (int)sizeof(double);
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_STRUCT_OR_UNION)
    {
        if (p_type->struct_or_union_specifier == NULL)
            return -2;

        struct struct_or_union_specifier* _Opt p_complete =
            get_complete_struct_or_union_specifier(p_type->struct_or_union_specifier);

        if (p_complete == NULL) return -2;

        return get_sizeof_struct(p_complete);
    }

    if (p_type->type_specifier_flags & TYPE_SPECIFIER_ENUM)
    {
        return (int)sizeof(int);
    }

    if (p_type->type_specifier_flags == TYPE_SPECIFIER_NONE)
    {
        return -3;
    }

    if (p_type->type_specifier_flags == TYPE_SPECIFIER_VOID)
    {
        return 1;
    }

    if (p_type->type_specifier_flags == TYPE_SPECIFIER_NULLPTR_T)
    {
        return sizeof(void*);
    }

    if (p_type->type_specifier_flags == TYPE_SPECIFIER_DECIMAL32)
    {
        return 4;
    }

    if (p_type->type_specifier_flags == TYPE_SPECIFIER_DECIMAL64)
    {
        return 8;
    }

    if (p_type->type_specifier_flags == TYPE_SPECIFIER_DECIMAL128)
    {
        return 16;
    }

    assert(false);
    return -1;
}

void type_set_attributes(struct type* p_type, struct declarator* pdeclarator)
{
    if (pdeclarator->declaration_specifiers)
    {
        p_type->attributes_flags =
            pdeclarator->declaration_specifiers->attributes_flags;
    }
    else if (pdeclarator->specifier_qualifier_list)
    {
        //p_type->type_qualifier_flags =
          //  pdeclarator->specifier_qualifier_list->ATR;
    }
}

struct type make_type_using_declarator(struct parser_ctx* ctx, struct declarator* pdeclarator);

struct type get_function_return_type(const struct type* p_type)
{
    try
    {
        if (p_type->next == NULL)
            throw;

        if (type_is_pointer(p_type))
        {
            if (p_type->next->next == NULL)
            {
                throw;
            }

            /*pointer to function returning ... */
            struct type r = type_dup(p_type->next->next);
            return r;
        }

        /*function returning ... */
        struct type r = type_dup(p_type->next);
        return r;
    }
    catch
    {
    }
    struct type empty = { 0 };
    return empty;
}


void type_set_int(struct type* p_type)
{
    p_type->type_specifier_flags = TYPE_SPECIFIER_INT;
    p_type->type_qualifier_flags = 0;
    p_type->category = TYPE_CATEGORY_ITSELF;
}

struct type type_make_enumerator(const struct enum_specifier* enum_specifier)
{
    struct type t = { 0 };
    t.type_specifier_flags = TYPE_SPECIFIER_ENUM;
    t.enum_specifier = enum_specifier;
    t.category = TYPE_CATEGORY_ITSELF;
    return t;
}

struct type type_get_enum_type(const struct type* p_type)
{
    try
    {
        if (p_type->enum_specifier == NULL)
            throw;

        const struct enum_specifier* _Opt p_complete_enum_specifier =
            get_complete_enum_specifier(p_type->enum_specifier);

        if (p_complete_enum_specifier &&
            p_complete_enum_specifier->specifier_qualifier_list)
        {
            struct type t = { 0 };
            t.type_qualifier_flags = p_complete_enum_specifier->specifier_qualifier_list->type_qualifier_flags;
            t.type_specifier_flags = p_complete_enum_specifier->specifier_qualifier_list->type_specifier_flags;
            return t;
        }

        struct type t = { 0 };
        t.type_specifier_flags = TYPE_SPECIFIER_INT;
        return t;
    }
    catch
    {
    }
    struct type empty = { 0 };
    return empty;
}

struct type type_make_long_double()
{
    struct type t = { 0 };
    t.type_specifier_flags = TYPE_SPECIFIER_LONG | TYPE_SPECIFIER_DOUBLE;
    t.category = TYPE_CATEGORY_ITSELF;
    return t;
}

struct type type_make_double()
{
    struct type t = { 0 };
    t.type_specifier_flags = TYPE_SPECIFIER_DOUBLE;
    t.category = TYPE_CATEGORY_ITSELF;
    return t;
}

struct type type_make_float()
{
    struct type t = { 0 };
    t.type_specifier_flags = TYPE_SPECIFIER_FLOAT;
    t.category = TYPE_CATEGORY_ITSELF;
    return t;
}


struct type type_make_size_t()
{
    struct type t = { 0 };

#ifdef _WIN64
    t.type_specifier_flags = TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT64;
#else
    t.type_specifier_flags = TYPE_SPECIFIER_UNSIGNED | TYPE_SPECIFIER_INT;
#endif

    t.category = TYPE_CATEGORY_ITSELF;
    return t;
}

struct type make_void_ptr_type()
{
    struct type t = { 0 };
    try
    {
        struct type* _Owner _Opt p = calloc(1, sizeof * p);
        if (p == NULL) throw;

        t.category = TYPE_CATEGORY_POINTER;
        p->category = TYPE_CATEGORY_ITSELF;
        p->type_specifier_flags = TYPE_SPECIFIER_VOID;
        t.next = p;
    }
    catch
    {

    }
    return t;
}

struct type make_void_type()
{
    struct type t = { 0 };
    t.type_specifier_flags = TYPE_SPECIFIER_VOID;
    t.category = TYPE_CATEGORY_ITSELF;
    return t;
}

struct type type_make_int_bool_like()
{
    struct type t = { 0 };
    t.type_specifier_flags = TYPE_SPECIFIER_INT;
    t.attributes_flags = CAKE_HIDDEN_ATTRIBUTE_LIKE_BOOL;
    t.category = TYPE_CATEGORY_ITSELF;
    return t;
}

struct type make_size_t_type()
{
    struct type t = { 0 };
    t.type_specifier_flags = CAKE_SIZE_T_TYPE_SPECIFIER;
    t.category = TYPE_CATEGORY_ITSELF;
    return t;
}

struct type type_make_int()
{
    struct type t = { 0 };
    t.type_specifier_flags = TYPE_SPECIFIER_INT;
    t.category = TYPE_CATEGORY_ITSELF;
    return t;
}

struct type type_make_literal_string(int size_in_bytes, enum type_specifier_flags chartype)
{
    struct type t = { 0 };

    try
    {
        struct type* _Owner _Opt p2 = calloc(1, sizeof(struct type));
        if (p2 == NULL) throw;

        struct type char_type = { 0 };
        char_type.category = TYPE_CATEGORY_ITSELF;
        char_type.type_specifier_flags = chartype;
        int char_size = type_get_sizeof(&char_type);
        if (char_size == 0)
        {
            char_size = 1;
        }
        type_destroy(&char_type);


        t.category = TYPE_CATEGORY_ARRAY;
        t.num_of_elements = size_in_bytes / char_size;

        p2->category = TYPE_CATEGORY_ITSELF;
        p2->type_specifier_flags = chartype;
        t.next = p2;
    }
    catch
    {
    }

    return t;
}

bool struct_or_union_specifier_is_same(struct struct_or_union_specifier* _Opt a, struct struct_or_union_specifier* _Opt b)
{
    if (a && b)
    {
        struct struct_or_union_specifier* _Opt p_complete_a = get_complete_struct_or_union_specifier(a);
        struct struct_or_union_specifier* _Opt p_complete_b = get_complete_struct_or_union_specifier(b);

        if (p_complete_a != NULL && p_complete_b != NULL)
        {
            if (p_complete_a != p_complete_b)
            {
                return false;
            }
            return true;
        }
        else
        {
            /*both incomplete then we compare tag names*/
            if (a->tagtoken != NULL && b->tagtoken != NULL)
            {
                if (strcmp(a->tagtoken->lexeme, b->tagtoken->lexeme) == 0)
                    return true;
            }
        }
        return p_complete_a == NULL && p_complete_b == NULL;
    }
    return a == NULL && b == NULL;
}

bool enum_specifier_is_same(struct enum_specifier* _Opt a, struct enum_specifier* _Opt b)
{
    if (a && b)
    {
        if (get_complete_enum_specifier(a) && get_complete_enum_specifier(b))
        {
            if (get_complete_enum_specifier(a) != get_complete_enum_specifier(b))
            {
                return false;
            }
            return true;
        }
        return get_complete_enum_specifier(a) == NULL &&
            get_complete_enum_specifier(b) == NULL;
    }
    return a == NULL && b == NULL;
}




bool type_is_same(const struct type* a, const struct type* b, bool compare_qualifiers)
{
    const struct type* _Opt pa = a;
    const struct type* _Opt pb = b;

    while (pa && pb)
    {


        if (pa->num_of_elements != pb->num_of_elements) return false;

        if (pa->category != pb->category) return false;

        if (pa->enum_specifier &&
            pb->enum_specifier &&
            get_complete_enum_specifier(pa->enum_specifier) !=
            get_complete_enum_specifier(pb->enum_specifier))
        {
            return false;
        }


        if (pa->enum_specifier && !pb->enum_specifier)
        {
            //TODO enum with types
            //enum  x int
           //return false;
        }

        if (!pa->enum_specifier && pb->enum_specifier)
        {
            //TODO enum with types
            //int x enum
            //return false;
        }

        //if (pa->name_opt != pb->name_opt) return false;
        if (pa->static_array != pb->static_array) return false;

        if (pa->category == TYPE_CATEGORY_FUNCTION)
        {

            if (pa->params.is_var_args != pb->params.is_var_args)
            {
                return false;
            }

            if (pa->params.is_void != pb->params.is_void)
            {
                return false;
            }

            struct param* _Opt p_param_a = pa->params.head;
            struct param* _Opt p_param_b = pb->params.head;
            while (p_param_a && p_param_b)
            {
                if (!type_is_same(&p_param_a->type, &p_param_b->type, true))
                {
                    return false;
                }
                p_param_a = p_param_a->next;
                p_param_b = p_param_b->next;
            }
            return p_param_a == NULL && p_param_b == NULL;
        }

        if (pa->struct_or_union_specifier &&
            pb->struct_or_union_specifier)
        {

            if (pa->struct_or_union_specifier->complete_struct_or_union_specifier_indirection !=
                pb->struct_or_union_specifier->complete_struct_or_union_specifier_indirection)
            {
                //this should work but it is not...
            }

            if (strcmp(pa->struct_or_union_specifier->tag_name, pb->struct_or_union_specifier->tag_name) != 0)
            {
                return false;
            }
        }

        if (compare_qualifiers && pa->type_qualifier_flags != pb->type_qualifier_flags)
        {
            return false;
        }

        if (pa->type_specifier_flags != pb->type_specifier_flags)
        {
            return false;
        }


        pa = pa->next;
        pb = pb->next;
    }
    return pa == NULL && pb == NULL;
}


void type_swap(_View struct type* a, _View struct type* b)
{
    _View struct type temp = *a;
    *a = *b;
    *b = temp;
}


void type_visit_to_mark_anonymous(struct type* p_type)
{
    //TODO better visit?
    if (p_type->struct_or_union_specifier != NULL &&
        p_type->struct_or_union_specifier->has_anonymous_tag)
    {
        if (p_type->struct_or_union_specifier->complete_struct_or_union_specifier_indirection)
        {
            p_type->struct_or_union_specifier->complete_struct_or_union_specifier_indirection->show_anonymous_tag = true;
        }
        p_type->struct_or_union_specifier->show_anonymous_tag = true;
    }

}


void type_merge_qualifiers_using_declarator(struct type* p_type, struct declarator* pdeclarator)
{

    enum type_qualifier_flags type_qualifier_flags = 0;
    if (pdeclarator->declaration_specifiers)
    {
        type_qualifier_flags = pdeclarator->declaration_specifiers->type_qualifier_flags;

    }
    else if (pdeclarator->specifier_qualifier_list)
    {
        type_qualifier_flags = pdeclarator->specifier_qualifier_list->type_qualifier_flags;

    }

    p_type->type_qualifier_flags |= type_qualifier_flags;




}


void type_set_qualifiers_using_declarator(struct type* p_type, struct declarator* pdeclarator)
{

    enum type_qualifier_flags type_qualifier_flags = 0;
    if (pdeclarator->declaration_specifiers)
    {
        type_qualifier_flags = pdeclarator->declaration_specifiers->type_qualifier_flags;

    }
    else if (pdeclarator->specifier_qualifier_list)
    {
        type_qualifier_flags = pdeclarator->specifier_qualifier_list->type_qualifier_flags;

    }

    p_type->type_qualifier_flags = type_qualifier_flags;



}

void type_set_storage_specifiers_using_declarator(struct type* p_type, struct declarator* pdeclarator)
{
    if (pdeclarator->declaration_specifiers)
    {
        p_type->storage_class_specifier_flags |=
            pdeclarator->declaration_specifiers->storage_class_specifier_flags;
    }
    else
    {
        //struct member
        //assert(false);
        /*
           where we don't have specifiers?
        */
        //p_type->storage_class_specifier_flags |= STORAGE_SPECIFIER_AUTO;
    }
}


void type_set_specifiers_using_declarator(struct type* p_type, struct declarator* pdeclarator)
{
    if (pdeclarator->declaration_specifiers)
    {
        p_type->type_specifier_flags =
            pdeclarator->declaration_specifiers->type_specifier_flags;

        p_type->enum_specifier = pdeclarator->declaration_specifiers->enum_specifier;
        p_type->struct_or_union_specifier = pdeclarator->declaration_specifiers->struct_or_union_specifier;

    }
    else if (pdeclarator->specifier_qualifier_list)
    {
        p_type->type_specifier_flags =
            pdeclarator->specifier_qualifier_list->type_specifier_flags;
        p_type->enum_specifier = pdeclarator->specifier_qualifier_list->enum_specifier;
        p_type->struct_or_union_specifier = pdeclarator->specifier_qualifier_list->struct_or_union_specifier;

    }


}

void type_set_attributes_using_declarator(struct type* p_type, struct declarator* pdeclarator)
{
    if (pdeclarator->declaration_specifiers)
    {
        if (pdeclarator->declaration_specifiers->attributes_flags & STD_ATTRIBUTE_NODISCARD)
        {
            p_type->storage_class_specifier_flags |= STORAGE_SPECIFIER_FUNCTION_RETURN_NODISCARD;
        }
        p_type->attributes_flags =
            pdeclarator->declaration_specifiers->attributes_flags;
    }
    else if (pdeclarator->specifier_qualifier_list)
    {
        //p_type->attributes_flags =
          //  pdeclarator->specifier_qualifier_list->attributes_flags;
    }
}


void type_list_push_front(struct type_list* books, struct type* _Owner new_book)
{
    assert(new_book->next == NULL);

    if (books->head == NULL)
    {
        books->head = new_book;
        books->tail = new_book;
    }
    else
    {
        new_book->next = books->head;
        books->head = new_book;
    }
}

void type_list_destroy(struct type_list* _Obj_owner p_type_list)
{
    struct type* _Owner _Opt item = p_type_list->head;
    while (item)
    {
        struct type* _Owner _Opt next = item->next;
        item->next = NULL;
        type_destroy_one(item);
        free(item);
        item = next;
    }
}

void type_list_push_back(struct type_list* type_list, struct type* _Owner new_book)
{
    if (type_list->tail == NULL)
    {
        assert(type_list->head == NULL);
        type_list->head = new_book;
    }
    else
    {
        assert(type_list->tail->next == NULL);
        type_list->tail->next = new_book;
    }

    type_list->tail = new_book;
}

void make_type_using_declarator_core(struct parser_ctx* ctx, struct declarator* pdeclarator, char** ppname, struct type_list* list);

void  make_type_using_direct_declarator(struct parser_ctx* ctx,
    struct direct_declarator* pdirectdeclarator,
    char** ppname,
    struct type_list* list)
{
    try
    {
        if (pdirectdeclarator->declarator)
        {
            make_type_using_declarator_core(ctx, pdirectdeclarator->declarator, ppname, list);
        }

        else if (pdirectdeclarator->function_declarator)
        {
            if (pdirectdeclarator->function_declarator->direct_declarator)
            {
                make_type_using_direct_declarator(ctx,
                    pdirectdeclarator->function_declarator->direct_declarator,
                    ppname,
                    list);
            }

            struct type* _Owner _Opt p_func = calloc(1, sizeof(struct type));
            if (p_func == NULL) throw;

            p_func->category = TYPE_CATEGORY_FUNCTION;


            if (pdirectdeclarator->function_declarator->parameter_type_list_opt &&
                pdirectdeclarator->function_declarator->parameter_type_list_opt->parameter_list)
            {

                struct parameter_declaration* _Opt p =
                    pdirectdeclarator->function_declarator->parameter_type_list_opt->parameter_list->head;

                p_func->params.is_var_args = pdirectdeclarator->function_declarator->parameter_type_list_opt->is_var_args;
                p_func->params.is_void = pdirectdeclarator->function_declarator->parameter_type_list_opt->is_void;

                while (p)
                {
                    if (p->declarator == NULL)
                    {
                        type_delete(p_func);
                        throw;
                    }

                    struct param* _Owner _Opt p_new_param = calloc(1, sizeof(struct param));
                    if (p_new_param == NULL)
                    {
                        type_delete(p_func);
                        throw;
                    }

                    p_new_param->type = type_dup(&p->declarator->type);
                    param_list_add(&p_func->params, p_new_param);
                    p = p->next;
                }
            }


            type_list_push_back(list, p_func);
        }
        else if (pdirectdeclarator->array_declarator)
        {

            if (pdirectdeclarator->array_declarator->direct_declarator)
            {
                make_type_using_direct_declarator(ctx,
                    pdirectdeclarator->array_declarator->direct_declarator,
                    ppname,
                    list);
            }

            struct type* _Owner _Opt  p = calloc(1, sizeof(struct type));
            if (p == NULL) throw;

            p->category = TYPE_CATEGORY_ARRAY;

            p->num_of_elements =
                (int)array_declarator_get_size(pdirectdeclarator->array_declarator);

            p->array_num_elements_expression = pdirectdeclarator->array_declarator->assignment_expression;

            if (pdirectdeclarator->array_declarator->static_token_opt)
            {
                p->static_array = true;
            }

            if (pdirectdeclarator->array_declarator->type_qualifier_list_opt)
            {
                p->type_qualifier_flags = pdirectdeclarator->array_declarator->type_qualifier_list_opt->flags;
            }

            type_list_push_back(list, p);

            // if (pdirectdeclarator->name_opt)
             //{
               //  p->name_opt = strdup(pdirectdeclarator->name_opt->lexeme);
             //}
        }

        if (pdirectdeclarator->name_opt)
        {
            *ppname = pdirectdeclarator->name_opt->lexeme;
        }

    }
    catch
    {
        //tODO
    }
}

void make_type_using_declarator_core(struct parser_ctx* ctx, struct declarator* pdeclarator,
    char** ppname, struct type_list* list)
{
    try
    {
        struct type_list pointers = { 0 };
        struct pointer* _Opt pointer = pdeclarator->pointer;
        while (pointer)
        {
            struct type* _Owner _Opt p_flat = calloc(1, sizeof(struct type));
            if (p_flat == NULL) 
            {
                type_list_destroy(&pointers);
                throw;
            }

            if (pointer->type_qualifier_list_opt)
            {
                p_flat->type_qualifier_flags = pointer->type_qualifier_list_opt->flags;
            }

            if (pointer->attribute_specifier_sequence_opt)
            {
                p_flat->attributes_flags |= pointer->attribute_specifier_sequence_opt->attributes_flags;
            }
            p_flat->category = TYPE_CATEGORY_POINTER;


            type_list_push_front(&pointers, p_flat); /*invertido*/
            pointer = pointer->pointer;
        }

        if (pdeclarator->direct_declarator)
        {
            make_type_using_direct_declarator(ctx, pdeclarator->direct_declarator, ppname, list);
            if (list->head &&
                list->head->category == TYPE_CATEGORY_FUNCTION)
            {
                if (pointers.head)
                {
                    pointers.head->storage_class_specifier_flags |= STORAGE_SPECIFIER_FUNCTION_RETURN;
                }
            }
        }

        while (pointers.head)
        {
            struct type* _Owner p = pointers.head;
            pointers.head = p->next;
            p->next = NULL;
            type_list_push_back(list, p);
        }
    }
    catch
    {
    }
}

struct enum_specifier* _Opt declarator_get_enum_specifier(struct declarator* pdeclarator)
{
    if (pdeclarator->declaration_specifiers &&
        pdeclarator->declaration_specifiers->enum_specifier)
    {
        return pdeclarator->declaration_specifiers->enum_specifier;
    }
    if (pdeclarator->specifier_qualifier_list &&
        pdeclarator->specifier_qualifier_list->enum_specifier)
    {
        return pdeclarator->specifier_qualifier_list->enum_specifier;
    }
    return NULL;
}


struct struct_or_union_specifier* _Opt declarator_get_struct_or_union_specifier(struct declarator* pdeclarator)
{
    if (pdeclarator->declaration_specifiers &&
        pdeclarator->declaration_specifiers->struct_or_union_specifier)
    {
        return pdeclarator->declaration_specifiers->struct_or_union_specifier;
    }
    if (pdeclarator->specifier_qualifier_list &&
        pdeclarator->specifier_qualifier_list->struct_or_union_specifier)
    {
        return pdeclarator->specifier_qualifier_list->struct_or_union_specifier;
    }
    return NULL;
}

struct typeof_specifier* _Opt declarator_get_typeof_specifier(struct declarator* pdeclarator)
{
    if (pdeclarator->declaration_specifiers)
    {
        return pdeclarator->declaration_specifiers->typeof_specifier;
    }
    else if (pdeclarator->specifier_qualifier_list)
    {
        return pdeclarator->specifier_qualifier_list->typeof_specifier;
    }
    return NULL;
}

struct declarator* _Opt declarator_get_typedef_declarator(struct declarator* pdeclarator)
{
    if (pdeclarator->declaration_specifiers)
    {
        return pdeclarator->declaration_specifiers->typedef_declarator;
    }
    else if (pdeclarator->specifier_qualifier_list)
    {
        return pdeclarator->specifier_qualifier_list->typedef_declarator;
    }

    return NULL;
}

struct type make_type_using_declarator(struct parser_ctx* ctx, struct declarator* pdeclarator)
{

    try
    {
        struct type_list list = { 0 };

        char* _Opt name = NULL;
        make_type_using_declarator_core(ctx, pdeclarator, &name, &list);


        if (declarator_get_typeof_specifier(pdeclarator))
        {
            struct type* _Owner _Opt p_nt = calloc(1, sizeof(struct type));
            if (p_nt == NULL)
            {
                type_list_destroy(&list);
                throw;
            }

            struct type nt =
                type_dup(&declarator_get_typeof_specifier(pdeclarator)->type);

            *p_nt = nt;


            if (list.head != NULL)
                type_set_qualifiers_using_declarator(list.head, pdeclarator);

            if (list.tail)
            {
                assert(list.tail->next == NULL);
                list.tail->next = p_nt;
            }
            else
            {
                type_list_push_back(&list, p_nt);
            }
        }
        else if (declarator_get_typedef_declarator(pdeclarator))
        {
            struct declarator* _Opt p_typedef_declarator =
                declarator_get_typedef_declarator(pdeclarator);
            
            if (p_typedef_declarator == NULL) 
            {   
                type_list_destroy(&list);
                throw;
            }

            struct type nt =
                type_dup(&p_typedef_declarator->type);

            struct type* _Owner _Opt p_nt = calloc(1, sizeof(struct type));
            if (p_nt == NULL)
            {
                type_list_destroy(&list);
                type_destroy(&nt);
                throw;
            }

            *p_nt = nt;


            /*
              maybe typedef already has const qualifier
              so we cannot override
            */
            type_merge_qualifiers_using_declarator(p_nt, pdeclarator);

            if (list.tail)
            {
                assert(list.tail->next == 0);
                list.tail->next = p_nt;
            }
            else
            {
                type_list_push_back(&list, p_nt);
            }
        }
        else
        {
            struct type* _Owner _Opt p = calloc(1, sizeof(struct type));
            if (p == NULL)
            {
                type_list_destroy(&list);
                throw;
            }

            p->category = TYPE_CATEGORY_ITSELF;


            type_set_specifiers_using_declarator(p, pdeclarator);
            type_set_attributes_using_declarator(p, pdeclarator);


            type_set_qualifiers_using_declarator(p, pdeclarator);

            if (list.tail &&
                list.tail->category == TYPE_CATEGORY_FUNCTION)
            {
                p->storage_class_specifier_flags |= STORAGE_SPECIFIER_FUNCTION_RETURN;
            }

            type_list_push_back(&list, p);

            if (list.head)
                type_set_storage_specifiers_using_declarator(list.head, pdeclarator);
        }


        if (list.head == NULL) throw;

        if (pdeclarator->name_opt)
        {
            char* _Owner _Opt temp = strdup(pdeclarator->name_opt->lexeme);
            if (temp == NULL)
            {
                type_list_destroy(&list);
                throw;
            }

            free((void* _Owner) list.head->name_opt);
            list.head->name_opt = temp;
        }

        struct type r = *list.head;
        /*
          we moved the contents of head
          but we also need to delete the memory
        */
        free(list.head);
        return r;
    }
    catch
    {

    }

    struct type empty = { 0 };
    return empty;
}

void type_remove_names(struct type* p_type)
{
    /*
      function parameters names are preserved
    */
    struct type* _Opt p = p_type;

    while (p)
    {
        if (p->name_opt)
        {
            free((void* _Owner _Opt)p->name_opt);
            p->name_opt = NULL;
        }
        p = p->next;
    }
}

const struct type* type_get_specifer_part(const struct type* p_type)
{
    /*
     last part is the specifier
    */
    const struct type* _Opt p = p_type;
    while (p->next) p = p->next;
    return p;
}

